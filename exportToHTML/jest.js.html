<html>
<head>
<title>jest.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jest.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @flow 
 * @format 
 * @oncall react_native 
 */</span>

<span class="s0">// Modified from https://raw.githubusercontent.com/flow-typed/flow-typed/master/definitions/npm/jest_v29.x.x/flow_v0.134.x-/jest_v29.x.x.js</span>
<span class="s0">// Modifications are explained inline by comments beginning with `// MODIFIED`.</span>

<span class="s0">// MODIFIED: Added ESLint suppression comment - no-unused-vars doesn't understand declaration files</span>
<span class="s0">/* eslint-disable no-unused-vars */</span>

<span class="s1">type JestMockFn&lt;TArguments: $ReadOnlyArray&lt;any&gt;, TReturn&gt; = {</span>
  <span class="s1">(...args: TArguments): TReturn,</span>
  <span class="s0">/** 
   * An object for introspecting mock calls 
   */</span>
  <span class="s1">mock: {</span>
    <span class="s0">/** 
     * An array that represents all calls that have been made into this mock 
     * function. Each call is represented by an array of arguments that were 
     * passed during the call. 
     */</span>
    <span class="s1">calls: Array&lt;TArguments&gt;,</span>
    <span class="s0">/** 
     * An array containing the call arguments of the last call that was made 
     * to this mock function. If the function was not called, it will return 
     * undefined. 
     */</span>
    <span class="s1">lastCall: TArguments,</span>
    <span class="s0">/** 
     * An array that contains all the object instances that have been 
     * instantiated from this mock function. 
     */</span>
    <span class="s1">instances: Array&lt;TReturn&gt;,</span>
    <span class="s0">/** 
     * An array that contains all the object results that have been 
     * returned by this mock function call 
     */</span>
    <span class="s1">results: Array&lt;{</span>
      <span class="s1">isThrow: boolean,</span>
      <span class="s1">value: TReturn,</span>
      <span class="s1">...</span>
    <span class="s1">}&gt;,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s0">/** 
   * Resets all information stored in the mockFn.mock.calls and 
   * mockFn.mock.instances arrays. Often this is useful when you want to clean 
   * up a mock's usage data between two assertions. 
   */</span>
  <span class="s1">mockClear(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Resets all information stored in the mock. This is useful when you want to 
   * completely restore a mock back to its initial state. 
   */</span>
  <span class="s1">mockReset(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Removes the mock and restores the initial implementation. This is useful 
   * when you want to mock functions in certain test cases and restore the 
   * original implementation in others. Beware that mockFn.mockRestore only 
   * works when mock was created with jest.spyOn. Thus you have to take care of 
   * restoration yourself when manually assigning jest.fn(). 
   */</span>
  <span class="s1">mockRestore(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Accepts a function that should be used as the implementation of the mock. 
   * The mock itself will still record all calls that go into and instances 
   * that come from itself -- the only difference is that the implementation 
   * will also be executed when the mock is called. 
   */</span>
  <span class="s1">mockImplementation(</span>
    <span class="s1">fn: (...args: TArguments) =&gt; TReturn,</span>
  <span class="s1">): JestMockFn&lt;TArguments, TReturn&gt;,</span>
  <span class="s0">/** 
   * Accepts a function that will be used as an implementation of the mock for 
   * one call to the mocked function. Can be chained so that multiple function 
   * calls produce different results. 
   */</span>
  <span class="s1">mockImplementationOnce(</span>
    <span class="s1">fn: (...args: TArguments) =&gt; TReturn,</span>
  <span class="s1">): JestMockFn&lt;TArguments, TReturn&gt;,</span>
  <span class="s0">/** 
   * Accepts a string to use in test result output in place of &quot;jest.fn()&quot; to 
   * indicate which mock function is being referenced. 
   */</span>
  <span class="s1">mockName(name: string): JestMockFn&lt;TArguments, TReturn&gt;,</span>
  <span class="s0">/** 
   * Just a simple sugar function for returning `this` 
   */</span>
  <span class="s1">mockReturnThis(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Accepts a value that will be returned whenever the mock function is called. 
   */</span>
  <span class="s1">mockReturnValue(value: TReturn): JestMockFn&lt;TArguments, TReturn&gt;,</span>
  <span class="s0">/** 
   * Sugar for only returning a value once inside your mock 
   */</span>
  <span class="s1">mockReturnValueOnce(value: TReturn): JestMockFn&lt;TArguments, TReturn&gt;,</span>
  <span class="s0">/** 
   * Sugar for jest.fn().mockImplementation(() =&gt; Promise.resolve(value)) 
   */</span>
  <span class="s1">mockResolvedValue(value: TReturn): JestMockFn&lt;TArguments, Promise&lt;TReturn&gt;&gt;,</span>
  <span class="s0">/** 
   * Sugar for jest.fn().mockImplementationOnce(() =&gt; Promise.resolve(value)) 
   */</span>
  <span class="s1">mockResolvedValueOnce(</span>
    <span class="s1">value: TReturn,</span>
  <span class="s1">): JestMockFn&lt;TArguments, Promise&lt;TReturn&gt;&gt;,</span>
  <span class="s0">/** 
   * Sugar for jest.fn().mockImplementation(() =&gt; Promise.reject(value)) 
   */</span>
  <span class="s1">mockRejectedValue(value: TReturn): JestMockFn&lt;TArguments, Promise&lt;any&gt;&gt;,</span>
  <span class="s0">/** 
   * Sugar for jest.fn().mockImplementationOnce(() =&gt; Promise.reject(value)) 
   */</span>
  <span class="s1">mockRejectedValueOnce(value: TReturn): JestMockFn&lt;TArguments, Promise&lt;any&gt;&gt;,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestAsymmetricEqualityType = {</span>
  <span class="s0">/** 
   * A custom Jasmine equality tester 
   */</span>
  <span class="s1">asymmetricMatch(value: mixed): boolean,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestCallsType = {</span>
  <span class="s1">allArgs(): mixed,</span>
  <span class="s1">all(): mixed,</span>
  <span class="s1">any(): boolean,</span>
  <span class="s1">count(): number,</span>
  <span class="s1">first(): mixed,</span>
  <span class="s1">mostRecent(): mixed,</span>
  <span class="s1">reset(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestClockType = {</span>
  <span class="s1">install(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">mockDate(date: Date): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">tick(milliseconds?: number): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">uninstall(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestMatcherResult = {</span>
  <span class="s1">message?: string | (() =&gt; string),</span>
  <span class="s1">pass: boolean,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestMatcher = (</span>
  <span class="s1">received: any,</span>
  <span class="s1">...actual: Array&lt;any&gt;</span>
<span class="s1">) =&gt; JestMatcherResult | Promise&lt;JestMatcherResult&gt;;</span>

<span class="s1">type JestPromiseType = {</span>
  <span class="s0">/** 
   * Use rejects to unwrap the reason of a rejected promise so any other 
   * matcher can be chained. If the promise is fulfilled the assertion fails. 
   */</span>
  <span class="s1">rejects: JestExpectType,</span>
  <span class="s0">/** 
   * Use resolves to unwrap the value of a fulfilled promise so any other 
   * matcher can be chained. If the promise is rejected the assertion fails. 
   */</span>
  <span class="s1">resolves: JestExpectType,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Jest allows functions and classes to be used as test names in test() and 
 * describe() 
 */</span>
<span class="s1">type JestTestName = string | Function;</span>

<span class="s1">type FakeableAPI =</span>
  <span class="s1">| </span><span class="s3">'Date'</span>
  <span class="s1">| </span><span class="s3">'hrtime'</span>
  <span class="s1">| </span><span class="s3">'nextTick'</span>
  <span class="s1">| </span><span class="s3">'performance'</span>
  <span class="s1">| </span><span class="s3">'queueMicrotask'</span>
  <span class="s1">| </span><span class="s3">'requestAnimationFrame'</span>
  <span class="s1">| </span><span class="s3">'cancelAnimationFrame'</span>
  <span class="s1">| </span><span class="s3">'requestIdleCallback'</span>
  <span class="s1">| </span><span class="s3">'cancelIdleCallback'</span>
  <span class="s1">| </span><span class="s3">'setImmediate'</span>
  <span class="s1">| </span><span class="s3">'clearImmediate'</span>
  <span class="s1">| </span><span class="s3">'setInterval'</span>
  <span class="s1">| </span><span class="s3">'clearInterval'</span>
  <span class="s1">| </span><span class="s3">'setTimeout'</span>
  <span class="s1">| </span><span class="s3">'clearTimeout'</span><span class="s1">;</span>

<span class="s1">type FakeTimersConfig = {</span>
  <span class="s1">advanceTimers?: boolean | number,</span>
  <span class="s1">doNotFake?: Array&lt;FakeableAPI&gt;,</span>
  <span class="s1">now?: number | Date,</span>
  <span class="s1">timerLimit?: number,</span>
  <span class="s1">legacyFakeTimers?: boolean,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">/** 
 *  Plugin: jest-styled-components 
 */</span>

<span class="s1">type JestStyledComponentsMatcherValue =</span>
  <span class="s1">| string</span>
  <span class="s1">| JestAsymmetricEqualityType</span>
  <span class="s1">| RegExp</span>
  <span class="s1">| </span><span class="s2">typeof </span><span class="s1">undefined;</span>

<span class="s1">type JestStyledComponentsMatcherOptions = {</span>
  <span class="s1">media?: string,</span>
  <span class="s1">modifier?: string,</span>
  <span class="s1">supports?: string,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestStyledComponentsMatchersType = {</span>
  <span class="s1">toHaveStyleRule(</span>
    <span class="s1">property: string,</span>
    <span class="s1">value: JestStyledComponentsMatcherValue,</span>
    <span class="s1">options?: JestStyledComponentsMatcherOptions,</span>
  <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">/** 
 *  Plugin: jest-enzyme 
 */</span>
<span class="s1">type EnzymeMatchersType = {</span>
  <span class="s0">// 5.x</span>
  <span class="s1">toBeEmpty(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBePresent(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">// 6.x</span>
  <span class="s1">toBeChecked(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeDisabled(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeEmptyRender(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toContainMatchingElement(selector: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toContainMatchingElements(n: number, selector: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toContainExactlyOneMatchingElement(selector: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toContainReact(element: React$Element&lt;any&gt;): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toExist(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveClassName(className: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveHTML(html: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveProp: ((propKey: string, propValue?: any) =&gt; </span><span class="s2">void</span><span class="s1">) &amp;</span>
    <span class="s1">((props: {...}) =&gt; </span><span class="s2">void</span><span class="s1">),</span>
  <span class="s1">toHaveRef(refName: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveState: ((stateKey: string, stateValue?: any) =&gt; </span><span class="s2">void</span><span class="s1">) &amp;</span>
    <span class="s1">((state: {...}) =&gt; </span><span class="s2">void</span><span class="s1">),</span>
  <span class="s1">toHaveStyle: ((styleKey: string, styleValue?: any) =&gt; </span><span class="s2">void</span><span class="s1">) &amp;</span>
    <span class="s1">((style: {...}) =&gt; </span><span class="s2">void</span><span class="s1">),</span>
  <span class="s1">toHaveTagName(tagName: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveText(text: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveValue(value: any): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toIncludeText(text: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toMatchElement(</span>
    <span class="s1">element: React$Element&lt;any&gt;,</span>
    <span class="s1">options?: {|ignoreProps?: boolean, verbose?: boolean|},</span>
  <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toMatchSelector(selector: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">// 7.x</span>
  <span class="s1">toHaveDisplayName(name: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">// DOM testing library extensions (jest-dom)</span>
<span class="s0">// https://github.com/testing-library/jest-dom</span>
<span class="s1">type DomTestingLibraryType = {</span>
  <span class="s0">/** 
   * @deprecated 
   */</span>
  <span class="s1">toBeInTheDOM(container?: HTMLElement): </span><span class="s2">void</span><span class="s1">,</span>

  <span class="s0">// 4.x</span>
  <span class="s1">toBeInTheDocument(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeVisible(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeEmpty(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeDisabled(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeEnabled(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeInvalid(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeRequired(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeValid(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toContainElement(element: HTMLElement | </span><span class="s2">null</span><span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toContainHTML(htmlText: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveAttribute(attr: string, value?: any): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveClass(...classNames: string[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveFocus(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveFormValues(expectedValues: {[name: string]: any, ...}): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveStyle(css: string | {[name: string]: any, ...}): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveTextContent(</span>
    <span class="s1">text: string | RegExp,</span>
    <span class="s1">options?: {|normalizeWhitespace: boolean|},</span>
  <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveValue(value?: string | string[] | number): </span><span class="s2">void</span><span class="s1">,</span>

  <span class="s0">// 5.x</span>
  <span class="s1">toHaveDisplayValue(value: string | string[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeChecked(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeEmptyDOMElement(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBePartiallyChecked(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveDescription(text: string | RegExp): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">// Jest JQuery Matchers: https://github.com/unindented/custom-jquery-matchers</span>
<span class="s1">type JestJQueryMatchersType = {</span>
  <span class="s1">toExist(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveLength(len: number): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveId(id: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveClass(className: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveTag(tag: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveAttr(key: string, val?: any): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveProp(key: string, val?: any): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveText(text: string | RegExp): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveData(key: string, val?: any): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveValue(val: any): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveCss(css: {[key: string]: any, ...}): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeChecked(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeDisabled(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeEmpty(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeHidden(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeSelected(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeVisible(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeFocused(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeInDom(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toBeMatchedBy(sel: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveDescendant(sel: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">toHaveDescendantWithText(sel: string, text: string | RegExp): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">// Jest Extended Matchers: https://github.com/jest-community/jest-extended</span>
<span class="s1">type JestExtendedMatchersType = {</span>
  <span class="s0">/** 
   * Note: Currently unimplemented 
   * Passing assertion 
   * 
   * @param {String} message 
   */</span>
  <span class="s0">//  pass(message: string): void;</span>

  <span class="s0">/** 
   * Note: Currently unimplemented 
   * Failing assertion 
   * 
   * @param {String} message 
   */</span>
  <span class="s0">//  fail(message: string): void;</span>

  <span class="s0">/** 
   * Use .toBeEmpty when checking if a String '', Array [] or Object {} is empty. 
   */</span>
  <span class="s1">toBeEmpty(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use .toBeOneOf when checking if a value is a member of a given Array. 
   * @param {Array.&lt;*&gt;} members 
   */</span>
  <span class="s1">toBeOneOf(members: any[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeNil` when checking a value is `null` or `undefined`. 
   */</span>
  <span class="s1">toBeNil(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toSatisfy` when you want to use a custom matcher by supplying a predicate function that returns a `Boolean`. 
   * @param {Function} predicate 
   */</span>
  <span class="s1">toSatisfy(predicate: (n: any) =&gt; boolean): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeArray` when checking if a value is an `Array`. 
   */</span>
  <span class="s1">toBeArray(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeArrayOfSize` when checking if a value is an `Array` of size x. 
   * @param {Number} x 
   */</span>
  <span class="s1">toBeArrayOfSize(x: number): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toIncludeAllMembers` when checking if an `Array` contains all of the same members of a given set. 
   * @param {Array.&lt;*&gt;} members 
   */</span>
  <span class="s1">toIncludeAllMembers(members: any[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toIncludeAnyMembers` when checking if an `Array` contains any of the members of a given set. 
   * @param {Array.&lt;*&gt;} members 
   */</span>
  <span class="s1">toIncludeAnyMembers(members: any[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toSatisfyAll` when you want to use a custom matcher by supplying a predicate function that returns a `Boolean` for all values in an array. 
   * @param {Function} predicate 
   */</span>
  <span class="s1">toSatisfyAll(predicate: (n: any) =&gt; boolean): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeBoolean` when checking if a value is a `Boolean`. 
   */</span>
  <span class="s1">toBeBoolean(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeTrue` when checking a value is equal (===) to `true`. 
   */</span>
  <span class="s1">toBeTrue(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeFalse` when checking a value is equal (===) to `false`. 
   */</span>
  <span class="s1">toBeFalse(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use .toBeDate when checking if a value is a Date. 
   */</span>
  <span class="s1">toBeDate(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeFunction` when checking if a value is a `Function`. 
   */</span>
  <span class="s1">toBeFunction(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toHaveBeenCalledBefore` when checking if a `Mock` was called before another `Mock`. 
   * 
   * Note: Required Jest version &gt;22 
   * Note: Your mock functions will have to be asynchronous to cause the timestamps inside of Jest to occur in a differentJS event loop, otherwise the mock timestamps will all be the same 
   * 
   * @param {Mock} mock 
   */</span>
  <span class="s1">toHaveBeenCalledBefore(mock: JestMockFn&lt;any, any&gt;): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeNumber` when checking if a value is a `Number`. 
   */</span>
  <span class="s1">toBeNumber(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeNaN` when checking a value is `NaN`. 
   */</span>
  <span class="s1">toBeNaN(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeFinite` when checking if a value is a `Number`, not `NaN` or `Infinity`. 
   */</span>
  <span class="s1">toBeFinite(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBePositive` when checking if a value is a positive `Number`. 
   */</span>
  <span class="s1">toBePositive(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeNegative` when checking if a value is a negative `Number`. 
   */</span>
  <span class="s1">toBeNegative(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeEven` when checking if a value is an even `Number`. 
   */</span>
  <span class="s1">toBeEven(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeOdd` when checking if a value is an odd `Number`. 
   */</span>
  <span class="s1">toBeOdd(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeWithin` when checking if a number is in between the given bounds of: start (inclusive) and end (exclusive). 
   * 
   * @param {Number} start 
   * @param {Number} end 
   */</span>
  <span class="s1">toBeWithin(start: number, end: number): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeObject` when checking if a value is an `Object`. 
   */</span>
  <span class="s1">toBeObject(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainKey` when checking if an object contains the provided key. 
   * 
   * @param {String} key 
   */</span>
  <span class="s1">toContainKey(key: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainKeys` when checking if an object has all of the provided keys. 
   * 
   * @param {Array.&lt;String&gt;} keys 
   */</span>
  <span class="s1">toContainKeys(keys: string[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainAllKeys` when checking if an object only contains all of the provided keys. 
   * 
   * @param {Array.&lt;String&gt;} keys 
   */</span>
  <span class="s1">toContainAllKeys(keys: string[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainAnyKeys` when checking if an object contains at least one of the provided keys. 
   * 
   * @param {Array.&lt;String&gt;} keys 
   */</span>
  <span class="s1">toContainAnyKeys(keys: string[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainValue` when checking if an object contains the provided value. 
   * 
   * @param {*} value 
   */</span>
  <span class="s1">toContainValue(value: any): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainValues` when checking if an object contains all of the provided values. 
   * 
   * @param {Array.&lt;*&gt;} values 
   */</span>
  <span class="s1">toContainValues(values: any[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainAllValues` when checking if an object only contains all of the provided values. 
   * 
   * @param {Array.&lt;*&gt;} values 
   */</span>
  <span class="s1">toContainAllValues(values: any[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainAnyValues` when checking if an object contains at least one of the provided values. 
   * 
   * @param {Array.&lt;*&gt;} values 
   */</span>
  <span class="s1">toContainAnyValues(values: any[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainEntry` when checking if an object contains the provided entry. 
   * 
   * @param {Array.&lt;String, String&gt;} entry 
   */</span>
  <span class="s1">toContainEntry(entry: [string, string]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainEntries` when checking if an object contains all of the provided entries. 
   * 
   * @param {Array.&lt;Array.&lt;String, String&gt;&gt;} entries 
   */</span>
  <span class="s1">toContainEntries(entries: [string, string][]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainAllEntries` when checking if an object only contains all of the provided entries. 
   * 
   * @param {Array.&lt;Array.&lt;String, String&gt;&gt;} entries 
   */</span>
  <span class="s1">toContainAllEntries(entries: [string, string][]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toContainAnyEntries` when checking if an object contains at least one of the provided entries. 
   * 
   * @param {Array.&lt;Array.&lt;String, String&gt;&gt;} entries 
   */</span>
  <span class="s1">toContainAnyEntries(entries: [string, string][]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeExtensible` when checking if an object is extensible. 
   */</span>
  <span class="s1">toBeExtensible(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeFrozen` when checking if an object is frozen. 
   */</span>
  <span class="s1">toBeFrozen(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeSealed` when checking if an object is sealed. 
   */</span>
  <span class="s1">toBeSealed(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toBeString` when checking if a value is a `String`. 
   */</span>
  <span class="s1">toBeString(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toEqualCaseInsensitive` when checking if a string is equal (===) to another ignoring the casing of both strings. 
   * 
   * @param {String} string 
   */</span>
  <span class="s1">toEqualCaseInsensitive(string: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toStartWith` when checking if a `String` starts with a given `String` prefix. 
   * 
   * @param {String} prefix 
   */</span>
  <span class="s1">toStartWith(prefix: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toEndWith` when checking if a `String` ends with a given `String` suffix. 
   * 
   * @param {String} suffix 
   */</span>
  <span class="s1">toEndWith(suffix: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toInclude` when checking if a `String` includes the given `String` substring. 
   * 
   * @param {String} substring 
   */</span>
  <span class="s1">toInclude(substring: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toIncludeRepeated` when checking if a `String` includes the given `String` substring the correct number of times. 
   * 
   * @param {String} substring 
   * @param {Number} times 
   */</span>
  <span class="s1">toIncludeRepeated(substring: string, times: number): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Use `.toIncludeMultiple` when checking if a `String` includes all of the given substrings. 
   * 
   * @param {Array.&lt;String&gt;} substring 
   */</span>
  <span class="s1">toIncludeMultiple(substring: string[]): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">// Diffing snapshot utility for Jest (snapshot-diff)</span>
<span class="s0">// https://github.com/jest-community/snapshot-diff</span>
<span class="s1">type SnapshotDiffType = {</span>
  <span class="s0">/** 
   * Compare the difference between the actual in the `expect()` 
   * vs the object inside `valueB` with some extra options. 
   */</span>
  <span class="s1">toMatchDiffSnapshot(</span>
    <span class="s1">valueB: any,</span>
    <span class="s1">options?: {|</span>
      <span class="s1">expand?: boolean,</span>
      <span class="s1">colors?: boolean,</span>
      <span class="s1">contextLines?: number,</span>
      <span class="s1">stablePatchmarks?: boolean,</span>
      <span class="s1">aAnnotation?: string,</span>
      <span class="s1">bAnnotation?: string,</span>
    <span class="s1">|},</span>
    <span class="s1">testName?: string,</span>
  <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">interface JestExpectType {</span>
  <span class="s1">not: JestExpectType &amp;</span>
    <span class="s1">EnzymeMatchersType &amp;</span>
    <span class="s1">DomTestingLibraryType &amp;</span>
    <span class="s1">JestJQueryMatchersType &amp;</span>
    <span class="s1">JestStyledComponentsMatchersType &amp;</span>
    <span class="s1">JestExtendedMatchersType &amp;</span>
    <span class="s1">SnapshotDiffType;</span>
  <span class="s0">/** 
   * If you have a mock function, you can use .lastCalledWith to test what 
   * arguments it was last called with. 
   */</span>
  <span class="s1">lastCalledWith(...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * toBe just checks that a value is what you expect. It uses === to check 
   * strict equality. 
   */</span>
  <span class="s1">toBe(value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toBeCalledWith to ensure that a mock function was called with 
   * specific arguments. 
   */</span>
  <span class="s1">toBeCalledWith(...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Using exact equality with floating point numbers is a bad idea. Rounding 
   * means that intuitive things fail. 
   */</span>
  <span class="s1">toBeCloseTo(num: number, delta: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toBeDefined to check that a variable is not undefined. 
   */</span>
  <span class="s1">toBeDefined(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toBeFalsy when you don't care what a value is, you just want to 
   * ensure a value is false in a boolean context. 
   */</span>
  <span class="s1">toBeFalsy(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * To compare floating point numbers, you can use toBeGreaterThan. 
   */</span>
  <span class="s1">toBeGreaterThan(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * To compare floating point numbers, you can use toBeGreaterThanOrEqual. 
   */</span>
  <span class="s1">toBeGreaterThanOrEqual(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * To compare floating point numbers, you can use toBeLessThan. 
   */</span>
  <span class="s1">toBeLessThan(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * To compare floating point numbers, you can use toBeLessThanOrEqual. 
   */</span>
  <span class="s1">toBeLessThanOrEqual(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toBeInstanceOf(Class) to check that an object is an instance of a 
   * class. 
   */</span>
  <span class="s1">toBeInstanceOf(cls: Class&lt;*&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * .toBeNull() is the same as .toBe(null) but the error messages are a bit 
   * nicer. 
   */</span>
  <span class="s1">toBeNull(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toBeTruthy when you don't care what a value is, you just want to 
   * ensure a value is true in a boolean context. 
   */</span>
  <span class="s1">toBeTruthy(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toBeUndefined to check that a variable is undefined. 
   */</span>
  <span class="s1">toBeUndefined(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toContain when you want to check that an item is in a list. For 
   * testing the items in the list, this uses ===, a strict equality check. 
   */</span>
  <span class="s1">toContain(item: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toContainEqual when you want to check that an item is in a list. For 
   * testing the items in the list, this matcher recursively checks the 
   * equality of all fields, rather than checking for object identity. 
   */</span>
  <span class="s1">toContainEqual(item: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toEqual when you want to check that two objects have the same value. 
   * This matcher recursively checks the equality of all fields, rather than 
   * checking for object identity. 
   */</span>
  <span class="s1">toEqual(value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toHaveBeenCalled to ensure that a mock function got called. 
   */</span>
  <span class="s1">toHaveBeenCalled(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toBeCalled(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toHaveBeenCalledTimes to ensure that a mock function got called exact 
   * number of times. 
   */</span>
  <span class="s1">toHaveBeenCalledTimes(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toBeCalledTimes(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * 
   */</span>
  <span class="s1">toHaveBeenNthCalledWith(nthCall: number, ...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">nthCalledWith(nthCall: number, ...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * 
   */</span>
  <span class="s1">toHaveReturned(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toReturn(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * 
   */</span>
  <span class="s1">toHaveReturnedTimes(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toReturnTimes(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * 
   */</span>
  <span class="s1">toHaveReturnedWith(value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toReturnWith(value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * 
   */</span>
  <span class="s1">toHaveLastReturnedWith(value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">lastReturnedWith(value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * 
   */</span>
  <span class="s1">toHaveNthReturnedWith(nthCall: number, value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">nthReturnedWith(nthCall: number, value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toHaveBeenCalledWith to ensure that a mock function was called with 
   * specific arguments. 
   */</span>
  <span class="s1">toHaveBeenCalledWith(...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toBeCalledWith(...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toHaveBeenLastCalledWith to ensure that a mock function was last called 
   * with specific arguments. 
   */</span>
  <span class="s1">toHaveBeenLastCalledWith(...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">lastCalledWith(...args: Array&lt;any&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Check that an object has a .length property and it is set to a certain 
   * numeric value. 
   */</span>
  <span class="s1">toHaveLength(number: number): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * 
   */</span>
  <span class="s1">toHaveProperty(propPath: string | $ReadOnlyArray&lt;string&gt;, value?: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toMatch to check that a string matches a regular expression or string. 
   */</span>
  <span class="s1">toMatch(regexpOrString: RegExp | string): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toMatchObject to check that a javascript object matches a subset of the properties of an object. 
   */</span>
  <span class="s1">toMatchObject(object: Object | Array&lt;Object&gt;): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toStrictEqual to check that a javascript object matches a subset of the properties of an object. 
   */</span>
  <span class="s1">toStrictEqual(value: any): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * This ensures that an Object matches the most recent snapshot. 
   */</span>
  <span class="s1">toMatchSnapshot(propertyMatchers?: any, name?: string): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * This ensures that an Object matches the most recent snapshot. 
   */</span>
  <span class="s1">toMatchSnapshot(name: string): </span><span class="s2">void</span><span class="s1">;</span>

  <span class="s1">toMatchInlineSnapshot(snapshot?: string): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toMatchInlineSnapshot(propertyMatchers?: any, snapshot?: string): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toThrow to test that a function throws when it is called. 
   * If you want to test that a specific error gets thrown, you can provide an 
   * argument to toThrow. The argument can be a string for the error message, 
   * a class for the error, or a regex that should match the error. 
   * 
   * Alias: .toThrowError 
   */</span>
  <span class="s1">toThrow(message?: string | Error | Class&lt;Error&gt; | RegExp): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toThrowError(message?: string | Error | Class&lt;Error&gt; | RegExp): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s0">/** 
   * Use .toThrowErrorMatchingSnapshot to test that a function throws a error 
   * matching the most recent snapshot when it is called. 
   */</span>
  <span class="s1">toThrowErrorMatchingSnapshot(): </span><span class="s2">void</span><span class="s1">;</span>
  <span class="s1">toThrowErrorMatchingInlineSnapshot(snapshot?: string): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">type JestObjectType = {</span>
  <span class="s0">/** 
   *  Disables automatic mocking in the module loader. 
   * 
   *  After this method is called, all `require()`s will return the real 
   *  versions of each module (rather than a mocked version). 
   */</span>
  <span class="s1">disableAutomock(): JestObjectType,</span>
  <span class="s0">/** 
   * An un-hoisted version of disableAutomock 
   */</span>
  <span class="s1">autoMockOff(): JestObjectType,</span>
  <span class="s0">/** 
   * Enables automatic mocking in the module loader. 
   */</span>
  <span class="s1">enableAutomock(): JestObjectType,</span>
  <span class="s0">/** 
   * An un-hoisted version of enableAutomock 
   */</span>
  <span class="s1">autoMockOn(): JestObjectType,</span>
  <span class="s0">/** 
   * Clears the mock.calls and mock.instances properties of all mocks. 
   * Equivalent to calling .mockClear() on every mocked function. 
   */</span>
  <span class="s1">clearAllMocks(): JestObjectType,</span>
  <span class="s0">/** 
   * Resets the state of all mocks. Equivalent to calling .mockReset() on every 
   * mocked function. 
   */</span>
  <span class="s1">resetAllMocks(): JestObjectType,</span>
  <span class="s0">/** 
   * Restores all mocks back to their original value. 
   */</span>
  <span class="s1">restoreAllMocks(): JestObjectType,</span>
  <span class="s0">/** 
   * Removes any pending timers from the timer system. 
   */</span>
  <span class="s1">clearAllTimers(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Returns the number of fake timers still left to run. 
   */</span>
  <span class="s1">getTimerCount(): number,</span>
  <span class="s0">/** 
   * Set the current system time used by fake timers. 
   * Simulates a user changing the system clock while your program is running. 
   * It affects the current time but it does not in itself cause 
   * e.g. timers to fire; they will fire exactly as they would have done 
   * without the call to jest.setSystemTime(). 
   */</span>
  <span class="s1">setSystemTime(now?: number | Date): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * The same as `mock` but not moved to the top of the expectation by 
   * babel-jest. 
   */</span>
  <span class="s1">doMock(moduleName: string, moduleFactory?: any): JestObjectType,</span>
  <span class="s0">/** 
   * The same as `unmock` but not moved to the top of the expectation by 
   * babel-jest. 
   */</span>
  <span class="s1">dontMock(moduleName: string): JestObjectType,</span>
  <span class="s0">/** 
   * Returns a new, unused mock function. Optionally takes a mock 
   * implementation. 
   */</span>
  <span class="s0">// MODIFIED: Added defaults to type arguments.</span>
  <span class="s1">fn&lt;TArguments: $ReadOnlyArray&lt;mixed&gt; = $ReadOnlyArray&lt;any&gt;, TReturn = any&gt;(</span>
    <span class="s1">implementation?: (...args: TArguments) =&gt; TReturn,</span>
  <span class="s1">): JestMockFn&lt;TArguments, TReturn&gt;,</span>
  <span class="s0">/** 
   * Determines if the given function is a mocked function. 
   */</span>
  <span class="s1">isMockFunction(fn: Function): boolean,</span>
  <span class="s0">/** 
   * Alias of `createMockFromModule`. 
   */</span>
  <span class="s1">genMockFromModule(moduleName: string): any,</span>
  <span class="s0">/** 
   * Given the name of a module, use the automatic mocking system to generate a 
   * mocked version of the module for you. 
   */</span>
  <span class="s1">createMockFromModule(moduleName: string): any,</span>
  <span class="s0">/** 
   * Mocks a module with an auto-mocked version when it is being required. 
   * 
   * The second argument can be used to specify an explicit module factory that 
   * is being run instead of using Jest's automocking feature. 
   * 
   * The third argument can be used to create virtual mocks -- mocks of modules 
   * that don't exist anywhere in the system. 
   */</span>
  <span class="s1">mock(</span>
    <span class="s1">moduleName: string,</span>
    <span class="s1">moduleFactory?: any,</span>
    <span class="s1">options?: Object,</span>
  <span class="s1">): JestObjectType,</span>
  <span class="s0">/** 
   * Returns the actual module instead of a mock, bypassing all checks on 
   * whether the module should receive a mock implementation or not. 
   */</span>
  <span class="s1">requireActual&lt;T&gt;(m: $Flow$ModuleRef&lt;T&gt; | string): T,</span>
  <span class="s0">/** 
   * Returns a mock module instead of the actual module, bypassing all checks 
   * on whether the module should be required normally or not. 
   */</span>
  <span class="s1">requireMock(moduleName: string): any,</span>
  <span class="s0">/** 
   * Resets the module registry - the cache of all required modules. This is 
   * useful to isolate modules where local state might conflict between tests. 
   */</span>
  <span class="s1">resetModules(): JestObjectType,</span>
  <span class="s0">/** 
   * Creates a sandbox registry for the modules that are loaded inside the 
   * callback function. This is useful to isolate specific modules for every 
   * test so that local module state doesn't conflict between tests. 
   */</span>
  <span class="s1">isolateModules(fn: () =&gt; </span><span class="s2">void</span><span class="s1">): JestObjectType,</span>
  <span class="s0">/** 
   * Exhausts the micro-task queue (usually interfaced in node via 
   * process.nextTick). 
   */</span>
  <span class="s1">runAllTicks(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Exhausts the macro-task queue (i.e., all tasks queued by setTimeout(), 
   * setInterval(), and setImmediate()). 
   */</span>
  <span class="s1">runAllTimers(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Exhausts all tasks queued by setImmediate(). 
   */</span>
  <span class="s1">runAllImmediates(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Executes only the macro task queue (i.e. all tasks queued by setTimeout() 
   * or setInterval() and setImmediate()). 
   */</span>
  <span class="s1">advanceTimersByTime(msToRun: number): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Executes only the macro-tasks that are currently pending (i.e., only the 
   * tasks that have been queued by setTimeout() or setInterval() up to this 
   * point) 
   */</span>
  <span class="s1">runOnlyPendingTimers(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Explicitly supplies the mock object that the module system should return 
   * for the specified module. Note: It is recommended to use jest.mock() 
   * instead. 
   */</span>
  <span class="s1">setMock(moduleName: string, moduleExports: any): JestObjectType,</span>
  <span class="s0">/** 
   * Indicates that the module system should never return a mocked version of 
   * the specified module from require() (e.g. that it should always return the 
   * real module). 
   */</span>
  <span class="s1">unmock(moduleName: string): JestObjectType,</span>
  <span class="s0">/** 
   * Instructs Jest to use fake versions of the standard timer functions 
   * (setTimeout, setInterval, clearTimeout, clearInterval, nextTick, 
   * setImmediate and clearImmediate). 
   */</span>
  <span class="s1">useFakeTimers(fakeTimersConfig?: FakeTimersConfig): JestObjectType,</span>
  <span class="s0">/** 
   * Instructs Jest to use the real versions of the standard timer functions. 
   */</span>
  <span class="s1">useRealTimers(): JestObjectType,</span>
  <span class="s0">/** 
   * Creates a mock function similar to jest.fn but also tracks calls to 
   * object[methodName]. 
   */</span>
  <span class="s1">spyOn(</span>
    <span class="s1">object: Object,</span>
    <span class="s1">methodName: string,</span>
    <span class="s1">accessType?: </span><span class="s3">'get' </span><span class="s1">| </span><span class="s3">'set'</span><span class="s1">,</span>
  <span class="s1">): JestMockFn&lt;any, any&gt;,</span>
  <span class="s0">/** 
   * Set the default timeout interval for tests and before/after hooks in milliseconds. 
   * Note: The default timeout interval is 5 seconds if this method is not called. 
   */</span>
  <span class="s1">setTimeout(timeout: number): JestObjectType,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestSpyType = {calls: JestCallsType, ...};</span>

<span class="s1">type JestDoneFn = {|</span>
  <span class="s1">(error?: Error): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">fail: (error: Error) =&gt; </span><span class="s2">void</span><span class="s1">,</span>
<span class="s1">|};</span>

<span class="s0">/** Runs this function after every test inside this context */</span>
<span class="s1">declare </span><span class="s2">function </span><span class="s1">afterEach(</span>
  <span class="s1">fn: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
  <span class="s1">timeout?: number,</span>
<span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s0">/** Runs this function before every test inside this context */</span>
<span class="s1">declare </span><span class="s2">function </span><span class="s1">beforeEach(</span>
  <span class="s1">fn: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
  <span class="s1">timeout?: number,</span>
<span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s0">/** Runs this function after all tests have finished inside this context */</span>
<span class="s1">declare </span><span class="s2">function </span><span class="s1">afterAll(</span>
  <span class="s1">fn: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
  <span class="s1">timeout?: number,</span>
<span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s0">/** Runs this function before any tests have started inside this context */</span>
<span class="s1">declare </span><span class="s2">function </span><span class="s1">beforeAll(</span>
  <span class="s1">fn: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
  <span class="s1">timeout?: number,</span>
<span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>

<span class="s0">/** A context for grouping tests together */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">describe: {</span>
  <span class="s0">/** 
   * Creates a block that groups together several related tests in one &quot;test suite&quot; 
   */</span>
  <span class="s1">(name: JestTestName, fn: () =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Only run this describe block 
   */</span>
  <span class="s1">only(name: JestTestName, fn: () =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Skip running this describe block 
   */</span>
  <span class="s1">skip(name: JestTestName, fn: () =&gt; </span><span class="s2">void</span><span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * each runs this test against array of argument arrays per each run 
   * 
   * @param {table} table of Test 
   */</span>
  <span class="s1">each(</span>
    <span class="s1">...table: Array&lt;Array&lt;mixed&gt; | mixed&gt; | [Array&lt;string&gt;, string]</span>
  <span class="s1">): (</span>
    <span class="s1">name: JestTestName,</span>
    <span class="s1">fn?: (...args: Array&lt;any&gt;) =&gt; ?Promise&lt;mixed&gt;,</span>
    <span class="s1">timeout?: number,</span>
  <span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">/** An individual test unit */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">it: {</span>
  <span class="s0">/** 
   * An individual test unit 
   * 
   * @param {JestTestName} Name of Test 
   * @param {Function} Test 
   * @param {number} Timeout for the test, in milliseconds. 
   */</span>
  <span class="s1">(</span>
    <span class="s1">name: JestTestName,</span>
    <span class="s1">fn?: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
    <span class="s1">timeout?: number,</span>
  <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Only run this test 
   * 
   * @param {JestTestName} Name of Test 
   * @param {Function} Test 
   * @param {number} Timeout for the test, in milliseconds. 
   */</span>
  <span class="s1">only: {|</span>
    <span class="s1">(</span>
      <span class="s1">name: JestTestName,</span>
      <span class="s1">fn?: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
      <span class="s1">timeout?: number,</span>
    <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
    <span class="s1">each(</span>
      <span class="s1">...table: Array&lt;Array&lt;mixed&gt; | mixed&gt; | [Array&lt;string&gt;, string]</span>
    <span class="s1">): (</span>
      <span class="s1">name: JestTestName,</span>
      <span class="s1">fn?: (...args: Array&lt;any&gt;) =&gt; ?Promise&lt;mixed&gt;,</span>
      <span class="s1">timeout?: number,</span>
    <span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">|},</span>
  <span class="s0">/** 
   * Skip running this test 
   * 
   * @param {JestTestName} Name of Test 
   * @param {Function} Test 
   * @param {number} Timeout for the test, in milliseconds. 
   */</span>
  <span class="s1">skip: {|</span>
    <span class="s1">(</span>
      <span class="s1">name: JestTestName,</span>
      <span class="s1">fn?: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
      <span class="s1">timeout?: number,</span>
    <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
    <span class="s1">each(</span>
      <span class="s1">...table: Array&lt;Array&lt;mixed&gt; | mixed&gt; | [Array&lt;string&gt;, string]</span>
    <span class="s1">): (</span>
      <span class="s1">name: JestTestName,</span>
      <span class="s1">fn?: (...args: Array&lt;any&gt;) =&gt; ?Promise&lt;mixed&gt;,</span>
      <span class="s1">timeout?: number,</span>
    <span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">|},</span>
  <span class="s0">/** 
   * Highlight planned tests in the summary output 
   * 
   * @param {String} Name of Test to do 
   */</span>
  <span class="s1">todo(name: string): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Run the test concurrently 
   * 
   * @param {JestTestName} Name of Test 
   * @param {Function} Test 
   * @param {number} Timeout for the test, in milliseconds. 
   */</span>
  <span class="s1">concurrent(</span>
    <span class="s1">name: JestTestName,</span>
    <span class="s1">fn?: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
    <span class="s1">timeout?: number,</span>
  <span class="s1">): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * each runs this test against array of argument arrays per each run 
   * 
   * @param {table} table of Test 
   */</span>
  <span class="s1">each(</span>
    <span class="s1">...table: Array&lt;Array&lt;mixed&gt; | mixed&gt; | [Array&lt;string&gt;, string]</span>
  <span class="s1">): (</span>
    <span class="s1">name: JestTestName,</span>
    <span class="s1">fn?: (...args: Array&lt;any&gt;) =&gt; ?Promise&lt;mixed&gt;,</span>
    <span class="s1">timeout?: number,</span>
  <span class="s1">) =&gt; </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">declare </span><span class="s2">function </span><span class="s1">fit(</span>
  <span class="s1">name: JestTestName,</span>
  <span class="s1">fn: (done: JestDoneFn) =&gt; ?Promise&lt;mixed&gt;,</span>
  <span class="s1">timeout?: number,</span>
<span class="s1">): </span><span class="s2">void</span><span class="s1">;</span>
<span class="s0">/** An individual test unit */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">test: </span><span class="s2">typeof </span><span class="s1">it;</span>
<span class="s0">/** A disabled group of tests */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">xdescribe: </span><span class="s2">typeof </span><span class="s1">describe;</span>
<span class="s0">/** A focused group of tests */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">fdescribe: </span><span class="s2">typeof </span><span class="s1">describe;</span>
<span class="s0">/** A disabled individual test */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">xit: </span><span class="s2">typeof </span><span class="s1">it;</span>
<span class="s0">/** A disabled individual test */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">xtest: </span><span class="s2">typeof </span><span class="s1">it;</span>

<span class="s1">type JestPrettyFormatColors = {</span>
  <span class="s1">comment: {</span>
    <span class="s1">close: string,</span>
    <span class="s1">open: string,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s1">content: {</span>
    <span class="s1">close: string,</span>
    <span class="s1">open: string,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s1">prop: {</span>
    <span class="s1">close: string,</span>
    <span class="s1">open: string,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s1">tag: {</span>
    <span class="s1">close: string,</span>
    <span class="s1">open: string,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s1">value: {</span>
    <span class="s1">close: string,</span>
    <span class="s1">open: string,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestPrettyFormatIndent = string =&gt; string;</span>
<span class="s1">type JestPrettyFormatRefs = Array&lt;any&gt;;</span>
<span class="s1">type JestPrettyFormatPrint = any =&gt; string;</span>
<span class="s1">type JestPrettyFormatStringOrNull = string | </span><span class="s2">null</span><span class="s1">;</span>

<span class="s1">type JestPrettyFormatOptions = {|</span>
  <span class="s1">callToJSON: boolean,</span>
  <span class="s1">edgeSpacing: string,</span>
  <span class="s1">escapeRegex: boolean,</span>
  <span class="s1">highlight: boolean,</span>
  <span class="s1">indent: number,</span>
  <span class="s1">maxDepth: number,</span>
  <span class="s1">min: boolean,</span>
  <span class="s1">plugins: JestPrettyFormatPlugins,</span>
  <span class="s1">printFunctionName: boolean,</span>
  <span class="s1">spacing: string,</span>
  <span class="s1">theme: {|</span>
    <span class="s1">comment: string,</span>
    <span class="s1">content: string,</span>
    <span class="s1">prop: string,</span>
    <span class="s1">tag: string,</span>
    <span class="s1">value: string,</span>
  <span class="s1">|},</span>
<span class="s1">|};</span>

<span class="s1">type JestPrettyFormatPlugin = {</span>
  <span class="s1">print: (</span>
    <span class="s1">val: any,</span>
    <span class="s1">serialize: JestPrettyFormatPrint,</span>
    <span class="s1">indent: JestPrettyFormatIndent,</span>
    <span class="s1">opts: JestPrettyFormatOptions,</span>
    <span class="s1">colors: JestPrettyFormatColors,</span>
  <span class="s1">) =&gt; string,</span>
  <span class="s1">test: any =&gt; boolean,</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s1">type JestPrettyFormatPlugins = Array&lt;JestPrettyFormatPlugin&gt;;</span>

<span class="s0">/** The expect function is used every time you want to test a value */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">expect: {</span>
  <span class="s0">/** The object that you want to make assertions against */</span>
  <span class="s1">(</span>
    <span class="s1">value: any,</span>
  <span class="s1">): JestExpectType &amp;</span>
    <span class="s1">JestPromiseType &amp;</span>
    <span class="s1">EnzymeMatchersType &amp;</span>
    <span class="s1">DomTestingLibraryType &amp;</span>
    <span class="s1">JestJQueryMatchersType &amp;</span>
    <span class="s1">JestStyledComponentsMatchersType &amp;</span>
    <span class="s1">JestExtendedMatchersType &amp;</span>
    <span class="s1">SnapshotDiffType,</span>
  <span class="s0">/** Add additional Jasmine matchers to Jest's roster */</span>
  <span class="s1">extend(matchers: {[name: string]: JestMatcher, ...}): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s0">/** Add a module that formats application-specific data structures. */</span>
  <span class="s1">addSnapshotSerializer(pluginModule: JestPrettyFormatPlugin): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">assertions(expectedAssertions: number): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">hasAssertions(): </span><span class="s2">void</span><span class="s1">,</span>
  <span class="s1">any(value: mixed): JestAsymmetricEqualityType,</span>
  <span class="s1">anything(): any,</span>
  <span class="s0">// MODIFIED: Array -&gt; $ReadOnlyArray</span>
  <span class="s1">arrayContaining(value: $ReadOnlyArray&lt;mixed&gt;): Array&lt;mixed&gt;,</span>
  <span class="s1">objectContaining(value: Object): Object,</span>
  <span class="s0">/** Matches any received string that contains the exact expected string. */</span>
  <span class="s1">stringContaining(value: string): string,</span>
  <span class="s1">stringMatching(value: string | RegExp): string,</span>
  <span class="s1">not: {</span>
    <span class="s1">arrayContaining: (value: $ReadOnlyArray&lt;mixed&gt;) =&gt; Array&lt;mixed&gt;,</span>
    <span class="s1">objectContaining: (value: {...}) =&gt; Object,</span>
    <span class="s1">stringContaining: (value: string) =&gt; string,</span>
    <span class="s1">stringMatching: (value: string | RegExp) =&gt; string,</span>
    <span class="s1">...</span>
  <span class="s1">},</span>
  <span class="s1">...</span>
<span class="s1">};</span>

<span class="s0">// TODO handle return type</span>
<span class="s0">// http://jasmine.github.io/2.4/introduction.html#section-Spies</span>
<span class="s1">declare </span><span class="s2">function </span><span class="s1">spyOn(value: mixed, method: string): Object;</span>

<span class="s0">/** Holds all functions related to manipulating test runner */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">jest: JestObjectType;</span>

<span class="s0">/** 
 * The global Jasmine object, this is generally not exposed as the public API, 
 * using features inside here could break in later versions of Jest. 
 */</span>
<span class="s1">declare </span><span class="s2">var </span><span class="s1">jasmine: {</span>
  <span class="s1">DEFAULT_TIMEOUT_INTERVAL: number,</span>
  <span class="s1">any(value: mixed): JestAsymmetricEqualityType,</span>
  <span class="s1">anything(): any,</span>
  <span class="s1">arrayContaining(value: Array&lt;mixed&gt;): Array&lt;mixed&gt;,</span>
  <span class="s1">clock(): JestClockType,</span>
  <span class="s1">createSpy(name: string): JestSpyType,</span>
  <span class="s1">createSpyObj(</span>
    <span class="s1">baseName: string,</span>
    <span class="s1">methodNames: Array&lt;string&gt;,</span>
  <span class="s1">): {[methodName: string]: JestSpyType, ...},</span>
  <span class="s1">objectContaining(value: Object): Object,</span>
  <span class="s1">stringMatching(value: string): string,</span>
  <span class="s1">...</span>
<span class="s1">};</span>
</pre>
</body>
</html>
<html>
<head>
<title>SourceCode.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
SourceCode.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ </span><span class="s2">ParserServices</span><span class="s1">, </span><span class="s2">TSESTree </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'../ts-estree'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ </span><span class="s2">Scope </span><span class="s1">} </span><span class="s0">from </span><span class="s3">'./Scope'</span><span class="s1">;</span>
<span class="s0">declare class </span><span class="s2">TokenStore </span><span class="s1">{</span>
    <span class="s4">/**</span>
     <span class="s4">* Checks whether any comments exist or not between the given 2 nodes. 
     * </span><span class="s0">@param </span><span class="s2">left </span><span class="s4">The node to check. 
     * </span><span class="s0">@param </span><span class="s2">right </span><span class="s4">The node to check. 
     * </span><span class="s0">@returns </span><span class="s4">`true` if one or more comments exist. 
     */</span>
    <span class="s1">commentsExistBetween(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets all comment tokens directly after the given node or token. 
     * </span><span class="s0">@param </span><span class="s2">nodeOrToken </span><span class="s4">The AST node or token to check for adjacent comment tokens. 
     * </span><span class="s0">@returns </span><span class="s4">An array of comments in occurrence order. 
     */</span>
    <span class="s1">getCommentsAfter(</span><span class="s2">nodeOrToken</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Comment</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets all comment tokens directly before the given node or token. 
     * </span><span class="s0">@param </span><span class="s2">nodeOrToken </span><span class="s4">The AST node or token to check for adjacent comment tokens. 
     * </span><span class="s0">@returns </span><span class="s4">An array of comments in occurrence order. 
     */</span>
    <span class="s1">getCommentsBefore(</span><span class="s2">nodeOrToken</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Comment</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets all comment tokens inside the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node to get the comments for. 
     * </span><span class="s0">@returns </span><span class="s4">An array of comments in occurrence order. 
     */</span>
    <span class="s1">getCommentsInside(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Comment</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the first token of the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">option </span><span class="s4">The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">An object representing the token. 
     */</span>
    <span class="s1">getFirstToken&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithSkipOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the first token between two non-overlapping nodes. 
     * </span><span class="s0">@param </span><span class="s2">left </span><span class="s4">Node before the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">right </span><span class="s4">Node after the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">option </span><span class="s4">The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">An object representing the token. 
     */</span>
    <span class="s1">getFirstTokenBetween&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithSkipOptions</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the first `count` tokens of the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens. 
     */</span>
    <span class="s1">getFirstTokens&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the first `count` tokens between two non-overlapping nodes. 
     * </span><span class="s0">@param </span><span class="s2">left </span><span class="s4">Node before the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">right </span><span class="s4">Node after the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens between left and right. 
     */</span>
    <span class="s1">getFirstTokensBetween&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the last token of the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">option </span><span class="s4">The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">An object representing the token. 
     */</span>
    <span class="s1">getLastToken&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithSkipOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the last token between two non-overlapping nodes. 
     * </span><span class="s0">@param </span><span class="s2">left </span><span class="s4">Node before the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">right </span><span class="s4">Node after the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">option </span><span class="s4">The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">An object representing the token. 
     */</span>
    <span class="s1">getLastTokenBetween&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithSkipOptions</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the last `count` tokens of the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens. 
     */</span>
    <span class="s1">getLastTokens&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the last `count` tokens between two non-overlapping nodes. 
     * </span><span class="s0">@param </span><span class="s2">left </span><span class="s4">Node before the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">right </span><span class="s4">Node after the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens between left and right. 
     */</span>
    <span class="s1">getLastTokensBetween&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the token that follows a given node or token. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node or token. 
     * </span><span class="s0">@param </span><span class="s2">option </span><span class="s4">The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">An object representing the token. 
     */</span>
    <span class="s1">getTokenAfter&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithSkipOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the token that precedes a given node or token. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node or token. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object 
     * </span><span class="s0">@returns </span><span class="s4">An object representing the token. 
     */</span>
    <span class="s1">getTokenBefore&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithSkipOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the token starting at the specified index. 
     * </span><span class="s0">@param </span><span class="s2">offset </span><span class="s4">Index of the start of the token's range. 
     * </span><span class="s0">@param </span><span class="s2">option </span><span class="s4">The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">The token starting at index, or null if no such token. 
     */</span>
    <span class="s2">getTokenByRangeStart</span><span class="s0">&lt;</span><span class="s2">T extends </span><span class="s1">{</span>
        <span class="s2">includeComments</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s1">}</span><span class="s0">&gt;</span><span class="s1">(</span><span class="s2">offset</span><span class="s0">: </span><span class="s2">number</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets all tokens that are related to the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">beforeCount </span><span class="s4">The number of tokens before the node to retrieve. 
     * </span><span class="s0">@param </span><span class="s2">afterCount </span><span class="s4">The number of tokens after the node to retrieve. 
     * </span><span class="s0">@returns </span><span class="s4">Array of objects representing tokens. 
     */</span>
    <span class="s1">getTokens(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">beforeCount</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">, </span><span class="s2">afterCount</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets all tokens that are related to the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Array of objects representing tokens. 
     */</span>
    <span class="s1">getTokens&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">options</span><span class="s0">: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the `count` tokens that follows a given node or token. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens. 
     */</span>
    <span class="s1">getTokensAfter&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the `count` tokens that precedes a given node or token. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens. 
     */</span>
    <span class="s1">getTokensBefore&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">node</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">options</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets all of the tokens between two non-overlapping nodes. 
     * </span><span class="s0">@param </span><span class="s2">left </span><span class="s4">Node before the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">right </span><span class="s4">Node after the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">options </span><span class="s4">The option object. If this is a function then it's `options.filter`. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens between left and right. 
     */</span>
    <span class="s1">getTokensBetween&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">padding</span><span class="s0">?: </span><span class="s2">T</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets all of the tokens between two non-overlapping nodes. 
     * </span><span class="s0">@param </span><span class="s2">left </span><span class="s4">Node before the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">right </span><span class="s4">Node after the desired token range. 
     * </span><span class="s0">@param </span><span class="s2">padding </span><span class="s4">Number of extra tokens on either side of center. 
     * </span><span class="s0">@returns </span><span class="s4">Tokens between left and right. 
     */</span>
    <span class="s1">getTokensBetween&lt;</span><span class="s2">T </span><span class="s0">extends </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">CursorWithCountOptions</span><span class="s1">&gt;(</span><span class="s2">left</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">right</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">padding</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">)</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt;[];</span>
<span class="s1">}</span>
<span class="s0">declare class </span><span class="s2">SourceCodeBase </span><span class="s0">extends </span><span class="s2">TokenStore </span><span class="s1">{</span>
    <span class="s4">/**</span>
     <span class="s4">* Represents parsed source code. 
     * </span><span class="s0">@param </span><span class="s2">text </span><span class="s4">The source code text. 
     * </span><span class="s0">@param </span><span class="s2">ast </span><span class="s4">The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped. 
     */</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s2">text</span><span class="s0">: </span><span class="s2">string</span><span class="s1">, </span><span class="s2">ast</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">Program</span><span class="s1">);</span>
    <span class="s4">/**</span>
     <span class="s4">* Represents parsed source code. 
     * </span><span class="s0">@param </span><span class="s2">config </span><span class="s4">The config object. 
     */</span>
    <span class="s0">constructor</span><span class="s1">(</span><span class="s2">config</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">SourceCodeConfig</span><span class="s1">);</span>
    <span class="s4">/**</span>
     <span class="s4">* The parsed AST for the source code. 
     */</span>
    <span class="s1">ast</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">Program</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Retrieves an array containing all comments in the source code. 
     * </span><span class="s0">@returns </span><span class="s4">An array of comment nodes. 
     */</span>
    <span class="s1">getAllComments()</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Comment</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a (line, column) pair into a range index. 
     * </span><span class="s0">@param </span><span class="s2">loc </span><span class="s4">A line/column location 
     * </span><span class="s0">@returns </span><span class="s4">The range index of the location in the file. 
     */</span>
    <span class="s1">getIndexFromLoc(</span><span class="s2">location</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Position</span><span class="s1">)</span><span class="s0">: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the entire source text split into an array of lines. 
     * </span><span class="s0">@returns </span><span class="s4">The source text as an array of lines. 
     */</span>
    <span class="s1">getLines()</span><span class="s0">: </span><span class="s2">string</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a source text index into a (line, column) pair. 
     * </span><span class="s0">@param </span><span class="s2">index </span><span class="s4">The index of a character in a file 
     * </span><span class="s0">@returns </span><span class="s4">A {line, column} location object with a 0-indexed column 
     */</span>
    <span class="s1">getLocFromIndex(</span><span class="s2">index</span><span class="s0">: </span><span class="s2">number</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Position</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the deepest node containing a range index. 
     * </span><span class="s0">@param </span><span class="s2">index </span><span class="s4">Range index of the desired node. 
     * </span><span class="s0">@returns </span><span class="s4">The node if found or `null` if not found. 
     */</span>
    <span class="s1">getNodeByRangeIndex(</span><span class="s2">index</span><span class="s0">: </span><span class="s2">number</span><span class="s1">)</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Gets the source code for the given node. 
     * </span><span class="s0">@param </span><span class="s2">node </span><span class="s4">The AST node to get the text for. 
     * </span><span class="s0">@param </span><span class="s2">beforeCount </span><span class="s4">The number of characters before the node to retrieve. 
     * </span><span class="s0">@param </span><span class="s2">afterCount </span><span class="s4">The number of characters after the node to retrieve. 
     * </span><span class="s0">@returns </span><span class="s4">The text representing the AST node. 
     */</span>
    <span class="s1">getText(</span><span class="s2">node</span><span class="s0">?: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">beforeCount</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">, </span><span class="s2">afterCount</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">)</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* The flag to indicate that the source code has Unicode BOM. 
     */</span>
    <span class="s1">hasBOM</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Determines if two nodes or tokens have at least one whitespace character 
     * between them. Order does not matter. Returns false if the given nodes or 
     * tokens overlap. 
     * </span><span class="s0">@since </span><span class="s4">6.7.0 
     * </span><span class="s0">@param </span><span class="s2">first </span><span class="s4">The first node or token to check between. 
     * </span><span class="s0">@param </span><span class="s2">second </span><span class="s4">The second node or token to check between. 
     * </span><span class="s0">@returns </span><span class="s4">True if there is a whitespace character between any of the tokens found between the two given nodes or tokens. 
     */</span>
    <span class="s1">isSpaceBetween</span><span class="s0">?</span><span class="s1">(</span><span class="s2">first</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">, </span><span class="s2">second</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token </span><span class="s0">| </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Node</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Determines if two nodes or tokens have at least one whitespace character 
     * between them. Order does not matter. Returns false if the given nodes or 
     * tokens overlap. 
     * For backward compatibility, this method returns true if there are 
     * `JSXText` tokens that contain whitespace between the two. 
     * </span><span class="s0">@param </span><span class="s2">first </span><span class="s4">The first node or token to check between. 
     * </span><span class="s0">@param </span><span class="s2">second </span><span class="s4">The second node or token to check between. 
     * </span><span class="s0">@returns </span><span class="s2">{boolean} </span><span class="s4">True if there is a whitespace character between 
     * any of the tokens found between the two given nodes or tokens. 
     * </span><span class="s0">@deprecated </span><span class="s4">in favor of isSpaceBetween 
     */</span>
    <span class="s1">isSpaceBetweenTokens(</span><span class="s2">first</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">second</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">)</span><span class="s0">: </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* The source code split into lines according to ECMA-262 specification. 
     * This is done to avoid each rule needing to do so separately. 
     */</span>
    <span class="s1">lines</span><span class="s0">: </span><span class="s2">string</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* The indexes in `text` that each line starts 
     */</span>
    <span class="s1">lineStartIndices</span><span class="s0">: </span><span class="s2">number</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* The parser services of this source code. 
     */</span>
    <span class="s1">parserServices</span><span class="s0">: </span><span class="s2">ParserServices</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* The scope of this source code. 
     */</span>
    <span class="s1">scopeManager</span><span class="s0">: </span><span class="s2">Scope</span><span class="s1">.</span><span class="s2">ScopeManager </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* The original text source code. BOM was stripped from this text. 
     */</span>
    <span class="s1">text</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* All of the tokens and comments in the AST. 
     * 
     * TODO: rename to 'tokens' 
     */</span>
    <span class="s1">tokensAndComments</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">[];</span>
    <span class="s4">/**</span>
     <span class="s4">* The visitor keys to traverse AST. 
     */</span>
    <span class="s1">visitorKeys</span><span class="s0">: </span><span class="s2">SourceCode</span><span class="s1">.</span><span class="s2">VisitorKeys</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Split the source code into multiple lines based on the line delimiters. 
     * </span><span class="s0">@param </span><span class="s2">text </span><span class="s4">Source code as a string. 
     * </span><span class="s0">@returns </span><span class="s4">Array of source code lines. 
     */</span>
    <span class="s0">static </span><span class="s1">splitLines(</span><span class="s2">text</span><span class="s0">: </span><span class="s2">string</span><span class="s1">)</span><span class="s0">: </span><span class="s2">string</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s0">declare namespace </span><span class="s2">SourceCode </span><span class="s1">{</span>
    <span class="s0">interface </span><span class="s2">Program </span><span class="s0">extends </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Program </span><span class="s1">{</span>
        <span class="s1">comments</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Comment</span><span class="s1">[];</span>
        <span class="s1">tokens</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">interface </span><span class="s2">SourceCodeConfig </span><span class="s1">{</span>
        <span class="s4">/**</span>
         <span class="s4">* The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped. 
         */</span>
        <span class="s1">ast</span><span class="s0">: </span><span class="s2">Program</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The parser services. 
         */</span>
        <span class="s1">parserServices</span><span class="s0">: </span><span class="s2">ParserServices </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The scope of this source code. 
         */</span>
        <span class="s1">scopeManager</span><span class="s0">: </span><span class="s2">Scope</span><span class="s1">.</span><span class="s2">ScopeManager </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The source code text. 
         */</span>
        <span class="s1">text</span><span class="s0">: </span><span class="s2">string</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The visitor keys to traverse AST. 
         */</span>
        <span class="s1">visitorKeys</span><span class="s0">: </span><span class="s2">VisitorKeys </span><span class="s0">| </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">interface </span><span class="s2">VisitorKeys </span><span class="s1">{</span>
        <span class="s1">[</span><span class="s2">nodeType</span><span class="s0">: </span><span class="s2">string</span><span class="s1">]</span><span class="s0">: </span><span class="s2">string</span><span class="s1">[];</span>
    <span class="s1">}</span>
    <span class="s0">type </span><span class="s2">FilterPredicate </span><span class="s0">= </span><span class="s1">(</span><span class="s2">token</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">boolean</span><span class="s1">;</span>
    <span class="s0">type </span><span class="s2">GetFilterPredicate</span><span class="s1">&lt;</span><span class="s2">TFilter</span><span class="s1">, </span><span class="s2">TDefault</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">TFilter </span><span class="s0">extends </span><span class="s1">((</span><span class="s2">token</span><span class="s0">: </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">) </span><span class="s0">=&gt; </span><span class="s2">token </span><span class="s0">is infer </span><span class="s2">U </span><span class="s0">extends </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">) </span><span class="s0">? </span><span class="s2">U </span><span class="s0">: </span><span class="s2">TDefault</span><span class="s1">;</span>
    <span class="s0">type </span><span class="s2">GetFilterPredicateFromOptions</span><span class="s1">&lt;</span><span class="s2">TOptions</span><span class="s1">, </span><span class="s2">TDefault</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">TOptions </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">filter</span><span class="s0">?: </span><span class="s2">FilterPredicate</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">? </span><span class="s2">GetFilterPredicate</span><span class="s1">&lt;</span><span class="s2">TOptions</span><span class="s1">[</span><span class="s3">'filter'</span><span class="s1">], </span><span class="s2">TDefault</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">GetFilterPredicate</span><span class="s1">&lt;</span><span class="s2">TOptions</span><span class="s1">, </span><span class="s2">TDefault</span><span class="s1">&gt;;</span>
    <span class="s0">type </span><span class="s2">ReturnTypeFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">&gt; </span><span class="s0">= </span><span class="s2">T </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">includeComments</span><span class="s0">: </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s0">? </span><span class="s2">GetFilterPredicateFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">&gt; </span><span class="s0">: </span><span class="s2">GetFilterPredicateFromOptions</span><span class="s1">&lt;</span><span class="s2">T</span><span class="s1">, </span><span class="s2">Exclude</span><span class="s1">&lt;</span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Token</span><span class="s1">, </span><span class="s2">TSESTree</span><span class="s1">.</span><span class="s2">Comment</span><span class="s1">&gt;&gt;;</span>
    <span class="s0">type </span><span class="s2">CursorWithSkipOptions </span><span class="s0">= </span><span class="s2">number </span><span class="s0">| </span><span class="s2">FilterPredicate </span><span class="s0">| </span><span class="s1">{</span>
        <span class="s4">/**</span>
         <span class="s4">* The predicate function to choose tokens. 
         */</span>
        <span class="s1">filter</span><span class="s0">?: </span><span class="s2">FilterPredicate</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The flag to iterate comments as well. 
         */</span>
        <span class="s1">includeComments</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The count of tokens the cursor skips. 
         */</span>
        <span class="s1">skip</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">type </span><span class="s2">CursorWithCountOptions </span><span class="s0">= </span><span class="s2">number </span><span class="s0">| </span><span class="s2">FilterPredicate </span><span class="s0">| </span><span class="s1">{</span>
        <span class="s4">/**</span>
         <span class="s4">* The predicate function to choose tokens. 
         */</span>
        <span class="s1">filter</span><span class="s0">?: </span><span class="s2">FilterPredicate</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The flag to iterate comments as well. 
         */</span>
        <span class="s1">includeComments</span><span class="s0">?: </span><span class="s2">boolean</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* The maximum count of tokens the cursor iterates. 
         */</span>
        <span class="s1">count</span><span class="s0">?: </span><span class="s2">number</span><span class="s1">;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">declare const </span><span class="s1">SourceCode_base</span><span class="s0">: typeof </span><span class="s2">SourceCodeBase</span><span class="s1">;</span>
<span class="s0">declare class </span><span class="s2">SourceCode </span><span class="s0">extends </span><span class="s2">SourceCode_base </span><span class="s1">{</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">{ </span><span class="s2">SourceCode </span><span class="s1">};</span>
<span class="s4">//# sourceMappingURL=SourceCode.d.ts.map</span>
</pre>
</body>
</html>
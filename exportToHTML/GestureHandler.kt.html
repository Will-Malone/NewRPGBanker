<html>
<head>
<title>GestureHandler.kt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GestureHandler.kt</font>
</center></td></tr></table>
<pre><span class="s0">package </span><span class="s1">com.swmansion.gesturehandler.core</span>

<span class="s1">import android.app.Activity</span>
<span class="s1">import android.content.Context</span>
<span class="s1">import android.content.ContextWrapper</span>
<span class="s1">import android.graphics.PointF</span>
<span class="s1">import android.graphics.Rect</span>
<span class="s1">import android.view.MotionEvent</span>
<span class="s1">import android.view.MotionEvent.PointerCoords</span>
<span class="s1">import android.view.MotionEvent.PointerProperties</span>
<span class="s1">import android.view.View</span>
<span class="s1">import android.view.Window</span>
<span class="s1">import com.facebook.react.bridge.Arguments</span>
<span class="s1">import com.facebook.react.bridge.UiThreadUtil</span>
<span class="s1">import com.facebook.react.bridge.WritableArray</span>
<span class="s1">import com.facebook.react.uimanager.PixelUtil</span>
<span class="s1">import com.swmansion.gesturehandler.BuildConfig</span>
<span class="s1">import com.swmansion.gesturehandler.react.RNGestureHandlerTouchEvent</span>
<span class="s1">import java.lang.IllegalStateException</span>
<span class="s1">import java.util.*</span>

<span class="s1">open </span><span class="s0">class </span><span class="s1">GestureHandler&lt;ConcreteGestureHandlerT : GestureHandler&lt;ConcreteGestureHandlerT&gt;&gt; {</span>
  <span class="s1">private </span><span class="s0">val </span><span class="s1">trackedPointerIDs = IntArray(MAX_POINTERS_COUNT)</span>
  <span class="s1">private </span><span class="s0">var </span><span class="s1">trackedPointersIDsCount = </span><span class="s2">0</span>
  <span class="s1">private </span><span class="s0">val </span><span class="s1">windowOffset = IntArray(</span><span class="s2">2</span><span class="s1">) { </span><span class="s2">0 </span><span class="s1">}</span>
  <span class="s0">var </span><span class="s1">tag = </span><span class="s2">0</span>
  <span class="s0">var </span><span class="s1">view: View? = </span><span class="s0">null</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">state = STATE_UNDETERMINED</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">x = </span><span class="s2">0f</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">y = </span><span class="s2">0f</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">isWithinBounds = </span><span class="s0">false</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">isEnabled = </span><span class="s0">true</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">actionType = </span><span class="s2">0</span>

  <span class="s0">var </span><span class="s1">changedTouchesPayload: WritableArray? = </span><span class="s0">null</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">allTouchesPayload: WritableArray? = </span><span class="s0">null</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">touchEventType = RNGestureHandlerTouchEvent.EVENT_UNDETERMINED</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">trackedPointersCount = </span><span class="s2">0</span>
    <span class="s1">private set</span>
  <span class="s1">private </span><span class="s0">val </span><span class="s1">trackedPointers: Array&lt;PointerData?&gt; = Array(MAX_POINTERS_COUNT) { </span><span class="s0">null </span><span class="s1">}</span>
  <span class="s0">var </span><span class="s1">needsPointerData = </span><span class="s0">false</span>

  <span class="s1">private </span><span class="s0">var </span><span class="s1">hitSlop: FloatArray? = </span><span class="s0">null</span>
  <span class="s0">var </span><span class="s1">eventCoalescingKey: Short = </span><span class="s2">0</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">lastAbsolutePositionX = </span><span class="s2">0f</span>
    <span class="s1">private set</span>
  <span class="s0">var </span><span class="s1">lastAbsolutePositionY = </span><span class="s2">0f</span>
    <span class="s1">private set</span>

  <span class="s1">private </span><span class="s0">var </span><span class="s1">manualActivation = </span><span class="s0">false</span>

  <span class="s1">private </span><span class="s0">var </span><span class="s1">lastEventOffsetX = </span><span class="s2">0f</span>
  <span class="s1">private </span><span class="s0">var </span><span class="s1">lastEventOffsetY = </span><span class="s2">0f</span>
  <span class="s1">private </span><span class="s0">var </span><span class="s1">shouldCancelWhenOutside = </span><span class="s0">false</span>
  <span class="s0">var </span><span class="s1">numberOfPointers = </span><span class="s2">0</span>
    <span class="s1">private set</span>
  <span class="s1">protected </span><span class="s0">var </span><span class="s1">orchestrator: GestureHandlerOrchestrator? = </span><span class="s0">null</span>
  <span class="s1">private </span><span class="s0">var </span><span class="s1">onTouchEventListener: OnTouchEventListener? = </span><span class="s0">null</span>
  <span class="s1">private </span><span class="s0">var </span><span class="s1">interactionController: GestureHandlerInteractionController? = </span><span class="s0">null</span>

  <span class="s1">@Suppress(</span><span class="s3">&quot;UNCHECKED_CAST&quot;</span><span class="s1">)</span>
  <span class="s1">protected </span><span class="s0">fun </span><span class="s1">self(): ConcreteGestureHandlerT = </span><span class="s0">this as </span><span class="s1">ConcreteGestureHandlerT</span>

  <span class="s1">protected inline </span><span class="s0">fun </span><span class="s1">applySelf(block: ConcreteGestureHandlerT.() -&gt; Unit): ConcreteGestureHandlerT =</span>
    <span class="s1">self().apply { block() }</span>

  <span class="s4">// properties set and accessed only by the orchestrator</span>
  <span class="s0">var </span><span class="s1">activationIndex = </span><span class="s2">0</span>
  <span class="s0">var </span><span class="s1">isActive = </span><span class="s0">false</span>
  <span class="s0">var </span><span class="s1">isAwaiting = </span><span class="s0">false</span>
  <span class="s0">var </span><span class="s1">shouldResetProgress = </span><span class="s0">false</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">dispatchStateChange(newState: Int</span><span class="s0">, </span><span class="s1">prevState: Int) {</span>
    <span class="s1">onTouchEventListener?.onStateChange(self()</span><span class="s0">, </span><span class="s1">newState</span><span class="s0">, </span><span class="s1">prevState)</span>
  <span class="s1">}</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">dispatchHandlerUpdate(event: MotionEvent) {</span>
    <span class="s1">onTouchEventListener?.onHandlerUpdate(self()</span><span class="s0">, </span><span class="s1">event)</span>
  <span class="s1">}</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">dispatchTouchEvent() {</span>
    <span class="s0">if </span><span class="s1">(changedTouchesPayload != </span><span class="s0">null</span><span class="s1">) {</span>
      <span class="s1">onTouchEventListener?.onTouchEvent(self())</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">resetConfig() {</span>
    <span class="s1">needsPointerData = </span><span class="s0">false</span>
    <span class="s1">manualActivation = </span><span class="s0">false</span>
    <span class="s1">shouldCancelWhenOutside = </span><span class="s0">false</span>
    <span class="s1">isEnabled = </span><span class="s0">true</span>
    <span class="s1">hitSlop = </span><span class="s0">null</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">hasCommonPointers(other: GestureHandler&lt;*&gt;): Boolean {</span>
    <span class="s0">for </span><span class="s1">(i </span><span class="s0">in </span><span class="s1">trackedPointerIDs.indices) {</span>
      <span class="s0">if </span><span class="s1">(trackedPointerIDs[i] != -</span><span class="s2">1 </span><span class="s1">&amp;&amp; other.trackedPointerIDs[i] != -</span><span class="s2">1</span><span class="s1">) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return false</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">setShouldCancelWhenOutside(shouldCancelWhenOutside: Boolean): ConcreteGestureHandlerT =</span>
    <span class="s1">applySelf { </span><span class="s0">this</span><span class="s1">.shouldCancelWhenOutside = shouldCancelWhenOutside }</span>

  <span class="s0">fun </span><span class="s1">setEnabled(enabled: Boolean): ConcreteGestureHandlerT = applySelf {</span>
    <span class="s4">// Don't cancel handler when not changing the value of the isEnabled, executing it always caused</span>
    <span class="s4">// handlers to be cancelled on re-render because that's the moment when the config is updated.</span>
    <span class="s4">// If the enabled prop &quot;changed&quot; from true to true the handler would get cancelled.</span>
    <span class="s0">if </span><span class="s1">(view != </span><span class="s0">null </span><span class="s1">&amp;&amp; isEnabled != enabled) {</span>
      <span class="s4">// If view is set then handler is in &quot;active&quot; state. In that case we want to &quot;cancel&quot; handler</span>
      <span class="s4">// when it changes enabled state so that it gets cleared from the orchestrator</span>
      <span class="s1">UiThreadUtil.runOnUiThread { cancel() }</span>
    <span class="s1">}</span>
    <span class="s1">isEnabled = enabled</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">setManualActivation(manualActivation: Boolean): ConcreteGestureHandlerT =</span>
    <span class="s1">applySelf { </span><span class="s0">this</span><span class="s1">.manualActivation = manualActivation }</span>

  <span class="s0">fun </span><span class="s1">setHitSlop(</span>
    <span class="s1">leftPad: Float</span><span class="s0">,</span>
    <span class="s1">topPad: Float</span><span class="s0">,</span>
    <span class="s1">rightPad: Float</span><span class="s0">,</span>
    <span class="s1">bottomPad: Float</span><span class="s0">,</span>
    <span class="s1">width: Float</span><span class="s0">,</span>
    <span class="s1">height: Float</span><span class="s0">,</span>
  <span class="s1">): ConcreteGestureHandlerT = applySelf {</span>
    <span class="s0">if </span><span class="s1">(hitSlop == </span><span class="s0">null</span><span class="s1">) {</span>
      <span class="s1">hitSlop = FloatArray(</span><span class="s2">6</span><span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s1">hitSlop!![HIT_SLOP_LEFT_IDX] = leftPad</span>
    <span class="s1">hitSlop!![HIT_SLOP_TOP_IDX] = topPad</span>
    <span class="s1">hitSlop!![HIT_SLOP_RIGHT_IDX] = rightPad</span>
    <span class="s1">hitSlop!![HIT_SLOP_BOTTOM_IDX] = bottomPad</span>
    <span class="s1">hitSlop!![HIT_SLOP_WIDTH_IDX] = width</span>
    <span class="s1">hitSlop!![HIT_SLOP_HEIGHT_IDX] = height</span>
    <span class="s1">require(!(hitSlopSet(width) &amp;&amp; hitSlopSet(leftPad) &amp;&amp; hitSlopSet(rightPad))) { </span><span class="s3">&quot;Cannot have all of left, right and width defined&quot; </span><span class="s1">}</span>
    <span class="s1">require(!(hitSlopSet(width) &amp;&amp; !hitSlopSet(leftPad) &amp;&amp; !hitSlopSet(rightPad))) { </span><span class="s3">&quot;When width is set one of left or right pads need to be defined&quot; </span><span class="s1">}</span>
    <span class="s1">require(!(hitSlopSet(height) &amp;&amp; hitSlopSet(bottomPad) &amp;&amp; hitSlopSet(topPad))) { </span><span class="s3">&quot;Cannot have all of top, bottom and height defined&quot; </span><span class="s1">}</span>
    <span class="s1">require(!(hitSlopSet(height) &amp;&amp; !hitSlopSet(bottomPad) &amp;&amp; !hitSlopSet(topPad))) { </span><span class="s3">&quot;When height is set one of top or bottom pads need to be defined&quot; </span><span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">setHitSlop(padding: Float): ConcreteGestureHandlerT {</span>
    <span class="s0">return </span><span class="s1">setHitSlop(padding</span><span class="s0">, </span><span class="s1">padding</span><span class="s0">, </span><span class="s1">padding</span><span class="s0">, </span><span class="s1">padding</span><span class="s0">, </span><span class="s1">HIT_SLOP_NONE</span><span class="s0">, </span><span class="s1">HIT_SLOP_NONE)</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">setInteractionController(controller: GestureHandlerInteractionController?): ConcreteGestureHandlerT =</span>
    <span class="s1">applySelf { interactionController = controller }</span>

  <span class="s0">fun </span><span class="s1">prepare(view: View?</span><span class="s0">, </span><span class="s1">orchestrator: GestureHandlerOrchestrator?) {</span>
    <span class="s1">check(!(</span><span class="s0">this</span><span class="s1">.view != </span><span class="s0">null </span><span class="s1">|| </span><span class="s0">this</span><span class="s1">.orchestrator != </span><span class="s0">null</span><span class="s1">)) { </span><span class="s3">&quot;Already prepared or hasn't been reset&quot; </span><span class="s1">}</span>
    <span class="s1">Arrays.fill(trackedPointerIDs</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">trackedPointersIDsCount = </span><span class="s2">0</span>
    <span class="s1">state = STATE_UNDETERMINED</span>
    <span class="s0">this</span><span class="s1">.view = view</span>
    <span class="s0">this</span><span class="s1">.orchestrator = orchestrator</span>

    <span class="s0">val </span><span class="s1">decorView = getWindow(view?.context)?.decorView</span>
    <span class="s0">if </span><span class="s1">(decorView != </span><span class="s0">null</span><span class="s1">) {</span>
      <span class="s0">val </span><span class="s1">frame = Rect()</span>
      <span class="s1">decorView.getWindowVisibleDisplayFrame(frame)</span>
      <span class="s1">windowOffset[</span><span class="s2">0</span><span class="s1">] = frame.left</span>
      <span class="s1">windowOffset[</span><span class="s2">1</span><span class="s1">] = frame.top</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">windowOffset[</span><span class="s2">0</span><span class="s1">] = </span><span class="s2">0</span>
      <span class="s1">windowOffset[</span><span class="s2">1</span><span class="s1">] = </span><span class="s2">0</span>
    <span class="s1">}</span>

    <span class="s1">onPrepare()</span>
  <span class="s1">}</span>

  <span class="s1">protected open </span><span class="s0">fun </span><span class="s1">onPrepare() {}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">getWindow(context: Context?): Window? {</span>
    <span class="s0">if </span><span class="s1">(context == </span><span class="s0">null</span><span class="s1">) </span><span class="s0">return null</span>
    <span class="s0">if </span><span class="s1">(context </span><span class="s0">is </span><span class="s1">Activity) </span><span class="s0">return </span><span class="s1">context.window</span>
    <span class="s0">if </span><span class="s1">(context </span><span class="s0">is </span><span class="s1">ContextWrapper) </span><span class="s0">return </span><span class="s1">getWindow(context.baseContext)</span>

    <span class="s0">return null</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">findNextLocalPointerId(): Int {</span>
    <span class="s0">var </span><span class="s1">localPointerId = </span><span class="s2">0</span>
    <span class="s0">while </span><span class="s1">(localPointerId &lt; trackedPointersIDsCount) {</span>
      <span class="s0">var </span><span class="s1">i = </span><span class="s2">0</span>
      <span class="s0">while </span><span class="s1">(i &lt; trackedPointerIDs.size) {</span>
        <span class="s0">if </span><span class="s1">(trackedPointerIDs[i] == localPointerId) {</span>
          <span class="s0">break</span>
        <span class="s1">}</span>
        <span class="s1">i++</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(i == trackedPointerIDs.size) {</span>
        <span class="s0">return </span><span class="s1">localPointerId</span>
      <span class="s1">}</span>
      <span class="s1">localPointerId++</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">localPointerId</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">startTrackingPointer(pointerId: Int) {</span>
    <span class="s0">if </span><span class="s1">(trackedPointerIDs[pointerId] == -</span><span class="s2">1</span><span class="s1">) {</span>
      <span class="s1">trackedPointerIDs[pointerId] = findNextLocalPointerId()</span>
      <span class="s1">trackedPointersIDsCount++</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">stopTrackingPointer(pointerId: Int) {</span>
    <span class="s0">if </span><span class="s1">(trackedPointerIDs[pointerId] != -</span><span class="s2">1</span><span class="s1">) {</span>
      <span class="s1">trackedPointerIDs[pointerId] = -</span><span class="s2">1</span>
      <span class="s1">trackedPointersIDsCount--</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">needAdapt(event: MotionEvent): Boolean {</span>
    <span class="s0">if </span><span class="s1">(event.pointerCount != trackedPointersIDsCount) {</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s0">for </span><span class="s1">(i </span><span class="s0">in </span><span class="s1">trackedPointerIDs.indices) {</span>
      <span class="s0">val </span><span class="s1">trackedPointer = trackedPointerIDs[i]</span>
      <span class="s0">if </span><span class="s1">(trackedPointer != -</span><span class="s2">1 </span><span class="s1">&amp;&amp; trackedPointer != i) {</span>
        <span class="s0">return true</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return false</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">adaptEvent(event: MotionEvent): MotionEvent {</span>
    <span class="s0">if </span><span class="s1">(!needAdapt(event)) {</span>
      <span class="s0">return </span><span class="s1">event</span>
    <span class="s1">}</span>
    <span class="s0">var </span><span class="s1">action = event.actionMasked</span>
    <span class="s0">var </span><span class="s1">actionIndex = -</span><span class="s2">1</span>
    <span class="s0">if </span><span class="s1">(action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) {</span>
      <span class="s1">actionIndex = event.actionIndex</span>
      <span class="s0">val </span><span class="s1">actionPointer = event.getPointerId(actionIndex)</span>
      <span class="s1">action = </span><span class="s0">if </span><span class="s1">(trackedPointerIDs[actionPointer] != -</span><span class="s2">1</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(trackedPointersIDsCount == </span><span class="s2">1</span><span class="s1">) MotionEvent.ACTION_DOWN </span><span class="s0">else </span><span class="s1">MotionEvent.ACTION_POINTER_DOWN</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s1">MotionEvent.ACTION_MOVE</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP) {</span>
      <span class="s1">actionIndex = event.actionIndex</span>
      <span class="s0">val </span><span class="s1">actionPointer = event.getPointerId(actionIndex)</span>
      <span class="s1">action = </span><span class="s0">if </span><span class="s1">(trackedPointerIDs[actionPointer] != -</span><span class="s2">1</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(trackedPointersIDsCount == </span><span class="s2">1</span><span class="s1">) MotionEvent.ACTION_UP </span><span class="s0">else </span><span class="s1">MotionEvent.ACTION_POINTER_UP</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s1">MotionEvent.ACTION_MOVE</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">initPointerProps(trackedPointersIDsCount)</span>
    <span class="s0">var </span><span class="s1">count = </span><span class="s2">0</span>
    <span class="s0">val </span><span class="s1">deltaX = event.rawX - event.x</span>
    <span class="s0">val </span><span class="s1">deltaY = event.rawY - event.y</span>
    <span class="s1">event.offsetLocation(deltaX</span><span class="s0">, </span><span class="s1">deltaY)</span>
    <span class="s0">var </span><span class="s1">index = </span><span class="s2">0</span>
    <span class="s0">val </span><span class="s1">size = event.pointerCount</span>
    <span class="s0">while </span><span class="s1">(index &lt; size) {</span>
      <span class="s0">val </span><span class="s1">origPointerId = event.getPointerId(index)</span>
      <span class="s0">if </span><span class="s1">(trackedPointerIDs[origPointerId] != -</span><span class="s2">1</span><span class="s1">) {</span>
        <span class="s1">event.getPointerProperties(index</span><span class="s0">, </span><span class="s1">pointerProps[count])</span>
        <span class="s1">pointerProps[count]!!.id = trackedPointerIDs[origPointerId]</span>
        <span class="s1">event.getPointerCoords(index</span><span class="s0">, </span><span class="s1">pointerCoords[count])</span>
        <span class="s0">if </span><span class="s1">(index == actionIndex) {</span>
          <span class="s1">action = action or (count shl MotionEvent.ACTION_POINTER_INDEX_SHIFT)</span>
        <span class="s1">}</span>
        <span class="s1">count++</span>
      <span class="s1">}</span>
      <span class="s1">index++</span>
    <span class="s1">}</span>

    <span class="s4">// introduced in 1.11.0, remove if crashes are not reported</span>
    <span class="s0">if </span><span class="s1">(pointerProps.isEmpty() || pointerCoords.isEmpty()) {</span>
      <span class="s0">throw </span><span class="s1">IllegalStateException(</span><span class="s3">&quot;pointerCoords.size=</span><span class="s0">${</span><span class="s1">pointerCoords.size</span><span class="s0">}</span><span class="s3">, pointerProps.size=</span><span class="s0">${</span><span class="s1">pointerProps.size</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">}</span>

    <span class="s0">val </span><span class="s1">result: MotionEvent</span>
    <span class="s0">try </span><span class="s1">{</span>
      <span class="s1">result = MotionEvent.obtain(</span>
        <span class="s1">event.downTime</span><span class="s0">,</span>
        <span class="s1">event.eventTime</span><span class="s0">,</span>
        <span class="s1">action</span><span class="s0">,</span>
        <span class="s1">count</span><span class="s0">,</span>
        <span class="s1">pointerProps</span><span class="s0">, </span><span class="s4">/* props are copied and hence it is safe to use static array here */</span>
        <span class="s1">pointerCoords</span><span class="s0">, </span><span class="s4">/* same applies to coords */</span>
        <span class="s1">event.metaState</span><span class="s0">,</span>
        <span class="s1">event.buttonState</span><span class="s0">,</span>
        <span class="s1">event.xPrecision</span><span class="s0">,</span>
        <span class="s1">event.yPrecision</span><span class="s0">,</span>
        <span class="s1">event.deviceId</span><span class="s0">,</span>
        <span class="s1">event.edgeFlags</span><span class="s0">,</span>
        <span class="s1">event.source</span><span class="s0">,</span>
        <span class="s1">event.flags</span>
      <span class="s1">)</span>
    <span class="s1">} catch (e: IllegalArgumentException) {</span>
      <span class="s0">throw </span><span class="s1">AdaptEventException(</span><span class="s0">this, </span><span class="s1">event</span><span class="s0">, </span><span class="s1">e)</span>
    <span class="s1">}</span>
    <span class="s1">event.offsetLocation(-deltaX</span><span class="s0">, </span><span class="s1">-deltaY)</span>
    <span class="s1">result.offsetLocation(-deltaX</span><span class="s0">, </span><span class="s1">-deltaY)</span>
    <span class="s0">return </span><span class="s1">result</span>
  <span class="s1">}</span>

  <span class="s4">// exception to help debug https://github.com/software-mansion/react-native-gesture-handler/issues/1188</span>
  <span class="s0">class </span><span class="s1">AdaptEventException(</span>
    <span class="s1">handler: GestureHandler&lt;*&gt;</span><span class="s0">,</span>
    <span class="s1">event: MotionEvent</span><span class="s0">,</span>
    <span class="s1">e: IllegalArgumentException</span>
  <span class="s1">) : Exception(</span>
    <span class="s3">&quot;&quot;&quot;</span>
    <span class="s3">handler: </span><span class="s0">${</span><span class="s1">handler::</span><span class="s0">class</span><span class="s1">.simpleName</span><span class="s0">}</span>
    <span class="s3">state: </span><span class="s0">${</span><span class="s1">handler.state</span><span class="s0">}</span>
    <span class="s3">view: </span><span class="s0">${</span><span class="s1">handler.view</span><span class="s0">}</span>
    <span class="s3">orchestrator: </span><span class="s0">${</span><span class="s1">handler.orchestrator</span><span class="s0">}</span>
    <span class="s3">isEnabled: </span><span class="s0">${</span><span class="s1">handler.isEnabled</span><span class="s0">}</span>
    <span class="s3">isActive: </span><span class="s0">${</span><span class="s1">handler.isActive</span><span class="s0">}</span>
    <span class="s3">isAwaiting: </span><span class="s0">${</span><span class="s1">handler.isAwaiting</span><span class="s0">}</span>
    <span class="s3">trackedPointersCount: </span><span class="s0">${</span><span class="s1">handler.trackedPointersIDsCount</span><span class="s0">}</span>
    <span class="s3">trackedPointers: </span><span class="s0">${</span><span class="s1">handler.trackedPointerIDs.joinToString(separator = </span><span class="s3">&quot;, &quot;</span><span class="s1">)</span><span class="s0">}</span>
    <span class="s3">while handling event: </span><span class="s0">$</span><span class="s1">event</span>
    <span class="s3">&quot;&quot;&quot;</span><span class="s1">.trimIndent()</span><span class="s0">,</span>
    <span class="s1">e</span>
  <span class="s1">)</span>

  <span class="s0">fun </span><span class="s1">handle(transformedEvent: MotionEvent</span><span class="s0">, </span><span class="s1">sourceEvent: MotionEvent) {</span>
    <span class="s0">if </span><span class="s1">(!isEnabled ||</span>
      <span class="s1">state == STATE_CANCELLED ||</span>
      <span class="s1">state == STATE_FAILED ||</span>
      <span class="s1">state == STATE_END ||</span>
      <span class="s1">trackedPointersIDsCount &lt; </span><span class="s2">1</span>
    <span class="s1">) {</span>
      <span class="s0">return</span>
    <span class="s1">}</span>

    <span class="s4">// a workaround for https://github.com/software-mansion/react-native-gesture-handler/issues/1188</span>
    <span class="s0">val </span><span class="s1">(adaptedTransformedEvent</span><span class="s0">, </span><span class="s1">adaptedSourceEvent) = </span><span class="s0">if </span><span class="s1">(BuildConfig.DEBUG) {</span>
      <span class="s1">arrayOf(adaptEvent(transformedEvent)</span><span class="s0">, </span><span class="s1">adaptEvent(sourceEvent))</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">try </span><span class="s1">{</span>
        <span class="s1">arrayOf(adaptEvent(transformedEvent)</span><span class="s0">, </span><span class="s1">adaptEvent(sourceEvent))</span>
      <span class="s1">} catch (e: AdaptEventException) {</span>
        <span class="s1">fail()</span>
        <span class="s0">return</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">x = adaptedTransformedEvent.x</span>
    <span class="s1">y = adaptedTransformedEvent.y</span>
    <span class="s1">numberOfPointers = adaptedTransformedEvent.pointerCount</span>
    <span class="s1">isWithinBounds = isWithinBounds(view</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">if </span><span class="s1">(shouldCancelWhenOutside &amp;&amp; !isWithinBounds) {</span>
      <span class="s0">if </span><span class="s1">(state == STATE_ACTIVE) {</span>
        <span class="s1">cancel()</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(state == STATE_BEGAN) {</span>
        <span class="s1">fail()</span>
      <span class="s1">}</span>
      <span class="s0">return</span>
    <span class="s1">}</span>
    <span class="s1">lastAbsolutePositionX = GestureUtils.getLastPointerX(adaptedTransformedEvent</span><span class="s0">, true</span><span class="s1">)</span>
    <span class="s1">lastAbsolutePositionY = GestureUtils.getLastPointerY(adaptedTransformedEvent</span><span class="s0">, true</span><span class="s1">)</span>
    <span class="s1">lastEventOffsetX = adaptedTransformedEvent.rawX - adaptedTransformedEvent.x</span>
    <span class="s1">lastEventOffsetY = adaptedTransformedEvent.rawY - adaptedTransformedEvent.y</span>
    <span class="s1">onHandle(adaptedTransformedEvent</span><span class="s0">, </span><span class="s1">adaptedSourceEvent)</span>
    <span class="s0">if </span><span class="s1">(adaptedTransformedEvent != transformedEvent) {</span>
      <span class="s1">adaptedTransformedEvent.recycle()</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(adaptedSourceEvent != sourceEvent) {</span>
      <span class="s1">adaptedSourceEvent.recycle()</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">dispatchTouchDownEvent(event: MotionEvent) {</span>
    <span class="s1">changedTouchesPayload = </span><span class="s0">null</span>
    <span class="s1">touchEventType = RNGestureHandlerTouchEvent.EVENT_TOUCH_DOWN</span>
    <span class="s0">val </span><span class="s1">pointerId = event.getPointerId(event.actionIndex)</span>
    <span class="s0">val </span><span class="s1">offsetX = event.rawX - event.x</span>
    <span class="s0">val </span><span class="s1">offsetY = event.rawY - event.y</span>

    <span class="s1">trackedPointers[pointerId] = PointerData(</span>
      <span class="s1">pointerId</span><span class="s0">,</span>
      <span class="s1">event.getX(event.actionIndex)</span><span class="s0">,</span>
      <span class="s1">event.getY(event.actionIndex)</span><span class="s0">,</span>
      <span class="s1">event.getX(event.actionIndex) + offsetX - windowOffset[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
      <span class="s1">event.getY(event.actionIndex) + offsetY - windowOffset[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">trackedPointersCount++</span>
    <span class="s1">addChangedPointer(trackedPointers[pointerId]!!)</span>
    <span class="s1">extractAllPointersData()</span>

    <span class="s1">dispatchTouchEvent()</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">dispatchTouchUpEvent(event: MotionEvent) {</span>
    <span class="s1">extractAllPointersData()</span>
    <span class="s1">changedTouchesPayload = </span><span class="s0">null</span>
    <span class="s1">touchEventType = RNGestureHandlerTouchEvent.EVENT_TOUCH_UP</span>
    <span class="s0">val </span><span class="s1">pointerId = event.getPointerId(event.actionIndex)</span>
    <span class="s0">val </span><span class="s1">offsetX = event.rawX - event.x</span>
    <span class="s0">val </span><span class="s1">offsetY = event.rawY - event.y</span>

    <span class="s1">trackedPointers[pointerId] = PointerData(</span>
      <span class="s1">pointerId</span><span class="s0">,</span>
      <span class="s1">event.getX(event.actionIndex)</span><span class="s0">,</span>
      <span class="s1">event.getY(event.actionIndex)</span><span class="s0">,</span>
      <span class="s1">event.getX(event.actionIndex) + offsetX - windowOffset[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
      <span class="s1">event.getY(event.actionIndex) + offsetY - windowOffset[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">addChangedPointer(trackedPointers[pointerId]!!)</span>
    <span class="s1">trackedPointers[pointerId] = </span><span class="s0">null</span>
    <span class="s1">trackedPointersCount--</span>

    <span class="s1">dispatchTouchEvent()</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">dispatchTouchMoveEvent(event: MotionEvent) {</span>
    <span class="s1">changedTouchesPayload = </span><span class="s0">null</span>
    <span class="s1">touchEventType = RNGestureHandlerTouchEvent.EVENT_TOUCH_MOVE</span>
    <span class="s0">val </span><span class="s1">offsetX = event.rawX - event.x</span>
    <span class="s0">val </span><span class="s1">offsetY = event.rawY - event.y</span>
    <span class="s0">var </span><span class="s1">pointersAdded = </span><span class="s2">0</span>

    <span class="s0">for </span><span class="s1">(i </span><span class="s0">in </span><span class="s2">0 </span><span class="s1">until event.pointerCount) {</span>
      <span class="s0">val </span><span class="s1">pointerId = event.getPointerId(i)</span>
      <span class="s0">val </span><span class="s1">pointer = trackedPointers[pointerId] ?: </span><span class="s0">continue</span>

      <span class="s0">if </span><span class="s1">(pointer.x != event.getX(i) || pointer.y != event.getY(i)) {</span>
        <span class="s1">pointer.x = event.getX(i)</span>
        <span class="s1">pointer.y = event.getY(i)</span>
        <span class="s1">pointer.absoluteX = event.getX(i) + offsetX - windowOffset[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">pointer.absoluteY = event.getY(i) + offsetY - windowOffset[</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">addChangedPointer(pointer)</span>
        <span class="s1">pointersAdded++</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">// only data about pointers that have changed their position is sent, it makes no sense to send</span>
    <span class="s4">// an empty move event (especially when this method is called during down/up event and there is</span>
    <span class="s4">// only info about one pointer)</span>
    <span class="s0">if </span><span class="s1">(pointersAdded &gt; </span><span class="s2">0</span><span class="s1">) {</span>
      <span class="s1">extractAllPointersData()</span>
      <span class="s1">dispatchTouchEvent()</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">updatePointerData(event: MotionEvent) {</span>
    <span class="s0">if </span><span class="s1">(event.actionMasked == MotionEvent.ACTION_DOWN || event.actionMasked == MotionEvent.ACTION_POINTER_DOWN) {</span>
      <span class="s1">dispatchTouchDownEvent(event)</span>
      <span class="s1">dispatchTouchMoveEvent(event)</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(event.actionMasked == MotionEvent.ACTION_UP || event.actionMasked == MotionEvent.ACTION_POINTER_UP) {</span>
      <span class="s1">dispatchTouchMoveEvent(event)</span>
      <span class="s1">dispatchTouchUpEvent(event)</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(event.actionMasked == MotionEvent.ACTION_MOVE) {</span>
      <span class="s1">dispatchTouchMoveEvent(event)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">extractAllPointersData() {</span>
    <span class="s1">allTouchesPayload = </span><span class="s0">null</span>

    <span class="s0">for </span><span class="s1">(pointerData </span><span class="s0">in </span><span class="s1">trackedPointers) {</span>
      <span class="s0">if </span><span class="s1">(pointerData != </span><span class="s0">null</span><span class="s1">) {</span>
        <span class="s1">addPointerToAll(pointerData)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">cancelPointers() {</span>
    <span class="s1">touchEventType = RNGestureHandlerTouchEvent.EVENT_TOUCH_CANCELLED</span>
    <span class="s1">changedTouchesPayload = </span><span class="s0">null</span>
    <span class="s1">extractAllPointersData()</span>

    <span class="s0">for </span><span class="s1">(pointer </span><span class="s0">in </span><span class="s1">trackedPointers) {</span>
      <span class="s1">pointer?.let {</span>
        <span class="s1">addChangedPointer(it)</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">trackedPointersCount = </span><span class="s2">0</span>
    <span class="s1">trackedPointers.fill(</span><span class="s0">null</span><span class="s1">)</span>

    <span class="s1">dispatchTouchEvent()</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">addChangedPointer(pointerData: PointerData) {</span>
    <span class="s0">if </span><span class="s1">(changedTouchesPayload == </span><span class="s0">null</span><span class="s1">) {</span>
      <span class="s1">changedTouchesPayload = Arguments.createArray()</span>
    <span class="s1">}</span>

    <span class="s1">changedTouchesPayload!!.pushMap(createPointerData(pointerData))</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">addPointerToAll(pointerData: PointerData) {</span>
    <span class="s0">if </span><span class="s1">(allTouchesPayload == </span><span class="s0">null</span><span class="s1">) {</span>
      <span class="s1">allTouchesPayload = Arguments.createArray()</span>
    <span class="s1">}</span>

    <span class="s1">allTouchesPayload!!.pushMap(createPointerData(pointerData))</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">createPointerData(pointerData: PointerData) = Arguments.createMap().apply {</span>
    <span class="s1">putInt(</span><span class="s3">&quot;id&quot;</span><span class="s0">, </span><span class="s1">pointerData.pointerId)</span>
    <span class="s1">putDouble(</span><span class="s3">&quot;x&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(pointerData.x).toDouble())</span>
    <span class="s1">putDouble(</span><span class="s3">&quot;y&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(pointerData.y).toDouble())</span>
    <span class="s1">putDouble(</span><span class="s3">&quot;absoluteX&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(pointerData.absoluteX).toDouble())</span>
    <span class="s1">putDouble(</span><span class="s3">&quot;absoluteY&quot;</span><span class="s0">, </span><span class="s1">PixelUtil.toDIPFromPixel(pointerData.absoluteY).toDouble())</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">consumeChangedTouchesPayload(): WritableArray? {</span>
    <span class="s0">val </span><span class="s1">result = changedTouchesPayload</span>
    <span class="s1">changedTouchesPayload = </span><span class="s0">null</span>
    <span class="s0">return </span><span class="s1">result</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">consumeAllTouchesPayload(): WritableArray? {</span>
    <span class="s0">val </span><span class="s1">result = allTouchesPayload</span>
    <span class="s1">allTouchesPayload = </span><span class="s0">null</span>
    <span class="s0">return </span><span class="s1">result</span>
  <span class="s1">}</span>

  <span class="s1">private </span><span class="s0">fun </span><span class="s1">moveToState(newState: Int) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span>
    <span class="s0">if </span><span class="s1">(state == newState) {</span>
      <span class="s0">return</span>
    <span class="s1">}</span>

    <span class="s4">// if there are tracked pointers and the gesture is about to end, send event cancelling all pointers</span>
    <span class="s0">if </span><span class="s1">(trackedPointersCount &gt; </span><span class="s2">0 </span><span class="s1">&amp;&amp; (newState == STATE_END || newState == STATE_CANCELLED || newState == STATE_FAILED)) {</span>
      <span class="s1">cancelPointers()</span>
    <span class="s1">}</span>

    <span class="s0">val </span><span class="s1">oldState = state</span>
    <span class="s1">state = newState</span>
    <span class="s0">if </span><span class="s1">(state == STATE_ACTIVE) {</span>
      <span class="s4">// Generate a unique coalescing-key each time the gesture-handler becomes active. All events will have</span>
      <span class="s4">// the same coalescing-key allowing EventDispatcher to coalesce RNGestureHandlerEvents when events are</span>
      <span class="s4">// generated faster than they can be treated by JS thread</span>
      <span class="s1">eventCoalescingKey = nextEventCoalescingKey++</span>
    <span class="s1">}</span>
    <span class="s1">orchestrator!!.onHandlerStateChange(</span><span class="s0">this, </span><span class="s1">newState</span><span class="s0">, </span><span class="s1">oldState)</span>
    <span class="s1">onStateChange(newState</span><span class="s0">, </span><span class="s1">oldState)</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">wantEvents(): Boolean {</span>
    <span class="s0">return </span><span class="s1">isEnabled &amp;&amp;</span>
      <span class="s1">state != STATE_FAILED &amp;&amp;</span>
      <span class="s1">state != STATE_CANCELLED &amp;&amp;</span>
      <span class="s1">state != STATE_END &amp;&amp;</span>
      <span class="s1">trackedPointersIDsCount &gt; </span><span class="s2">0</span>
  <span class="s1">}</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">shouldRequireToWaitForFailure(handler: GestureHandler&lt;*&gt;): Boolean {</span>
    <span class="s0">if </span><span class="s1">(handler === </span><span class="s0">this</span><span class="s1">) {</span>
      <span class="s0">return false</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">interactionController?.shouldRequireHandlerToWaitForFailure(</span><span class="s0">this, </span><span class="s1">handler) ?: </span><span class="s0">false</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">shouldWaitForHandlerFailure(handler: GestureHandler&lt;*&gt;): Boolean {</span>
    <span class="s0">if </span><span class="s1">(handler === </span><span class="s0">this</span><span class="s1">) {</span>
      <span class="s0">return false</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">interactionController?.shouldWaitForHandlerFailure(</span><span class="s0">this, </span><span class="s1">handler) ?: </span><span class="s0">false</span>
  <span class="s1">}</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">shouldRecognizeSimultaneously(handler: GestureHandler&lt;*&gt;): Boolean {</span>
    <span class="s0">if </span><span class="s1">(handler === </span><span class="s0">this</span><span class="s1">) {</span>
      <span class="s0">return true</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">interactionController?.shouldRecognizeSimultaneously(</span><span class="s0">this, </span><span class="s1">handler) ?: </span><span class="s0">false</span>
  <span class="s1">}</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">shouldBeCancelledBy(handler: GestureHandler&lt;*&gt;): Boolean {</span>
    <span class="s0">if </span><span class="s1">(handler === </span><span class="s0">this</span><span class="s1">) {</span>
      <span class="s0">return false</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">interactionController?.shouldHandlerBeCancelledBy(</span><span class="s0">this, </span><span class="s1">handler) ?: </span><span class="s0">false</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">isWithinBounds(view: View?</span><span class="s0">, </span><span class="s1">posX: Float</span><span class="s0">, </span><span class="s1">posY: Float): Boolean {</span>
    <span class="s0">var </span><span class="s1">left = </span><span class="s2">0f</span>
    <span class="s0">var </span><span class="s1">top = </span><span class="s2">0f</span>
    <span class="s0">var </span><span class="s1">right = view!!.width.toFloat()</span>
    <span class="s0">var </span><span class="s1">bottom = view.height.toFloat()</span>
    <span class="s1">hitSlop?.let { hitSlop -&gt;</span>
      <span class="s0">val </span><span class="s1">padLeft = hitSlop[HIT_SLOP_LEFT_IDX]</span>
      <span class="s0">val </span><span class="s1">padTop = hitSlop[HIT_SLOP_TOP_IDX]</span>
      <span class="s0">val </span><span class="s1">padRight = hitSlop[HIT_SLOP_RIGHT_IDX]</span>
      <span class="s0">val </span><span class="s1">padBottom = hitSlop[HIT_SLOP_BOTTOM_IDX]</span>
      <span class="s0">if </span><span class="s1">(hitSlopSet(padLeft)) {</span>
        <span class="s1">left -= padLeft</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(hitSlopSet(padTop)) {</span>
        <span class="s1">top -= padTop</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(hitSlopSet(padRight)) {</span>
        <span class="s1">right += padRight</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(hitSlopSet(padBottom)) {</span>
        <span class="s1">bottom += padBottom</span>
      <span class="s1">}</span>
      <span class="s0">val </span><span class="s1">width = hitSlop[HIT_SLOP_WIDTH_IDX]</span>
      <span class="s0">val </span><span class="s1">height = hitSlop[HIT_SLOP_HEIGHT_IDX]</span>
      <span class="s0">if </span><span class="s1">(hitSlopSet(width)) {</span>
        <span class="s0">if </span><span class="s1">(!hitSlopSet(padLeft)) {</span>
          <span class="s1">left = right - width</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!hitSlopSet(padRight)) {</span>
          <span class="s1">right = left + width</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(hitSlopSet(height)) {</span>
        <span class="s0">if </span><span class="s1">(!hitSlopSet(padTop)) {</span>
          <span class="s1">top = bottom - height</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!hitSlopSet(padBottom)) {</span>
          <span class="s1">bottom = top + height</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">posX </span><span class="s0">in </span><span class="s1">left..right &amp;&amp; posY </span><span class="s0">in </span><span class="s1">top..bottom</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">cancel() {</span>
    <span class="s0">if </span><span class="s1">(state == STATE_ACTIVE || state == STATE_UNDETERMINED || state == STATE_BEGAN) {</span>
      <span class="s1">onCancel()</span>
      <span class="s1">moveToState(STATE_CANCELLED)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">fail() {</span>
    <span class="s0">if </span><span class="s1">(state == STATE_ACTIVE || state == STATE_UNDETERMINED || state == STATE_BEGAN) {</span>
      <span class="s1">moveToState(STATE_FAILED)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">activate() = activate(force = </span><span class="s0">false</span><span class="s1">)</span>

  <span class="s1">open </span><span class="s0">fun </span><span class="s1">activate(force: Boolean) {</span>
    <span class="s0">if </span><span class="s1">((!manualActivation || force) &amp;&amp; (state == STATE_UNDETERMINED || state == STATE_BEGAN)) {</span>
      <span class="s1">moveToState(STATE_ACTIVE)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">begin() {</span>
    <span class="s0">if </span><span class="s1">(state == STATE_UNDETERMINED) {</span>
      <span class="s1">moveToState(STATE_BEGAN)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">end() {</span>
    <span class="s0">if </span><span class="s1">(state == STATE_BEGAN || state == STATE_ACTIVE) {</span>
      <span class="s1">moveToState(STATE_END)</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">// responsible for resetting the state of handler upon activation (may be called more than once</span>
  <span class="s4">// if the handler is waiting for failure of other one)</span>
  <span class="s1">open </span><span class="s0">fun </span><span class="s1">resetProgress() {}</span>

  <span class="s1">protected open </span><span class="s0">fun </span><span class="s1">onHandle(event: MotionEvent</span><span class="s0">, </span><span class="s1">sourceEvent: MotionEvent) {</span>
    <span class="s1">moveToState(STATE_FAILED)</span>
  <span class="s1">}</span>

  <span class="s1">protected open </span><span class="s0">fun </span><span class="s1">onStateChange(newState: Int</span><span class="s0">, </span><span class="s1">previousState: Int) {}</span>
  <span class="s1">protected open </span><span class="s0">fun </span><span class="s1">onReset() {}</span>
  <span class="s1">protected open </span><span class="s0">fun </span><span class="s1">onCancel() {}</span>

  <span class="s5">/**</span>
   <span class="s5">* Transforms a point in the coordinate space of the wrapperView (GestureHandlerRootView) to</span>
   <span class="s5">* coordinate space of the view the gesture is attached to.</span>
   <span class="s5">*</span>
   <span class="s5">* If the gesture handler is not currently attached to a view, it will return (NaN, NaN).</span>
   <span class="s5">*</span>
   <span class="s5">* This method modifies and transforms the received point.</span>
   <span class="s5">*/</span>
  <span class="s1">protected </span><span class="s0">fun </span><span class="s1">transformPoint(point: PointF): PointF {</span>
    <span class="s0">return </span><span class="s1">orchestrator?.transformPointToViewCoords(</span><span class="s0">this</span><span class="s1">.view</span><span class="s0">, </span><span class="s1">point) ?: run {</span>
      <span class="s1">point.x = Float.NaN</span>
      <span class="s1">point.y = Float.NaN</span>
      <span class="s1">point</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">fun </span><span class="s1">reset() {</span>
    <span class="s1">view = </span><span class="s0">null</span>
    <span class="s1">orchestrator = </span><span class="s0">null</span>
    <span class="s1">Arrays.fill(trackedPointerIDs</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">trackedPointersIDsCount = </span><span class="s2">0</span>

    <span class="s1">trackedPointersCount = </span><span class="s2">0</span>
    <span class="s1">trackedPointers.fill(</span><span class="s0">null</span><span class="s1">)</span>
    <span class="s1">touchEventType = RNGestureHandlerTouchEvent.EVENT_UNDETERMINED</span>
    <span class="s1">onReset()</span>
  <span class="s1">}</span>

  <span class="s0">fun </span><span class="s1">setOnTouchEventListener(listener: OnTouchEventListener?): GestureHandler&lt;*&gt; {</span>
    <span class="s1">onTouchEventListener = listener</span>
    <span class="s0">return this</span>
  <span class="s1">}</span>

  <span class="s1">override </span><span class="s0">fun </span><span class="s1">toString(): String {</span>
    <span class="s0">val </span><span class="s1">viewString = </span><span class="s0">if </span><span class="s1">(view == </span><span class="s0">null</span><span class="s1">) </span><span class="s0">null else </span><span class="s1">view!!.javaClass.simpleName</span>
    <span class="s0">return this</span><span class="s1">.javaClass.simpleName + </span><span class="s3">&quot;@[&quot; </span><span class="s1">+ tag + </span><span class="s3">&quot;]:&quot; </span><span class="s1">+ viewString</span>
  <span class="s1">}</span>

  <span class="s0">val </span><span class="s1">lastRelativePositionX: Float</span>
    <span class="s1">get() = lastAbsolutePositionX</span>
  <span class="s0">val </span><span class="s1">lastRelativePositionY: Float</span>
    <span class="s1">get() = lastAbsolutePositionY</span>

  <span class="s0">val </span><span class="s1">lastPositionInWindowX: Float</span>
    <span class="s1">get() = lastAbsolutePositionX + lastEventOffsetX - windowOffset[</span><span class="s2">0</span><span class="s1">]</span>
  <span class="s0">val </span><span class="s1">lastPositionInWindowY: Float</span>
    <span class="s1">get() = lastAbsolutePositionY + lastEventOffsetY - windowOffset[</span><span class="s2">1</span><span class="s1">]</span>

  <span class="s1">companion </span><span class="s0">object </span><span class="s1">{</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">STATE_UNDETERMINED = </span><span class="s2">0</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">STATE_FAILED = </span><span class="s2">1</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">STATE_BEGAN = </span><span class="s2">2</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">STATE_CANCELLED = </span><span class="s2">3</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">STATE_ACTIVE = </span><span class="s2">4</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">STATE_END = </span><span class="s2">5</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">HIT_SLOP_NONE = Float.NaN</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">HIT_SLOP_LEFT_IDX = </span><span class="s2">0</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">HIT_SLOP_TOP_IDX = </span><span class="s2">1</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">HIT_SLOP_RIGHT_IDX = </span><span class="s2">2</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">HIT_SLOP_BOTTOM_IDX = </span><span class="s2">3</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">HIT_SLOP_WIDTH_IDX = </span><span class="s2">4</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">HIT_SLOP_HEIGHT_IDX = </span><span class="s2">5</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">DIRECTION_RIGHT = </span><span class="s2">1</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">DIRECTION_LEFT = </span><span class="s2">2</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">DIRECTION_UP = </span><span class="s2">4</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">DIRECTION_DOWN = </span><span class="s2">8</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">ACTION_TYPE_REANIMATED_WORKLET = </span><span class="s2">1</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">ACTION_TYPE_NATIVE_ANIMATED_EVENT = </span><span class="s2">2</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">ACTION_TYPE_JS_FUNCTION_OLD_API = </span><span class="s2">3</span>
    <span class="s1">const </span><span class="s0">val </span><span class="s1">ACTION_TYPE_JS_FUNCTION_NEW_API = </span><span class="s2">4</span>
    <span class="s1">private const </span><span class="s0">val </span><span class="s1">MAX_POINTERS_COUNT = </span><span class="s2">12</span>
    <span class="s1">private lateinit </span><span class="s0">var </span><span class="s1">pointerProps: Array&lt;PointerProperties?&gt;</span>
    <span class="s1">private lateinit </span><span class="s0">var </span><span class="s1">pointerCoords: Array&lt;PointerCoords?&gt;</span>
    <span class="s1">private </span><span class="s0">fun </span><span class="s1">initPointerProps(size: Int) {</span>
      <span class="s0">var </span><span class="s1">size = size</span>
      <span class="s0">if </span><span class="s1">(!Companion::pointerProps.isInitialized) {</span>
        <span class="s1">pointerProps = arrayOfNulls(MAX_POINTERS_COUNT)</span>
        <span class="s1">pointerCoords = arrayOfNulls(MAX_POINTERS_COUNT)</span>
      <span class="s1">}</span>
      <span class="s0">while </span><span class="s1">(size &gt; </span><span class="s2">0 </span><span class="s1">&amp;&amp; pointerProps[size - </span><span class="s2">1</span><span class="s1">] == </span><span class="s0">null</span><span class="s1">) {</span>
        <span class="s1">pointerProps[size - </span><span class="s2">1</span><span class="s1">] = PointerProperties()</span>
        <span class="s1">pointerCoords[size - </span><span class="s2">1</span><span class="s1">] = PointerCoords()</span>
        <span class="s1">size--</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">private </span><span class="s0">var </span><span class="s1">nextEventCoalescingKey: Short = </span><span class="s2">0</span>
    <span class="s1">private </span><span class="s0">fun </span><span class="s1">hitSlopSet(value: Float): Boolean {</span>
      <span class="s0">return </span><span class="s1">!java.lang.Float.isNaN(value)</span>
    <span class="s1">}</span>

    <span class="s0">fun </span><span class="s1">stateToString(state: Int): String? {</span>
      <span class="s0">when </span><span class="s1">(state) {</span>
        <span class="s1">STATE_UNDETERMINED -&gt; </span><span class="s0">return </span><span class="s3">&quot;UNDETERMINED&quot;</span>
        <span class="s1">STATE_ACTIVE -&gt; </span><span class="s0">return </span><span class="s3">&quot;ACTIVE&quot;</span>
        <span class="s1">STATE_FAILED -&gt; </span><span class="s0">return </span><span class="s3">&quot;FAILED&quot;</span>
        <span class="s1">STATE_BEGAN -&gt; </span><span class="s0">return </span><span class="s3">&quot;BEGIN&quot;</span>
        <span class="s1">STATE_CANCELLED -&gt; </span><span class="s0">return </span><span class="s3">&quot;CANCELLED&quot;</span>
        <span class="s1">STATE_END -&gt; </span><span class="s0">return </span><span class="s3">&quot;END&quot;</span>
      <span class="s1">}</span>
      <span class="s0">return null</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">private data </span><span class="s0">class </span><span class="s1">PointerData(</span>
    <span class="s0">val </span><span class="s1">pointerId: Int</span><span class="s0">,</span>
    <span class="s0">var </span><span class="s1">x: Float</span><span class="s0">,</span>
    <span class="s0">var </span><span class="s1">y: Float</span><span class="s0">,</span>
    <span class="s0">var </span><span class="s1">absoluteX: Float</span><span class="s0">,</span>
    <span class="s0">var </span><span class="s1">absoluteY: Float</span>
  <span class="s1">)</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>ScaleGestureDetector.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #77b767; font-style: italic;}
.s6 { color: #6a8759;}
.s7 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ScaleGestureDetector.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (C) 2010 The Android Open Source Project 
 * 
 * Copied from https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ScaleGestureDetector.java 
 * Modified line 189 to set initial min span to 0 instead of copying it from the system configuration 
 */</span>

<span class="s2">package </span><span class="s1">com.swmansion.gesturehandler.core</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Build</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.os.Handler</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.GestureDetector</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MotionEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewConfiguration</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Detects scaling transformation gestures using the supplied {</span><span class="s4">@link </span><span class="s3">MotionEvent}s.</span>
 <span class="s3">* The {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener} callback will notify users when a particular</span>
 <span class="s3">* gesture event has occurred.</span>
 <span class="s3">*</span>
 <span class="s3">* This class should only be used with {</span><span class="s4">@link </span><span class="s3">MotionEvent}s reported via touch.</span>
 <span class="s3">*</span>
 <span class="s3">* To use this class:</span>
 <span class="s3">* </span><span class="s5">&lt;ul&gt;</span>
 <span class="s3">*  </span><span class="s5">&lt;li&gt;</span><span class="s3">Create an instance of the {</span><span class="s4">@code </span><span class="s3">ScaleGestureDetector} for your</span>
 <span class="s3">*      {</span><span class="s4">@link </span><span class="s3">View}</span>
 <span class="s3">*  </span><span class="s5">&lt;li&gt;</span><span class="s3">In the {</span><span class="s4">@link </span><span class="s3">View#onTouchEvent(MotionEvent)} method ensure you call</span>
 <span class="s3">*          {</span><span class="s4">@link </span><span class="s3">#onTouchEvent(MotionEvent)}. The methods defined in your</span>
 <span class="s3">*          callback will be executed when the events occur.</span>
 <span class="s3">* </span><span class="s5">&lt;/ul&gt;</span>
 <span class="s3">*/</span>
<span class="s2">public class </span><span class="s1">ScaleGestureDetector {</span>
    <span class="s2">private static final </span><span class="s1">String TAG = </span><span class="s6">&quot;ScaleGestureDetector&quot;</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* The listener for receiving notifications when gestures occur.</span>
     <span class="s3">* If you want to listen for all the different gestures then implement</span>
     <span class="s3">* this interface. If you only want to listen for a subset it might</span>
     <span class="s3">* be easier to extend {</span><span class="s4">@link </span><span class="s3">SimpleOnScaleGestureListener}.</span>
     <span class="s3">*</span>
     <span class="s3">* An application will receive events in the following order:</span>
     <span class="s3">* </span><span class="s5">&lt;ul&gt;</span>
     <span class="s3">*  </span><span class="s5">&lt;li&gt;</span><span class="s3">One {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener#onScaleBegin(ScaleGestureDetector)}</span>
     <span class="s3">*  </span><span class="s5">&lt;li&gt;</span><span class="s3">Zero or more {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener#onScale(ScaleGestureDetector)}</span>
     <span class="s3">*  </span><span class="s5">&lt;li&gt;</span><span class="s3">One {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener#onScaleEnd(ScaleGestureDetector)}</span>
     <span class="s3">* </span><span class="s5">&lt;/ul&gt;</span>
     <span class="s3">*/</span>
    <span class="s2">public interface </span><span class="s1">OnScaleGestureListener {</span>
        <span class="s3">/**</span>
         <span class="s3">* Responds to scaling events for a gesture in progress.</span>
         <span class="s3">* Reported by pointer motion.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">detector The detector reporting the event - use this to</span>
         <span class="s3">*          retrieve extended info about event state.</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">Whether or not the detector should consider this event</span>
         <span class="s3">*          as handled. If an event was not handled, the detector</span>
         <span class="s3">*          will continue to accumulate movement until an event is</span>
         <span class="s3">*          handled. This can be useful if an application, for example,</span>
         <span class="s3">*          only wants to update scaling factors if the change is</span>
         <span class="s3">*          greater than 0.01.</span>
         <span class="s3">*/</span>
        <span class="s2">public boolean </span><span class="s1">onScale(ScaleGestureDetector detector)</span><span class="s2">;</span>

        <span class="s3">/**</span>
         <span class="s3">* Responds to the beginning of a scaling gesture. Reported by</span>
         <span class="s3">* new pointers going down.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">detector The detector reporting the event - use this to</span>
         <span class="s3">*          retrieve extended info about event state.</span>
         <span class="s3">* </span><span class="s4">@return </span><span class="s3">Whether or not the detector should continue recognizing</span>
         <span class="s3">*          this gesture. For example, if a gesture is beginning</span>
         <span class="s3">*          with a focal point outside of a region where it makes</span>
         <span class="s3">*          sense, onScaleBegin() may return false to ignore the</span>
         <span class="s3">*          rest of the gesture.</span>
         <span class="s3">*/</span>
        <span class="s2">public boolean </span><span class="s1">onScaleBegin(ScaleGestureDetector detector)</span><span class="s2">;</span>

        <span class="s3">/**</span>
         <span class="s3">* Responds to the end of a scale gesture. Reported by existing</span>
         <span class="s3">* pointers going up.</span>
         <span class="s3">*</span>
         <span class="s3">* Once a scale has ended, {</span><span class="s4">@link </span><span class="s3">ScaleGestureDetector#getFocusX()}</span>
         <span class="s3">* and {</span><span class="s4">@link </span><span class="s3">ScaleGestureDetector#getFocusY()} will return focal point</span>
         <span class="s3">* of the pointers remaining on the screen.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s4">@param </span><span class="s3">detector The detector reporting the event - use this to</span>
         <span class="s3">*          retrieve extended info about event state.</span>
         <span class="s3">*/</span>
        <span class="s2">public void </span><span class="s1">onScaleEnd(ScaleGestureDetector detector)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A convenience class to extend when you only want to listen for a subset</span>
     <span class="s3">* of scaling-related events. This implements all methods in</span>
     <span class="s3">* {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener} but does nothing.</span>
     <span class="s3">* {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener#onScale(ScaleGestureDetector)} returns</span>
     <span class="s3">* {</span><span class="s4">@code </span><span class="s3">false} so that a subclass can retrieve the accumulated scale</span>
     <span class="s3">* factor in an overridden onScaleEnd.</span>
     <span class="s3">* {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener#onScaleBegin(ScaleGestureDetector)} returns</span>
     <span class="s3">* {</span><span class="s4">@code </span><span class="s3">true}.</span>
     <span class="s3">*/</span>
    <span class="s2">public static class </span><span class="s1">SimpleOnScaleGestureListener </span><span class="s2">implements </span><span class="s1">OnScaleGestureListener {</span>

        <span class="s2">public boolean </span><span class="s1">onScale(ScaleGestureDetector detector) {</span>
            <span class="s2">return false;</span>
        <span class="s1">}</span>

        <span class="s2">public boolean </span><span class="s1">onScaleBegin(ScaleGestureDetector detector) {</span>
            <span class="s2">return true;</span>
        <span class="s1">}</span>

        <span class="s2">public void </span><span class="s1">onScaleEnd(ScaleGestureDetector detector) {</span>
            <span class="s0">// Intentionally empty</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">private final </span><span class="s1">Context mContext</span><span class="s2">;</span>
    <span class="s2">private final </span><span class="s1">OnScaleGestureListener mListener</span><span class="s2">;</span>

    <span class="s2">private float </span><span class="s1">mFocusX</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mFocusY</span><span class="s2">;</span>

    <span class="s2">private boolean </span><span class="s1">mQuickScaleEnabled</span><span class="s2">;</span>
    <span class="s2">private boolean </span><span class="s1">mStylusScaleEnabled</span><span class="s2">;</span>

    <span class="s2">private float </span><span class="s1">mCurrSpan</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mPrevSpan</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mInitialSpan</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mCurrSpanX</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mCurrSpanY</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mPrevSpanX</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mPrevSpanY</span><span class="s2">;</span>
    <span class="s2">private long </span><span class="s1">mCurrTime</span><span class="s2">;</span>
    <span class="s2">private long </span><span class="s1">mPrevTime</span><span class="s2">;</span>
    <span class="s2">private boolean </span><span class="s1">mInProgress</span><span class="s2">;</span>
    <span class="s2">private int </span><span class="s1">mSpanSlop</span><span class="s2">;</span>
    <span class="s2">private int </span><span class="s1">mMinSpan</span><span class="s2">;</span>

    <span class="s2">private final </span><span class="s1">Handler mHandler</span><span class="s2">;</span>

    <span class="s2">private float </span><span class="s1">mAnchoredScaleStartX</span><span class="s2">;</span>
    <span class="s2">private float </span><span class="s1">mAnchoredScaleStartY</span><span class="s2">;</span>
    <span class="s2">private int </span><span class="s1">mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE</span><span class="s2">;</span>

    <span class="s2">private static final long </span><span class="s1">TOUCH_STABILIZE_TIME = </span><span class="s7">128</span><span class="s2">; </span><span class="s0">// ms</span>
    <span class="s2">private static final float </span><span class="s1">SCALE_FACTOR = </span><span class="s7">.5f</span><span class="s2">;</span>
    <span class="s2">private static final int </span><span class="s1">ANCHORED_SCALE_MODE_NONE = </span><span class="s7">0</span><span class="s2">;</span>
    <span class="s2">private static final int </span><span class="s1">ANCHORED_SCALE_MODE_DOUBLE_TAP = </span><span class="s7">1</span><span class="s2">;</span>
    <span class="s2">private static final int </span><span class="s1">ANCHORED_SCALE_MODE_STYLUS = </span><span class="s7">2</span><span class="s2">;</span>


    <span class="s2">private </span><span class="s1">GestureDetector mGestureDetector</span><span class="s2">;</span>

    <span class="s2">private boolean </span><span class="s1">mEventBeforeOrAboveStartingGestureEvent</span><span class="s2">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Creates a ScaleGestureDetector with the supplied listener.</span>
     <span class="s3">* You may only use this constructor from a {</span><span class="s4">@link </span><span class="s3">android.os.Looper Looper} thread.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">context the application's context</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">listener the listener invoked for all the callbacks, this must</span>
     <span class="s3">* not be null.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">NullPointerException if {</span><span class="s4">@code </span><span class="s3">listener} is null.</span>
     <span class="s3">*/</span>
    <span class="s2">public </span><span class="s1">ScaleGestureDetector(Context context</span><span class="s2">, </span><span class="s1">OnScaleGestureListener listener) {</span>
        <span class="s2">this</span><span class="s1">(context</span><span class="s2">, </span><span class="s1">listener</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Creates a ScaleGestureDetector with the supplied listener.</span>
     <span class="s3">* </span><span class="s4">@see </span><span class="s3">android.os.Handler#Handler()</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">context the application's context</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">listener the listener invoked for all the callbacks, this must</span>
     <span class="s3">* not be null.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">handler the handler to use for running deferred listener events.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">NullPointerException if {</span><span class="s4">@code </span><span class="s3">listener} is null.</span>
     <span class="s3">*/</span>
    <span class="s2">public </span><span class="s1">ScaleGestureDetector(Context context</span><span class="s2">, </span><span class="s1">OnScaleGestureListener listener</span><span class="s2">,</span>
                                <span class="s1">Handler handler) {</span>
        <span class="s1">mContext = context</span><span class="s2">;</span>
        <span class="s1">mListener = listener</span><span class="s2">;</span>
        <span class="s2">final </span><span class="s1">ViewConfiguration viewConfiguration = ViewConfiguration.get(context)</span><span class="s2">;</span>
        <span class="s1">mSpanSlop = viewConfiguration.getScaledTouchSlop() * </span><span class="s7">2</span><span class="s2">;</span>
        <span class="s1">mMinSpan = </span><span class="s7">0</span><span class="s2">; </span><span class="s0">// set to zero, to allow for scaling when distance between fingers is small</span>
        <span class="s1">mHandler = handler</span><span class="s2">;</span>
        <span class="s0">// Quick scale is enabled by default after JB_MR2</span>
        <span class="s2">final int </span><span class="s1">targetSdkVersion = context.getApplicationInfo().targetSdkVersion</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(targetSdkVersion &gt; Build.VERSION_CODES.JELLY_BEAN_MR2) {</span>
            <span class="s1">setQuickScaleEnabled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">// Stylus scale is enabled by default after LOLLIPOP_MR1</span>
        <span class="s2">if </span><span class="s1">(targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) {</span>
            <span class="s1">setStylusScaleEnabled(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Accepts MotionEvents and dispatches events to a {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener}</span>
     <span class="s3">* when appropriate.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s5">&lt;p&gt;</span><span class="s3">Applications should pass a complete and consistent event stream to this method.</span>
     <span class="s3">* A complete and consistent event stream involves all MotionEvents from the initial</span>
     <span class="s3">* ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</span><span class="s5">&lt;/p&gt;</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">event The event to process</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">true if the event was processed and the detector wants to receive the</span>
     <span class="s3">*         rest of the MotionEvents in this event stream.</span>
     <span class="s3">*/</span>
    <span class="s2">public boolean </span><span class="s1">onTouchEvent(MotionEvent event) {</span>
        <span class="s1">mCurrTime = event.getEventTime()</span><span class="s2">;</span>

        <span class="s2">final int </span><span class="s1">action = event.getActionMasked()</span><span class="s2">;</span>

        <span class="s0">// Forward the event to check for double tap gesture</span>
        <span class="s2">if </span><span class="s1">(mQuickScaleEnabled) {</span>
            <span class="s1">mGestureDetector.onTouchEvent(event)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">final int </span><span class="s1">count = event.getPointerCount()</span><span class="s2">;</span>
        <span class="s2">final boolean </span><span class="s1">isStylusButtonDown =</span>
                <span class="s1">(event.getButtonState() &amp; MotionEvent.BUTTON_STYLUS_PRIMARY) != </span><span class="s7">0</span><span class="s2">;</span>

        <span class="s2">final boolean </span><span class="s1">anchoredScaleCancelled =</span>
                <span class="s1">mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS &amp;&amp; !isStylusButtonDown</span><span class="s2">;</span>
        <span class="s2">final boolean </span><span class="s1">streamComplete = action == MotionEvent.ACTION_UP ||</span>
                <span class="s1">action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled</span><span class="s2">;</span>

        <span class="s2">if </span><span class="s1">(action == MotionEvent.ACTION_DOWN || streamComplete) {</span>
            <span class="s0">// Reset any scale in progress with the listener.</span>
            <span class="s0">// If it's an ACTION_DOWN we're beginning a new event stream.</span>
            <span class="s0">// This means the app probably didn't give us all the events. Shame on it.</span>
            <span class="s2">if </span><span class="s1">(mInProgress) {</span>
                <span class="s1">mListener.onScaleEnd(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
                <span class="s1">mInProgress = </span><span class="s2">false;</span>
                <span class="s1">mInitialSpan = </span><span class="s7">0</span><span class="s2">;</span>
                <span class="s1">mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE</span><span class="s2">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(inAnchoredScaleMode() &amp;&amp; streamComplete) {</span>
                <span class="s1">mInProgress = </span><span class="s2">false;</span>
                <span class="s1">mInitialSpan = </span><span class="s7">0</span><span class="s2">;</span>
                <span class="s1">mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(streamComplete) {</span>
                <span class="s2">return true;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!mInProgress &amp;&amp; mStylusScaleEnabled &amp;&amp; !inAnchoredScaleMode()</span>
                <span class="s1">&amp;&amp; !streamComplete &amp;&amp; isStylusButtonDown) {</span>
            <span class="s0">// Start of a button scale gesture</span>
            <span class="s1">mAnchoredScaleStartX = event.getX()</span><span class="s2">;</span>
            <span class="s1">mAnchoredScaleStartY = event.getY()</span><span class="s2">;</span>
            <span class="s1">mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS</span><span class="s2">;</span>
            <span class="s1">mInitialSpan = </span><span class="s7">0</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">final boolean </span><span class="s1">configChanged = action == MotionEvent.ACTION_DOWN ||</span>
                <span class="s1">action == MotionEvent.ACTION_POINTER_UP ||</span>
                <span class="s1">action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled</span><span class="s2">;</span>

        <span class="s2">final boolean </span><span class="s1">pointerUp = action == MotionEvent.ACTION_POINTER_UP</span><span class="s2">;</span>
        <span class="s2">final int </span><span class="s1">skipIndex = pointerUp ? event.getActionIndex() : -</span><span class="s7">1</span><span class="s2">;</span>

        <span class="s0">// Determine focal point</span>
        <span class="s2">float </span><span class="s1">sumX = </span><span class="s7">0</span><span class="s2">, </span><span class="s1">sumY = </span><span class="s7">0</span><span class="s2">;</span>
        <span class="s2">final int </span><span class="s1">div = pointerUp ? count - </span><span class="s7">1 </span><span class="s1">: count</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">focusX</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">focusY</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(inAnchoredScaleMode()) {</span>
            <span class="s0">// In anchored scale mode, the focal pt is always where the double tap</span>
            <span class="s0">// or button down gesture started</span>
            <span class="s1">focusX = mAnchoredScaleStartX</span><span class="s2">;</span>
            <span class="s1">focusY = mAnchoredScaleStartY</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(event.getY() &lt; focusY) {</span>
                <span class="s1">mEventBeforeOrAboveStartingGestureEvent = </span><span class="s2">true;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">mEventBeforeOrAboveStartingGestureEvent = </span><span class="s2">false;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i &lt; count</span><span class="s2">; </span><span class="s1">i++) {</span>
                <span class="s2">if </span><span class="s1">(skipIndex == i) </span><span class="s2">continue;</span>
                <span class="s1">sumX += event.getX(i)</span><span class="s2">;</span>
                <span class="s1">sumY += event.getY(i)</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s1">focusX = sumX / div</span><span class="s2">;</span>
            <span class="s1">focusY = sumY / div</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">// Determine average deviation from focal point</span>
        <span class="s2">float </span><span class="s1">devSumX = </span><span class="s7">0</span><span class="s2">, </span><span class="s1">devSumY = </span><span class="s7">0</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s7">0</span><span class="s2">; </span><span class="s1">i &lt; count</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">if </span><span class="s1">(skipIndex == i) </span><span class="s2">continue;</span>

            <span class="s0">// Convert the resulting diameter into a radius.</span>
            <span class="s1">devSumX += Math.abs(event.getX(i) - focusX)</span><span class="s2">;</span>
            <span class="s1">devSumY += Math.abs(event.getY(i) - focusY)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">final float </span><span class="s1">devX = devSumX / div</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">devY = devSumY / div</span><span class="s2">;</span>

        <span class="s0">// Span is the average distance between touch points through the focal point;</span>
        <span class="s0">// i.e. the diameter of the circle with a radius of the average deviation from</span>
        <span class="s0">// the focal point.</span>
        <span class="s2">final float </span><span class="s1">spanX = devX * </span><span class="s7">2</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">spanY = devY * </span><span class="s7">2</span><span class="s2">;</span>
        <span class="s2">final float </span><span class="s1">span</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(inAnchoredScaleMode()) {</span>
            <span class="s1">span = spanY</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">span = (</span><span class="s2">float</span><span class="s1">) Math.hypot(spanX</span><span class="s2">, </span><span class="s1">spanY)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">// Dispatch begin/end events as needed.</span>
        <span class="s0">// If the configuration changes, notify the app to reset its current state by beginning</span>
        <span class="s0">// a fresh scale event stream.</span>
        <span class="s2">final boolean </span><span class="s1">wasInProgress = mInProgress</span><span class="s2">;</span>
        <span class="s1">mFocusX = focusX</span><span class="s2">;</span>
        <span class="s1">mFocusY = focusY</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!inAnchoredScaleMode() &amp;&amp; mInProgress &amp;&amp; (span &lt; mMinSpan || configChanged)) {</span>
            <span class="s1">mListener.onScaleEnd(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">mInProgress = </span><span class="s2">false;</span>
            <span class="s1">mInitialSpan = span</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(configChanged) {</span>
            <span class="s1">mPrevSpanX = mCurrSpanX = spanX</span><span class="s2">;</span>
            <span class="s1">mPrevSpanY = mCurrSpanY = spanY</span><span class="s2">;</span>
            <span class="s1">mInitialSpan = mPrevSpan = mCurrSpan = span</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s2">final int </span><span class="s1">minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!mInProgress &amp;&amp; span &gt;=  minSpan &amp;&amp;</span>
                <span class="s1">(wasInProgress || Math.abs(span - mInitialSpan) &gt; mSpanSlop)) {</span>
            <span class="s1">mPrevSpanX = mCurrSpanX = spanX</span><span class="s2">;</span>
            <span class="s1">mPrevSpanY = mCurrSpanY = spanY</span><span class="s2">;</span>
            <span class="s1">mPrevSpan = mCurrSpan = span</span><span class="s2">;</span>
            <span class="s1">mPrevTime = mCurrTime</span><span class="s2">;</span>
            <span class="s1">mInProgress = mListener.onScaleBegin(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">// Handle motion; focal point and span/scale factor are changing.</span>
        <span class="s2">if </span><span class="s1">(action == MotionEvent.ACTION_MOVE) {</span>
            <span class="s1">mCurrSpanX = spanX</span><span class="s2">;</span>
            <span class="s1">mCurrSpanY = spanY</span><span class="s2">;</span>
            <span class="s1">mCurrSpan = span</span><span class="s2">;</span>

            <span class="s2">boolean </span><span class="s1">updatePrev = </span><span class="s2">true;</span>

            <span class="s2">if </span><span class="s1">(mInProgress) {</span>
                <span class="s1">updatePrev = mListener.onScale(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(updatePrev) {</span>
                <span class="s1">mPrevSpanX = mCurrSpanX</span><span class="s2">;</span>
                <span class="s1">mPrevSpanY = mCurrSpanY</span><span class="s2">;</span>
                <span class="s1">mPrevSpan = mCurrSpan</span><span class="s2">;</span>
                <span class="s1">mPrevTime = mCurrTime</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return true;</span>
    <span class="s1">}</span>

    <span class="s2">private boolean </span><span class="s1">inAnchoredScaleMode() {</span>
        <span class="s2">return </span><span class="s1">mAnchoredScaleMode != ANCHORED_SCALE_MODE_NONE</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Set whether the associated {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener} should receive onScale callbacks</span>
     <span class="s3">* when the user performs a doubleTap followed by a swipe. Note that this is enabled by default</span>
     <span class="s3">* if the app targets API 19 and newer.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">scales true to enable quick scaling, false to disable</span>
     <span class="s3">*/</span>
    <span class="s2">public void </span><span class="s1">setQuickScaleEnabled(</span><span class="s2">boolean </span><span class="s1">scales) {</span>
        <span class="s1">mQuickScaleEnabled = scales</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mQuickScaleEnabled &amp;&amp; mGestureDetector == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">GestureDetector.SimpleOnGestureListener gestureListener =</span>
                    <span class="s2">new </span><span class="s1">GestureDetector.SimpleOnGestureListener() {</span>
                        <span class="s1">@Override</span>
                        <span class="s2">public boolean </span><span class="s1">onDoubleTap(MotionEvent e) {</span>
                            <span class="s0">// Double tap: start watching for a swipe</span>
                            <span class="s1">mAnchoredScaleStartX = e.getX()</span><span class="s2">;</span>
                            <span class="s1">mAnchoredScaleStartY = e.getY()</span><span class="s2">;</span>
                            <span class="s1">mAnchoredScaleMode = ANCHORED_SCALE_MODE_DOUBLE_TAP</span><span class="s2">;</span>
                            <span class="s2">return true;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">mGestureDetector = </span><span class="s2">new </span><span class="s1">GestureDetector(mContext</span><span class="s2">, </span><span class="s1">gestureListener</span><span class="s2">, </span><span class="s1">mHandler)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return whether the quick scale gesture, in which the user performs a double tap followed by a</span>
     <span class="s3">* swipe, should perform scaling. {</span><span class="s4">@see </span><span class="s3">#setQuickScaleEnabled(boolean)}.</span>
     <span class="s3">*/</span>
    <span class="s2">public boolean </span><span class="s1">isQuickScaleEnabled() {</span>
        <span class="s2">return </span><span class="s1">mQuickScaleEnabled</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Sets whether the associates {</span><span class="s4">@link </span><span class="s3">OnScaleGestureListener} should receive</span>
     <span class="s3">* onScale callbacks when the user uses a stylus and presses the button.</span>
     <span class="s3">* Note that this is enabled by default if the app targets API 23 and newer.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">scales true to enable stylus scaling, false to disable.</span>
     <span class="s3">*/</span>
    <span class="s2">public void </span><span class="s1">setStylusScaleEnabled(</span><span class="s2">boolean </span><span class="s1">scales) {</span>
        <span class="s1">mStylusScaleEnabled = scales</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return whether the stylus scale gesture, in which the user uses a stylus and presses the</span>
     <span class="s3">* button, should perform scaling. {</span><span class="s4">@see </span><span class="s3">#setStylusScaleEnabled(boolean)}</span>
     <span class="s3">*/</span>
    <span class="s2">public boolean </span><span class="s1">isStylusScaleEnabled() {</span>
        <span class="s2">return </span><span class="s1">mStylusScaleEnabled</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Returns {</span><span class="s4">@code </span><span class="s3">true} if a scale gesture is in progress.</span>
     <span class="s3">*/</span>
    <span class="s2">public boolean </span><span class="s1">isInProgress() {</span>
        <span class="s2">return </span><span class="s1">mInProgress</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Get the X coordinate of the current gesture's focal point.</span>
     <span class="s3">* If a gesture is in progress, the focal point is between</span>
     <span class="s3">* each of the pointers forming the gesture.</span>
     <span class="s3">*</span>
     <span class="s3">* If {</span><span class="s4">@link </span><span class="s3">#isInProgress()} would return false, the result of this</span>
     <span class="s3">* function is undefined.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">X coordinate of the focal point in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getFocusX() {</span>
        <span class="s2">return </span><span class="s1">mFocusX</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Get the Y coordinate of the current gesture's focal point.</span>
     <span class="s3">* If a gesture is in progress, the focal point is between</span>
     <span class="s3">* each of the pointers forming the gesture.</span>
     <span class="s3">*</span>
     <span class="s3">* If {</span><span class="s4">@link </span><span class="s3">#isInProgress()} would return false, the result of this</span>
     <span class="s3">* function is undefined.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Y coordinate of the focal point in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getFocusY() {</span>
        <span class="s2">return </span><span class="s1">mFocusY</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the average distance between each of the pointers forming the</span>
     <span class="s3">* gesture in progress through the focal point.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Distance between pointers in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getCurrentSpan() {</span>
        <span class="s2">return </span><span class="s1">mCurrSpan</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the average X distance between each of the pointers forming the</span>
     <span class="s3">* gesture in progress through the focal point.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Distance between pointers in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getCurrentSpanX() {</span>
        <span class="s2">return </span><span class="s1">mCurrSpanX</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the average Y distance between each of the pointers forming the</span>
     <span class="s3">* gesture in progress through the focal point.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Distance between pointers in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getCurrentSpanY() {</span>
        <span class="s2">return </span><span class="s1">mCurrSpanY</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the previous average distance between each of the pointers forming the</span>
     <span class="s3">* gesture in progress through the focal point.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Previous distance between pointers in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getPreviousSpan() {</span>
        <span class="s2">return </span><span class="s1">mPrevSpan</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the previous average X distance between each of the pointers forming the</span>
     <span class="s3">* gesture in progress through the focal point.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Previous distance between pointers in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getPreviousSpanX() {</span>
        <span class="s2">return </span><span class="s1">mPrevSpanX</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the previous average Y distance between each of the pointers forming the</span>
     <span class="s3">* gesture in progress through the focal point.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Previous distance between pointers in pixels.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getPreviousSpanY() {</span>
        <span class="s2">return </span><span class="s1">mPrevSpanY</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the scaling factor from the previous scale event to the current</span>
     <span class="s3">* event. This value is defined as</span>
     <span class="s3">* ({</span><span class="s4">@link </span><span class="s3">#getCurrentSpan()} / {</span><span class="s4">@link </span><span class="s3">#getPreviousSpan()}).</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">The current scaling factor.</span>
     <span class="s3">*/</span>
    <span class="s2">public float </span><span class="s1">getScaleFactor() {</span>
        <span class="s2">if </span><span class="s1">(inAnchoredScaleMode()) {</span>
            <span class="s0">// Drag is moving up; the further away from the gesture</span>
            <span class="s0">// start, the smaller the span should be, the closer,</span>
            <span class="s0">// the larger the span, and therefore the larger the scale</span>
            <span class="s2">final boolean </span><span class="s1">scaleUp =</span>
                    <span class="s1">(mEventBeforeOrAboveStartingGestureEvent &amp;&amp; (mCurrSpan &lt; mPrevSpan)) ||</span>
                            <span class="s1">(!mEventBeforeOrAboveStartingGestureEvent &amp;&amp; (mCurrSpan &gt; mPrevSpan))</span><span class="s2">;</span>
            <span class="s2">final float </span><span class="s1">spanDiff = (Math.abs(</span><span class="s7">1 </span><span class="s1">- (mCurrSpan / mPrevSpan)) * SCALE_FACTOR)</span><span class="s2">;</span>
            <span class="s2">return </span><span class="s1">mPrevSpan &lt;= mSpanSlop ? </span><span class="s7">1 </span><span class="s1">: scaleUp ? (</span><span class="s7">1 </span><span class="s1">+ spanDiff) : (</span><span class="s7">1 </span><span class="s1">- spanDiff)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">mPrevSpan &gt; </span><span class="s7">0 </span><span class="s1">? mCurrSpan / mPrevSpan : </span><span class="s7">1</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the time difference in milliseconds between the previous</span>
     <span class="s3">* accepted scaling event and the current scaling event.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Time difference since the last scaling event in milliseconds.</span>
     <span class="s3">*/</span>
    <span class="s2">public long </span><span class="s1">getTimeDelta() {</span>
        <span class="s2">return </span><span class="s1">mCurrTime - mPrevTime</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Return the event time of the current event being processed.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">Current event time in milliseconds.</span>
     <span class="s3">*/</span>
    <span class="s2">public long </span><span class="s1">getEventTime() {</span>
        <span class="s2">return </span><span class="s1">mCurrTime</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
<html>
<head>
<title>create.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">/*-------------------------------------------------------------------------- 
 
@sinclair/typebox/value 
 
The MIT License (MIT) 
 
Copyright (c) 2017-2023 Haydn Paterson (sinclair) &lt;haydn.developer@gmail.com&gt; 
 
Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the &quot;Software&quot;), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions: 
 
The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software. 
 
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
THE SOFTWARE. 
 
---------------------------------------------------------------------------*/</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s3">true </span><span class="s1">});</span>
<span class="s1">exports.ValueCreate = exports.ValueCreateDereferenceError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">const Types = require(</span><span class="s0">&quot;../typebox&quot;</span><span class="s1">);</span>
<span class="s1">const check_1 = require(</span><span class="s0">&quot;./check&quot;</span><span class="s1">);</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// Errors</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s1">class ValueCreateUnknownTypeError extends Error {</span>
    <span class="s1">constructor(schema) {</span>
        <span class="s1">super(</span><span class="s0">'ValueCreate: Unknown type'</span><span class="s1">);</span>
        <span class="s3">this</span><span class="s1">.schema = schema;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;</span>
<span class="s1">class ValueCreateNeverTypeError extends Error {</span>
    <span class="s1">constructor(schema) {</span>
        <span class="s1">super(</span><span class="s0">'ValueCreate: Never types cannot be created'</span><span class="s1">);</span>
        <span class="s3">this</span><span class="s1">.schema = schema;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;</span>
<span class="s1">class ValueCreateIntersectTypeError extends Error {</span>
    <span class="s1">constructor(schema) {</span>
        <span class="s1">super(</span><span class="s0">'ValueCreate: Intersect produced invalid value. Consider using a default value.'</span><span class="s1">);</span>
        <span class="s3">this</span><span class="s1">.schema = schema;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;</span>
<span class="s1">class ValueCreateTempateLiteralTypeError extends Error {</span>
    <span class="s1">constructor(schema) {</span>
        <span class="s1">super(</span><span class="s0">'ValueCreate: Can only create template literal values from patterns that produce finite sequences. Consider using a default value.'</span><span class="s1">);</span>
        <span class="s3">this</span><span class="s1">.schema = schema;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;</span>
<span class="s1">class ValueCreateDereferenceError extends Error {</span>
    <span class="s1">constructor(schema) {</span>
        <span class="s1">super(`ValueCreate: Unable to dereference schema </span><span class="s3">with </span><span class="s1">$id </span><span class="s0">'${schema.$ref}'</span><span class="s1">`);</span>
        <span class="s3">this</span><span class="s1">.schema = schema;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.ValueCreateDereferenceError = ValueCreateDereferenceError;</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s2">// ValueCreate</span>
<span class="s2">// --------------------------------------------------------------------------</span>
<span class="s3">var </span><span class="s1">ValueCreate;</span>
<span class="s1">(</span><span class="s3">function </span><span class="s1">(ValueCreate) {</span>
    <span class="s2">// --------------------------------------------------------</span>
    <span class="s2">// Guards</span>
    <span class="s2">// --------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">IsString(value) {</span>
        <span class="s3">return typeof </span><span class="s1">value === </span><span class="s0">'string'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">// --------------------------------------------------------</span>
    <span class="s2">// Types</span>
    <span class="s2">// --------------------------------------------------------</span>
    <span class="s3">function </span><span class="s1">Any(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">{};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Array(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(schema.uniqueItems === </span><span class="s3">true </span><span class="s1">&amp;&amp; schema.</span><span class="s3">default </span><span class="s1">=== undefined) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'ValueCreate.Array: Arrays with uniqueItems require a default value'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(schema.minItems !== undefined) {</span>
            <span class="s3">return </span><span class="s1">globalThis.Array.from({ length: schema.minItems }).map((item) =&gt; {</span>
                <span class="s3">return </span><span class="s1">ValueCreate.Create(schema.items, references);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">[];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">BigInt(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">globalThis.BigInt(</span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Boolean(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Constructor(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">const value = ValueCreate.Create(schema.returns, references);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">value === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; !globalThis.Array.isArray(value)) {</span>
                <span class="s3">return </span><span class="s1">class {</span>
                    <span class="s1">constructor() {</span>
                        <span class="s3">for </span><span class="s1">(const [key, val] of globalThis.Object.entries(value)) {</span>
                            <span class="s1">const self = </span><span class="s3">this</span><span class="s1">;</span>
                            <span class="s1">self[key] = val;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">class {</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Date(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(schema.minimumTimestamp !== undefined) {</span>
            <span class="s3">return new </span><span class="s1">globalThis.Date(schema.minimumTimestamp);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return new </span><span class="s1">globalThis.Date(</span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Function(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">() =&gt; ValueCreate.Create(schema.returns, references);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Integer(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(schema.minimum !== undefined) {</span>
            <span class="s3">return </span><span class="s1">schema.minimum;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Intersect(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s2">// Note: The best we can do here is attempt to instance each sub type and apply through object assign. For non-object</span>
            <span class="s2">// sub types, we just escape the assignment and just return the value. In the latter case, this is typically going to</span>
            <span class="s2">// be a consequence of an illogical intersection.</span>
            <span class="s1">const value = schema.allOf.reduce((acc, schema) =&gt; {</span>
                <span class="s1">const next = Visit(schema, references);</span>
                <span class="s3">return typeof </span><span class="s1">next === </span><span class="s0">'object' </span><span class="s1">? { ...acc, ...next } : next;</span>
            <span class="s1">}, {});</span>
            <span class="s3">if </span><span class="s1">(!check_1.ValueCheck.Check(schema, references, value))</span>
                <span class="s3">throw new </span><span class="s1">ValueCreateIntersectTypeError(schema);</span>
            <span class="s3">return </span><span class="s1">value;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Literal(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">schema.const;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Never(schema, references) {</span>
        <span class="s3">throw new </span><span class="s1">ValueCreateNeverTypeError(schema);</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Not(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">Visit(schema.allOf[</span><span class="s4">1</span><span class="s1">], references);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Null(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Number(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(schema.minimum !== undefined) {</span>
            <span class="s3">return </span><span class="s1">schema.minimum;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Object(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">const required = </span><span class="s3">new </span><span class="s1">Set(schema.required);</span>
            <span class="s3">return </span><span class="s1">(schema.</span><span class="s3">default </span><span class="s1">||</span>
                <span class="s1">globalThis.Object.entries(schema.properties).reduce((acc, [key, schema]) =&gt; {</span>
                    <span class="s3">return </span><span class="s1">required.has(key) ? { ...acc, [key]: ValueCreate.Create(schema, references) } : { ...acc };</span>
                <span class="s1">}, {}));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Promise(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">globalThis.Promise.resolve(ValueCreate.Create(schema.item, references));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Record(schema, references) {</span>
        <span class="s1">const [keyPattern, valueSchema] = globalThis.Object.entries(schema.patternProperties)[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(!(keyPattern === Types.PatternStringExact || keyPattern === Types.PatternNumberExact)) {</span>
            <span class="s1">const propertyKeys = keyPattern.slice(</span><span class="s4">1</span><span class="s1">, keyPattern.length - </span><span class="s4">1</span><span class="s1">).split(</span><span class="s0">'|'</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">propertyKeys.reduce((acc, key) =&gt; {</span>
                <span class="s3">return </span><span class="s1">{ ...acc, [key]: Create(valueSchema, references) };</span>
            <span class="s1">}, {});</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">{};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Ref(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">const index = references.findIndex((foreign) =&gt; foreign.$id === schema.$id);</span>
            <span class="s3">if </span><span class="s1">(index === -</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s3">throw new </span><span class="s1">ValueCreateDereferenceError(schema);</span>
            <span class="s1">const target = references[index];</span>
            <span class="s3">return </span><span class="s1">Visit(target, references);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">String(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(schema.pattern !== undefined) {</span>
            <span class="s3">if </span><span class="s1">(!(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema)) {</span>
                <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'ValueCreate.String: String types with patterns must specify a default value'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(schema.format !== undefined) {</span>
            <span class="s3">if </span><span class="s1">(!(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema)) {</span>
                <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'ValueCreate.String: String types with formats must specify a default value'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
                <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">else if </span><span class="s1">(schema.minLength !== undefined) {</span>
                <span class="s3">return </span><span class="s1">globalThis.Array.from({ length: schema.minLength })</span>
                    <span class="s1">.map(() =&gt; </span><span class="s0">'.'</span><span class="s1">)</span>
                    <span class="s1">.join(</span><span class="s0">''</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Symbol(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(</span><span class="s0">'value' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">globalThis.Symbol.</span><span class="s3">for</span><span class="s1">(schema.value);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">globalThis.Symbol();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">TemplateLiteral(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const expression = Types.TemplateLiteralParser.ParseExact(schema.pattern);</span>
        <span class="s3">if </span><span class="s1">(!Types.TemplateLiteralFinite.Check(expression))</span>
            <span class="s3">throw new </span><span class="s1">ValueCreateTempateLiteralTypeError(schema);</span>
        <span class="s1">const sequence = Types.TemplateLiteralGenerator.Generate(expression);</span>
        <span class="s3">return </span><span class="s1">sequence.next().value;</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">This(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s1">const index = references.findIndex((foreign) =&gt; foreign.$id === schema.$id);</span>
            <span class="s3">if </span><span class="s1">(index === -</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s3">throw new </span><span class="s1">ValueCreateDereferenceError(schema);</span>
            <span class="s1">const target = references[index];</span>
            <span class="s3">return </span><span class="s1">Visit(target, references);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Tuple(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(schema.items === undefined) {</span>
            <span class="s3">return </span><span class="s1">[];</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">globalThis.Array.from({ length: schema.minItems }).map((_, index) =&gt; ValueCreate.Create(schema.items[index], references));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Undefined(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Union(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(schema.anyOf.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'ValueCreate.Union: Cannot create Union with zero variants'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">ValueCreate.Create(schema.anyOf[</span><span class="s4">0</span><span class="s1">], references);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Uint8Array(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else if </span><span class="s1">(schema.minByteLength !== undefined) {</span>
            <span class="s3">return new </span><span class="s1">globalThis.Uint8Array(schema.minByteLength);</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return new </span><span class="s1">globalThis.Uint8Array(</span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Unknown(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return </span><span class="s1">{};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">Void(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">return void </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">function </span><span class="s1">UserDefined(schema, references) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s0">'default' </span><span class="s3">in </span><span class="s1">schema) {</span>
            <span class="s3">return </span><span class="s1">schema.</span><span class="s3">default</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">else </span><span class="s1">{</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">'ValueCreate.UserDefined: User defined types must specify a default value'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">/** Creates a value from the given schema. If the schema specifies a default value, then that value is returned. */</span>
    <span class="s3">function </span><span class="s1">Visit(schema, references) {</span>
        <span class="s1">const references_ = IsString(schema.$id) ? [...references, schema] : references;</span>
        <span class="s1">const schema_ = schema;</span>
        <span class="s3">switch </span><span class="s1">(schema_[Types.Kind]) {</span>
            <span class="s3">case </span><span class="s0">'Any'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Any(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Array'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Array(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'BigInt'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">BigInt(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Boolean'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Boolean(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Constructor'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Constructor(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Date'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Date(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Function'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Function(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Integer'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Integer(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Intersect'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Intersect(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Literal'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Literal(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Never'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Never(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Not'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Not(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Null'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Null(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Number'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Number(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Object'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Object(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Promise'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Promise(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Record'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Record(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Ref'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Ref(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'String'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">String(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Symbol'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Symbol(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'TemplateLiteral'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">TemplateLiteral(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'This'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">This(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Tuple'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Tuple(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Undefined'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Undefined(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Union'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Union(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Uint8Array'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Uint8Array(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Unknown'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Unknown(schema_, references_);</span>
            <span class="s3">case </span><span class="s0">'Void'</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">Void(schema_, references_);</span>
            <span class="s3">default</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(!Types.TypeRegistry.Has(schema_[Types.Kind]))</span>
                    <span class="s3">throw new </span><span class="s1">ValueCreateUnknownTypeError(schema_);</span>
                <span class="s3">return </span><span class="s1">UserDefined(schema_, references_);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ValueCreate.Visit = Visit;</span>
    <span class="s3">function </span><span class="s1">Create(schema, references) {</span>
        <span class="s3">return </span><span class="s1">Visit(schema, references);</span>
    <span class="s1">}</span>
    <span class="s1">ValueCreate.Create = Create;</span>
<span class="s1">})(ValueCreate = exports.ValueCreate || (exports.ValueCreate = {}));</span>
</pre>
</body>
</html>
<html>
<head>
<title>createHandler.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
createHandler.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
  <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= createHandler;</span>

<span class="s2">var </span><span class="s1">React = _interopRequireWildcard(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_reactNative = require(</span><span class="s0">&quot;react-native&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_isEqual = _interopRequireDefault(require(</span><span class="s0">&quot;lodash/isEqual&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_RNGestureHandlerModule = _interopRequireDefault(require(</span><span class="s0">&quot;../RNGestureHandlerModule&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_State = require(</span><span class="s0">&quot;../State&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_handlersRegistry = require(</span><span class="s0">&quot;./handlersRegistry&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_gestureHandlerCommon = require(</span><span class="s0">&quot;./gestureHandlerCommon&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_utils = require(</span><span class="s0">&quot;../utils&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_ActionType = require(</span><span class="s0">&quot;../ActionType&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_PressabilityDebugView = require(</span><span class="s0">&quot;./PressabilityDebugView&quot;</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_GestureHandlerRootViewContext = _interopRequireDefault(require(</span><span class="s0">&quot;../GestureHandlerRootViewContext&quot;</span><span class="s1">));</span>

<span class="s2">var </span><span class="s1">_UIManagerAny$getView, _UIManagerAny$getView2, _UIManagerAny$getCons;</span>

<span class="s2">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">default</span><span class="s1">: obj }; }</span>

<span class="s2">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">; </span><span class="s2">var </span><span class="s1">cache = </span><span class="s2">new </span><span class="s1">WeakMap(); _getRequireWildcardCache = </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s1">cache; }; </span><span class="s2">return </span><span class="s1">cache; }</span>

<span class="s2">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s2">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s2">return </span><span class="s1">obj; } </span><span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) { </span><span class="s2">return </span><span class="s1">{ </span><span class="s2">default</span><span class="s1">: obj }; } </span><span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(); </span><span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s2">return </span><span class="s1">cache.get(obj); } </span><span class="s2">var </span><span class="s1">newObj = {}; </span><span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor; </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) { </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj, key)) { </span><span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } </span><span class="s2">else </span><span class="s1">{ newObj[key] = obj[key]; } } } newObj.</span><span class="s2">default </span><span class="s1">= obj; </span><span class="s2">if </span><span class="s1">(cache) { cache.set(obj, newObj); } </span><span class="s2">return </span><span class="s1">newObj; }</span>

<span class="s2">function </span><span class="s1">_defineProperty(obj, key, value) { </span><span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">obj) { Object.defineProperty(obj, key, { value: value, enumerable: </span><span class="s2">true</span><span class="s1">, configurable: </span><span class="s2">true</span><span class="s1">, writable: </span><span class="s2">true </span><span class="s1">}); } </span><span class="s2">else </span><span class="s1">{ obj[key] = value; } </span><span class="s2">return </span><span class="s1">obj; }</span>

<span class="s1">const UIManagerAny = _reactNative.UIManager;</span>
<span class="s1">const customGHEventsConfigFabricAndroid = {</span>
  <span class="s1">topOnGestureHandlerEvent: {</span>
    <span class="s1">registrationName: </span><span class="s0">'onGestureHandlerEvent'</span>
  <span class="s1">},</span>
  <span class="s1">topOnGestureHandlerStateChange: {</span>
    <span class="s1">registrationName: </span><span class="s0">'onGestureHandlerStateChange'</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s1">const customGHEventsConfig = {</span>
  <span class="s1">onGestureHandlerEvent: {</span>
    <span class="s1">registrationName: </span><span class="s0">'onGestureHandlerEvent'</span>
  <span class="s1">},</span>
  <span class="s1">onGestureHandlerStateChange: {</span>
    <span class="s1">registrationName: </span><span class="s0">'onGestureHandlerStateChange'</span>
  <span class="s1">},</span>
  <span class="s3">// When using React Native Gesture Handler for Animated.event with useNativeDriver: true</span>
  <span class="s3">// on Android with Fabric enabled, the native part still sends the native events to JS</span>
  <span class="s3">// but prefixed with &quot;top&quot;. We cannot simply rename the events above so they are prefixed</span>
  <span class="s3">// with &quot;top&quot; instead of &quot;on&quot; because in such case Animated.events would not be registered.</span>
  <span class="s3">// That's why we need to register another pair of event names.</span>
  <span class="s3">// The incoming events will be queued but never handled.</span>
  <span class="s3">// Without this piece of code below, you'll get the following JS error:</span>
  <span class="s3">// Unsupported top level event type &quot;topOnGestureHandlerEvent&quot; dispatched</span>
  <span class="s1">...((</span><span class="s4">0</span><span class="s1">, _utils.isFabric)() &amp;&amp; _reactNative.Platform.OS === </span><span class="s0">'android' </span><span class="s1">&amp;&amp; customGHEventsConfigFabricAndroid)</span>
<span class="s1">}; </span><span class="s3">// Add gesture specific events to genericDirectEventTypes object exported from UIManager</span>
<span class="s3">// native module.</span>
<span class="s3">// Once new event types are registered with react it is possible to dispatch these</span>
<span class="s3">// events to all kind of native views.</span>

<span class="s1">UIManagerAny.genericDirectEventTypes = { ...UIManagerAny.genericDirectEventTypes,</span>
  <span class="s1">...customGHEventsConfig</span>
<span class="s1">}; </span><span class="s3">// In newer versions of RN the `genericDirectEventTypes` is located in the object</span>
<span class="s3">// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make</span>
<span class="s3">// it compatible with RN 61+</span>

<span class="s1">const UIManagerConstants = (_UIManagerAny$getView = (_UIManagerAny$getView2 = UIManagerAny.getViewManagerConfig) === </span><span class="s2">null </span><span class="s1">|| _UIManagerAny$getView2 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _UIManagerAny$getView2.call(UIManagerAny, </span><span class="s0">'getConstants'</span><span class="s1">)) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _UIManagerAny$getView !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? _UIManagerAny$getView : (_UIManagerAny$getCons = UIManagerAny.getConstants) === </span><span class="s2">null </span><span class="s1">|| _UIManagerAny$getCons === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _UIManagerAny$getCons.call(UIManagerAny);</span>

<span class="s2">if </span><span class="s1">(UIManagerConstants) {</span>
  <span class="s1">UIManagerConstants.genericDirectEventTypes = { ...UIManagerConstants.genericDirectEventTypes,</span>
    <span class="s1">...customGHEventsConfig</span>
  <span class="s1">};</span>
<span class="s1">} </span><span class="s3">// Wrap JS responder calls and notify gesture handler manager</span>


<span class="s1">const {</span>
  <span class="s1">setJSResponder: oldSetJSResponder = () =&gt; {</span><span class="s3">//no operation</span>
  <span class="s1">},</span>
  <span class="s1">clearJSResponder: oldClearJSResponder = () =&gt; {</span><span class="s3">//no operation</span>
  <span class="s1">}</span>
<span class="s1">} = UIManagerAny;</span>

<span class="s1">UIManagerAny.setJSResponder = (tag, blockNativeResponder) =&gt; {</span>
  <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.handleSetJSResponder(tag, blockNativeResponder);</span>

  <span class="s1">oldSetJSResponder(tag, blockNativeResponder);</span>
<span class="s1">};</span>

<span class="s1">UIManagerAny.clearJSResponder = () =&gt; {</span>
  <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.handleClearJSResponder();</span>

  <span class="s1">oldClearJSResponder();</span>
<span class="s1">};</span>

<span class="s1">let allowTouches = </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">const DEV_ON_ANDROID = __DEV__ &amp;&amp; _reactNative.Platform.OS === </span><span class="s0">'android'</span><span class="s1">; </span><span class="s3">// Toggled inspector blocks touch events in order to allow inspecting on Android</span>
<span class="s3">// This needs to be a global variable in order to set initial state for `allowTouches` property in Handler component</span>

<span class="s2">if </span><span class="s1">(DEV_ON_ANDROID) {</span>
  <span class="s1">_reactNative.DeviceEventEmitter.addListener(</span><span class="s0">'toggleElementInspector'</span><span class="s1">, () =&gt; {</span>
    <span class="s1">allowTouches = !allowTouches;</span>
  <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">hasUnresolvedRefs(props) {</span>
  <span class="s3">// TODO(TS) - add type for extract arg</span>
  <span class="s1">const extract = refs =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!Array.isArray(refs)) {</span>
      <span class="s2">return </span><span class="s1">refs &amp;&amp; refs.current === </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">refs.some(r =&gt; r &amp;&amp; r.current === </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s2">return </span><span class="s1">extract(props[</span><span class="s0">'simultaneousHandlers'</span><span class="s1">]) || extract(props[</span><span class="s0">'waitFor'</span><span class="s1">]);</span>
<span class="s1">}</span>

<span class="s1">const stateToPropMappings = {</span>
  <span class="s1">[_State.State.UNDETERMINED]: undefined,</span>
  <span class="s1">[_State.State.BEGAN]: </span><span class="s0">'onBegan'</span><span class="s1">,</span>
  <span class="s1">[_State.State.FAILED]: </span><span class="s0">'onFailed'</span><span class="s1">,</span>
  <span class="s1">[_State.State.CANCELLED]: </span><span class="s0">'onCancelled'</span><span class="s1">,</span>
  <span class="s1">[_State.State.ACTIVE]: </span><span class="s0">'onActivated'</span><span class="s1">,</span>
  <span class="s1">[_State.State.END]: </span><span class="s0">'onEnded'</span>
<span class="s1">};</span>
<span class="s1">const UNRESOLVED_REFS_RETRY_LIMIT = </span><span class="s4">1</span><span class="s1">; </span><span class="s3">// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.</span>

<span class="s2">function </span><span class="s1">createHandler({</span>
  <span class="s1">name,</span>
  <span class="s1">allowedProps = [],</span>
  <span class="s1">config = {},</span>
  <span class="s1">transformProps,</span>
  <span class="s1">customNativeProps = []</span>
<span class="s1">}) {</span>
  <span class="s1">class Handler extends React.Component {</span>
    <span class="s1">constructor(props) {</span>
      <span class="s1">super(props);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;handlerTag&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;config&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;propsRef&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;isMountedRef&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;viewNode&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;viewTag&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;inspectorToggleListener&quot;</span><span class="s1">, </span><span class="s2">void </span><span class="s4">0</span><span class="s1">);</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;onGestureHandlerEvent&quot;</span><span class="s1">, event =&gt; {</span>
        <span class="s2">if </span><span class="s1">(event.nativeEvent.handlerTag === </span><span class="s2">this</span><span class="s1">.handlerTag) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">.props.onGestureEvent === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">_this$props$onGesture, _this$props;</span>

            <span class="s1">(_this$props$onGesture = (_this$props = </span><span class="s2">this</span><span class="s1">.props).onGestureEvent) === </span><span class="s2">null </span><span class="s1">|| _this$props$onGesture === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this$props$onGesture.call(_this$props, event);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_this$props$onGesture2, _this$props2;</span>

          <span class="s1">(_this$props$onGesture2 = (_this$props2 = </span><span class="s2">this</span><span class="s1">.props).onGestureHandlerEvent) === </span><span class="s2">null </span><span class="s1">|| _this$props$onGesture2 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this$props$onGesture2.call(_this$props2, event);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;onGestureHandlerStateChange&quot;</span><span class="s1">, event =&gt; {</span>
        <span class="s2">if </span><span class="s1">(event.nativeEvent.handlerTag === </span><span class="s2">this</span><span class="s1">.handlerTag) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof this</span><span class="s1">.props.onHandlerStateChange === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">_this$props$onHandler, _this$props3;</span>

            <span class="s1">(_this$props$onHandler = (_this$props3 = </span><span class="s2">this</span><span class="s1">.props).onHandlerStateChange) === </span><span class="s2">null </span><span class="s1">|| _this$props$onHandler === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this$props$onHandler.call(_this$props3, event);</span>
          <span class="s1">}</span>

          <span class="s1">const state = event.nativeEvent.state;</span>
          <span class="s1">const stateEventName = stateToPropMappings[state];</span>
          <span class="s1">const eventHandler = stateEventName &amp;&amp; </span><span class="s2">this</span><span class="s1">.props[stateEventName];</span>

          <span class="s2">if </span><span class="s1">(eventHandler &amp;&amp; </span><span class="s2">typeof </span><span class="s1">eventHandler === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">eventHandler(event);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">var </span><span class="s1">_this$props$onGesture3, _this$props4;</span>

          <span class="s1">(_this$props$onGesture3 = (_this$props4 = </span><span class="s2">this</span><span class="s1">.props).onGestureHandlerStateChange) === </span><span class="s2">null </span><span class="s1">|| _this$props$onGesture3 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this$props$onGesture3.call(_this$props4, event);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;refHandler&quot;</span><span class="s1">, node =&gt; {</span>
        <span class="s2">this</span><span class="s1">.viewNode = node;</span>
        <span class="s1">const child = React.Children.only(</span><span class="s2">this</span><span class="s1">.props.children); </span><span class="s3">// TODO(TS) fix ref type</span>

        <span class="s1">const {</span>
          <span class="s1">ref</span>
        <span class="s1">} = child;</span>

        <span class="s2">if </span><span class="s1">(ref !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ref === </span><span class="s0">'function'</span><span class="s1">) {</span>
            <span class="s1">ref(node);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">ref.current = node;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">});</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;createGestureHandler&quot;</span><span class="s1">, newConfig =&gt; {</span>
        <span class="s2">this</span><span class="s1">.config = newConfig;</span>

        <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.createGestureHandler(name, </span><span class="s2">this</span><span class="s1">.handlerTag, newConfig);</span>
      <span class="s1">});</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;attachGestureHandler&quot;</span><span class="s1">, newViewTag =&gt; {</span>
        <span class="s2">this</span><span class="s1">.viewTag = newViewTag;</span>

        <span class="s2">if </span><span class="s1">(_reactNative.Platform.OS === </span><span class="s0">'web'</span><span class="s1">) {</span>
          <span class="s3">// typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch</span>
          <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.attachGestureHandler(</span><span class="s2">this</span><span class="s1">.handlerTag, newViewTag, _ActionType.ActionType.JS_FUNCTION_OLD_API, </span><span class="s3">// ignored on web</span>
          <span class="s2">this</span><span class="s1">.propsRef);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">(</span><span class="s4">0</span><span class="s1">, _handlersRegistry.registerOldGestureHandler)(</span><span class="s2">this</span><span class="s1">.handlerTag, {</span>
            <span class="s1">onGestureEvent: </span><span class="s2">this</span><span class="s1">.onGestureHandlerEvent,</span>
            <span class="s1">onGestureStateChange: </span><span class="s2">this</span><span class="s1">.onGestureHandlerStateChange</span>
          <span class="s1">});</span>

          <span class="s1">const actionType = (() =&gt; {</span>
            <span class="s2">var </span><span class="s1">_this$props5, _this$props6;</span>

            <span class="s2">if </span><span class="s1">((_this$props5 = </span><span class="s2">this</span><span class="s1">.props) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _this$props5 !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; _this$props5.onGestureEvent &amp;&amp; </span><span class="s0">'current' </span><span class="s2">in this</span><span class="s1">.props.onGestureEvent) {</span>
              <span class="s3">// Reanimated worklet</span>
              <span class="s2">return </span><span class="s1">_ActionType.ActionType.REANIMATED_WORKLET;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">((_this$props6 = </span><span class="s2">this</span><span class="s1">.props) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _this$props6 !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">&amp;&amp; _this$props6.onGestureEvent &amp;&amp; </span><span class="s0">'__isNative' </span><span class="s2">in this</span><span class="s1">.props.onGestureEvent) {</span>
              <span class="s3">// Animated.event with useNativeDriver: true</span>
              <span class="s2">return </span><span class="s1">_ActionType.ActionType.NATIVE_ANIMATED_EVENT;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s3">// JS callback or Animated.event with useNativeDriver: false</span>
              <span class="s2">return </span><span class="s1">_ActionType.ActionType.JS_FUNCTION_OLD_API;</span>
            <span class="s1">}</span>
          <span class="s1">})();</span>

          <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.attachGestureHandler(</span><span class="s2">this</span><span class="s1">.handlerTag, newViewTag, actionType);</span>
        <span class="s1">}</span>

        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.scheduleFlushOperations)();</span>
      <span class="s1">});</span>

      <span class="s1">_defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">&quot;updateGestureHandler&quot;</span><span class="s1">, newConfig =&gt; {</span>
        <span class="s2">this</span><span class="s1">.config = newConfig;</span>

        <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.updateGestureHandler(</span><span class="s2">this</span><span class="s1">.handlerTag, newConfig);</span>

        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.scheduleFlushOperations)();</span>
      <span class="s1">});</span>

      <span class="s2">this</span><span class="s1">.handlerTag = (</span><span class="s4">0</span><span class="s1">, _handlersRegistry.getNextHandlerTag)();</span>
      <span class="s2">this</span><span class="s1">.config = {};</span>
      <span class="s2">this</span><span class="s1">.propsRef = </span><span class="s3">/*#__PURE__*/</span><span class="s1">React.createRef();</span>
      <span class="s2">this</span><span class="s1">.isMountedRef = </span><span class="s3">/*#__PURE__*/</span><span class="s1">React.createRef();</span>
      <span class="s2">this</span><span class="s1">.state = {</span>
        <span class="s1">allowTouches</span>
      <span class="s1">};</span>

      <span class="s2">if </span><span class="s1">(props.id) {</span>
        <span class="s2">if </span><span class="s1">(_handlersRegistry.handlerIDToTag[props.id] !== undefined) {</span>
          <span class="s2">throw new </span><span class="s1">Error(`Handler </span><span class="s2">with </span><span class="s1">ID </span><span class="s0">&quot;${props.id}&quot; </span><span class="s1">already registered`);</span>
        <span class="s1">}</span>

        <span class="s1">_handlersRegistry.handlerIDToTag[props.id] = </span><span class="s2">this</span><span class="s1">.handlerTag;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">componentDidMount() {</span>
      <span class="s1">const props = </span><span class="s2">this</span><span class="s1">.props;</span>
      <span class="s2">this</span><span class="s1">.isMountedRef.current = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(DEV_ON_ANDROID) {</span>
        <span class="s2">this</span><span class="s1">.inspectorToggleListener = _reactNative.DeviceEventEmitter.addListener(</span><span class="s0">'toggleElementInspector'</span><span class="s1">, () =&gt; {</span>
          <span class="s2">this</span><span class="s1">.setState(_ =&gt; ({</span>
            <span class="s1">allowTouches</span>
          <span class="s1">}));</span>
          <span class="s2">this</span><span class="s1">.update(UNRESOLVED_REFS_RETRY_LIMIT);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(hasUnresolvedRefs(props)) {</span>
        <span class="s3">// If there are unresolved refs (e.g. &quot;.current&quot; has not yet been set)</span>
        <span class="s3">// passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to</span>
        <span class="s3">// _update method that will try to update native handler props using</span>
        <span class="s3">// queueMicrotask. This makes it so update() function gets called after all</span>
        <span class="s3">// react components are mounted and we expect the missing ref object to</span>
        <span class="s3">// be resolved by then.</span>
        <span class="s1">queueMicrotask(() =&gt; {</span>
          <span class="s2">this</span><span class="s1">.update(UNRESOLVED_REFS_RETRY_LIMIT);</span>
        <span class="s1">});</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.createGestureHandler((</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.filterConfig)(transformProps ? transformProps(</span><span class="s2">this</span><span class="s1">.props) : </span><span class="s2">this</span><span class="s1">.props, [...allowedProps, ...customNativeProps], config));</span>
      <span class="s2">this</span><span class="s1">.attachGestureHandler((</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.findNodeHandle)(</span><span class="s2">this</span><span class="s1">.viewNode)); </span><span class="s3">// TODO(TS) - check if this can be null</span>
    <span class="s1">}</span>

    <span class="s1">componentDidUpdate() {</span>
      <span class="s1">const viewTag = (</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.findNodeHandle)(</span><span class="s2">this</span><span class="s1">.viewNode);</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.viewTag !== viewTag) {</span>
        <span class="s2">this</span><span class="s1">.attachGestureHandler(viewTag); </span><span class="s3">// TODO(TS) - check interaction between _viewTag &amp; findNodeHandle</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.update(UNRESOLVED_REFS_RETRY_LIMIT);</span>
    <span class="s1">}</span>

    <span class="s1">componentWillUnmount() {</span>
      <span class="s2">var </span><span class="s1">_this$inspectorToggle;</span>

      <span class="s1">(_this$inspectorToggle = </span><span class="s2">this</span><span class="s1">.inspectorToggleListener) === </span><span class="s2">null </span><span class="s1">|| _this$inspectorToggle === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this$inspectorToggle.remove();</span>
      <span class="s2">this</span><span class="s1">.isMountedRef.current = </span><span class="s2">false</span><span class="s1">;</span>

      <span class="s1">_RNGestureHandlerModule.</span><span class="s2">default</span><span class="s1">.dropGestureHandler(</span><span class="s2">this</span><span class="s1">.handlerTag);</span>

      <span class="s1">(</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.scheduleFlushOperations)(); </span><span class="s3">// We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context</span>

      <span class="s1">const handlerID = </span><span class="s2">this</span><span class="s1">.props.id;</span>

      <span class="s2">if </span><span class="s1">(handlerID) {</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-dynamic-delete</span>
        <span class="s2">delete </span><span class="s1">_handlersRegistry.handlerIDToTag[handlerID];</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">update(remainingTries) {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isMountedRef.current) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">const props = </span><span class="s2">this</span><span class="s1">.props; </span><span class="s3">// When ref is set via a function i.e. `ref={(r) =&gt; refObject.current = r}` instead of</span>
      <span class="s3">// `ref={refObject}` it's possible that it won't be resolved in time. Seems like trying</span>
      <span class="s3">// again is easy enough fix.</span>

      <span class="s2">if </span><span class="s1">(hasUnresolvedRefs(props) &amp;&amp; remainingTries &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">queueMicrotask(() =&gt; {</span>
          <span class="s2">this</span><span class="s1">.update(remainingTries - </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">});</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">const newConfig = (</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.filterConfig)(transformProps ? transformProps(</span><span class="s2">this</span><span class="s1">.props) : </span><span class="s2">this</span><span class="s1">.props, [...allowedProps, ...customNativeProps], config);</span>

        <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _isEqual.</span><span class="s2">default</span><span class="s1">)(</span><span class="s2">this</span><span class="s1">.config, newConfig)) {</span>
          <span class="s2">this</span><span class="s1">.updateGestureHandler(newConfig);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">setNativeProps(updates) {</span>
      <span class="s1">const mergedProps = { ...</span><span class="s2">this</span><span class="s1">.props,</span>
        <span class="s1">...updates</span>
      <span class="s1">};</span>
      <span class="s1">const newConfig = (</span><span class="s4">0</span><span class="s1">, _gestureHandlerCommon.filterConfig)(transformProps ? transformProps(mergedProps) : mergedProps, [...allowedProps, ...customNativeProps], config);</span>
      <span class="s2">this</span><span class="s1">.updateGestureHandler(newConfig);</span>
    <span class="s1">}</span>

    <span class="s1">render() {</span>
      <span class="s2">var </span><span class="s1">_this$props$testID;</span>

      <span class="s2">if </span><span class="s1">(__DEV__ &amp;&amp; !</span><span class="s2">this</span><span class="s1">.context &amp;&amp; !(</span><span class="s4">0</span><span class="s1">, _utils.isJestEnv)()) {</span>
        <span class="s2">throw new </span><span class="s1">Error(name + </span><span class="s0">' must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/installation for more details.'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">let gestureEventHandler = </span><span class="s2">this</span><span class="s1">.onGestureHandlerEvent; </span><span class="s3">// Another instance of https://github.com/microsoft/TypeScript/issues/13995</span>

      <span class="s1">const {</span>
        <span class="s1">onGestureEvent,</span>
        <span class="s1">onGestureHandlerEvent</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>

      <span class="s2">if </span><span class="s1">(onGestureEvent &amp;&amp; </span><span class="s2">typeof </span><span class="s1">onGestureEvent !== </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s3">// If it's not a method it should be an native Animated.event</span>
        <span class="s3">// object. We set it directly as the handler for the view</span>
        <span class="s3">// In this case nested handlers are not going to be supported</span>
        <span class="s2">if </span><span class="s1">(onGestureHandlerEvent) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Nesting touch handlers with native animated driver is not supported yet'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">gestureEventHandler = onGestureEvent;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(onGestureHandlerEvent &amp;&amp; </span><span class="s2">typeof </span><span class="s1">onGestureHandlerEvent !== </span><span class="s0">'function'</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Nesting touch handlers with native animated driver is not supported yet'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">let gestureStateEventHandler = </span><span class="s2">this</span><span class="s1">.onGestureHandlerStateChange; </span><span class="s3">// Another instance of https://github.com/microsoft/TypeScript/issues/13995</span>

      <span class="s1">const {</span>
        <span class="s1">onHandlerStateChange,</span>
        <span class="s1">onGestureHandlerStateChange</span>
      <span class="s1">} = </span><span class="s2">this</span><span class="s1">.props;</span>

      <span class="s2">if </span><span class="s1">(onHandlerStateChange &amp;&amp; </span><span class="s2">typeof </span><span class="s1">onHandlerStateChange !== </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s3">// If it's not a method it should be an native Animated.event</span>
        <span class="s3">// object. We set it directly as the handler for the view</span>
        <span class="s3">// In this case nested handlers are not going to be supported</span>
        <span class="s2">if </span><span class="s1">(onGestureHandlerStateChange) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Nesting touch handlers with native animated driver is not supported yet'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">gestureStateEventHandler = onHandlerStateChange;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(onGestureHandlerStateChange &amp;&amp; </span><span class="s2">typeof </span><span class="s1">onGestureHandlerStateChange !== </span><span class="s0">'function'</span><span class="s1">) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'Nesting touch handlers with native animated driver is not supported yet'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">const events = {</span>
        <span class="s1">onGestureHandlerEvent: </span><span class="s2">this</span><span class="s1">.state.allowTouches ? gestureEventHandler : undefined,</span>
        <span class="s1">onGestureHandlerStateChange: </span><span class="s2">this</span><span class="s1">.state.allowTouches ? gestureStateEventHandler : undefined</span>
      <span class="s1">};</span>
      <span class="s2">this</span><span class="s1">.propsRef.current = events;</span>
      <span class="s1">let child = </span><span class="s2">null</span><span class="s1">;</span>

      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">child = React.Children.only(</span><span class="s2">this</span><span class="s1">.props.children);</span>
      <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s2">throw new </span><span class="s1">Error((</span><span class="s4">0</span><span class="s1">, _utils.tagMessage)(`${name} got more than one view as a child. If you want the gesture to work on multiple views, wrap them </span><span class="s2">with </span><span class="s1">a common parent and attach the gesture to that view.`));</span>
      <span class="s1">}</span>

      <span class="s1">let grandChildren = child.props.children;</span>

      <span class="s2">if </span><span class="s1">(__DEV__ &amp;&amp; child.type &amp;&amp; (child.type === </span><span class="s0">'RNGestureHandlerButton' </span><span class="s1">|| child.type.name === </span><span class="s0">'View' </span><span class="s1">|| child.type.displayName === </span><span class="s0">'View'</span><span class="s1">)) {</span>
        <span class="s1">grandChildren = React.Children.toArray(grandChildren);</span>
        <span class="s1">grandChildren.push( </span><span class="s3">/*#__PURE__*/</span><span class="s1">React.createElement(_PressabilityDebugView.PressabilityDebugView, {</span>
          <span class="s1">key: </span><span class="s0">&quot;pressabilityDebugView&quot;</span><span class="s1">,</span>
          <span class="s1">color: </span><span class="s0">&quot;mediumspringgreen&quot;</span><span class="s1">,</span>
          <span class="s1">hitSlop: child.props.hitSlop</span>
        <span class="s1">}));</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s3">/*#__PURE__*/</span><span class="s1">React.cloneElement(child, {</span>
        <span class="s1">ref: </span><span class="s2">this</span><span class="s1">.refHandler,</span>
        <span class="s1">collapsable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">...((</span><span class="s4">0</span><span class="s1">, _utils.isJestEnv)() ? {</span>
          <span class="s1">handlerType: name,</span>
          <span class="s1">handlerTag: </span><span class="s2">this</span><span class="s1">.handlerTag</span>
        <span class="s1">} : {}),</span>
        <span class="s1">testID: (_this$props$testID = </span><span class="s2">this</span><span class="s1">.props.testID) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _this$props$testID !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? _this$props$testID : child.props.testID,</span>
        <span class="s1">...events</span>
      <span class="s1">}, grandChildren);</span>
    <span class="s1">}</span>

  <span class="s1">}</span>

  <span class="s1">_defineProperty(Handler, </span><span class="s0">&quot;displayName&quot;</span><span class="s1">, name);</span>

  <span class="s1">_defineProperty(Handler, </span><span class="s0">&quot;contextType&quot;</span><span class="s1">, _GestureHandlerRootViewContext.</span><span class="s2">default</span><span class="s1">);</span>

  <span class="s2">return </span><span class="s1">Handler;</span>
<span class="s1">}</span>
<span class="s3">//# sourceMappingURL=createHandler.js.map</span></pre>
</body>
</html>
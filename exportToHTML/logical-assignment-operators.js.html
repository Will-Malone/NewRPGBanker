<html>
<head>
<title>logical-assignment-operators.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
logical-assignment-operators.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @fileoverview Rule to replace assignment expressions with logical operator assignment 
 * @author Daniel Martens 
 */</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s1">const astUtils = require(</span><span class="s2">&quot;./utils/ast-utils.js&quot;</span><span class="s1">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s1">const baseTypes = </span><span class="s3">new </span><span class="s1">Set([</span><span class="s2">&quot;Identifier&quot;</span><span class="s1">, </span><span class="s2">&quot;Super&quot;</span><span class="s1">, </span><span class="s2">&quot;ThisExpression&quot;</span><span class="s1">]);</span>

<span class="s0">/** 
 * Returns true iff either &quot;undefined&quot; or a void expression (eg. &quot;void 0&quot;) 
 * @param {ASTNode} expression Expression to check 
 * @param {import('eslint-scope').Scope} scope Scope of the expression 
 * @returns {boolean} True iff &quot;undefined&quot; or &quot;void ...&quot; 
 */</span>
<span class="s3">function </span><span class="s1">isUndefined(expression, scope) {</span>
    <span class="s3">if </span><span class="s1">(expression.type === </span><span class="s2">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; expression.name === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">astUtils.isReferenceToGlobalVariable(scope, expression);</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">expression.type === </span><span class="s2">&quot;UnaryExpression&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.operator === </span><span class="s2">&quot;void&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.argument.type === </span><span class="s2">&quot;Literal&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.argument.value === </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns true iff the reference is either an identifier or member expression 
 * @param {ASTNode} expression Expression to check 
 * @returns {boolean} True for identifiers and member expressions 
 */</span>
<span class="s3">function </span><span class="s1">isReference(expression) {</span>
    <span class="s3">return </span><span class="s1">(expression.type === </span><span class="s2">&quot;Identifier&quot; </span><span class="s1">&amp;&amp; expression.name !== </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) ||</span>
           <span class="s1">expression.type === </span><span class="s2">&quot;MemberExpression&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns true iff the expression checks for nullish with loose equals. 
 * Examples: value == null, value == void 0 
 * @param {ASTNode} expression Test condition 
 * @param {import('eslint-scope').Scope} scope Scope of the expression 
 * @returns {boolean} True iff implicit nullish comparison 
 */</span>
<span class="s3">function </span><span class="s1">isImplicitNullishComparison(expression, scope) {</span>
    <span class="s3">if </span><span class="s1">(expression.type !== </span><span class="s2">&quot;BinaryExpression&quot; </span><span class="s1">|| expression.operator !== </span><span class="s2">&quot;==&quot;</span><span class="s1">) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const reference = isReference(expression.left) ? </span><span class="s2">&quot;left&quot; </span><span class="s1">: </span><span class="s2">&quot;right&quot;</span><span class="s1">;</span>
    <span class="s1">const nullish = reference === </span><span class="s2">&quot;left&quot; </span><span class="s1">? </span><span class="s2">&quot;right&quot; </span><span class="s1">: </span><span class="s2">&quot;left&quot;</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s1">isReference(expression[reference]) &amp;&amp;</span>
           <span class="s1">(astUtils.isNullLiteral(expression[nullish]) || isUndefined(expression[nullish], scope));</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Condition with two equal comparisons. 
 * @param {ASTNode} expression Condition 
 * @returns {boolean} True iff matches ? === ? || ? === ? 
 */</span>
<span class="s3">function </span><span class="s1">isDoubleComparison(expression) {</span>
    <span class="s3">return </span><span class="s1">expression.type === </span><span class="s2">&quot;LogicalExpression&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.operator === </span><span class="s2">&quot;||&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.left.type === </span><span class="s2">&quot;BinaryExpression&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.left.operator === </span><span class="s2">&quot;===&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.right.type === </span><span class="s2">&quot;BinaryExpression&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.right.operator === </span><span class="s2">&quot;===&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns true iff the expression checks for undefined and null. 
 * Example: value === null || value === undefined 
 * @param {ASTNode} expression Test condition 
 * @param {import('eslint-scope').Scope} scope Scope of the expression 
 * @returns {boolean} True iff explicit nullish comparison 
 */</span>
<span class="s3">function </span><span class="s1">isExplicitNullishComparison(expression, scope) {</span>
    <span class="s3">if </span><span class="s1">(!isDoubleComparison(expression)) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const leftReference = isReference(expression.left.left) ? </span><span class="s2">&quot;left&quot; </span><span class="s1">: </span><span class="s2">&quot;right&quot;</span><span class="s1">;</span>
    <span class="s1">const leftNullish = leftReference === </span><span class="s2">&quot;left&quot; </span><span class="s1">? </span><span class="s2">&quot;right&quot; </span><span class="s1">: </span><span class="s2">&quot;left&quot;</span><span class="s1">;</span>
    <span class="s1">const rightReference = isReference(expression.right.left) ? </span><span class="s2">&quot;left&quot; </span><span class="s1">: </span><span class="s2">&quot;right&quot;</span><span class="s1">;</span>
    <span class="s1">const rightNullish = rightReference === </span><span class="s2">&quot;left&quot; </span><span class="s1">? </span><span class="s2">&quot;right&quot; </span><span class="s1">: </span><span class="s2">&quot;left&quot;</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s1">astUtils.isSameReference(expression.left[leftReference], expression.right[rightReference]) &amp;&amp;</span>
           <span class="s1">((astUtils.isNullLiteral(expression.left[leftNullish]) &amp;&amp; isUndefined(expression.right[rightNullish], scope)) ||</span>
           <span class="s1">(isUndefined(expression.left[leftNullish], scope) &amp;&amp; astUtils.isNullLiteral(expression.right[rightNullish])));</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns true for Boolean(arg) calls 
 * @param {ASTNode} expression Test condition 
 * @param {import('eslint-scope').Scope} scope Scope of the expression 
 * @returns {boolean} Whether the expression is a boolean cast 
 */</span>
<span class="s3">function </span><span class="s1">isBooleanCast(expression, scope) {</span>
    <span class="s3">return </span><span class="s1">expression.type === </span><span class="s2">&quot;CallExpression&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.callee.name === </span><span class="s2">&quot;Boolean&quot; </span><span class="s1">&amp;&amp;</span>
           <span class="s1">expression.arguments.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
           <span class="s1">astUtils.isReferenceToGlobalVariable(scope, expression.callee);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns true for: 
 * truthiness checks:  value, Boolean(value), !!value 
 * falsiness checks:   !value, !Boolean(value) 
 * nullish checks:     value == null, value === undefined || value === null 
 * @param {ASTNode} expression Test condition 
 * @param {import('eslint-scope').Scope} scope Scope of the expression 
 * @returns {?{ reference: ASTNode, operator: '??'|'||'|'&amp;&amp;'}} Null if not a known existence 
 */</span>
<span class="s3">function </span><span class="s1">getExistence(expression, scope) {</span>
    <span class="s1">const isNegated = expression.type === </span><span class="s2">&quot;UnaryExpression&quot; </span><span class="s1">&amp;&amp; expression.operator === </span><span class="s2">&quot;!&quot;</span><span class="s1">;</span>
    <span class="s1">const base = isNegated ? expression.argument : expression;</span>

    <span class="s3">switch </span><span class="s1">(</span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s3">case </span><span class="s1">isReference(base):</span>
            <span class="s3">return </span><span class="s1">{ reference: base, operator: isNegated ? </span><span class="s2">&quot;||&quot; </span><span class="s1">: </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">};</span>
        <span class="s3">case </span><span class="s1">base.type === </span><span class="s2">&quot;UnaryExpression&quot; </span><span class="s1">&amp;&amp; base.operator === </span><span class="s2">&quot;!&quot; </span><span class="s1">&amp;&amp; isReference(base.argument):</span>
            <span class="s3">return </span><span class="s1">{ reference: base.argument, operator: </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">};</span>
        <span class="s3">case </span><span class="s1">isBooleanCast(base, scope) &amp;&amp; isReference(base.arguments[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s3">return </span><span class="s1">{ reference: base.arguments[</span><span class="s4">0</span><span class="s1">], operator: isNegated ? </span><span class="s2">&quot;||&quot; </span><span class="s1">: </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s1">};</span>
        <span class="s3">case </span><span class="s1">isImplicitNullishComparison(expression, scope):</span>
            <span class="s3">return </span><span class="s1">{ reference: isReference(expression.left) ? expression.left : expression.right, operator: </span><span class="s2">&quot;??&quot; </span><span class="s1">};</span>
        <span class="s3">case </span><span class="s1">isExplicitNullishComparison(expression, scope):</span>
            <span class="s3">return </span><span class="s1">{ reference: isReference(expression.left.left) ? expression.left.left : expression.left.right, operator: </span><span class="s2">&quot;??&quot; </span><span class="s1">};</span>
        <span class="s3">default</span><span class="s1">: </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns true iff the node is inside a with block 
 * @param {ASTNode} node Node to check 
 * @returns {boolean} True iff passed node is inside a with block 
 */</span>
<span class="s3">function </span><span class="s1">isInsideWithBlock(node) {</span>
    <span class="s3">if </span><span class="s1">(node.type === </span><span class="s2">&quot;Program&quot;</span><span class="s1">) {</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">node.parent.type === </span><span class="s2">&quot;WithStatement&quot; </span><span class="s1">&amp;&amp; node.parent.body === node ? </span><span class="s3">true </span><span class="s1">: isInsideWithBlock(node.parent);</span>
<span class="s1">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">/** @type {import('../shared/types').Rule} */</span>
<span class="s1">module.exports = {</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s2">&quot;suggestion&quot;</span><span class="s1">,</span>

        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s2">&quot;Require or disallow logical assignment operator shorthand&quot;</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">url: </span><span class="s2">&quot;https://eslint.org/docs/latest/rules/logical-assignment-operators&quot;</span>
        <span class="s1">},</span>

        <span class="s1">schema: {</span>
            <span class="s1">type: </span><span class="s2">&quot;array&quot;</span><span class="s1">,</span>
            <span class="s1">oneOf: [{</span>
                <span class="s1">items: [</span>
                    <span class="s1">{ const: </span><span class="s2">&quot;always&quot; </span><span class="s1">},</span>
                    <span class="s1">{</span>
                        <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                        <span class="s1">properties: {</span>
                            <span class="s1">enforceForIfStatements: {</span>
                                <span class="s1">type: </span><span class="s2">&quot;boolean&quot;</span>
                            <span class="s1">}</span>
                        <span class="s1">},</span>
                        <span class="s1">additionalProperties: </span><span class="s3">false</span>
                    <span class="s1">}</span>
                <span class="s1">],</span>
                <span class="s1">minItems: </span><span class="s4">0</span><span class="s1">, </span><span class="s0">// 0 for allowing passing no options</span>
                <span class="s1">maxItems: </span><span class="s4">2</span>
            <span class="s1">}, {</span>
                <span class="s1">items: [{ const: </span><span class="s2">&quot;never&quot; </span><span class="s1">}],</span>
                <span class="s1">minItems: </span><span class="s4">1</span><span class="s1">,</span>
                <span class="s1">maxItems: </span><span class="s4">1</span>
            <span class="s1">}]</span>
        <span class="s1">},</span>
        <span class="s1">fixable: </span><span class="s2">&quot;code&quot;</span><span class="s1">,</span>
        <span class="s1">hasSuggestions: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">assignment: </span><span class="s2">&quot;Assignment (=) can be replaced with operator assignment ({{operator}}).&quot;</span><span class="s1">,</span>
            <span class="s1">useLogicalOperator: </span><span class="s2">&quot;Convert this assignment to use the operator {{ operator }}.&quot;</span><span class="s1">,</span>
            <span class="s1">logical: </span><span class="s2">&quot;Logical expression can be replaced with an assignment ({{ operator }}).&quot;</span><span class="s1">,</span>
            <span class="s1">convertLogical: </span><span class="s2">&quot;Replace this logical expression with an assignment with the operator {{ operator }}.&quot;</span><span class="s1">,</span>
            <span class="s3">if</span><span class="s1">: </span><span class="s2">&quot;'if' statement can be replaced with a logical operator assignment with operator {{ operator }}.&quot;</span><span class="s1">,</span>
            <span class="s1">convertIf: </span><span class="s2">&quot;Replace this 'if' statement with a logical assignment with operator {{ operator }}.&quot;</span><span class="s1">,</span>
            <span class="s1">unexpected: </span><span class="s2">&quot;Unexpected logical operator assignment ({{operator}}) shorthand.&quot;</span><span class="s1">,</span>
            <span class="s1">separate: </span><span class="s2">&quot;Separate the logical assignment into an assignment with a logical operator.&quot;</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">create(context) {</span>
        <span class="s1">const mode = context.options[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">&quot;never&quot; </span><span class="s1">? </span><span class="s2">&quot;never&quot; </span><span class="s1">: </span><span class="s2">&quot;always&quot;</span><span class="s1">;</span>
        <span class="s1">const checkIf = mode === </span><span class="s2">&quot;always&quot; </span><span class="s1">&amp;&amp; context.options.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; context.options[</span><span class="s4">1</span><span class="s1">].enforceForIfStatements;</span>
        <span class="s1">const sourceCode = context.sourceCode;</span>
        <span class="s1">const isStrict = sourceCode.getScope(sourceCode.ast).isStrict;</span>

        <span class="s0">/** 
         * Returns false if the access could be a getter 
         * @param {ASTNode} node Assignment expression 
         * @returns {boolean} True iff the fix is safe 
         */</span>
        <span class="s3">function </span><span class="s1">cannotBeGetter(node) {</span>
            <span class="s3">return </span><span class="s1">node.type === </span><span class="s2">&quot;Identifier&quot; </span><span class="s1">&amp;&amp;</span>
                   <span class="s1">(isStrict || !isInsideWithBlock(node));</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check whether only a single property is accessed 
         * @param {ASTNode} node reference 
         * @returns {boolean} True iff a single property is accessed 
         */</span>
        <span class="s3">function </span><span class="s1">accessesSingleProperty(node) {</span>
            <span class="s3">if </span><span class="s1">(!isStrict &amp;&amp; isInsideWithBlock(node)) {</span>
                <span class="s3">return </span><span class="s1">node.type === </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">node.type === </span><span class="s2">&quot;MemberExpression&quot; </span><span class="s1">&amp;&amp;</span>
                   <span class="s1">baseTypes.has(node.object.type) &amp;&amp;</span>
                   <span class="s1">(!node.computed || (node.property.type !== </span><span class="s2">&quot;MemberExpression&quot; </span><span class="s1">&amp;&amp; node.property.type !== </span><span class="s2">&quot;ChainExpression&quot;</span><span class="s1">));</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Adds a fixer or suggestion whether on the fix is safe. 
         * @param {{ messageId: string, node: ASTNode }} descriptor Report descriptor without fix or suggest 
         * @param {{ messageId: string, fix: Function }} suggestion Adds the fix or the whole suggestion as only element in &quot;suggest&quot; to suggestion 
         * @param {boolean} shouldBeFixed Fix iff the condition is true 
         * @returns {Object} Descriptor with either an added fix or suggestion 
         */</span>
        <span class="s3">function </span><span class="s1">createConditionalFixer(descriptor, suggestion, shouldBeFixed) {</span>
            <span class="s3">if </span><span class="s1">(shouldBeFixed) {</span>
                <span class="s3">return </span><span class="s1">{</span>
                    <span class="s1">...descriptor,</span>
                    <span class="s1">fix: suggestion.fix</span>
                <span class="s1">};</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">{</span>
                <span class="s1">...descriptor,</span>
                <span class="s1">suggest: [suggestion]</span>
            <span class="s1">};</span>
        <span class="s1">}</span>


        <span class="s0">/** 
         * Returns the operator token for assignments and binary expressions 
         * @param {ASTNode} node AssignmentExpression or BinaryExpression 
         * @returns {import('eslint').AST.Token} Operator token between the left and right expression 
         */</span>
        <span class="s3">function </span><span class="s1">getOperatorToken(node) {</span>
            <span class="s3">return </span><span class="s1">sourceCode.getFirstTokenBetween(node.left, node.right, token =&gt; token.value === node.operator);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(mode === </span><span class="s2">&quot;never&quot;</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">{</span>

                <span class="s0">// foo ||= bar</span>
                <span class="s2">&quot;AssignmentExpression&quot;</span><span class="s1">(assignment) {</span>
                    <span class="s3">if </span><span class="s1">(!astUtils.isLogicalAssignmentOperator(assignment.operator)) {</span>
                        <span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">}</span>

                    <span class="s1">const descriptor = {</span>
                        <span class="s1">messageId: </span><span class="s2">&quot;unexpected&quot;</span><span class="s1">,</span>
                        <span class="s1">node: assignment,</span>
                        <span class="s1">data: { operator: assignment.operator }</span>
                    <span class="s1">};</span>
                    <span class="s1">const suggestion = {</span>
                        <span class="s1">messageId: </span><span class="s2">&quot;separate&quot;</span><span class="s1">,</span>
                        <span class="s1">*fix(ruleFixer) {</span>
                            <span class="s3">if </span><span class="s1">(sourceCode.getCommentsInside(assignment).length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                                <span class="s3">return</span><span class="s1">;</span>
                            <span class="s1">}</span>

                            <span class="s1">const operatorToken = getOperatorToken(assignment);</span>

                            <span class="s0">// -&gt; foo = bar</span>
                            <span class="s1">yield ruleFixer.replaceText(operatorToken, </span><span class="s2">&quot;=&quot;</span><span class="s1">);</span>

                            <span class="s1">const assignmentText = sourceCode.getText(assignment.left);</span>
                            <span class="s1">const operator = assignment.operator.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

                            <span class="s0">// -&gt; foo = foo || bar</span>
                            <span class="s1">yield ruleFixer.insertTextAfter(operatorToken, ` ${assignmentText} ${operator}`);</span>

                            <span class="s1">const precedence = astUtils.getPrecedence(assignment.right) &lt;= astUtils.getPrecedence({ type: </span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s1">, operator });</span>

                            <span class="s0">// ?? and || / &amp;&amp; cannot be mixed but have same precedence</span>
                            <span class="s1">const mixed = assignment.operator === </span><span class="s2">&quot;??=&quot; </span><span class="s1">&amp;&amp; astUtils.isLogicalExpression(assignment.right);</span>

                            <span class="s3">if </span><span class="s1">(!astUtils.isParenthesised(sourceCode, assignment.right) &amp;&amp; (precedence || mixed)) {</span>

                                <span class="s0">// -&gt; foo = foo || (bar)</span>
                                <span class="s1">yield ruleFixer.insertTextBefore(assignment.right, </span><span class="s2">&quot;(&quot;</span><span class="s1">);</span>
                                <span class="s1">yield ruleFixer.insertTextAfter(assignment.right, </span><span class="s2">&quot;)&quot;</span><span class="s1">);</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">};</span>

                    <span class="s1">context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">{</span>

            <span class="s0">// foo = foo || bar</span>
            <span class="s2">&quot;AssignmentExpression[operator='='][right.type='LogicalExpression']&quot;</span><span class="s1">(assignment) {</span>
                <span class="s3">if </span><span class="s1">(!astUtils.isSameReference(assignment.left, assignment.right.left)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">const descriptor = {</span>
                    <span class="s1">messageId: </span><span class="s2">&quot;assignment&quot;</span><span class="s1">,</span>
                    <span class="s1">node: assignment,</span>
                    <span class="s1">data: { operator: `${assignment.right.operator}=` }</span>
                <span class="s1">};</span>
                <span class="s1">const suggestion = {</span>
                    <span class="s1">messageId: </span><span class="s2">&quot;useLogicalOperator&quot;</span><span class="s1">,</span>
                    <span class="s1">data: { operator: `${assignment.right.operator}=` },</span>
                    <span class="s1">*fix(ruleFixer) {</span>
                        <span class="s3">if </span><span class="s1">(sourceCode.getCommentsInside(assignment).length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                            <span class="s3">return</span><span class="s1">;</span>
                        <span class="s1">}</span>

                        <span class="s0">// No need for parenthesis around the assignment based on precedence as the precedence stays the same even with changed operator</span>
                        <span class="s1">const assignmentOperatorToken = getOperatorToken(assignment);</span>

                        <span class="s0">// -&gt; foo ||= foo || bar</span>
                        <span class="s1">yield ruleFixer.insertTextBefore(assignmentOperatorToken, assignment.right.operator);</span>

                        <span class="s0">// -&gt; foo ||= bar</span>
                        <span class="s1">const logicalOperatorToken = getOperatorToken(assignment.right);</span>
                        <span class="s1">const firstRightOperandToken = sourceCode.getTokenAfter(logicalOperatorToken);</span>

                        <span class="s1">yield ruleFixer.removeRange([assignment.right.range[</span><span class="s4">0</span><span class="s1">], firstRightOperandToken.range[</span><span class="s4">0</span><span class="s1">]]);</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>

                <span class="s1">context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));</span>
            <span class="s1">},</span>

            <span class="s0">// foo || (foo = bar)</span>
            <span class="s2">'LogicalExpression[right.type=&quot;AssignmentExpression&quot;][right.operator=&quot;=&quot;]'</span><span class="s1">(logical) {</span>

                <span class="s0">// Right side has to be parenthesized, otherwise would be parsed as (foo || foo) = bar which is illegal</span>
                <span class="s3">if </span><span class="s1">(isReference(logical.left) &amp;&amp; astUtils.isSameReference(logical.left, logical.right.left)) {</span>
                    <span class="s1">const descriptor = {</span>
                        <span class="s1">messageId: </span><span class="s2">&quot;logical&quot;</span><span class="s1">,</span>
                        <span class="s1">node: logical,</span>
                        <span class="s1">data: { operator: `${logical.operator}=` }</span>
                    <span class="s1">};</span>
                    <span class="s1">const suggestion = {</span>
                        <span class="s1">messageId: </span><span class="s2">&quot;convertLogical&quot;</span><span class="s1">,</span>
                        <span class="s1">data: { operator: `${logical.operator}=` },</span>
                        <span class="s1">*fix(ruleFixer) {</span>
                            <span class="s3">if </span><span class="s1">(sourceCode.getCommentsInside(logical).length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                                <span class="s3">return</span><span class="s1">;</span>
                            <span class="s1">}</span>

                            <span class="s1">const parentPrecedence = astUtils.getPrecedence(logical.parent);</span>
                            <span class="s1">const requiresOuterParenthesis = logical.parent.type !== </span><span class="s2">&quot;ExpressionStatement&quot; </span><span class="s1">&amp;&amp; (</span>
                                <span class="s1">parentPrecedence === -</span><span class="s4">1 </span><span class="s1">||</span>
                                <span class="s1">astUtils.getPrecedence({ type: </span><span class="s2">&quot;AssignmentExpression&quot; </span><span class="s1">}) &lt; parentPrecedence</span>
                            <span class="s1">);</span>

                            <span class="s3">if </span><span class="s1">(!astUtils.isParenthesised(sourceCode, logical) &amp;&amp; requiresOuterParenthesis) {</span>
                                <span class="s1">yield ruleFixer.insertTextBefore(logical, </span><span class="s2">&quot;(&quot;</span><span class="s1">);</span>
                                <span class="s1">yield ruleFixer.insertTextAfter(logical, </span><span class="s2">&quot;)&quot;</span><span class="s1">);</span>
                            <span class="s1">}</span>

                            <span class="s0">// Also removes all opening parenthesis</span>
                            <span class="s1">yield ruleFixer.removeRange([logical.range[</span><span class="s4">0</span><span class="s1">], logical.right.range[</span><span class="s4">0</span><span class="s1">]]); </span><span class="s0">// -&gt; foo = bar)</span>

                            <span class="s0">// Also removes all ending parenthesis</span>
                            <span class="s1">yield ruleFixer.removeRange([logical.right.range[</span><span class="s4">1</span><span class="s1">], logical.range[</span><span class="s4">1</span><span class="s1">]]); </span><span class="s0">// -&gt; foo = bar</span>

                            <span class="s1">const operatorToken = getOperatorToken(logical.right);</span>

                            <span class="s1">yield ruleFixer.insertTextBefore(operatorToken, logical.operator); </span><span class="s0">// -&gt; foo ||= bar</span>
                        <span class="s1">}</span>
                    <span class="s1">};</span>
                    <span class="s1">const fix = cannotBeGetter(logical.left) || accessesSingleProperty(logical.left);</span>

                    <span class="s1">context.report(createConditionalFixer(descriptor, suggestion, fix));</span>
                <span class="s1">}</span>
            <span class="s1">},</span>

            <span class="s0">// if (foo) foo = bar</span>
            <span class="s2">&quot;IfStatement[alternate=null]&quot;</span><span class="s1">(ifNode) {</span>
                <span class="s3">if </span><span class="s1">(!checkIf) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">const hasBody = ifNode.consequent.type === </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s1">;</span>

                <span class="s3">if </span><span class="s1">(hasBody &amp;&amp; ifNode.consequent.body.length !== </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">const body = hasBody ? ifNode.consequent.body[</span><span class="s4">0</span><span class="s1">] : ifNode.consequent;</span>
                <span class="s1">const scope = sourceCode.getScope(ifNode);</span>
                <span class="s1">const existence = getExistence(ifNode.test, scope);</span>

                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">body.type === </span><span class="s2">&quot;ExpressionStatement&quot; </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">body.expression.type === </span><span class="s2">&quot;AssignmentExpression&quot; </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">body.expression.operator === </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">existence !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">astUtils.isSameReference(existence.reference, body.expression.left)</span>
                <span class="s1">) {</span>
                    <span class="s1">const descriptor = {</span>
                        <span class="s1">messageId: </span><span class="s2">&quot;if&quot;</span><span class="s1">,</span>
                        <span class="s1">node: ifNode,</span>
                        <span class="s1">data: { operator: `${existence.operator}=` }</span>
                    <span class="s1">};</span>
                    <span class="s1">const suggestion = {</span>
                        <span class="s1">messageId: </span><span class="s2">&quot;convertIf&quot;</span><span class="s1">,</span>
                        <span class="s1">data: { operator: `${existence.operator}=` },</span>
                        <span class="s1">*fix(ruleFixer) {</span>
                            <span class="s3">if </span><span class="s1">(sourceCode.getCommentsInside(ifNode).length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                                <span class="s3">return</span><span class="s1">;</span>
                            <span class="s1">}</span>

                            <span class="s1">const firstBodyToken = sourceCode.getFirstToken(body);</span>
                            <span class="s1">const prevToken = sourceCode.getTokenBefore(ifNode);</span>

                            <span class="s3">if </span><span class="s1">(</span>
                                <span class="s1">prevToken !== </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">prevToken.value !== </span><span class="s2">&quot;;&quot; </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">prevToken.value !== </span><span class="s2">&quot;{&quot; </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">firstBodyToken.type !== </span><span class="s2">&quot;Identifier&quot; </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">firstBodyToken.type !== </span><span class="s2">&quot;Keyword&quot;</span>
                            <span class="s1">) {</span>

                                <span class="s0">// Do not fix if the fixed statement could be part of the previous statement (eg. fn() if (a == null) (a) = b --&gt; fn()(a) ??= b)</span>
                                <span class="s3">return</span><span class="s1">;</span>
                            <span class="s1">}</span>


                            <span class="s1">const operatorToken = getOperatorToken(body.expression);</span>

                            <span class="s1">yield ruleFixer.insertTextBefore(operatorToken, existence.operator); </span><span class="s0">// -&gt; if (foo) foo ||= bar</span>

                            <span class="s1">yield ruleFixer.removeRange([ifNode.range[</span><span class="s4">0</span><span class="s1">], body.range[</span><span class="s4">0</span><span class="s1">]]); </span><span class="s0">// -&gt; foo ||= bar</span>

                            <span class="s1">yield ruleFixer.removeRange([body.range[</span><span class="s4">1</span><span class="s1">], ifNode.range[</span><span class="s4">1</span><span class="s1">]]); </span><span class="s0">// -&gt; foo ||= bar, only present if &quot;if&quot; had a body</span>

                            <span class="s1">const nextToken = sourceCode.getTokenAfter(body.expression);</span>

                            <span class="s3">if </span><span class="s1">(hasBody &amp;&amp; (nextToken !== </span><span class="s3">null </span><span class="s1">&amp;&amp; nextToken.value !== </span><span class="s2">&quot;;&quot;</span><span class="s1">)) {</span>
                                <span class="s1">yield ruleFixer.insertTextAfter(ifNode, </span><span class="s2">&quot;;&quot;</span><span class="s1">);</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">};</span>
                    <span class="s1">const shouldBeFixed = cannotBeGetter(existence.reference) ||</span>
                                          <span class="s1">(ifNode.test.type !== </span><span class="s2">&quot;LogicalExpression&quot; </span><span class="s1">&amp;&amp; accessesSingleProperty(existence.reference));</span>

                    <span class="s1">context.report(createConditionalFixer(descriptor, suggestion, shouldBeFixed));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">};</span>
</pre>
</body>
</html>
<html>
<head>
<title>Yoga.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #cc7832;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Yoga.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#include </span><span class="s3">&quot;Yoga.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;log.h&quot;</span>
<span class="s2">#include </span><span class="s3">&lt;float.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;string.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;algorithm&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;atomic&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;memory&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;Utils.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;YGNode.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;YGNodePrint.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;Yoga-internal.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;event/event.h&quot;</span>
<span class="s2">#ifdef </span><span class="s1">_MSC_VER</span>
<span class="s2">#include </span><span class="s3">&lt;float.h&gt;</span>

<span class="s0">/* define fmaxf if &lt; VC12 */</span>
<span class="s2">#if </span><span class="s1">_MSC_VER &lt; </span><span class="s4">1800</span>
<span class="s5">__forceinline const float </span><span class="s1">fmaxf(</span><span class="s5">const float </span><span class="s1">a</span><span class="s5">, const float </span><span class="s1">b) {</span>
  <span class="s5">return </span><span class="s1">(a &gt; b) ? a : b</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s2">#endif</span>

<span class="s5">using namespace </span><span class="s1">facebook::yoga</span><span class="s5">;</span>
<span class="s5">using </span><span class="s1">detail::Log</span><span class="s5">;</span>

<span class="s2">#ifdef </span><span class="s1">ANDROID</span>
<span class="s5">static int </span><span class="s1">YGAndroidLog(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGLogLevel level</span><span class="s5">,</span>
    <span class="s5">const char</span><span class="s1">* format</span><span class="s5">,</span>
    <span class="s1">va_list args)</span><span class="s5">;</span>
<span class="s2">#else</span>
<span class="s5">static int </span><span class="s1">YGDefaultLog(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGLogLevel level</span><span class="s5">,</span>
    <span class="s5">const char</span><span class="s1">* format</span><span class="s5">,</span>
    <span class="s1">va_list args)</span><span class="s5">;</span>
<span class="s2">#endif</span>

<span class="s2">#ifdef </span><span class="s1">ANDROID</span>
<span class="s2">#include </span><span class="s3">&lt;android/log.h&gt;</span>
<span class="s5">static int </span><span class="s1">YGAndroidLog(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGLogLevel level</span><span class="s5">,</span>
    <span class="s5">const char</span><span class="s1">* format</span><span class="s5">,</span>
    <span class="s1">va_list args) {</span>
  <span class="s5">int </span><span class="s1">androidLevel = YGLogLevelDebug</span><span class="s5">;</span>
  <span class="s5">switch </span><span class="s1">(level) {</span>
    <span class="s5">case </span><span class="s1">YGLogLevelFatal:</span>
      <span class="s1">androidLevel = ANDROID_LOG_FATAL</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">YGLogLevelError:</span>
      <span class="s1">androidLevel = ANDROID_LOG_ERROR</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">YGLogLevelWarn:</span>
      <span class="s1">androidLevel = ANDROID_LOG_WARN</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">YGLogLevelInfo:</span>
      <span class="s1">androidLevel = ANDROID_LOG_INFO</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">YGLogLevelDebug:</span>
      <span class="s1">androidLevel = ANDROID_LOG_DEBUG</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">YGLogLevelVerbose:</span>
      <span class="s1">androidLevel = ANDROID_LOG_VERBOSE</span><span class="s5">;</span>
      <span class="s5">break;</span>
  <span class="s1">}</span>
  <span class="s5">const int </span><span class="s1">result = __android_log_vprint(androidLevel</span><span class="s5">, </span><span class="s3">&quot;yoga&quot;</span><span class="s5">, </span><span class="s1">format</span><span class="s5">, </span><span class="s1">args)</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">result</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s2">#else</span>
<span class="s2">#define </span><span class="s1">YG_UNUSED(x) (</span><span class="s5">void</span><span class="s1">) (x)</span><span class="s5">;</span>

<span class="s5">static int </span><span class="s1">YGDefaultLog(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGLogLevel level</span><span class="s5">,</span>
    <span class="s5">const char</span><span class="s1">* format</span><span class="s5">,</span>
    <span class="s1">va_list args) {</span>
  <span class="s1">YG_UNUSED(config)</span><span class="s5">;</span>
  <span class="s1">YG_UNUSED(node)</span><span class="s5">;</span>
  <span class="s5">switch </span><span class="s1">(level) {</span>
    <span class="s5">case </span><span class="s1">YGLogLevelError:</span>
    <span class="s5">case </span><span class="s1">YGLogLevelFatal:</span>
      <span class="s5">return </span><span class="s1">vfprintf(stderr</span><span class="s5">, </span><span class="s1">format</span><span class="s5">, </span><span class="s1">args)</span><span class="s5">;</span>
    <span class="s5">case </span><span class="s1">YGLogLevelWarn:</span>
    <span class="s5">case </span><span class="s1">YGLogLevelInfo:</span>
    <span class="s5">case </span><span class="s1">YGLogLevelDebug:</span>
    <span class="s5">case </span><span class="s1">YGLogLevelVerbose:</span>
    <span class="s5">default</span><span class="s1">:</span>
      <span class="s5">return </span><span class="s1">vprintf(format</span><span class="s5">, </span><span class="s1">args)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#undef </span><span class="s1">YG_UNUSED</span>
<span class="s2">#endif</span>

<span class="s5">static inline bool </span><span class="s1">YGDoubleIsUndefined(</span><span class="s5">const double </span><span class="s1">value) {</span>
  <span class="s5">return </span><span class="s1">facebook::yoga::isUndefined(value)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGFloatIsUndefined(</span><span class="s5">const float </span><span class="s1">value) {</span>
  <span class="s5">return </span><span class="s1">facebook::yoga::isUndefined(value)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void</span><span class="s1">* YGNodeGetContext(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getContext()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetContext(YGNodeRef node</span><span class="s5">, void</span><span class="s1">* context) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;setContext(context)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGNodeHasMeasureFunc(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;hasMeasureFunc()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetMeasureFunc(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGMeasureFunc measureFunc) {</span>
  <span class="s1">node-&gt;setMeasureFunc(measureFunc)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGNodeHasBaselineFunc(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;hasBaselineFunc()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetBaselineFunc(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGBaselineFunc baselineFunc) {</span>
  <span class="s1">node-&gt;setBaselineFunc(baselineFunc)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGDirtiedFunc YGNodeGetDirtiedFunc(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getDirtied()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetDirtiedFunc(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGDirtiedFunc dirtiedFunc) {</span>
  <span class="s1">node-&gt;setDirtiedFunc(dirtiedFunc)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetPrintFunc(YGNodeRef node</span><span class="s5">, </span><span class="s1">YGPrintFunc printFunc) {</span>
  <span class="s1">node-&gt;setPrintFunc(printFunc)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGNodeGetHasNewLayout(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getHasNewLayout()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetPrintTreeFlag(YGConfigRef config</span><span class="s5">, bool </span><span class="s1">enabled) {</span>
  <span class="s1">config-&gt;printTree = enabled</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetHasNewLayout(YGNodeRef node</span><span class="s5">, bool </span><span class="s1">hasNewLayout) {</span>
  <span class="s1">node-&gt;setHasNewLayout(hasNewLayout)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGNodeType YGNodeGetNodeType(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getNodeType()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetNodeType(YGNodeRef node</span><span class="s5">, </span><span class="s1">YGNodeType nodeType) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;setNodeType(nodeType)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGNodeIsDirty(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;isDirty()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeMarkDirtyAndPropogateToDescendants(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;markDirtyAndPropogateDownwards()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">int32_t gConfigInstanceCount = </span><span class="s4">0</span><span class="s5">;</span>

<span class="s1">YOGA_EXPORT WIN_EXPORT YGNodeRef YGNodeNewWithConfig(</span><span class="s5">const </span><span class="s1">YGConfigRef config) {</span>
  <span class="s5">const </span><span class="s1">YGNodeRef node = </span><span class="s5">new </span><span class="s1">YGNode{config}</span><span class="s5">;</span>
  <span class="s1">YGAssert(config != </span><span class="s5">nullptr, </span><span class="s3">&quot;Tried to construct YGNode with null config&quot;</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">YGAssertWithConfig(</span>
      <span class="s1">config</span><span class="s5">, </span><span class="s1">node != </span><span class="s5">nullptr, </span><span class="s3">&quot;Could not allocate memory for node&quot;</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">Event::publish&lt;Event::NodeAllocation&gt;(node</span><span class="s5">, </span><span class="s1">{config})</span><span class="s5">;</span>

  <span class="s5">return </span><span class="s1">node</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGConfigRef YGConfigGetDefault() {</span>
  <span class="s5">static </span><span class="s1">YGConfigRef defaultConfig = YGConfigNew()</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">defaultConfig</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGNodeRef YGNodeNew(</span><span class="s5">void</span><span class="s1">) {</span>
  <span class="s5">return </span><span class="s1">YGNodeNewWithConfig(YGConfigGetDefault())</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGNodeRef YGNodeClone(YGNodeRef oldNode) {</span>
  <span class="s1">YGNodeRef node = </span><span class="s5">new </span><span class="s1">YGNode(*oldNode)</span><span class="s5">;</span>
  <span class="s1">YGAssertWithConfig(</span>
      <span class="s1">oldNode-&gt;getConfig()</span><span class="s5">,</span>
      <span class="s1">node != </span><span class="s5">nullptr,</span>
      <span class="s3">&quot;Could not allocate memory for node&quot;</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">Event::publish&lt;Event::NodeAllocation&gt;(node</span><span class="s5">, </span><span class="s1">{node-&gt;getConfig()})</span><span class="s5">;</span>
  <span class="s1">node-&gt;setOwner(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">node</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeFree(</span><span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s5">if </span><span class="s1">(YGNodeRef owner = node-&gt;getOwner()) {</span>
    <span class="s1">owner-&gt;removeChild(node)</span><span class="s5">;</span>
    <span class="s1">node-&gt;setOwner(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">const </span><span class="s1">uint32_t childCount = YGNodeGetChildCount(node)</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; childCount</span><span class="s5">; </span><span class="s1">i++) {</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child = YGNodeGetChild(node</span><span class="s5">, </span><span class="s1">i)</span><span class="s5">;</span>
    <span class="s1">child-&gt;setOwner(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">node-&gt;clearChildren()</span><span class="s5">;</span>
  <span class="s1">Event::publish&lt;Event::NodeDeallocation&gt;(node</span><span class="s5">, </span><span class="s1">{node-&gt;getConfig()})</span><span class="s5">;</span>
  <span class="s5">delete </span><span class="s1">node</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeFreeRecursiveWithCleanupFunc(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef root</span><span class="s5">,</span>
    <span class="s1">YGNodeCleanupFunc cleanup) {</span>
  <span class="s1">uint32_t skipped = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">while </span><span class="s1">(YGNodeGetChildCount(root) &gt; skipped) {</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child = YGNodeGetChild(root</span><span class="s5">, </span><span class="s1">skipped)</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getOwner() != root) {</span>
      <span class="s0">// Don't free shared nodes that we don't own.</span>
      <span class="s1">skipped += </span><span class="s4">1</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
      <span class="s1">YGNodeRemoveChild(root</span><span class="s5">, </span><span class="s1">child)</span><span class="s5">;</span>
      <span class="s1">YGNodeFreeRecursive(child)</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s5">if </span><span class="s1">(cleanup != </span><span class="s5">nullptr</span><span class="s1">) {</span>
    <span class="s1">cleanup(root)</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">YGNodeFree(root)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeFreeRecursive(</span><span class="s5">const </span><span class="s1">YGNodeRef root) {</span>
  <span class="s5">return </span><span class="s1">YGNodeFreeRecursiveWithCleanupFunc(root</span><span class="s5">, nullptr</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeReset(YGNodeRef node) {</span>
  <span class="s1">node-&gt;reset()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT int32_t YGConfigGetInstanceCount(</span><span class="s5">void</span><span class="s1">) {</span>
  <span class="s5">return </span><span class="s1">gConfigInstanceCount</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGConfigRef YGConfigNew(</span><span class="s5">void</span><span class="s1">) {</span>
<span class="s2">#ifdef </span><span class="s1">ANDROID</span>
  <span class="s5">const </span><span class="s1">YGConfigRef config = </span><span class="s5">new </span><span class="s1">YGConfig(YGAndroidLog)</span><span class="s5">;</span>
<span class="s2">#else</span>
  <span class="s5">const </span><span class="s1">YGConfigRef config = </span><span class="s5">new </span><span class="s1">YGConfig(YGDefaultLog)</span><span class="s5">;</span>
<span class="s2">#endif</span>
  <span class="s1">gConfigInstanceCount++</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">config</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigFree(</span><span class="s5">const </span><span class="s1">YGConfigRef config) {</span>
  <span class="s5">delete </span><span class="s1">config</span><span class="s5">;</span>
  <span class="s1">gConfigInstanceCount--</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">void </span><span class="s1">YGConfigCopy(</span><span class="s5">const </span><span class="s1">YGConfigRef dest</span><span class="s5">, const </span><span class="s1">YGConfigRef src) {</span>
  <span class="s1">memcpy(dest</span><span class="s5">, </span><span class="s1">src</span><span class="s5">, sizeof</span><span class="s1">(YGConfig))</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetIsReferenceBaseline(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">bool </span><span class="s1">isReferenceBaseline) {</span>
  <span class="s5">if </span><span class="s1">(node-&gt;isReferenceBaseline() != isReferenceBaseline) {</span>
    <span class="s1">node-&gt;setIsReferenceBaseline(isReferenceBaseline)</span><span class="s5">;</span>
    <span class="s1">node-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGNodeIsReferenceBaseline(YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;isReferenceBaseline()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeInsertChild(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef owner</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t index) {</span>
  <span class="s1">YGAssertWithNode(</span>
      <span class="s1">owner</span><span class="s5">,</span>
      <span class="s1">child-&gt;getOwner() == </span><span class="s5">nullptr,</span>
      <span class="s3">&quot;Child already has a owner, it must be removed first.&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s1">YGAssertWithNode(</span>
      <span class="s1">owner</span><span class="s5">,</span>
      <span class="s1">!owner-&gt;hasMeasureFunc()</span><span class="s5">,</span>
      <span class="s3">&quot;Cannot add child: Nodes with measure functions cannot have children.&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s1">owner-&gt;insertChild(child</span><span class="s5">, </span><span class="s1">index)</span><span class="s5">;</span>
  <span class="s1">child-&gt;setOwner(owner)</span><span class="s5">;</span>
  <span class="s1">owner-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSwapChild(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef owner</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t index) {</span>
  <span class="s1">owner-&gt;replaceChild(child</span><span class="s5">, </span><span class="s1">index)</span><span class="s5">;</span>
  <span class="s1">child-&gt;setOwner(owner)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeRemoveChild(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef owner</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef excludedChild) {</span>
  <span class="s5">if </span><span class="s1">(YGNodeGetChildCount(owner) == </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">// This is an empty set. Nothing to remove.</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s0">// Children may be shared between parents, which is indicated by not having an</span>
  <span class="s0">// owner. We only want to reset the child completely if it is owned</span>
  <span class="s0">// exclusively by one node.</span>
  <span class="s5">auto </span><span class="s1">childOwner = excludedChild-&gt;getOwner()</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(owner-&gt;removeChild(excludedChild)) {</span>
    <span class="s5">if </span><span class="s1">(owner == childOwner) {</span>
      <span class="s1">excludedChild-&gt;setLayout({})</span><span class="s5">; </span><span class="s0">// layout is no longer valid</span>
      <span class="s1">excludedChild-&gt;setOwner(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">}</span>
    <span class="s1">owner-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeRemoveAllChildren(</span><span class="s5">const </span><span class="s1">YGNodeRef owner) {</span>
  <span class="s5">const </span><span class="s1">uint32_t childCount = YGNodeGetChildCount(owner)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(childCount == </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">// This is an empty set already. Nothing to do.</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>
  <span class="s5">const </span><span class="s1">YGNodeRef firstChild = YGNodeGetChild(owner</span><span class="s5">, </span><span class="s4">0</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(firstChild-&gt;getOwner() == owner) {</span>
    <span class="s0">// If the first child has this node as its owner, we assume that this child</span>
    <span class="s0">// set is unique.</span>
    <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; childCount</span><span class="s5">; </span><span class="s1">i++) {</span>
      <span class="s5">const </span><span class="s1">YGNodeRef oldChild = YGNodeGetChild(owner</span><span class="s5">, </span><span class="s1">i)</span><span class="s5">;</span>
      <span class="s1">oldChild-&gt;setLayout(YGNode().getLayout())</span><span class="s5">; </span><span class="s0">// layout is no longer valid</span>
      <span class="s1">oldChild-&gt;setOwner(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">}</span>
    <span class="s1">owner-&gt;clearChildren()</span><span class="s5">;</span>
    <span class="s1">owner-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>
  <span class="s0">// Otherwise, we are not the owner of the child set. We don't have to do</span>
  <span class="s0">// anything to clear it.</span>
  <span class="s1">owner-&gt;setChildren(YGVector())</span><span class="s5">;</span>
  <span class="s1">owner-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGNodeSetChildrenInternal(</span>
    <span class="s1">YGNodeRef </span><span class="s5">const </span><span class="s1">owner</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">std::vector&lt;YGNodeRef&gt;&amp; children) {</span>
  <span class="s5">if </span><span class="s1">(!owner) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>
  <span class="s5">if </span><span class="s1">(children.size() == </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s5">if </span><span class="s1">(YGNodeGetChildCount(owner) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s5">for </span><span class="s1">(YGNodeRef </span><span class="s5">const </span><span class="s1">child : owner-&gt;getChildren()) {</span>
        <span class="s1">child-&gt;setLayout(YGLayout())</span><span class="s5">;</span>
        <span class="s1">child-&gt;setOwner(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
      <span class="s1">}</span>
      <span class="s1">owner-&gt;setChildren(YGVector())</span><span class="s5">;</span>
      <span class="s1">owner-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s5">if </span><span class="s1">(YGNodeGetChildCount(owner) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s5">for </span><span class="s1">(YGNodeRef </span><span class="s5">const </span><span class="s1">oldChild : owner-&gt;getChildren()) {</span>
        <span class="s0">// Our new children may have nodes in common with the old children. We</span>
        <span class="s0">// don't reset these common nodes.</span>
        <span class="s5">if </span><span class="s1">(std::find(children.begin()</span><span class="s5">, </span><span class="s1">children.end()</span><span class="s5">, </span><span class="s1">oldChild) ==</span>
            <span class="s1">children.end()) {</span>
          <span class="s1">oldChild-&gt;setLayout(YGLayout())</span><span class="s5">;</span>
          <span class="s1">oldChild-&gt;setOwner(</span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">owner-&gt;setChildren(children)</span><span class="s5">;</span>
    <span class="s5">for </span><span class="s1">(YGNodeRef child : children) {</span>
      <span class="s1">child-&gt;setOwner(owner)</span><span class="s5">;</span>
    <span class="s1">}</span>
    <span class="s1">owner-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetChildren(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef owner</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef c[]</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t count) {</span>
  <span class="s5">const </span><span class="s1">YGVector children = {c</span><span class="s5">, </span><span class="s1">c + count}</span><span class="s5">;</span>
  <span class="s1">YGNodeSetChildrenInternal(owner</span><span class="s5">, </span><span class="s1">children)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeSetChildren(</span>
    <span class="s1">YGNodeRef </span><span class="s5">const </span><span class="s1">owner</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">std::vector&lt;YGNodeRef&gt;&amp; children) {</span>
  <span class="s1">YGNodeSetChildrenInternal(owner</span><span class="s5">, </span><span class="s1">children)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGNodeRef</span>
<span class="s1">YGNodeGetChild(</span><span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">, const </span><span class="s1">uint32_t index) {</span>
  <span class="s5">if </span><span class="s1">(index &lt; node-&gt;getChildren().size()) {</span>
    <span class="s5">return </span><span class="s1">node-&gt;getChild(index)</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">return nullptr;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT uint32_t YGNodeGetChildCount(</span><span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s5">return static_cast</span><span class="s1">&lt;uint32_t&gt;(node-&gt;getChildren().size())</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGNodeRef YGNodeGetOwner(</span><span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getOwner()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGNodeRef YGNodeGetParent(</span><span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getOwner()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeMarkDirty(</span><span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s1">YGAssertWithNode(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">node-&gt;hasMeasureFunc()</span><span class="s5">,</span>
      <span class="s3">&quot;Only leaf nodes with custom measure functions&quot;</span>
      <span class="s3">&quot;should manually mark themselves as dirty&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s1">node-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeCopyStyle(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef dstNode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef srcNode) {</span>
  <span class="s5">if </span><span class="s1">(!(dstNode-&gt;getStyle() == srcNode-&gt;getStyle())) {</span>
    <span class="s1">dstNode-&gt;setStyle(srcNode-&gt;getStyle())</span><span class="s5">;</span>
    <span class="s1">dstNode-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">float </span><span class="s1">YGNodeStyleGetFlexGrow(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().flexGrow().isUndefined()</span>
      <span class="s1">? kDefaultFlexGrow</span>
      <span class="s1">: node-&gt;getStyle().flexGrow().unwrap()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">float </span><span class="s1">YGNodeStyleGetFlexShrink(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().flexShrink().isUndefined()</span>
      <span class="s1">? (node-&gt;getConfig()-&gt;useWebDefaults ? kWebDefaultFlexShrink</span>
                                           <span class="s1">: kDefaultFlexShrink)</span>
      <span class="s1">: node-&gt;getStyle().flexShrink().unwrap()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">namespace </span><span class="s1">{</span>

<span class="s5">template </span><span class="s1">&lt;</span><span class="s5">typename </span><span class="s1">T</span><span class="s5">, typename </span><span class="s1">NeedsUpdate</span><span class="s5">, typename </span><span class="s1">Update&gt;</span>
<span class="s5">void </span><span class="s1">updateStyle(</span>
    <span class="s1">YGNode* node</span><span class="s5">,</span>
    <span class="s1">T value</span><span class="s5">,</span>
    <span class="s1">NeedsUpdate&amp;&amp; needsUpdate</span><span class="s5">,</span>
    <span class="s1">Update&amp;&amp; update) {</span>
  <span class="s5">if </span><span class="s1">(needsUpdate(node-&gt;getStyle()</span><span class="s5">, </span><span class="s1">value)) {</span>
    <span class="s1">update(node-&gt;getStyle()</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
    <span class="s1">node-&gt;markDirtyAndPropogate()</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">template </span><span class="s1">&lt;</span><span class="s5">typename </span><span class="s1">Ref</span><span class="s5">, typename </span><span class="s1">T&gt;</span>
<span class="s5">void </span><span class="s1">updateStyle(YGNode* node</span><span class="s5">, </span><span class="s1">Ref (YGStyle::*prop)()</span><span class="s5">, </span><span class="s1">T value) {</span>
  <span class="s1">updateStyle(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">value</span><span class="s5">,</span>
      <span class="s1">[prop](YGStyle&amp; s</span><span class="s5">, </span><span class="s1">T x) { </span><span class="s5">return </span><span class="s1">(s.*prop)() != x</span><span class="s5">; </span><span class="s1">}</span><span class="s5">,</span>
      <span class="s1">[prop](YGStyle&amp; s</span><span class="s5">, </span><span class="s1">T x) { (s.*prop)() = x</span><span class="s5">; </span><span class="s1">})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">template </span><span class="s1">&lt;</span><span class="s5">typename </span><span class="s1">Ref</span><span class="s5">, typename </span><span class="s1">Idx&gt;</span>
<span class="s5">void </span><span class="s1">updateIndexedStyleProp(</span>
    <span class="s1">YGNode* node</span><span class="s5">,</span>
    <span class="s1">Ref (YGStyle::*prop)()</span><span class="s5">,</span>
    <span class="s1">Idx idx</span><span class="s5">,</span>
    <span class="s1">detail::CompactValue value) {</span>
  <span class="s5">using </span><span class="s1">detail::CompactValue</span><span class="s5">;</span>
  <span class="s1">updateStyle(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">value</span><span class="s5">,</span>
      <span class="s1">[idx</span><span class="s5">, </span><span class="s1">prop](YGStyle&amp; s</span><span class="s5">, </span><span class="s1">CompactValue x) { </span><span class="s5">return </span><span class="s1">(s.*prop)()[idx] != x</span><span class="s5">; </span><span class="s1">}</span><span class="s5">,</span>
      <span class="s1">[idx</span><span class="s5">, </span><span class="s1">prop](YGStyle&amp; s</span><span class="s5">, </span><span class="s1">CompactValue x) { (s.*prop)()[idx] = x</span><span class="s5">; </span><span class="s1">})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace</span>

<span class="s0">// MSVC has trouble inferring the return type of pointer to member functions</span>
<span class="s0">// with const and non-const overloads, instead of preferring the non-const</span>
<span class="s0">// overload like clang and GCC. For the purposes of updateStyle(), we can help</span>
<span class="s0">// MSVC by specifying that return type explicitely. In combination with</span>
<span class="s0">// decltype, MSVC will prefer the non-const version.</span>
<span class="s2">#define </span><span class="s1">MSVC_HINT(PROP) </span><span class="s5">decltype</span><span class="s1">(YGStyle{}.PROP())</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetDirection(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection value) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(direction)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::direction</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGDirection YGNodeStyleGetDirection(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().direction()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlexDirection(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection flexDirection) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flexDirection)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flexDirection</span><span class="s5">, </span><span class="s1">flexDirection)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGFlexDirection</span>
<span class="s1">YGNodeStyleGetFlexDirection(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().flexDirection()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetJustifyContent(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGJustify justifyContent) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(justifyContent)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::justifyContent</span><span class="s5">, </span><span class="s1">justifyContent)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGJustify YGNodeStyleGetJustifyContent(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().justifyContent()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetAlignContent(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGAlign alignContent) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(alignContent)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::alignContent</span><span class="s5">, </span><span class="s1">alignContent)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGAlign YGNodeStyleGetAlignContent(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().alignContent()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetAlignItems(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGAlign alignItems) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(alignItems)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::alignItems</span><span class="s5">, </span><span class="s1">alignItems)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGAlign YGNodeStyleGetAlignItems(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().alignItems()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetAlignSelf(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGAlign alignSelf) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(alignSelf)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::alignSelf</span><span class="s5">, </span><span class="s1">alignSelf)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGAlign YGNodeStyleGetAlignSelf(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().alignSelf()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetPositionType(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGPositionType positionType) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(positionType)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::positionType</span><span class="s5">, </span><span class="s1">positionType)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGPositionType</span>
<span class="s1">YGNodeStyleGetPositionType(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().positionType()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlexWrap(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGWrap flexWrap) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flexWrap)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flexWrap</span><span class="s5">, </span><span class="s1">flexWrap)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGWrap YGNodeStyleGetFlexWrap(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().flexWrap()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetOverflow(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGOverflow overflow) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(overflow)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::overflow</span><span class="s5">, </span><span class="s1">overflow)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGOverflow YGNodeStyleGetOverflow(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().overflow()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetDisplay(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDisplay display) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(display)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::display</span><span class="s5">, </span><span class="s1">display)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGDisplay YGNodeStyleGetDisplay(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().display()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// TODO(T26792433): Change the API to accept YGFloatOptional.</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlex(</span><span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">, const float </span><span class="s1">flex) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flex)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flex</span><span class="s5">, </span><span class="s1">YGFloatOptional{flex})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// TODO(T26792433): Change the API to accept YGFloatOptional.</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">float </span><span class="s1">YGNodeStyleGetFlex(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().flex().isUndefined()</span>
      <span class="s1">? YGUndefined</span>
      <span class="s1">: node-&gt;getStyle().flex().unwrap()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// TODO(T26792433): Change the API to accept YGFloatOptional.</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlexGrow(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">flexGrow) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flexGrow)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flexGrow</span><span class="s5">, </span><span class="s1">YGFloatOptional{flexGrow})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// TODO(T26792433): Change the API to accept YGFloatOptional.</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlexShrink(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">flexShrink) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flexShrink)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flexShrink</span><span class="s5">, </span><span class="s1">YGFloatOptional{flexShrink})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetFlexBasis(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s1">YGValue flexBasis = node-&gt;getStyle().flexBasis()</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(flexBasis.unit == YGUnitUndefined || flexBasis.unit == YGUnitAuto) {</span>
    <span class="s0">// TODO(T26792433): Get rid off the use of YGUndefined at client side</span>
    <span class="s1">flexBasis.value = YGUndefined</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">return </span><span class="s1">flexBasis</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlexBasis(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">flexBasis) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(flexBasis)</span><span class="s5">;</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flexBasis)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flexBasis</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlexBasisPercent(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">flexBasisPercent) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(flexBasisPercent)</span><span class="s5">;</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flexBasis)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flexBasis</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetFlexBasisAuto(</span><span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(flexBasis)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::flexBasis</span><span class="s5">, </span><span class="s1">detail::CompactValue::ofAuto())</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetPosition(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGEdge edge</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">points) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(points)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(position)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::position</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetPositionPercent(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGEdge edge</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">percent) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(percent)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(position)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::position</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetPosition(YGNodeConstRef node</span><span class="s5">, </span><span class="s1">YGEdge edge) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().position()[edge]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMargin(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGEdge edge</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">points) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(points)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(margin)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::margin</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMarginPercent(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGEdge edge</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">percent) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(percent)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(margin)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::margin</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMarginAuto(YGNodeRef node</span><span class="s5">, </span><span class="s1">YGEdge edge) {</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(margin)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::margin</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">detail::CompactValue::ofAuto())</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetMargin(YGNodeConstRef node</span><span class="s5">, </span><span class="s1">YGEdge edge) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().margin()[edge]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetPadding(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGEdge edge</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">points) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(points)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(padding)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::padding</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetPaddingPercent(</span>
    <span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGEdge edge</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">percent) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(percent)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(padding)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::padding</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetPadding(YGNodeConstRef node</span><span class="s5">, </span><span class="s1">YGEdge edge) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().padding()[edge]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// TODO(T26792433): Change the API to accept YGFloatOptional.</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetBorder(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGEdge edge</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">border) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(border)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(border)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::border</span><span class="s5">, </span><span class="s1">edge</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">float </span><span class="s1">YGNodeStyleGetBorder(</span>
    <span class="s5">const </span><span class="s1">YGNodeConstRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGEdge edge) {</span>
  <span class="s5">auto </span><span class="s1">border = node-&gt;getStyle().border()[edge]</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(border.isUndefined() || border.isAuto()) {</span>
    <span class="s0">// TODO(T26792433): Rather than returning YGUndefined, change the api to</span>
    <span class="s0">// return YGFloatOptional.</span>
    <span class="s5">return </span><span class="s1">YGUndefined</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">return static_cast</span><span class="s1">&lt;YGValue&gt;(border).value</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetGap(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGGutter gutter</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">gapLength) {</span>
  <span class="s5">auto </span><span class="s1">length = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(gapLength)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(gap)&gt;(node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::gap</span><span class="s5">, </span><span class="s1">gutter</span><span class="s5">, </span><span class="s1">length)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">float </span><span class="s1">YGNodeStyleGetGap(</span>
    <span class="s5">const </span><span class="s1">YGNodeConstRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGGutter gutter) {</span>
  <span class="s5">auto </span><span class="s1">gapLength = node-&gt;getStyle().gap()[gutter]</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(gapLength.isUndefined() || gapLength.isAuto()) {</span>
    <span class="s0">// TODO(T26792433): Rather than returning YGUndefined, change the api to</span>
    <span class="s0">// return YGFloatOptional.</span>
    <span class="s5">return </span><span class="s1">YGUndefined</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">return static_cast</span><span class="s1">&lt;YGValue&gt;(gapLength).value</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// Yoga specific properties, not compatible with flexbox specification</span>

<span class="s0">// TODO(T26792433): Change the API to accept YGFloatOptional.</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">float </span><span class="s1">YGNodeStyleGetAspectRatio(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">const </span><span class="s1">YGFloatOptional op = node-&gt;getStyle().aspectRatio()</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">op.isUndefined() ? YGUndefined : op.unwrap()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// TODO(T26792433): Change the API to accept YGFloatOptional.</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetAspectRatio(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">aspectRatio) {</span>
  <span class="s1">updateStyle&lt;MSVC_HINT(aspectRatio)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::aspectRatio</span><span class="s5">, </span><span class="s1">YGFloatOptional{aspectRatio})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetWidth(YGNodeRef node</span><span class="s5">, float </span><span class="s1">points) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(points)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(dimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::dimensions</span><span class="s5">, </span><span class="s1">YGDimensionWidth</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetWidthPercent(YGNodeRef node</span><span class="s5">, float </span><span class="s1">percent) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(percent)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(dimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::dimensions</span><span class="s5">, </span><span class="s1">YGDimensionWidth</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetWidthAuto(YGNodeRef node) {</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(dimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">&amp;YGStyle::dimensions</span><span class="s5">,</span>
      <span class="s1">YGDimensionWidth</span><span class="s5">,</span>
      <span class="s1">detail::CompactValue::ofAuto())</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetWidth(YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().dimensions()[YGDimensionWidth]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetHeight(YGNodeRef node</span><span class="s5">, float </span><span class="s1">points) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(points)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(dimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::dimensions</span><span class="s5">, </span><span class="s1">YGDimensionHeight</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetHeightPercent(YGNodeRef node</span><span class="s5">, float </span><span class="s1">percent) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(percent)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(dimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::dimensions</span><span class="s5">, </span><span class="s1">YGDimensionHeight</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetHeightAuto(YGNodeRef node) {</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(dimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">&amp;YGStyle::dimensions</span><span class="s5">,</span>
      <span class="s1">YGDimensionHeight</span><span class="s5">,</span>
      <span class="s1">detail::CompactValue::ofAuto())</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetHeight(YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().dimensions()[YGDimensionHeight]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMinWidth(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">minWidth) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(minWidth)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(minDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::minDimensions</span><span class="s5">, </span><span class="s1">YGDimensionWidth</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMinWidthPercent(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">minWidth) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(minWidth)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(minDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::minDimensions</span><span class="s5">, </span><span class="s1">YGDimensionWidth</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetMinWidth(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().minDimensions()[YGDimensionWidth]</span><span class="s5">;</span>
<span class="s1">}</span><span class="s5">;</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMinHeight(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">minHeight) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(minHeight)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(minDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::minDimensions</span><span class="s5">, </span><span class="s1">YGDimensionHeight</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMinHeightPercent(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">minHeight) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(minHeight)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(minDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::minDimensions</span><span class="s5">, </span><span class="s1">YGDimensionHeight</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetMinHeight(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().minDimensions()[YGDimensionHeight]</span><span class="s5">;</span>
<span class="s1">}</span><span class="s5">;</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMaxWidth(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">maxWidth) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(maxWidth)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(maxDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::maxDimensions</span><span class="s5">, </span><span class="s1">YGDimensionWidth</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMaxWidthPercent(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">maxWidth) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(maxWidth)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(maxDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::maxDimensions</span><span class="s5">, </span><span class="s1">YGDimensionWidth</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetMaxWidth(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().maxDimensions()[YGDimensionWidth]</span><span class="s5">;</span>
<span class="s1">}</span><span class="s5">;</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMaxHeight(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">maxHeight) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPoint&gt;(maxHeight)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(maxDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::maxDimensions</span><span class="s5">, </span><span class="s1">YGDimensionHeight</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeStyleSetMaxHeightPercent(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">maxHeight) {</span>
  <span class="s5">auto </span><span class="s1">value = detail::CompactValue::ofMaybe&lt;YGUnitPercent&gt;(maxHeight)</span><span class="s5">;</span>
  <span class="s1">updateIndexedStyleProp&lt;MSVC_HINT(maxDimensions)&gt;(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">&amp;YGStyle::maxDimensions</span><span class="s5">, </span><span class="s1">YGDimensionHeight</span><span class="s5">, </span><span class="s1">value)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s1">YOGA_EXPORT YGValue YGNodeStyleGetMaxHeight(</span><span class="s5">const </span><span class="s1">YGNodeConstRef node) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getStyle().maxDimensions()[YGDimensionHeight]</span><span class="s5">;</span>
<span class="s1">}</span><span class="s5">;</span>

<span class="s2">#define </span><span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(type</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">instanceName)   \ 
  YOGA_EXPORT type YGNodeLayoutGet##name(</span><span class="s5">const </span><span class="s1">YGNodeRef node) { \ 
    </span><span class="s5">return </span><span class="s1">node-&gt;getLayout().instanceName</span><span class="s5">;                       </span><span class="s1">\ 
  }</span>

<span class="s2">#define </span><span class="s1">YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(type</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">instanceName) \ 
  YOGA_EXPORT type YGNodeLayoutGet##name(                               \ 
      </span><span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">, const </span><span class="s1">YGEdge edge) {                        \ 
    YGAssertWithNode(                                                   \ 
        node</span><span class="s5">,                                                           </span><span class="s1">\ 
        edge &lt;= YGEdgeEnd</span><span class="s5">,                                              </span><span class="s1">\ 
        </span><span class="s3">&quot;Cannot get layout properties of multi-edge shorthands&quot;</span><span class="s1">)</span><span class="s5">;       </span><span class="s1">\ 
                                                                        \ 
    </span><span class="s5">if </span><span class="s1">(edge == YGEdgeStart) {                                          \ 
      </span><span class="s5">if </span><span class="s1">(node-&gt;getLayout().direction() == YGDirectionRTL) {            \ 
        </span><span class="s5">return </span><span class="s1">node-&gt;getLayout().instanceName[YGEdgeRight]</span><span class="s5">;             </span><span class="s1">\ 
      } </span><span class="s5">else </span><span class="s1">{                                                          \ 
        </span><span class="s5">return </span><span class="s1">node-&gt;getLayout().instanceName[YGEdgeLeft]</span><span class="s5">;              </span><span class="s1">\ 
      }                                                                 \ 
    }                                                                   \ 
                                                                        \ 
    </span><span class="s5">if </span><span class="s1">(edge == YGEdgeEnd) {                                            \ 
      </span><span class="s5">if </span><span class="s1">(node-&gt;getLayout().direction() == YGDirectionRTL) {            \ 
        </span><span class="s5">return </span><span class="s1">node-&gt;getLayout().instanceName[YGEdgeLeft]</span><span class="s5">;              </span><span class="s1">\ 
      } </span><span class="s5">else </span><span class="s1">{                                                          \ 
        </span><span class="s5">return </span><span class="s1">node-&gt;getLayout().instanceName[YGEdgeRight]</span><span class="s5">;             </span><span class="s1">\ 
      }                                                                 \ 
    }                                                                   \ 
                                                                        \ 
    </span><span class="s5">return </span><span class="s1">node-&gt;getLayout().instanceName[edge]</span><span class="s5">;                        </span><span class="s1">\ 
  }</span>

<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Left</span><span class="s5">, </span><span class="s1">position[YGEdgeLeft])</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Top</span><span class="s5">, </span><span class="s1">position[YGEdgeTop])</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Right</span><span class="s5">, </span><span class="s1">position[YGEdgeRight])</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Bottom</span><span class="s5">, </span><span class="s1">position[YGEdgeBottom])</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Width</span><span class="s5">, </span><span class="s1">dimensions[YGDimensionWidth])</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Height</span><span class="s5">, </span><span class="s1">dimensions[YGDimensionHeight])</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(YGDirection</span><span class="s5">, </span><span class="s1">Direction</span><span class="s5">, </span><span class="s1">direction())</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_PROPERTY_IMPL(</span><span class="s5">bool, </span><span class="s1">HadOverflow</span><span class="s5">, </span><span class="s1">hadOverflow())</span><span class="s5">;</span>

<span class="s1">YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Margin</span><span class="s5">, </span><span class="s1">margin)</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Border</span><span class="s5">, </span><span class="s1">border)</span><span class="s5">;</span>
<span class="s1">YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(</span><span class="s5">float, </span><span class="s1">Padding</span><span class="s5">, </span><span class="s1">padding)</span><span class="s5">;</span>

<span class="s1">std::atomic&lt;uint32_t&gt; gCurrentGenerationCount(</span><span class="s4">0</span><span class="s1">)</span><span class="s5">;</span>

<span class="s5">bool </span><span class="s1">YGLayoutNodeInternal(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection ownerDirection</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMeasureMode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMeasureMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">performLayout</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">LayoutPassReason reason</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount)</span><span class="s5">;</span>

<span class="s2">#ifdef </span><span class="s1">DEBUG</span>
<span class="s5">static void </span><span class="s1">YGNodePrintInternal(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGPrintOptions options) {</span>
  <span class="s1">std::string str</span><span class="s5">;</span>
  <span class="s1">facebook::yoga::YGNodeToString(str</span><span class="s5">, </span><span class="s1">node</span><span class="s5">, </span><span class="s1">options</span><span class="s5">, </span><span class="s4">0</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">Log::log(node</span><span class="s5">, </span><span class="s1">YGLogLevelDebug</span><span class="s5">, nullptr, </span><span class="s1">str.c_str())</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodePrint(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGPrintOptions options) {</span>
  <span class="s1">YGNodePrintInternal(node</span><span class="s5">, </span><span class="s1">options)</span><span class="s5">;</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s5">const </span><span class="s1">std::array&lt;YGEdge</span><span class="s5">, </span><span class="s4">4</span><span class="s1">&gt; leading = {</span>
    <span class="s1">{YGEdgeTop</span><span class="s5">, </span><span class="s1">YGEdgeBottom</span><span class="s5">, </span><span class="s1">YGEdgeLeft</span><span class="s5">, </span><span class="s1">YGEdgeRight}}</span><span class="s5">;</span>

<span class="s5">const </span><span class="s1">std::array&lt;YGEdge</span><span class="s5">, </span><span class="s4">4</span><span class="s1">&gt; trailing = {</span>
    <span class="s1">{YGEdgeBottom</span><span class="s5">, </span><span class="s1">YGEdgeTop</span><span class="s5">, </span><span class="s1">YGEdgeRight</span><span class="s5">, </span><span class="s1">YGEdgeLeft}}</span><span class="s5">;</span>
<span class="s5">static const </span><span class="s1">std::array&lt;YGEdge</span><span class="s5">, </span><span class="s4">4</span><span class="s1">&gt; pos = {{</span>
    <span class="s1">YGEdgeTop</span><span class="s5">,</span>
    <span class="s1">YGEdgeBottom</span><span class="s5">,</span>
    <span class="s1">YGEdgeLeft</span><span class="s5">,</span>
    <span class="s1">YGEdgeRight</span><span class="s5">,</span>
<span class="s1">}}</span><span class="s5">;</span>

<span class="s5">static const </span><span class="s1">std::array&lt;YGDimension</span><span class="s5">, </span><span class="s4">4</span><span class="s1">&gt; dim = {</span>
    <span class="s1">{YGDimensionHeight</span><span class="s5">, </span><span class="s1">YGDimensionHeight</span><span class="s5">, </span><span class="s1">YGDimensionWidth</span><span class="s5">, </span><span class="s1">YGDimensionWidth}}</span><span class="s5">;</span>

<span class="s5">static inline float </span><span class="s1">YGNodePaddingAndBorderForAxis(</span>
    <span class="s5">const </span><span class="s1">YGNodeConstRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection axis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">widthSize) {</span>
  <span class="s5">return </span><span class="s1">(node-&gt;getLeadingPaddingAndBorder(axis</span><span class="s5">, </span><span class="s1">widthSize) +</span>
          <span class="s1">node-&gt;getTrailingPaddingAndBorder(axis</span><span class="s5">, </span><span class="s1">widthSize))</span>
      <span class="s1">.unwrap()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static inline </span><span class="s1">YGAlign YGNodeAlignItem(</span><span class="s5">const </span><span class="s1">YGNode* node</span><span class="s5">, const </span><span class="s1">YGNode* child) {</span>
  <span class="s5">const </span><span class="s1">YGAlign align = child-&gt;getStyle().alignSelf() == YGAlignAuto</span>
      <span class="s1">? node-&gt;getStyle().alignItems()</span>
      <span class="s1">: child-&gt;getStyle().alignSelf()</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(align == YGAlignBaseline &amp;&amp;</span>
      <span class="s1">YGFlexDirectionIsColumn(node-&gt;getStyle().flexDirection())) {</span>
    <span class="s5">return </span><span class="s1">YGAlignFlexStart</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">return </span><span class="s1">align</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static float </span><span class="s1">YGBaseline(</span><span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">, void</span><span class="s1">* layoutContext) {</span>
  <span class="s5">if </span><span class="s1">(node-&gt;hasBaselineFunc()) {</span>

    <span class="s1">Event::publish&lt;Event::NodeBaselineStart&gt;(node)</span><span class="s5">;</span>

    <span class="s5">const float </span><span class="s1">baseline = node-&gt;baseline(</span>
        <span class="s1">node-&gt;getLayout().measuredDimensions[YGDimensionWidth]</span><span class="s5">,</span>
        <span class="s1">node-&gt;getLayout().measuredDimensions[YGDimensionHeight]</span><span class="s5">,</span>
        <span class="s1">layoutContext)</span><span class="s5">;</span>

    <span class="s1">Event::publish&lt;Event::NodeBaselineEnd&gt;(node)</span><span class="s5">;</span>

    <span class="s1">YGAssertWithNode(</span>
        <span class="s1">node</span><span class="s5">,</span>
        <span class="s1">!YGFloatIsUndefined(baseline)</span><span class="s5">,</span>
        <span class="s3">&quot;Expect custom baseline function to not return NaN&quot;</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s5">return </span><span class="s1">baseline</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">YGNodeRef baselineChild = </span><span class="s5">nullptr;</span>
  <span class="s5">const </span><span class="s1">uint32_t childCount = YGNodeGetChildCount(node)</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; childCount</span><span class="s5">; </span><span class="s1">i++) {</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child = YGNodeGetChild(node</span><span class="s5">, </span><span class="s1">i)</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getLineIndex() &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s5">break;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() == YGPositionTypeAbsolute) {</span>
      <span class="s5">continue;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child) == YGAlignBaseline ||</span>
        <span class="s1">child-&gt;isReferenceBaseline()) {</span>
      <span class="s1">baselineChild = child</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(baselineChild == </span><span class="s5">nullptr</span><span class="s1">) {</span>
      <span class="s1">baselineChild = child</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(baselineChild == </span><span class="s5">nullptr</span><span class="s1">) {</span>
    <span class="s5">return </span><span class="s1">node-&gt;getLayout().measuredDimensions[YGDimensionHeight]</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">const float </span><span class="s1">baseline = YGBaseline(baselineChild</span><span class="s5">, </span><span class="s1">layoutContext)</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">baseline + baselineChild-&gt;getLayout().position[YGEdgeTop]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static bool </span><span class="s1">YGIsBaselineLayout(</span><span class="s5">const </span><span class="s1">YGNodeRef node) {</span>
  <span class="s5">if </span><span class="s1">(YGFlexDirectionIsColumn(node-&gt;getStyle().flexDirection())) {</span>
    <span class="s5">return false;</span>
  <span class="s1">}</span>
  <span class="s5">if </span><span class="s1">(node-&gt;getStyle().alignItems() == YGAlignBaseline) {</span>
    <span class="s5">return true;</span>
  <span class="s1">}</span>
  <span class="s5">const </span><span class="s1">uint32_t childCount = YGNodeGetChildCount(node)</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; childCount</span><span class="s5">; </span><span class="s1">i++) {</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child = YGNodeGetChild(node</span><span class="s5">, </span><span class="s1">i)</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() != YGPositionTypeAbsolute &amp;&amp;</span>
        <span class="s1">child-&gt;getStyle().alignSelf() == YGAlignBaseline) {</span>
      <span class="s5">return true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">return false;</span>
<span class="s1">}</span>

<span class="s5">static inline float </span><span class="s1">YGNodeDimWithMargin(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection axis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">widthSize) {</span>
  <span class="s5">return </span><span class="s1">node-&gt;getLayout().measuredDimensions[dim[axis]] +</span>
      <span class="s1">(node-&gt;getLeadingMargin(axis</span><span class="s5">, </span><span class="s1">widthSize) +</span>
       <span class="s1">node-&gt;getTrailingMargin(axis</span><span class="s5">, </span><span class="s1">widthSize))</span>
          <span class="s1">.unwrap()</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static inline bool </span><span class="s1">YGNodeIsStyleDimDefined(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection axis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerSize) {</span>
  <span class="s5">bool </span><span class="s1">isUndefined =</span>
      <span class="s1">YGFloatIsUndefined(node-&gt;getResolvedDimension(dim[axis]).value)</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">!(</span>
      <span class="s1">node-&gt;getResolvedDimension(dim[axis]).unit == YGUnitAuto ||</span>
      <span class="s1">node-&gt;getResolvedDimension(dim[axis]).unit == YGUnitUndefined ||</span>
      <span class="s1">(node-&gt;getResolvedDimension(dim[axis]).unit == YGUnitPoint &amp;&amp;</span>
       <span class="s1">!isUndefined &amp;&amp; node-&gt;getResolvedDimension(dim[axis]).value &lt; </span><span class="s4">0.0f</span><span class="s1">) ||</span>
      <span class="s1">(node-&gt;getResolvedDimension(dim[axis]).unit == YGUnitPercent &amp;&amp;</span>
       <span class="s1">!isUndefined &amp;&amp;</span>
       <span class="s1">(node-&gt;getResolvedDimension(dim[axis]).value &lt; </span><span class="s4">0.0f </span><span class="s1">||</span>
        <span class="s1">YGFloatIsUndefined(ownerSize))))</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static inline bool </span><span class="s1">YGNodeIsLayoutDimDefined(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection axis) {</span>
  <span class="s5">const float </span><span class="s1">value = node-&gt;getLayout().measuredDimensions[dim[axis]]</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">!YGFloatIsUndefined(value) &amp;&amp; value &gt;= </span><span class="s4">0.0f</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static </span><span class="s1">YGFloatOptional YGNodeBoundAxisWithinMinAndMax(</span>
    <span class="s5">const </span><span class="s1">YGNodeConstRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection axis</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFloatOptional value</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">axisSize) {</span>
  <span class="s1">YGFloatOptional min</span><span class="s5">;</span>
  <span class="s1">YGFloatOptional max</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(YGFlexDirectionIsColumn(axis)) {</span>
    <span class="s1">min = YGResolveValue(</span>
        <span class="s1">node-&gt;getStyle().minDimensions()[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">axisSize)</span><span class="s5">;</span>
    <span class="s1">max = YGResolveValue(</span>
        <span class="s1">node-&gt;getStyle().maxDimensions()[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">axisSize)</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(YGFlexDirectionIsRow(axis)) {</span>
    <span class="s1">min = YGResolveValue(</span>
        <span class="s1">node-&gt;getStyle().minDimensions()[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">axisSize)</span><span class="s5">;</span>
    <span class="s1">max = YGResolveValue(</span>
        <span class="s1">node-&gt;getStyle().maxDimensions()[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">axisSize)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(max &gt;= YGFloatOptional{</span><span class="s4">0</span><span class="s1">} &amp;&amp; value &gt; max) {</span>
    <span class="s5">return </span><span class="s1">max</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(min &gt;= YGFloatOptional{</span><span class="s4">0</span><span class="s1">} &amp;&amp; value &lt; min) {</span>
    <span class="s5">return </span><span class="s1">min</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">return </span><span class="s1">value</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// Like YGNodeBoundAxisWithinMinAndMax but also ensures that the value doesn't</span>
<span class="s0">// go below the padding and border amount.</span>
<span class="s5">static inline float </span><span class="s1">YGNodeBoundAxis(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection axis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">value</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">axisSize</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">widthSize) {</span>
  <span class="s5">return </span><span class="s1">YGFloatMax(</span>
      <span class="s1">YGNodeBoundAxisWithinMinAndMax(</span>
          <span class="s1">node</span><span class="s5">, </span><span class="s1">axis</span><span class="s5">, </span><span class="s1">YGFloatOptional{value}</span><span class="s5">, </span><span class="s1">axisSize)</span>
          <span class="s1">.unwrap()</span><span class="s5">,</span>
      <span class="s1">YGNodePaddingAndBorderForAxis(node</span><span class="s5">, </span><span class="s1">axis</span><span class="s5">, </span><span class="s1">widthSize))</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGNodeSetChildTrailingPosition(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection axis) {</span>
  <span class="s5">const float </span><span class="s1">size = child-&gt;getLayout().measuredDimensions[dim[axis]]</span><span class="s5">;</span>
  <span class="s1">child-&gt;setLayoutPosition(</span>
      <span class="s1">node-&gt;getLayout().measuredDimensions[dim[axis]] - size -</span>
          <span class="s1">child-&gt;getLayout().position[pos[axis]]</span><span class="s5">,</span>
      <span class="s1">trailing[axis])</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGConstrainMaxSizeForMode(</span>
    <span class="s5">const </span><span class="s1">YGNodeConstRef node</span><span class="s5">,</span>
    <span class="s5">const enum </span><span class="s1">YGFlexDirection axis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerAxisSize</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s1">YGMeasureMode* mode</span><span class="s5">,</span>
    <span class="s5">float</span><span class="s1">* size) {</span>
  <span class="s5">const </span><span class="s1">YGFloatOptional maxSize =</span>
      <span class="s1">YGResolveValue(</span>
          <span class="s1">node-&gt;getStyle().maxDimensions()[dim[axis]]</span><span class="s5">, </span><span class="s1">ownerAxisSize) +</span>
      <span class="s1">YGFloatOptional(node-&gt;getMarginForAxis(axis</span><span class="s5">, </span><span class="s1">ownerWidth))</span><span class="s5">;</span>
  <span class="s5">switch </span><span class="s1">(*mode) {</span>
    <span class="s5">case </span><span class="s1">YGMeasureModeExactly:</span>
    <span class="s5">case </span><span class="s1">YGMeasureModeAtMost:</span>
      <span class="s1">*size = (maxSize.isUndefined() || *size &lt; maxSize.unwrap())</span>
          <span class="s1">? *size</span>
          <span class="s1">: maxSize.unwrap()</span><span class="s5">;</span>
      <span class="s5">break;</span>
    <span class="s5">case </span><span class="s1">YGMeasureModeUndefined:</span>
      <span class="s5">if </span><span class="s1">(!maxSize.isUndefined()) {</span>
        <span class="s1">*mode = YGMeasureModeAtMost</span><span class="s5">;</span>
        <span class="s1">*size = maxSize.unwrap()</span><span class="s5">;</span>
      <span class="s1">}</span>
      <span class="s5">break;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGNodeComputeFlexBasisForChild(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">width</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">height</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection direction</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount) {</span>
  <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis =</span>
      <span class="s1">YGResolveFlexDirection(node-&gt;getStyle().flexDirection()</span><span class="s5">, </span><span class="s1">direction)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isMainAxisRow = YGFlexDirectionIsRow(mainAxis)</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">mainAxisSize = isMainAxisRow ? width : height</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">mainAxisownerSize = isMainAxisRow ? ownerWidth : ownerHeight</span><span class="s5">;</span>

  <span class="s5">float </span><span class="s1">childWidth</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">childHeight</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode childWidthMeasureMode</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode childHeightMeasureMode</span><span class="s5">;</span>

  <span class="s5">const </span><span class="s1">YGFloatOptional resolvedFlexBasis =</span>
      <span class="s1">YGResolveValue(child-&gt;resolveFlexBasisPtr()</span><span class="s5">, </span><span class="s1">mainAxisownerSize)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isRowStyleDimDefined =</span>
      <span class="s1">YGNodeIsStyleDimDefined(child</span><span class="s5">, </span><span class="s1">YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isColumnStyleDimDefined =</span>
      <span class="s1">YGNodeIsStyleDimDefined(child</span><span class="s5">, </span><span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">ownerHeight)</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(!resolvedFlexBasis.isUndefined() &amp;&amp; !YGFloatIsUndefined(mainAxisSize)) {</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getLayout().computedFlexBasis.isUndefined() ||</span>
        <span class="s1">(YGConfigIsExperimentalFeatureEnabled(</span>
             <span class="s1">child-&gt;getConfig()</span><span class="s5">, </span><span class="s1">YGExperimentalFeatureWebFlexBasis) &amp;&amp;</span>
         <span class="s1">child-&gt;getLayout().computedFlexBasisGeneration != generationCount)) {</span>
      <span class="s5">const </span><span class="s1">YGFloatOptional paddingAndBorder = YGFloatOptional(</span>
          <span class="s1">YGNodePaddingAndBorderForAxis(child</span><span class="s5">, </span><span class="s1">mainAxis</span><span class="s5">, </span><span class="s1">ownerWidth))</span><span class="s5">;</span>
      <span class="s1">child-&gt;setLayoutComputedFlexBasis(</span>
          <span class="s1">YGFloatOptionalMax(resolvedFlexBasis</span><span class="s5">, </span><span class="s1">paddingAndBorder))</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(isMainAxisRow &amp;&amp; isRowStyleDimDefined) {</span>
    <span class="s0">// The width is definite, so use that as the flex basis.</span>
    <span class="s5">const </span><span class="s1">YGFloatOptional paddingAndBorder = YGFloatOptional(</span>
        <span class="s1">YGNodePaddingAndBorderForAxis(child</span><span class="s5">, </span><span class="s1">YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">ownerWidth))</span><span class="s5">;</span>

    <span class="s1">child-&gt;setLayoutComputedFlexBasis(YGFloatOptionalMax(</span>
        <span class="s1">YGResolveValue(</span>
            <span class="s1">child-&gt;getResolvedDimensions()[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">paddingAndBorder))</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(!isMainAxisRow &amp;&amp; isColumnStyleDimDefined) {</span>
    <span class="s0">// The height is definite, so use that as the flex basis.</span>
    <span class="s5">const </span><span class="s1">YGFloatOptional paddingAndBorder =</span>
        <span class="s1">YGFloatOptional(YGNodePaddingAndBorderForAxis(</span>
            <span class="s1">child</span><span class="s5">, </span><span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">ownerWidth))</span><span class="s5">;</span>
    <span class="s1">child-&gt;setLayoutComputedFlexBasis(YGFloatOptionalMax(</span>
        <span class="s1">YGResolveValue(</span>
            <span class="s1">child-&gt;getResolvedDimensions()[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">ownerHeight)</span><span class="s5">,</span>
        <span class="s1">paddingAndBorder))</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s0">// Compute the flex basis and hypothetical main size (i.e. the clamped flex</span>
    <span class="s0">// basis).</span>
    <span class="s1">childWidth = YGUndefined</span><span class="s5">;</span>
    <span class="s1">childHeight = YGUndefined</span><span class="s5">;</span>
    <span class="s1">childWidthMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>
    <span class="s1">childHeightMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>

    <span class="s5">auto </span><span class="s1">marginRow =</span>
        <span class="s1">child-&gt;getMarginForAxis(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
    <span class="s5">auto </span><span class="s1">marginColumn =</span>
        <span class="s1">child-&gt;getMarginForAxis(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(isRowStyleDimDefined) {</span>
      <span class="s1">childWidth =</span>
          <span class="s1">YGResolveValue(</span>
              <span class="s1">child-&gt;getResolvedDimensions()[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">ownerWidth)</span>
              <span class="s1">.unwrap() +</span>
          <span class="s1">marginRow</span><span class="s5">;</span>
      <span class="s1">childWidthMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(isColumnStyleDimDefined) {</span>
      <span class="s1">childHeight =</span>
          <span class="s1">YGResolveValue(</span>
              <span class="s1">child-&gt;getResolvedDimensions()[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">ownerHeight)</span>
              <span class="s1">.unwrap() +</span>
          <span class="s1">marginColumn</span><span class="s5">;</span>
      <span class="s1">childHeightMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s0">// The W3C spec doesn't say anything about the 'overflow' property, but all</span>
    <span class="s0">// major browsers appear to implement the following logic.</span>
    <span class="s5">if </span><span class="s1">((!isMainAxisRow &amp;&amp; node-&gt;getStyle().overflow() == YGOverflowScroll) ||</span>
        <span class="s1">node-&gt;getStyle().overflow() != YGOverflowScroll) {</span>
      <span class="s5">if </span><span class="s1">(YGFloatIsUndefined(childWidth) &amp;&amp; !YGFloatIsUndefined(width)) {</span>
        <span class="s1">childWidth = width</span><span class="s5">;</span>
        <span class="s1">childWidthMeasureMode = YGMeasureModeAtMost</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">((isMainAxisRow &amp;&amp; node-&gt;getStyle().overflow() == YGOverflowScroll) ||</span>
        <span class="s1">node-&gt;getStyle().overflow() != YGOverflowScroll) {</span>
      <span class="s5">if </span><span class="s1">(YGFloatIsUndefined(childHeight) &amp;&amp; !YGFloatIsUndefined(height)) {</span>
        <span class="s1">childHeight = height</span><span class="s5">;</span>
        <span class="s1">childHeightMeasureMode = YGMeasureModeAtMost</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">const auto</span><span class="s1">&amp; childStyle = child-&gt;getStyle()</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(!childStyle.aspectRatio().isUndefined()) {</span>
      <span class="s5">if </span><span class="s1">(!isMainAxisRow &amp;&amp; childWidthMeasureMode == YGMeasureModeExactly) {</span>
        <span class="s1">childHeight = marginColumn +</span>
            <span class="s1">(childWidth - marginRow) / childStyle.aspectRatio().unwrap()</span><span class="s5">;</span>
        <span class="s1">childHeightMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
          <span class="s1">isMainAxisRow &amp;&amp; childHeightMeasureMode == YGMeasureModeExactly) {</span>
        <span class="s1">childWidth = marginRow +</span>
            <span class="s1">(childHeight - marginColumn) * childStyle.aspectRatio().unwrap()</span><span class="s5">;</span>
        <span class="s1">childWidthMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// If child has no defined size in the cross axis and is set to stretch, set</span>
    <span class="s0">// the cross axis to be measured exactly with the available inner width</span>

    <span class="s5">const bool </span><span class="s1">hasExactWidth =</span>
        <span class="s1">!YGFloatIsUndefined(width) &amp;&amp; widthMode == YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s5">const bool </span><span class="s1">childWidthStretch =</span>
        <span class="s1">YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child) == YGAlignStretch &amp;&amp;</span>
        <span class="s1">childWidthMeasureMode != YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(!isMainAxisRow &amp;&amp; !isRowStyleDimDefined &amp;&amp; hasExactWidth &amp;&amp;</span>
        <span class="s1">childWidthStretch) {</span>
      <span class="s1">childWidth = width</span><span class="s5">;</span>
      <span class="s1">childWidthMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(!childStyle.aspectRatio().isUndefined()) {</span>
        <span class="s1">childHeight =</span>
            <span class="s1">(childWidth - marginRow) / childStyle.aspectRatio().unwrap()</span><span class="s5">;</span>
        <span class="s1">childHeightMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">const bool </span><span class="s1">hasExactHeight =</span>
        <span class="s1">!YGFloatIsUndefined(height) &amp;&amp; heightMode == YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s5">const bool </span><span class="s1">childHeightStretch =</span>
        <span class="s1">YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child) == YGAlignStretch &amp;&amp;</span>
        <span class="s1">childHeightMeasureMode != YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(isMainAxisRow &amp;&amp; !isColumnStyleDimDefined &amp;&amp; hasExactHeight &amp;&amp;</span>
        <span class="s1">childHeightStretch) {</span>
      <span class="s1">childHeight = height</span><span class="s5">;</span>
      <span class="s1">childHeightMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>

      <span class="s5">if </span><span class="s1">(!childStyle.aspectRatio().isUndefined()) {</span>
        <span class="s1">childWidth =</span>
            <span class="s1">(childHeight - marginColumn) * childStyle.aspectRatio().unwrap()</span><span class="s5">;</span>
        <span class="s1">childWidthMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">YGConstrainMaxSizeForMode(</span>
        <span class="s1">child</span><span class="s5">,</span>
        <span class="s1">YGFlexDirectionRow</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">&amp;childWidthMeasureMode</span><span class="s5">,</span>
        <span class="s1">&amp;childWidth)</span><span class="s5">;</span>
    <span class="s1">YGConstrainMaxSizeForMode(</span>
        <span class="s1">child</span><span class="s5">,</span>
        <span class="s1">YGFlexDirectionColumn</span><span class="s5">,</span>
        <span class="s1">ownerHeight</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">&amp;childHeightMeasureMode</span><span class="s5">,</span>
        <span class="s1">&amp;childHeight)</span><span class="s5">;</span>

    <span class="s0">// Measure the child</span>
    <span class="s1">YGLayoutNodeInternal(</span>
        <span class="s1">child</span><span class="s5">,</span>
        <span class="s1">childWidth</span><span class="s5">,</span>
        <span class="s1">childHeight</span><span class="s5">,</span>
        <span class="s1">direction</span><span class="s5">,</span>
        <span class="s1">childWidthMeasureMode</span><span class="s5">,</span>
        <span class="s1">childHeightMeasureMode</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">ownerHeight</span><span class="s5">,</span>
        <span class="s5">false,</span>
        <span class="s1">LayoutPassReason::kMeasureChild</span><span class="s5">,</span>
        <span class="s1">config</span><span class="s5">,</span>
        <span class="s1">layoutMarkerData</span><span class="s5">,</span>
        <span class="s1">layoutContext</span><span class="s5">,</span>
        <span class="s1">depth</span><span class="s5">,</span>
        <span class="s1">generationCount)</span><span class="s5">;</span>

    <span class="s1">child-&gt;setLayoutComputedFlexBasis(YGFloatOptional(YGFloatMax(</span>
        <span class="s1">child-&gt;getLayout().measuredDimensions[dim[mainAxis]]</span><span class="s5">,</span>
        <span class="s1">YGNodePaddingAndBorderForAxis(child</span><span class="s5">, </span><span class="s1">mainAxis</span><span class="s5">, </span><span class="s1">ownerWidth))))</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">child-&gt;setLayoutComputedFlexBasisGeneration(generationCount)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGNodeAbsoluteLayoutChild(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">width</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">height</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection direction</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount) {</span>
  <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis =</span>
      <span class="s1">YGResolveFlexDirection(node-&gt;getStyle().flexDirection()</span><span class="s5">, </span><span class="s1">direction)</span><span class="s5">;</span>
  <span class="s5">const </span><span class="s1">YGFlexDirection crossAxis = YGFlexDirectionCross(mainAxis</span><span class="s5">, </span><span class="s1">direction)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isMainAxisRow = YGFlexDirectionIsRow(mainAxis)</span><span class="s5">;</span>

  <span class="s5">float </span><span class="s1">childWidth = YGUndefined</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">childHeight = YGUndefined</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode childWidthMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode childHeightMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>

  <span class="s5">auto </span><span class="s1">marginRow = child-&gt;getMarginForAxis(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">width).unwrap()</span><span class="s5">;</span>
  <span class="s5">auto </span><span class="s1">marginColumn =</span>
      <span class="s1">child-&gt;getMarginForAxis(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">width).unwrap()</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(YGNodeIsStyleDimDefined(child</span><span class="s5">, </span><span class="s1">YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">width)) {</span>
    <span class="s1">childWidth =</span>
        <span class="s1">YGResolveValue(child-&gt;getResolvedDimensions()[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">width)</span>
            <span class="s1">.unwrap() +</span>
        <span class="s1">marginRow</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s0">// If the child doesn't have a specified width, compute the width based on</span>
    <span class="s0">// the left/right offsets if they're defined.</span>
    <span class="s5">if </span><span class="s1">(child-&gt;isLeadingPositionDefined(YGFlexDirectionRow) &amp;&amp;</span>
        <span class="s1">child-&gt;isTrailingPosDefined(YGFlexDirectionRow)) {</span>
      <span class="s1">childWidth = node-&gt;getLayout().measuredDimensions[YGDimensionWidth] -</span>
          <span class="s1">(node-&gt;getLeadingBorder(YGFlexDirectionRow) +</span>
           <span class="s1">node-&gt;getTrailingBorder(YGFlexDirectionRow)) -</span>
          <span class="s1">(child-&gt;getLeadingPosition(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">width) +</span>
           <span class="s1">child-&gt;getTrailingPosition(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">width))</span>
              <span class="s1">.unwrap()</span><span class="s5">;</span>
      <span class="s1">childWidth =</span>
          <span class="s1">YGNodeBoundAxis(child</span><span class="s5">, </span><span class="s1">YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">childWidth</span><span class="s5">, </span><span class="s1">width</span><span class="s5">, </span><span class="s1">width)</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(YGNodeIsStyleDimDefined(child</span><span class="s5">, </span><span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">height)) {</span>
    <span class="s1">childHeight = YGResolveValue(</span>
                      <span class="s1">child-&gt;getResolvedDimensions()[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">height)</span>
                      <span class="s1">.unwrap() +</span>
        <span class="s1">marginColumn</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s0">// If the child doesn't have a specified height, compute the height based on</span>
    <span class="s0">// the top/bottom offsets if they're defined.</span>
    <span class="s5">if </span><span class="s1">(child-&gt;isLeadingPositionDefined(YGFlexDirectionColumn) &amp;&amp;</span>
        <span class="s1">child-&gt;isTrailingPosDefined(YGFlexDirectionColumn)) {</span>
      <span class="s1">childHeight = node-&gt;getLayout().measuredDimensions[YGDimensionHeight] -</span>
          <span class="s1">(node-&gt;getLeadingBorder(YGFlexDirectionColumn) +</span>
           <span class="s1">node-&gt;getTrailingBorder(YGFlexDirectionColumn)) -</span>
          <span class="s1">(child-&gt;getLeadingPosition(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">height) +</span>
           <span class="s1">child-&gt;getTrailingPosition(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">height))</span>
              <span class="s1">.unwrap()</span><span class="s5">;</span>
      <span class="s1">childHeight = YGNodeBoundAxis(</span>
          <span class="s1">child</span><span class="s5">, </span><span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">childHeight</span><span class="s5">, </span><span class="s1">height</span><span class="s5">, </span><span class="s1">width)</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Exactly one dimension needs to be defined for us to be able to do aspect</span>
  <span class="s0">// ratio calculation. One dimension being the anchor and the other being</span>
  <span class="s0">// flexible.</span>
  <span class="s5">const auto</span><span class="s1">&amp; childStyle = child-&gt;getStyle()</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(YGFloatIsUndefined(childWidth) ^ YGFloatIsUndefined(childHeight)) {</span>
    <span class="s5">if </span><span class="s1">(!childStyle.aspectRatio().isUndefined()) {</span>
      <span class="s5">if </span><span class="s1">(YGFloatIsUndefined(childWidth)) {</span>
        <span class="s1">childWidth = marginRow +</span>
            <span class="s1">(childHeight - marginColumn) * childStyle.aspectRatio().unwrap()</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else if </span><span class="s1">(YGFloatIsUndefined(childHeight)) {</span>
        <span class="s1">childHeight = marginColumn +</span>
            <span class="s1">(childWidth - marginRow) / childStyle.aspectRatio().unwrap()</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// If we're still missing one or the other dimension, measure the content.</span>
  <span class="s5">if </span><span class="s1">(YGFloatIsUndefined(childWidth) || YGFloatIsUndefined(childHeight)) {</span>
    <span class="s1">childWidthMeasureMode = YGFloatIsUndefined(childWidth)</span>
        <span class="s1">? YGMeasureModeUndefined</span>
        <span class="s1">: YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s1">childHeightMeasureMode = YGFloatIsUndefined(childHeight)</span>
        <span class="s1">? YGMeasureModeUndefined</span>
        <span class="s1">: YGMeasureModeExactly</span><span class="s5">;</span>

    <span class="s0">// If the size of the owner is defined then try to constrain the absolute</span>
    <span class="s0">// child to that size as well. This allows text within the absolute child to</span>
    <span class="s0">// wrap to the size of its owner. This is the same behavior as many browsers</span>
    <span class="s0">// implement.</span>
    <span class="s5">if </span><span class="s1">(!isMainAxisRow &amp;&amp; YGFloatIsUndefined(childWidth) &amp;&amp;</span>
        <span class="s1">widthMode != YGMeasureModeUndefined &amp;&amp; !YGFloatIsUndefined(width) &amp;&amp;</span>
        <span class="s1">width &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">childWidth = width</span><span class="s5">;</span>
      <span class="s1">childWidthMeasureMode = YGMeasureModeAtMost</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">YGLayoutNodeInternal(</span>
        <span class="s1">child</span><span class="s5">,</span>
        <span class="s1">childWidth</span><span class="s5">,</span>
        <span class="s1">childHeight</span><span class="s5">,</span>
        <span class="s1">direction</span><span class="s5">,</span>
        <span class="s1">childWidthMeasureMode</span><span class="s5">,</span>
        <span class="s1">childHeightMeasureMode</span><span class="s5">,</span>
        <span class="s1">childWidth</span><span class="s5">,</span>
        <span class="s1">childHeight</span><span class="s5">,</span>
        <span class="s5">false,</span>
        <span class="s1">LayoutPassReason::kAbsMeasureChild</span><span class="s5">,</span>
        <span class="s1">config</span><span class="s5">,</span>
        <span class="s1">layoutMarkerData</span><span class="s5">,</span>
        <span class="s1">layoutContext</span><span class="s5">,</span>
        <span class="s1">depth</span><span class="s5">,</span>
        <span class="s1">generationCount)</span><span class="s5">;</span>
    <span class="s1">childWidth = child-&gt;getLayout().measuredDimensions[YGDimensionWidth] +</span>
        <span class="s1">child-&gt;getMarginForAxis(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">width).unwrap()</span><span class="s5">;</span>
    <span class="s1">childHeight = child-&gt;getLayout().measuredDimensions[YGDimensionHeight] +</span>
        <span class="s1">child-&gt;getMarginForAxis(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">width).unwrap()</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">YGLayoutNodeInternal(</span>
      <span class="s1">child</span><span class="s5">,</span>
      <span class="s1">childWidth</span><span class="s5">,</span>
      <span class="s1">childHeight</span><span class="s5">,</span>
      <span class="s1">direction</span><span class="s5">,</span>
      <span class="s1">YGMeasureModeExactly</span><span class="s5">,</span>
      <span class="s1">YGMeasureModeExactly</span><span class="s5">,</span>
      <span class="s1">childWidth</span><span class="s5">,</span>
      <span class="s1">childHeight</span><span class="s5">,</span>
      <span class="s5">true,</span>
      <span class="s1">LayoutPassReason::kAbsLayout</span><span class="s5">,</span>
      <span class="s1">config</span><span class="s5">,</span>
      <span class="s1">layoutMarkerData</span><span class="s5">,</span>
      <span class="s1">layoutContext</span><span class="s5">,</span>
      <span class="s1">depth</span><span class="s5">,</span>
      <span class="s1">generationCount)</span><span class="s5">;</span>

  <span class="s5">auto </span><span class="s1">trailingMarginOuterSize =</span>
      <span class="s1">YGConfigIsExperimentalFeatureEnabled(</span>
          <span class="s1">node-&gt;getConfig()</span><span class="s5">,</span>
          <span class="s1">YGExperimentalFeatureFixAbsoluteTrailingColumnMargin)</span>
      <span class="s1">? isMainAxisRow ? height : width</span>
      <span class="s1">: width</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(child-&gt;isTrailingPosDefined(mainAxis) &amp;&amp;</span>
      <span class="s1">!child-&gt;isLeadingPositionDefined(mainAxis)) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">node-&gt;getLayout().measuredDimensions[dim[mainAxis]] -</span>
            <span class="s1">child-&gt;getLayout().measuredDimensions[dim[mainAxis]] -</span>
            <span class="s1">node-&gt;getTrailingBorder(mainAxis) -</span>
            <span class="s1">child-&gt;getTrailingMargin(mainAxis</span><span class="s5">, </span><span class="s1">trailingMarginOuterSize)</span>
                <span class="s1">.unwrap() -</span>
            <span class="s1">child-&gt;getTrailingPosition(mainAxis</span><span class="s5">, </span><span class="s1">isMainAxisRow ? width : height)</span>
                <span class="s1">.unwrap()</span><span class="s5">,</span>
        <span class="s1">leading[mainAxis])</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">!child-&gt;isLeadingPositionDefined(mainAxis) &amp;&amp;</span>
      <span class="s1">node-&gt;getStyle().justifyContent() == YGJustifyCenter) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">(node-&gt;getLayout().measuredDimensions[dim[mainAxis]] -</span>
         <span class="s1">child-&gt;getLayout().measuredDimensions[dim[mainAxis]]) /</span>
            <span class="s4">2.0f</span><span class="s5">,</span>
        <span class="s1">leading[mainAxis])</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">!child-&gt;isLeadingPositionDefined(mainAxis) &amp;&amp;</span>
      <span class="s1">node-&gt;getStyle().justifyContent() == YGJustifyFlexEnd) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">(node-&gt;getLayout().measuredDimensions[dim[mainAxis]] -</span>
         <span class="s1">child-&gt;getLayout().measuredDimensions[dim[mainAxis]])</span><span class="s5">,</span>
        <span class="s1">leading[mainAxis])</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">YGConfigIsExperimentalFeatureEnabled(</span>
          <span class="s1">node-&gt;getConfig()</span><span class="s5">,</span>
          <span class="s1">YGExperimentalFeatureAbsolutePercentageAgainstPaddingEdge) &amp;&amp;</span>
      <span class="s1">child-&gt;isLeadingPositionDefined(mainAxis)) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">child-&gt;getLeadingPosition(</span>
                 <span class="s1">mainAxis</span><span class="s5">, </span><span class="s1">node-&gt;getLayout().measuredDimensions[dim[mainAxis]])</span>
                <span class="s1">.unwrap() +</span>
            <span class="s1">node-&gt;getLeadingBorder(mainAxis) +</span>
            <span class="s1">child</span>
                <span class="s1">-&gt;getLeadingMargin(</span>
                    <span class="s1">mainAxis</span><span class="s5">,</span>
                    <span class="s1">node-&gt;getLayout().measuredDimensions[dim[mainAxis]])</span>
                <span class="s1">.unwrap()</span><span class="s5">,</span>
        <span class="s1">leading[mainAxis])</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(child-&gt;isTrailingPosDefined(crossAxis) &amp;&amp;</span>
      <span class="s1">!child-&gt;isLeadingPositionDefined(crossAxis)) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">node-&gt;getLayout().measuredDimensions[dim[crossAxis]] -</span>
            <span class="s1">child-&gt;getLayout().measuredDimensions[dim[crossAxis]] -</span>
            <span class="s1">node-&gt;getTrailingBorder(crossAxis) -</span>
            <span class="s1">child-&gt;getTrailingMargin(crossAxis</span><span class="s5">, </span><span class="s1">trailingMarginOuterSize)</span>
                <span class="s1">.unwrap() -</span>
            <span class="s1">child</span>
                <span class="s1">-&gt;getTrailingPosition(crossAxis</span><span class="s5">, </span><span class="s1">isMainAxisRow ? height : width)</span>
                <span class="s1">.unwrap()</span><span class="s5">,</span>
        <span class="s1">leading[crossAxis])</span><span class="s5">;</span>

  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">!child-&gt;isLeadingPositionDefined(crossAxis) &amp;&amp;</span>
      <span class="s1">YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child) == YGAlignCenter) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">(node-&gt;getLayout().measuredDimensions[dim[crossAxis]] -</span>
         <span class="s1">child-&gt;getLayout().measuredDimensions[dim[crossAxis]]) /</span>
            <span class="s4">2.0f</span><span class="s5">,</span>
        <span class="s1">leading[crossAxis])</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">!child-&gt;isLeadingPositionDefined(crossAxis) &amp;&amp;</span>
      <span class="s1">((YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child) == YGAlignFlexEnd) ^</span>
       <span class="s1">(node-&gt;getStyle().flexWrap() == YGWrapWrapReverse))) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">(node-&gt;getLayout().measuredDimensions[dim[crossAxis]] -</span>
         <span class="s1">child-&gt;getLayout().measuredDimensions[dim[crossAxis]])</span><span class="s5">,</span>
        <span class="s1">leading[crossAxis])</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">YGConfigIsExperimentalFeatureEnabled(</span>
          <span class="s1">node-&gt;getConfig()</span><span class="s5">,</span>
          <span class="s1">YGExperimentalFeatureAbsolutePercentageAgainstPaddingEdge) &amp;&amp;</span>
      <span class="s1">child-&gt;isLeadingPositionDefined(crossAxis)) {</span>
    <span class="s1">child-&gt;setLayoutPosition(</span>
        <span class="s1">child-&gt;getLeadingPosition(</span>
                 <span class="s1">crossAxis</span><span class="s5">,</span>
                 <span class="s1">node-&gt;getLayout().measuredDimensions[dim[crossAxis]])</span>
                <span class="s1">.unwrap() +</span>
            <span class="s1">node-&gt;getLeadingBorder(crossAxis) +</span>
            <span class="s1">child</span>
                <span class="s1">-&gt;getLeadingMargin(</span>
                    <span class="s1">crossAxis</span><span class="s5">,</span>
                    <span class="s1">node-&gt;getLayout().measuredDimensions[dim[crossAxis]])</span>
                <span class="s1">.unwrap()</span><span class="s5">,</span>
        <span class="s1">leading[crossAxis])</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGNodeWithMeasureFuncSetMeasuredDimensions(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">availableWidth</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">availableHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMeasureMode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMeasureMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">LayoutPassReason reason) {</span>
  <span class="s1">YGAssertWithNode(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">node-&gt;hasMeasureFunc()</span><span class="s5">,</span>
      <span class="s3">&quot;Expected node to have custom measure function&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(widthMeasureMode == YGMeasureModeUndefined) {</span>
    <span class="s1">availableWidth = YGUndefined</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">if </span><span class="s1">(heightMeasureMode == YGMeasureModeUndefined) {</span>
    <span class="s1">availableHeight = YGUndefined</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">const auto</span><span class="s1">&amp; padding = node-&gt;getLayout().padding</span><span class="s5">;</span>
  <span class="s5">const auto</span><span class="s1">&amp; border = node-&gt;getLayout().border</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">paddingAndBorderAxisRow = padding[YGEdgeLeft] +</span>
      <span class="s1">padding[YGEdgeRight] + border[YGEdgeLeft] + border[YGEdgeRight]</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">paddingAndBorderAxisColumn = padding[YGEdgeTop] +</span>
      <span class="s1">padding[YGEdgeBottom] + border[YGEdgeTop] + border[YGEdgeBottom]</span><span class="s5">;</span>

  <span class="s0">// We want to make sure we don't call measure with negative size</span>
  <span class="s5">const float </span><span class="s1">innerWidth = YGFloatIsUndefined(availableWidth)</span>
      <span class="s1">? availableWidth</span>
      <span class="s1">: YGFloatMax(</span><span class="s4">0</span><span class="s5">, </span><span class="s1">availableWidth - paddingAndBorderAxisRow)</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">innerHeight = YGFloatIsUndefined(availableHeight)</span>
      <span class="s1">? availableHeight</span>
      <span class="s1">: YGFloatMax(</span><span class="s4">0</span><span class="s5">, </span><span class="s1">availableHeight - paddingAndBorderAxisColumn)</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(widthMeasureMode == YGMeasureModeExactly &amp;&amp;</span>
      <span class="s1">heightMeasureMode == YGMeasureModeExactly) {</span>
    <span class="s0">// Don't bother sizing the text if both dimensions are already defined.</span>
    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">, </span><span class="s1">YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">availableWidth</span><span class="s5">, </span><span class="s1">ownerWidth</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">YGDimensionWidth)</span><span class="s5">;</span>
    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">,</span>
            <span class="s1">YGFlexDirectionColumn</span><span class="s5">,</span>
            <span class="s1">availableHeight</span><span class="s5">,</span>
            <span class="s1">ownerHeight</span><span class="s5">,</span>
            <span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">YGDimensionHeight)</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">Event::publish&lt;Event::MeasureCallbackStart&gt;(node)</span><span class="s5">;</span>

    <span class="s0">// Measure the text under the current constraints.</span>
    <span class="s5">const </span><span class="s1">YGSize measuredSize = node-&gt;measure(</span>
        <span class="s1">innerWidth</span><span class="s5">,</span>
        <span class="s1">widthMeasureMode</span><span class="s5">,</span>
        <span class="s1">innerHeight</span><span class="s5">,</span>
        <span class="s1">heightMeasureMode</span><span class="s5">,</span>
        <span class="s1">layoutContext)</span><span class="s5">;</span>

    <span class="s1">layoutMarkerData.measureCallbacks += </span><span class="s4">1</span><span class="s5">;</span>
    <span class="s1">layoutMarkerData.measureCallbackReasonsCount[</span><span class="s5">static_cast</span><span class="s1">&lt;size_t&gt;(reason)] +=</span>
        <span class="s4">1</span><span class="s5">;</span>

    <span class="s1">Event::publish&lt;Event::MeasureCallbackEnd&gt;(</span>
        <span class="s1">node</span><span class="s5">,</span>
        <span class="s1">{layoutContext</span><span class="s5">,</span>
         <span class="s1">innerWidth</span><span class="s5">,</span>
         <span class="s1">widthMeasureMode</span><span class="s5">,</span>
         <span class="s1">innerHeight</span><span class="s5">,</span>
         <span class="s1">heightMeasureMode</span><span class="s5">,</span>
         <span class="s1">measuredSize.width</span><span class="s5">,</span>
         <span class="s1">measuredSize.height</span><span class="s5">,</span>
         <span class="s1">reason})</span><span class="s5">;</span>

    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">,</span>
            <span class="s1">YGFlexDirectionRow</span><span class="s5">,</span>
            <span class="s1">(widthMeasureMode == YGMeasureModeUndefined ||</span>
             <span class="s1">widthMeasureMode == YGMeasureModeAtMost)</span>
                <span class="s1">? measuredSize.width + paddingAndBorderAxisRow</span>
                <span class="s1">: availableWidth</span><span class="s5">,</span>
            <span class="s1">ownerWidth</span><span class="s5">,</span>
            <span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">YGDimensionWidth)</span><span class="s5">;</span>

    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">,</span>
            <span class="s1">YGFlexDirectionColumn</span><span class="s5">,</span>
            <span class="s1">(heightMeasureMode == YGMeasureModeUndefined ||</span>
             <span class="s1">heightMeasureMode == YGMeasureModeAtMost)</span>
                <span class="s1">? measuredSize.height + paddingAndBorderAxisColumn</span>
                <span class="s1">: availableHeight</span><span class="s5">,</span>
            <span class="s1">ownerHeight</span><span class="s5">,</span>
            <span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">YGDimensionHeight)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// For nodes with no children, use the available values if they were provided,</span>
<span class="s0">// or the minimum size as indicated by the padding and border sizes.</span>
<span class="s5">static void </span><span class="s1">YGNodeEmptyContainerSetMeasuredDimensions(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMeasureMode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMeasureMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight) {</span>
  <span class="s5">const auto</span><span class="s1">&amp; padding = node-&gt;getLayout().padding</span><span class="s5">;</span>
  <span class="s5">const auto</span><span class="s1">&amp; border = node-&gt;getLayout().border</span><span class="s5">;</span>

  <span class="s5">float </span><span class="s1">width = availableWidth</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(widthMeasureMode == YGMeasureModeUndefined ||</span>
      <span class="s1">widthMeasureMode == YGMeasureModeAtMost) {</span>
    <span class="s1">width = padding[YGEdgeLeft] + padding[YGEdgeRight] + border[YGEdgeLeft] +</span>
        <span class="s1">border[YGEdgeRight]</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
      <span class="s1">YGNodeBoundAxis(node</span><span class="s5">, </span><span class="s1">YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">width</span><span class="s5">, </span><span class="s1">ownerWidth</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">,</span>
      <span class="s1">YGDimensionWidth)</span><span class="s5">;</span>

  <span class="s5">float </span><span class="s1">height = availableHeight</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(heightMeasureMode == YGMeasureModeUndefined ||</span>
      <span class="s1">heightMeasureMode == YGMeasureModeAtMost) {</span>
    <span class="s1">height = padding[YGEdgeTop] + padding[YGEdgeBottom] + border[YGEdgeTop] +</span>
        <span class="s1">border[YGEdgeBottom]</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
      <span class="s1">YGNodeBoundAxis(</span>
          <span class="s1">node</span><span class="s5">, </span><span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">height</span><span class="s5">, </span><span class="s1">ownerHeight</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">,</span>
      <span class="s1">YGDimensionHeight)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static bool </span><span class="s1">YGNodeFixedSizeSetMeasuredDimensions(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMeasureMode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMeasureMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight) {</span>
  <span class="s5">if </span><span class="s1">((!YGFloatIsUndefined(availableWidth) &amp;&amp;</span>
       <span class="s1">widthMeasureMode == YGMeasureModeAtMost &amp;&amp; availableWidth &lt;= </span><span class="s4">0.0f</span><span class="s1">) ||</span>
      <span class="s1">(!YGFloatIsUndefined(availableHeight) &amp;&amp;</span>
       <span class="s1">heightMeasureMode == YGMeasureModeAtMost &amp;&amp; availableHeight &lt;= </span><span class="s4">0.0f</span><span class="s1">) ||</span>
      <span class="s1">(widthMeasureMode == YGMeasureModeExactly &amp;&amp;</span>
       <span class="s1">heightMeasureMode == YGMeasureModeExactly)) {</span>
    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">,</span>
            <span class="s1">YGFlexDirectionRow</span><span class="s5">,</span>
            <span class="s1">YGFloatIsUndefined(availableWidth) ||</span>
                    <span class="s1">(widthMeasureMode == YGMeasureModeAtMost &amp;&amp;</span>
                     <span class="s1">availableWidth &lt; </span><span class="s4">0.0f</span><span class="s1">)</span>
                <span class="s1">? </span><span class="s4">0.0f</span>
                <span class="s1">: availableWidth</span><span class="s5">,</span>
            <span class="s1">ownerWidth</span><span class="s5">,</span>
            <span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">YGDimensionWidth)</span><span class="s5">;</span>

    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">,</span>
            <span class="s1">YGFlexDirectionColumn</span><span class="s5">,</span>
            <span class="s1">YGFloatIsUndefined(availableHeight) ||</span>
                    <span class="s1">(heightMeasureMode == YGMeasureModeAtMost &amp;&amp;</span>
                     <span class="s1">availableHeight &lt; </span><span class="s4">0.0f</span><span class="s1">)</span>
                <span class="s1">? </span><span class="s4">0.0f</span>
                <span class="s1">: availableHeight</span><span class="s5">,</span>
            <span class="s1">ownerHeight</span><span class="s5">,</span>
            <span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">YGDimensionHeight)</span><span class="s5">;</span>
    <span class="s5">return true;</span>
  <span class="s1">}</span>

  <span class="s5">return false;</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGZeroOutLayoutRecursivly(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* layoutContext) {</span>
  <span class="s1">node-&gt;getLayout() = {}</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutDimension(</span><span class="s4">0</span><span class="s5">, </span><span class="s4">0</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutDimension(</span><span class="s4">0</span><span class="s5">, </span><span class="s4">1</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setHasNewLayout(</span><span class="s5">true</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s1">node-&gt;iterChildrenAfterCloningIfNeeded(</span>
      <span class="s1">YGZeroOutLayoutRecursivly</span><span class="s5">, </span><span class="s1">layoutContext)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static float </span><span class="s1">YGNodeCalculateAvailableInnerDim(</span>
    <span class="s5">const </span><span class="s1">YGNodeConstRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDimension dimension</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">paddingAndBorder</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerDim) {</span>
  <span class="s5">float </span><span class="s1">availableInnerDim = availableDim - paddingAndBorder</span><span class="s5">;</span>
  <span class="s0">// Max dimension overrides predefined dimension value; Min dimension in turn</span>
  <span class="s0">// overrides both of the above</span>
  <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(availableInnerDim)) {</span>
    <span class="s0">// We want to make sure our available height does not violate min and max</span>
    <span class="s0">// constraints</span>
    <span class="s5">const </span><span class="s1">YGFloatOptional minDimensionOptional =</span>
        <span class="s1">YGResolveValue(node-&gt;getStyle().minDimensions()[dimension]</span><span class="s5">, </span><span class="s1">ownerDim)</span><span class="s5">;</span>
    <span class="s5">const float </span><span class="s1">minInnerDim = minDimensionOptional.isUndefined()</span>
        <span class="s1">? </span><span class="s4">0.0f</span>
        <span class="s1">: minDimensionOptional.unwrap() - paddingAndBorder</span><span class="s5">;</span>

    <span class="s5">const </span><span class="s1">YGFloatOptional maxDimensionOptional =</span>
        <span class="s1">YGResolveValue(node-&gt;getStyle().maxDimensions()[dimension]</span><span class="s5">, </span><span class="s1">ownerDim)</span><span class="s5">;</span>

    <span class="s5">const float </span><span class="s1">maxInnerDim = maxDimensionOptional.isUndefined()</span>
        <span class="s1">? FLT_MAX</span>
        <span class="s1">: maxDimensionOptional.unwrap() - paddingAndBorder</span><span class="s5">;</span>
    <span class="s1">availableInnerDim =</span>
        <span class="s1">YGFloatMax(YGFloatMin(availableInnerDim</span><span class="s5">, </span><span class="s1">maxInnerDim)</span><span class="s5">, </span><span class="s1">minInnerDim)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">return </span><span class="s1">availableInnerDim</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static float </span><span class="s1">YGNodeComputeFlexBasisForChildren(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerHeight</span><span class="s5">,</span>
    <span class="s1">YGMeasureMode widthMeasureMode</span><span class="s5">,</span>
    <span class="s1">YGMeasureMode heightMeasureMode</span><span class="s5">,</span>
    <span class="s1">YGDirection direction</span><span class="s5">,</span>
    <span class="s1">YGFlexDirection mainAxis</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">bool </span><span class="s1">performLayout</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount) {</span>
  <span class="s5">float </span><span class="s1">totalOuterFlexBasis = </span><span class="s4">0.0f</span><span class="s5">;</span>
  <span class="s1">YGNodeRef singleFlexChild = </span><span class="s5">nullptr;</span>
  <span class="s5">const </span><span class="s1">YGVector&amp; children = node-&gt;getChildren()</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode measureModeMainDim =</span>
      <span class="s1">YGFlexDirectionIsRow(mainAxis) ? widthMeasureMode : heightMeasureMode</span><span class="s5">;</span>
  <span class="s0">// If there is only one child with flexGrow + flexShrink it means we can set</span>
  <span class="s0">// the computedFlexBasis to 0 instead of measuring and shrinking / flexing the</span>
  <span class="s0">// child to exactly match the remaining space</span>
  <span class="s5">if </span><span class="s1">(measureModeMainDim == YGMeasureModeExactly) {</span>
    <span class="s5">for </span><span class="s1">(</span><span class="s5">auto </span><span class="s1">child : children) {</span>
      <span class="s5">if </span><span class="s1">(child-&gt;isNodeFlexible()) {</span>
        <span class="s5">if </span><span class="s1">(singleFlexChild != </span><span class="s5">nullptr </span><span class="s1">||</span>
            <span class="s1">YGFloatsEqual(child-&gt;resolveFlexGrow()</span><span class="s5">, </span><span class="s4">0.0f</span><span class="s1">) ||</span>
            <span class="s1">YGFloatsEqual(child-&gt;resolveFlexShrink()</span><span class="s5">, </span><span class="s4">0.0f</span><span class="s1">)) {</span>
          <span class="s0">// There is already a flexible child, or this flexible child doesn't</span>
          <span class="s0">// have flexGrow and flexShrink, abort</span>
          <span class="s1">singleFlexChild = </span><span class="s5">nullptr;</span>
          <span class="s5">break;</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
          <span class="s1">singleFlexChild = child</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">for </span><span class="s1">(</span><span class="s5">auto </span><span class="s1">child : children) {</span>
    <span class="s1">child-&gt;resolveDimension()</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getStyle().display() == YGDisplayNone) {</span>
      <span class="s1">YGZeroOutLayoutRecursivly(child</span><span class="s5">, </span><span class="s1">layoutContext)</span><span class="s5">;</span>
      <span class="s1">child-&gt;setHasNewLayout(</span><span class="s5">true</span><span class="s1">)</span><span class="s5">;</span>
      <span class="s1">child-&gt;setDirty(</span><span class="s5">false</span><span class="s1">)</span><span class="s5">;</span>
      <span class="s5">continue;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(performLayout) {</span>
      <span class="s0">// Set the initial position (relative to the owner).</span>
      <span class="s5">const </span><span class="s1">YGDirection childDirection = child-&gt;resolveDirection(direction)</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">mainDim = YGFlexDirectionIsRow(mainAxis)</span>
          <span class="s1">? availableInnerWidth</span>
          <span class="s1">: availableInnerHeight</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">crossDim = YGFlexDirectionIsRow(mainAxis)</span>
          <span class="s1">? availableInnerHeight</span>
          <span class="s1">: availableInnerWidth</span><span class="s5">;</span>
      <span class="s1">child-&gt;setPosition(</span>
          <span class="s1">childDirection</span><span class="s5">, </span><span class="s1">mainDim</span><span class="s5">, </span><span class="s1">crossDim</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() == YGPositionTypeAbsolute) {</span>
      <span class="s5">continue;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(child == singleFlexChild) {</span>
      <span class="s1">child-&gt;setLayoutComputedFlexBasisGeneration(generationCount)</span><span class="s5">;</span>
      <span class="s1">child-&gt;setLayoutComputedFlexBasis(YGFloatOptional(</span><span class="s4">0</span><span class="s1">))</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
      <span class="s1">YGNodeComputeFlexBasisForChild(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">child</span><span class="s5">,</span>
          <span class="s1">availableInnerWidth</span><span class="s5">,</span>
          <span class="s1">widthMeasureMode</span><span class="s5">,</span>
          <span class="s1">availableInnerHeight</span><span class="s5">,</span>
          <span class="s1">availableInnerWidth</span><span class="s5">,</span>
          <span class="s1">availableInnerHeight</span><span class="s5">,</span>
          <span class="s1">heightMeasureMode</span><span class="s5">,</span>
          <span class="s1">direction</span><span class="s5">,</span>
          <span class="s1">config</span><span class="s5">,</span>
          <span class="s1">layoutMarkerData</span><span class="s5">,</span>
          <span class="s1">layoutContext</span><span class="s5">,</span>
          <span class="s1">depth</span><span class="s5">,</span>
          <span class="s1">generationCount)</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">totalOuterFlexBasis +=</span>
        <span class="s1">(child-&gt;getLayout().computedFlexBasis +</span>
         <span class="s1">child-&gt;getMarginForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth))</span>
            <span class="s1">.unwrap()</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">return </span><span class="s1">totalOuterFlexBasis</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// This function assumes that all the children of node have their</span>
<span class="s0">// computedFlexBasis properly computed(To do this use</span>
<span class="s0">// YGNodeComputeFlexBasisForChildren function). This function calculates</span>
<span class="s0">// YGCollectFlexItemsRowMeasurement</span>
<span class="s5">static </span><span class="s1">YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef&amp; node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection ownerDirection</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">mainAxisownerSize</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerMainDim</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t startOfLineIndex</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t lineCount) {</span>
  <span class="s1">YGCollectFlexItemsRowValues flexAlgoRowMeasurement = {}</span><span class="s5">;</span>
  <span class="s1">flexAlgoRowMeasurement.relativeChildren.reserve(node-&gt;getChildren().size())</span><span class="s5">;</span>

  <span class="s5">float </span><span class="s1">sizeConsumedOnCurrentLineIncludingMinConstraint = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis = YGResolveFlexDirection(</span>
      <span class="s1">node-&gt;getStyle().flexDirection()</span><span class="s5">, </span><span class="s1">node-&gt;resolveDirection(ownerDirection))</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isNodeFlexWrap = node-&gt;getStyle().flexWrap() != YGWrapNoWrap</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">gap = node-&gt;getGapForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth).unwrap()</span><span class="s5">;</span>

  <span class="s0">// Add items to the current line until it's full or we run out of items.</span>
  <span class="s1">uint32_t endOfLineIndex = startOfLineIndex</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(</span><span class="s5">; </span><span class="s1">endOfLineIndex &lt; node-&gt;getChildren().size()</span><span class="s5">; </span><span class="s1">endOfLineIndex++) {</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child = node-&gt;getChild(endOfLineIndex)</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getStyle().display() == YGDisplayNone ||</span>
        <span class="s1">child-&gt;getStyle().positionType() == YGPositionTypeAbsolute) {</span>
      <span class="s5">continue;</span>
    <span class="s1">}</span>

    <span class="s5">const bool </span><span class="s1">isFirstElementInLine = (endOfLineIndex - startOfLineIndex) == </span><span class="s4">0</span><span class="s5">;</span>

    <span class="s1">child-&gt;setLineIndex(lineCount)</span><span class="s5">;</span>
    <span class="s5">const float </span><span class="s1">childMarginMainAxis =</span>
        <span class="s1">child-&gt;getMarginForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth).unwrap()</span><span class="s5">;</span>
    <span class="s5">const float </span><span class="s1">childLeadingGapMainAxis = isFirstElementInLine ? </span><span class="s4">0.0f </span><span class="s1">: gap</span><span class="s5">;</span>
    <span class="s5">const float </span><span class="s1">flexBasisWithMinAndMaxConstraints =</span>
        <span class="s1">YGNodeBoundAxisWithinMinAndMax(</span>
            <span class="s1">child</span><span class="s5">,</span>
            <span class="s1">mainAxis</span><span class="s5">,</span>
            <span class="s1">child-&gt;getLayout().computedFlexBasis</span><span class="s5">,</span>
            <span class="s1">mainAxisownerSize)</span>
            <span class="s1">.unwrap()</span><span class="s5">;</span>

    <span class="s0">// If this is a multi-line flow and this item pushes us over the available</span>
    <span class="s0">// size, we've hit the end of the current line. Break out of the loop and</span>
    <span class="s0">// lay out the current line.</span>
    <span class="s5">if </span><span class="s1">(sizeConsumedOnCurrentLineIncludingMinConstraint +</span>
                <span class="s1">flexBasisWithMinAndMaxConstraints + childMarginMainAxis +</span>
                <span class="s1">childLeadingGapMainAxis &gt;</span>
            <span class="s1">availableInnerMainDim &amp;&amp;</span>
        <span class="s1">isNodeFlexWrap &amp;&amp; flexAlgoRowMeasurement.itemsOnLine &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s5">break;</span>
    <span class="s1">}</span>

    <span class="s1">sizeConsumedOnCurrentLineIncludingMinConstraint +=</span>
        <span class="s1">flexBasisWithMinAndMaxConstraints + childMarginMainAxis +</span>
        <span class="s1">childLeadingGapMainAxis</span><span class="s5">;</span>
    <span class="s1">flexAlgoRowMeasurement.sizeConsumedOnCurrentLine +=</span>
        <span class="s1">flexBasisWithMinAndMaxConstraints + childMarginMainAxis +</span>
        <span class="s1">childLeadingGapMainAxis</span><span class="s5">;</span>
    <span class="s1">flexAlgoRowMeasurement.itemsOnLine++</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(child-&gt;isNodeFlexible()) {</span>
      <span class="s1">flexAlgoRowMeasurement.totalFlexGrowFactors += child-&gt;resolveFlexGrow()</span><span class="s5">;</span>

      <span class="s0">// Unlike the grow factor, the shrink factor is scaled relative to the</span>
      <span class="s0">// child dimension.</span>
      <span class="s1">flexAlgoRowMeasurement.totalFlexShrinkScaledFactors +=</span>
          <span class="s1">-child-&gt;resolveFlexShrink() *</span>
          <span class="s1">child-&gt;getLayout().computedFlexBasis.unwrap()</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">flexAlgoRowMeasurement.relativeChildren.push_back(child)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// The total flex factor needs to be floored to 1.</span>
  <span class="s5">if </span><span class="s1">(flexAlgoRowMeasurement.totalFlexGrowFactors &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">flexAlgoRowMeasurement.totalFlexGrowFactors &lt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">flexAlgoRowMeasurement.totalFlexGrowFactors = </span><span class="s4">1</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// The total flex shrink factor needs to be floored to 1.</span>
  <span class="s5">if </span><span class="s1">(flexAlgoRowMeasurement.totalFlexShrinkScaledFactors &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">flexAlgoRowMeasurement.totalFlexShrinkScaledFactors &lt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">flexAlgoRowMeasurement.totalFlexShrinkScaledFactors = </span><span class="s4">1</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">flexAlgoRowMeasurement.endOfLineIndex = endOfLineIndex</span><span class="s5">;</span>
  <span class="s5">return </span><span class="s1">flexAlgoRowMeasurement</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// It distributes the free space to the flexible items and ensures that the size</span>
<span class="s0">// of the flex items abide the min and max constraints. At the end of this</span>
<span class="s0">// function the child nodes would have proper size. Prior using this function</span>
<span class="s0">// please ensure that YGDistributeFreeSpaceFirstPass is called.</span>
<span class="s5">static float </span><span class="s1">YGDistributeFreeSpaceSecondPass(</span>
    <span class="s1">YGCollectFlexItemsRowValues&amp; collectedFlexItemsValues</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection crossAxis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">mainAxisownerSize</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerMainDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerHeight</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">mainAxisOverflows</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode measureModeCrossDim</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">performLayout</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount) {</span>
  <span class="s5">float </span><span class="s1">childFlexBasis = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">flexShrinkScaledFactor = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">flexGrowFactor = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">deltaFreeSpace = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isMainAxisRow = YGFlexDirectionIsRow(mainAxis)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isNodeFlexWrap = node-&gt;getStyle().flexWrap() != YGWrapNoWrap</span><span class="s5">;</span>

  <span class="s5">for </span><span class="s1">(</span><span class="s5">auto </span><span class="s1">currentRelativeChild : collectedFlexItemsValues.relativeChildren) {</span>
    <span class="s1">childFlexBasis = YGNodeBoundAxisWithinMinAndMax(</span>
                         <span class="s1">currentRelativeChild</span><span class="s5">,</span>
                         <span class="s1">mainAxis</span><span class="s5">,</span>
                         <span class="s1">currentRelativeChild-&gt;getLayout().computedFlexBasis</span><span class="s5">,</span>
                         <span class="s1">mainAxisownerSize)</span>
                         <span class="s1">.unwrap()</span><span class="s5">;</span>
    <span class="s5">float </span><span class="s1">updatedMainSize = childFlexBasis</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(collectedFlexItemsValues.remainingFreeSpace) &amp;&amp;</span>
        <span class="s1">collectedFlexItemsValues.remainingFreeSpace &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">flexShrinkScaledFactor =</span>
          <span class="s1">-currentRelativeChild-&gt;resolveFlexShrink() * childFlexBasis</span><span class="s5">;</span>
      <span class="s0">// Is this child able to shrink?</span>
      <span class="s5">if </span><span class="s1">(flexShrinkScaledFactor != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s5">float </span><span class="s1">childSize</span><span class="s5">;</span>

        <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(</span>
                <span class="s1">collectedFlexItemsValues.totalFlexShrinkScaledFactors) &amp;&amp;</span>
            <span class="s1">collectedFlexItemsValues.totalFlexShrinkScaledFactors == </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">childSize = childFlexBasis + flexShrinkScaledFactor</span><span class="s5">;</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
          <span class="s1">childSize = childFlexBasis +</span>
              <span class="s1">(collectedFlexItemsValues.remainingFreeSpace /</span>
               <span class="s1">collectedFlexItemsValues.totalFlexShrinkScaledFactors) *</span>
                  <span class="s1">flexShrinkScaledFactor</span><span class="s5">;</span>
        <span class="s1">}</span>

        <span class="s1">updatedMainSize = YGNodeBoundAxis(</span>
            <span class="s1">currentRelativeChild</span><span class="s5">,</span>
            <span class="s1">mainAxis</span><span class="s5">,</span>
            <span class="s1">childSize</span><span class="s5">,</span>
            <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
            <span class="s1">availableInnerWidth)</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
        <span class="s1">!YGFloatIsUndefined(collectedFlexItemsValues.remainingFreeSpace) &amp;&amp;</span>
        <span class="s1">collectedFlexItemsValues.remainingFreeSpace &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">flexGrowFactor = currentRelativeChild-&gt;resolveFlexGrow()</span><span class="s5">;</span>

      <span class="s0">// Is this child able to grow?</span>
      <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(flexGrowFactor) &amp;&amp; flexGrowFactor != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">updatedMainSize = YGNodeBoundAxis(</span>
            <span class="s1">currentRelativeChild</span><span class="s5">,</span>
            <span class="s1">mainAxis</span><span class="s5">,</span>
            <span class="s1">childFlexBasis +</span>
                <span class="s1">collectedFlexItemsValues.remainingFreeSpace /</span>
                    <span class="s1">collectedFlexItemsValues.totalFlexGrowFactors *</span>
                    <span class="s1">flexGrowFactor</span><span class="s5">,</span>
            <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
            <span class="s1">availableInnerWidth)</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">deltaFreeSpace += updatedMainSize - childFlexBasis</span><span class="s5">;</span>

    <span class="s5">const float </span><span class="s1">marginMain =</span>
        <span class="s1">currentRelativeChild-&gt;getMarginForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
            <span class="s1">.unwrap()</span><span class="s5">;</span>
    <span class="s5">const float </span><span class="s1">marginCross =</span>
        <span class="s1">currentRelativeChild-&gt;getMarginForAxis(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
            <span class="s1">.unwrap()</span><span class="s5">;</span>

    <span class="s5">float </span><span class="s1">childCrossSize</span><span class="s5">;</span>
    <span class="s5">float </span><span class="s1">childMainSize = updatedMainSize + marginMain</span><span class="s5">;</span>
    <span class="s1">YGMeasureMode childCrossMeasureMode</span><span class="s5">;</span>
    <span class="s1">YGMeasureMode childMainMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>

    <span class="s5">const auto</span><span class="s1">&amp; childStyle = currentRelativeChild-&gt;getStyle()</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(!childStyle.aspectRatio().isUndefined()) {</span>
      <span class="s1">childCrossSize = isMainAxisRow</span>
          <span class="s1">? (childMainSize - marginMain) / childStyle.aspectRatio().unwrap()</span>
          <span class="s1">: (childMainSize - marginMain) * childStyle.aspectRatio().unwrap()</span><span class="s5">;</span>
      <span class="s1">childCrossMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>

      <span class="s1">childCrossSize += marginCross</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
        <span class="s1">!YGFloatIsUndefined(availableInnerCrossDim) &amp;&amp;</span>
        <span class="s1">!YGNodeIsStyleDimDefined(</span>
            <span class="s1">currentRelativeChild</span><span class="s5">, </span><span class="s1">crossAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim) &amp;&amp;</span>
        <span class="s1">measureModeCrossDim == YGMeasureModeExactly &amp;&amp;</span>
        <span class="s1">!(isNodeFlexWrap &amp;&amp; mainAxisOverflows) &amp;&amp;</span>
        <span class="s1">YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">currentRelativeChild) == YGAlignStretch &amp;&amp;</span>
        <span class="s1">currentRelativeChild-&gt;marginLeadingValue(crossAxis).unit !=</span>
            <span class="s1">YGUnitAuto &amp;&amp;</span>
        <span class="s1">currentRelativeChild-&gt;marginTrailingValue(crossAxis).unit !=</span>
            <span class="s1">YGUnitAuto) {</span>
      <span class="s1">childCrossSize = availableInnerCrossDim</span><span class="s5">;</span>
      <span class="s1">childCrossMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(!YGNodeIsStyleDimDefined(</span>
                   <span class="s1">currentRelativeChild</span><span class="s5">, </span><span class="s1">crossAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim)) {</span>
      <span class="s1">childCrossSize = availableInnerCrossDim</span><span class="s5">;</span>
      <span class="s1">childCrossMeasureMode = YGFloatIsUndefined(childCrossSize)</span>
          <span class="s1">? YGMeasureModeUndefined</span>
          <span class="s1">: YGMeasureModeAtMost</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
      <span class="s1">childCrossSize =</span>
          <span class="s1">YGResolveValue(</span>
              <span class="s1">currentRelativeChild-&gt;getResolvedDimension(dim[crossAxis])</span><span class="s5">,</span>
              <span class="s1">availableInnerCrossDim)</span>
              <span class="s1">.unwrap() +</span>
          <span class="s1">marginCross</span><span class="s5">;</span>
      <span class="s5">const bool </span><span class="s1">isLoosePercentageMeasurement =</span>
          <span class="s1">currentRelativeChild-&gt;getResolvedDimension(dim[crossAxis]).unit ==</span>
              <span class="s1">YGUnitPercent &amp;&amp;</span>
          <span class="s1">measureModeCrossDim != YGMeasureModeExactly</span><span class="s5">;</span>
      <span class="s1">childCrossMeasureMode =</span>
          <span class="s1">YGFloatIsUndefined(childCrossSize) || isLoosePercentageMeasurement</span>
          <span class="s1">? YGMeasureModeUndefined</span>
          <span class="s1">: YGMeasureModeExactly</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">YGConstrainMaxSizeForMode(</span>
        <span class="s1">currentRelativeChild</span><span class="s5">,</span>
        <span class="s1">mainAxis</span><span class="s5">,</span>
        <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
        <span class="s1">availableInnerWidth</span><span class="s5">,</span>
        <span class="s1">&amp;childMainMeasureMode</span><span class="s5">,</span>
        <span class="s1">&amp;childMainSize)</span><span class="s5">;</span>
    <span class="s1">YGConstrainMaxSizeForMode(</span>
        <span class="s1">currentRelativeChild</span><span class="s5">,</span>
        <span class="s1">crossAxis</span><span class="s5">,</span>
        <span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
        <span class="s1">availableInnerWidth</span><span class="s5">,</span>
        <span class="s1">&amp;childCrossMeasureMode</span><span class="s5">,</span>
        <span class="s1">&amp;childCrossSize)</span><span class="s5">;</span>

    <span class="s5">const bool </span><span class="s1">requiresStretchLayout =</span>
        <span class="s1">!YGNodeIsStyleDimDefined(</span>
            <span class="s1">currentRelativeChild</span><span class="s5">, </span><span class="s1">crossAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim) &amp;&amp;</span>
        <span class="s1">YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">currentRelativeChild) == YGAlignStretch &amp;&amp;</span>
        <span class="s1">currentRelativeChild-&gt;marginLeadingValue(crossAxis).unit !=</span>
            <span class="s1">YGUnitAuto &amp;&amp;</span>
        <span class="s1">currentRelativeChild-&gt;marginTrailingValue(crossAxis).unit != YGUnitAuto</span><span class="s5">;</span>

    <span class="s5">const float </span><span class="s1">childWidth = isMainAxisRow ? childMainSize : childCrossSize</span><span class="s5">;</span>
    <span class="s5">const float </span><span class="s1">childHeight = !isMainAxisRow ? childMainSize : childCrossSize</span><span class="s5">;</span>

    <span class="s5">const </span><span class="s1">YGMeasureMode childWidthMeasureMode =</span>
        <span class="s1">isMainAxisRow ? childMainMeasureMode : childCrossMeasureMode</span><span class="s5">;</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode childHeightMeasureMode =</span>
        <span class="s1">!isMainAxisRow ? childMainMeasureMode : childCrossMeasureMode</span><span class="s5">;</span>

    <span class="s5">const bool </span><span class="s1">isLayoutPass = performLayout &amp;&amp; !requiresStretchLayout</span><span class="s5">;</span>
    <span class="s0">// Recursively call the layout algorithm for this child with the updated</span>
    <span class="s0">// main size.</span>
    <span class="s1">YGLayoutNodeInternal(</span>
        <span class="s1">currentRelativeChild</span><span class="s5">,</span>
        <span class="s1">childWidth</span><span class="s5">,</span>
        <span class="s1">childHeight</span><span class="s5">,</span>
        <span class="s1">node-&gt;getLayout().direction()</span><span class="s5">,</span>
        <span class="s1">childWidthMeasureMode</span><span class="s5">,</span>
        <span class="s1">childHeightMeasureMode</span><span class="s5">,</span>
        <span class="s1">availableInnerWidth</span><span class="s5">,</span>
        <span class="s1">availableInnerHeight</span><span class="s5">,</span>
        <span class="s1">isLayoutPass</span><span class="s5">,</span>
        <span class="s1">isLayoutPass ? LayoutPassReason::kFlexLayout</span>
                     <span class="s1">: LayoutPassReason::kFlexMeasure</span><span class="s5">,</span>
        <span class="s1">config</span><span class="s5">,</span>
        <span class="s1">layoutMarkerData</span><span class="s5">,</span>
        <span class="s1">layoutContext</span><span class="s5">,</span>
        <span class="s1">depth</span><span class="s5">,</span>
        <span class="s1">generationCount)</span><span class="s5">;</span>
    <span class="s1">node-&gt;setLayoutHadOverflow(</span>
        <span class="s1">node-&gt;getLayout().hadOverflow() ||</span>
        <span class="s1">currentRelativeChild-&gt;getLayout().hadOverflow())</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">return </span><span class="s1">deltaFreeSpace</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// It distributes the free space to the flexible items.For those flexible items</span>
<span class="s0">// whose min and max constraints are triggered, those flex item's clamped size</span>
<span class="s0">// is removed from the remaingfreespace.</span>
<span class="s5">static void </span><span class="s1">YGDistributeFreeSpaceFirstPass(</span>
    <span class="s1">YGCollectFlexItemsRowValues&amp; collectedFlexItemsValues</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">mainAxisownerSize</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerMainDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerWidth) {</span>
  <span class="s5">float </span><span class="s1">flexShrinkScaledFactor = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">flexGrowFactor = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">baseMainSize = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">boundMainSize = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">deltaFreeSpace = </span><span class="s4">0</span><span class="s5">;</span>

  <span class="s5">for </span><span class="s1">(</span><span class="s5">auto </span><span class="s1">currentRelativeChild : collectedFlexItemsValues.relativeChildren) {</span>
    <span class="s5">float </span><span class="s1">childFlexBasis =</span>
        <span class="s1">YGNodeBoundAxisWithinMinAndMax(</span>
            <span class="s1">currentRelativeChild</span><span class="s5">,</span>
            <span class="s1">mainAxis</span><span class="s5">,</span>
            <span class="s1">currentRelativeChild-&gt;getLayout().computedFlexBasis</span><span class="s5">,</span>
            <span class="s1">mainAxisownerSize)</span>
            <span class="s1">.unwrap()</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(collectedFlexItemsValues.remainingFreeSpace &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">flexShrinkScaledFactor =</span>
          <span class="s1">-currentRelativeChild-&gt;resolveFlexShrink() * childFlexBasis</span><span class="s5">;</span>

      <span class="s0">// Is this child able to shrink?</span>
      <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(flexShrinkScaledFactor) &amp;&amp;</span>
          <span class="s1">flexShrinkScaledFactor != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">baseMainSize = childFlexBasis +</span>
            <span class="s1">collectedFlexItemsValues.remainingFreeSpace /</span>
                <span class="s1">collectedFlexItemsValues.totalFlexShrinkScaledFactors *</span>
                <span class="s1">flexShrinkScaledFactor</span><span class="s5">;</span>
        <span class="s1">boundMainSize = YGNodeBoundAxis(</span>
            <span class="s1">currentRelativeChild</span><span class="s5">,</span>
            <span class="s1">mainAxis</span><span class="s5">,</span>
            <span class="s1">baseMainSize</span><span class="s5">,</span>
            <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
            <span class="s1">availableInnerWidth)</span><span class="s5">;</span>
        <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(baseMainSize) &amp;&amp;</span>
            <span class="s1">!YGFloatIsUndefined(boundMainSize) &amp;&amp;</span>
            <span class="s1">baseMainSize != boundMainSize) {</span>
          <span class="s0">// By excluding this item's size and flex factor from remaining, this</span>
          <span class="s0">// item's min/max constraints should also trigger in the second pass</span>
          <span class="s0">// resulting in the item's size calculation being identical in the</span>
          <span class="s0">// first and second passes.</span>
          <span class="s1">deltaFreeSpace += boundMainSize - childFlexBasis</span><span class="s5">;</span>
          <span class="s1">collectedFlexItemsValues.totalFlexShrinkScaledFactors -=</span>
              <span class="s1">(-currentRelativeChild-&gt;resolveFlexShrink() *</span>
               <span class="s1">currentRelativeChild-&gt;getLayout().computedFlexBasis.unwrap())</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
        <span class="s1">!YGFloatIsUndefined(collectedFlexItemsValues.remainingFreeSpace) &amp;&amp;</span>
        <span class="s1">collectedFlexItemsValues.remainingFreeSpace &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">flexGrowFactor = currentRelativeChild-&gt;resolveFlexGrow()</span><span class="s5">;</span>

      <span class="s0">// Is this child able to grow?</span>
      <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(flexGrowFactor) &amp;&amp; flexGrowFactor != </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">baseMainSize = childFlexBasis +</span>
            <span class="s1">collectedFlexItemsValues.remainingFreeSpace /</span>
                <span class="s1">collectedFlexItemsValues.totalFlexGrowFactors * flexGrowFactor</span><span class="s5">;</span>
        <span class="s1">boundMainSize = YGNodeBoundAxis(</span>
            <span class="s1">currentRelativeChild</span><span class="s5">,</span>
            <span class="s1">mainAxis</span><span class="s5">,</span>
            <span class="s1">baseMainSize</span><span class="s5">,</span>
            <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
            <span class="s1">availableInnerWidth)</span><span class="s5">;</span>

        <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(baseMainSize) &amp;&amp;</span>
            <span class="s1">!YGFloatIsUndefined(boundMainSize) &amp;&amp;</span>
            <span class="s1">baseMainSize != boundMainSize) {</span>
          <span class="s0">// By excluding this item's size and flex factor from remaining, this</span>
          <span class="s0">// item's min/max constraints should also trigger in the second pass</span>
          <span class="s0">// resulting in the item's size calculation being identical in the</span>
          <span class="s0">// first and second passes.</span>
          <span class="s1">deltaFreeSpace += boundMainSize - childFlexBasis</span><span class="s5">;</span>
          <span class="s1">collectedFlexItemsValues.totalFlexGrowFactors -= flexGrowFactor</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">collectedFlexItemsValues.remainingFreeSpace -= deltaFreeSpace</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">// Do two passes over the flex items to figure out how to distribute the</span>
<span class="s0">// remaining space.</span>
<span class="s0">//</span>
<span class="s0">// The first pass finds the items whose min/max constraints trigger, freezes</span>
<span class="s0">// them at those sizes, and excludes those sizes from the remaining space.</span>
<span class="s0">//</span>
<span class="s0">// The second pass sets the size of each flexible item. It distributes the</span>
<span class="s0">// remaining space amongst the items whose min/max constraints didn't trigger in</span>
<span class="s0">// the first pass. For the other items, it sets their sizes by forcing their</span>
<span class="s0">// min/max constraints to trigger again.</span>
<span class="s0">//</span>
<span class="s0">// This two pass approach for resolving min/max constraints deviates from the</span>
<span class="s0">// spec. The spec</span>
<span class="s0">// (https://www.w3.org/TR/CSS-flexbox-1/#resolve-flexible-lengths) describes a</span>
<span class="s0">// process that needs to be repeated a variable number of times. The algorithm</span>
<span class="s0">// implemented here won't handle all cases but it was simpler to implement and</span>
<span class="s0">// it mitigates performance concerns because we know exactly how many passes</span>
<span class="s0">// it'll do.</span>
<span class="s0">//</span>
<span class="s0">// At the end of this function the child nodes would have the proper size</span>
<span class="s0">// assigned to them.</span>
<span class="s0">//</span>
<span class="s5">static void </span><span class="s1">YGResolveFlexibleLength(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGCollectFlexItemsRowValues&amp; collectedFlexItemsValues</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection crossAxis</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">mainAxisownerSize</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerMainDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerHeight</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">mainAxisOverflows</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode measureModeCrossDim</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">performLayout</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount) {</span>
  <span class="s5">const float </span><span class="s1">originalFreeSpace = collectedFlexItemsValues.remainingFreeSpace</span><span class="s5">;</span>
  <span class="s0">// First pass: detect the flex items whose min/max constraints trigger</span>
  <span class="s1">YGDistributeFreeSpaceFirstPass(</span>
      <span class="s1">collectedFlexItemsValues</span><span class="s5">,</span>
      <span class="s1">mainAxis</span><span class="s5">,</span>
      <span class="s1">mainAxisownerSize</span><span class="s5">,</span>
      <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
      <span class="s1">availableInnerWidth)</span><span class="s5">;</span>

  <span class="s0">// Second pass: resolve the sizes of the flexible items</span>
  <span class="s5">const float </span><span class="s1">distributedFreeSpace = YGDistributeFreeSpaceSecondPass(</span>
      <span class="s1">collectedFlexItemsValues</span><span class="s5">,</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">mainAxis</span><span class="s5">,</span>
      <span class="s1">crossAxis</span><span class="s5">,</span>
      <span class="s1">mainAxisownerSize</span><span class="s5">,</span>
      <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
      <span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
      <span class="s1">availableInnerWidth</span><span class="s5">,</span>
      <span class="s1">availableInnerHeight</span><span class="s5">,</span>
      <span class="s1">mainAxisOverflows</span><span class="s5">,</span>
      <span class="s1">measureModeCrossDim</span><span class="s5">,</span>
      <span class="s1">performLayout</span><span class="s5">,</span>
      <span class="s1">config</span><span class="s5">,</span>
      <span class="s1">layoutMarkerData</span><span class="s5">,</span>
      <span class="s1">layoutContext</span><span class="s5">,</span>
      <span class="s1">depth</span><span class="s5">,</span>
      <span class="s1">generationCount)</span><span class="s5">;</span>

  <span class="s1">collectedFlexItemsValues.remainingFreeSpace =</span>
      <span class="s1">originalFreeSpace - distributedFreeSpace</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGJustifyMainAxis(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s1">YGCollectFlexItemsRowValues&amp; collectedFlexItemsValues</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t startOfLineIndex</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGFlexDirection crossAxis</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode measureModeMainDim</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode measureModeCrossDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">mainAxisownerSize</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerMainDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableInnerWidth</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">performLayout</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext) {</span>
  <span class="s5">const auto</span><span class="s1">&amp; style = node-&gt;getStyle()</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">leadingPaddingAndBorderMain =</span>
      <span class="s1">node-&gt;getLeadingPaddingAndBorder(mainAxis</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">trailingPaddingAndBorderMain =</span>
      <span class="s1">node-&gt;getTrailingPaddingAndBorder(mainAxis</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">gap = node-&gt;getGapForAxis(mainAxis</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s0">// If we are using &quot;at most&quot; rules in the main axis, make sure that</span>
  <span class="s0">// remainingFreeSpace is 0 when min main dimension is not given</span>
  <span class="s5">if </span><span class="s1">(measureModeMainDim == YGMeasureModeAtMost &amp;&amp;</span>
      <span class="s1">collectedFlexItemsValues.remainingFreeSpace &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s5">if </span><span class="s1">(!style.minDimensions()[dim[mainAxis]].isUndefined() &amp;&amp;</span>
        <span class="s1">!YGResolveValue(style.minDimensions()[dim[mainAxis]]</span><span class="s5">, </span><span class="s1">mainAxisownerSize)</span>
             <span class="s1">.isUndefined()) {</span>
      <span class="s0">// This condition makes sure that if the size of main dimension(after</span>
      <span class="s0">// considering child nodes main dim, leading and trailing padding etc)</span>
      <span class="s0">// falls below min dimension, then the remainingFreeSpace is reassigned</span>
      <span class="s0">// considering the min dimension</span>

      <span class="s0">// `minAvailableMainDim` denotes minimum available space in which child</span>
      <span class="s0">// can be laid out, it will exclude space consumed by padding and border.</span>
      <span class="s5">const float </span><span class="s1">minAvailableMainDim =</span>
          <span class="s1">YGResolveValue(</span>
              <span class="s1">style.minDimensions()[dim[mainAxis]]</span><span class="s5">, </span><span class="s1">mainAxisownerSize)</span>
              <span class="s1">.unwrap() -</span>
          <span class="s1">leadingPaddingAndBorderMain - trailingPaddingAndBorderMain</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">occupiedSpaceByChildNodes =</span>
          <span class="s1">availableInnerMainDim - collectedFlexItemsValues.remainingFreeSpace</span><span class="s5">;</span>
      <span class="s1">collectedFlexItemsValues.remainingFreeSpace =</span>
          <span class="s1">YGFloatMax(</span><span class="s4">0</span><span class="s5">, </span><span class="s1">minAvailableMainDim - occupiedSpaceByChildNodes)</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
      <span class="s1">collectedFlexItemsValues.remainingFreeSpace = </span><span class="s4">0</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">int </span><span class="s1">numberOfAutoMarginsOnCurrentLine = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(uint32_t i = startOfLineIndex</span><span class="s5">;</span>
       <span class="s1">i &lt; collectedFlexItemsValues.endOfLineIndex</span><span class="s5">;</span>
       <span class="s1">i++) {</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child = node-&gt;getChild(i)</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() != YGPositionTypeAbsolute) {</span>
      <span class="s5">if </span><span class="s1">(child-&gt;marginLeadingValue(mainAxis).unit == YGUnitAuto) {</span>
        <span class="s1">numberOfAutoMarginsOnCurrentLine++</span><span class="s5">;</span>
      <span class="s1">}</span>
      <span class="s5">if </span><span class="s1">(child-&gt;marginTrailingValue(mainAxis).unit == YGUnitAuto) {</span>
        <span class="s1">numberOfAutoMarginsOnCurrentLine++</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// In order to position the elements in the main axis, we have two controls.</span>
  <span class="s0">// The space between the beginning and the first element and the space between</span>
  <span class="s0">// each two elements.</span>
  <span class="s5">float </span><span class="s1">leadingMainDim = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">betweenMainDim = gap</span><span class="s5">;</span>
  <span class="s5">const </span><span class="s1">YGJustify justifyContent = node-&gt;getStyle().justifyContent()</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(numberOfAutoMarginsOnCurrentLine == </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s5">switch </span><span class="s1">(justifyContent) {</span>
      <span class="s5">case </span><span class="s1">YGJustifyCenter:</span>
        <span class="s1">leadingMainDim = collectedFlexItemsValues.remainingFreeSpace / </span><span class="s4">2</span><span class="s5">;</span>
        <span class="s5">break;</span>
      <span class="s5">case </span><span class="s1">YGJustifyFlexEnd:</span>
        <span class="s1">leadingMainDim = collectedFlexItemsValues.remainingFreeSpace</span><span class="s5">;</span>
        <span class="s5">break;</span>
      <span class="s5">case </span><span class="s1">YGJustifySpaceBetween:</span>
        <span class="s5">if </span><span class="s1">(collectedFlexItemsValues.itemsOnLine &gt; </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">betweenMainDim +=</span>
              <span class="s1">YGFloatMax(collectedFlexItemsValues.remainingFreeSpace</span><span class="s5">, </span><span class="s4">0</span><span class="s1">) /</span>
              <span class="s1">(collectedFlexItemsValues.itemsOnLine - </span><span class="s4">1</span><span class="s1">)</span><span class="s5">;</span>
        <span class="s1">}</span>
        <span class="s5">break;</span>
      <span class="s5">case </span><span class="s1">YGJustifySpaceEvenly:</span>
        <span class="s0">// Space is distributed evenly across all elements</span>
        <span class="s1">leadingMainDim = collectedFlexItemsValues.remainingFreeSpace /</span>
            <span class="s1">(collectedFlexItemsValues.itemsOnLine + </span><span class="s4">1</span><span class="s1">)</span><span class="s5">;</span>
        <span class="s1">betweenMainDim += leadingMainDim</span><span class="s5">;</span>
        <span class="s5">break;</span>
      <span class="s5">case </span><span class="s1">YGJustifySpaceAround:</span>
        <span class="s0">// Space on the edges is half of the space between elements</span>
        <span class="s1">leadingMainDim = </span><span class="s4">0.5f </span><span class="s1">* collectedFlexItemsValues.remainingFreeSpace /</span>
            <span class="s1">collectedFlexItemsValues.itemsOnLine</span><span class="s5">;</span>
        <span class="s1">betweenMainDim += leadingMainDim * </span><span class="s4">2</span><span class="s5">;</span>
        <span class="s5">break;</span>
      <span class="s5">case </span><span class="s1">YGJustifyFlexStart:</span>
        <span class="s5">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">collectedFlexItemsValues.mainDim =</span>
      <span class="s1">leadingPaddingAndBorderMain + leadingMainDim</span><span class="s5">;</span>
  <span class="s1">collectedFlexItemsValues.crossDim = </span><span class="s4">0</span><span class="s5">;</span>

  <span class="s5">float </span><span class="s1">maxAscentForCurrentLine = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">maxDescentForCurrentLine = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">bool </span><span class="s1">isNodeBaselineLayout = YGIsBaselineLayout(node)</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(uint32_t i = startOfLineIndex</span><span class="s5">;</span>
       <span class="s1">i &lt; collectedFlexItemsValues.endOfLineIndex</span><span class="s5">;</span>
       <span class="s1">i++) {</span>
    <span class="s5">const </span><span class="s1">YGNodeRef child = node-&gt;getChild(i)</span><span class="s5">;</span>
    <span class="s5">const </span><span class="s1">YGStyle&amp; childStyle = child-&gt;getStyle()</span><span class="s5">;</span>
    <span class="s5">const </span><span class="s1">YGLayout childLayout = child-&gt;getLayout()</span><span class="s5">;</span>
    <span class="s5">const bool </span><span class="s1">isLastChild = i == collectedFlexItemsValues.endOfLineIndex - </span><span class="s4">1</span><span class="s5">;</span>
    <span class="s0">// remove the gap if it is the last element of the line</span>
    <span class="s5">if </span><span class="s1">(isLastChild) {</span>
      <span class="s1">betweenMainDim -= gap</span><span class="s5">;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(childStyle.display() == YGDisplayNone) {</span>
      <span class="s5">continue;</span>
    <span class="s1">}</span>
    <span class="s5">if </span><span class="s1">(childStyle.positionType() == YGPositionTypeAbsolute &amp;&amp;</span>
        <span class="s1">child-&gt;isLeadingPositionDefined(mainAxis)) {</span>
      <span class="s5">if </span><span class="s1">(performLayout) {</span>
        <span class="s0">// In case the child is position absolute and has left/top being</span>
        <span class="s0">// defined, we override the position to whatever the user said (and</span>
        <span class="s0">// margin/border).</span>
        <span class="s1">child-&gt;setLayoutPosition(</span>
            <span class="s1">child-&gt;getLeadingPosition(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerMainDim)</span>
                    <span class="s1">.unwrap() +</span>
                <span class="s1">node-&gt;getLeadingBorder(mainAxis) +</span>
                <span class="s1">child-&gt;getLeadingMargin(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth).unwrap()</span><span class="s5">,</span>
            <span class="s1">pos[mainAxis])</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
      <span class="s0">// Now that we placed the element, we need to update the variables.</span>
      <span class="s0">// We need to do that only for relative elements. Absolute elements do not</span>
      <span class="s0">// take part in that phase.</span>
      <span class="s5">if </span><span class="s1">(childStyle.positionType() != YGPositionTypeAbsolute) {</span>
        <span class="s5">if </span><span class="s1">(child-&gt;marginLeadingValue(mainAxis).unit == YGUnitAuto) {</span>
          <span class="s1">collectedFlexItemsValues.mainDim +=</span>
              <span class="s1">collectedFlexItemsValues.remainingFreeSpace /</span>
              <span class="s1">numberOfAutoMarginsOnCurrentLine</span><span class="s5">;</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(performLayout) {</span>
          <span class="s1">child-&gt;setLayoutPosition(</span>
              <span class="s1">childLayout.position[pos[mainAxis]] +</span>
                  <span class="s1">collectedFlexItemsValues.mainDim</span><span class="s5">,</span>
              <span class="s1">pos[mainAxis])</span><span class="s5">;</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(child-&gt;marginTrailingValue(mainAxis).unit == YGUnitAuto) {</span>
          <span class="s1">collectedFlexItemsValues.mainDim +=</span>
              <span class="s1">collectedFlexItemsValues.remainingFreeSpace /</span>
              <span class="s1">numberOfAutoMarginsOnCurrentLine</span><span class="s5">;</span>
        <span class="s1">}</span>
        <span class="s5">bool </span><span class="s1">canSkipFlex =</span>
            <span class="s1">!performLayout &amp;&amp; measureModeCrossDim == YGMeasureModeExactly</span><span class="s5">;</span>
        <span class="s5">if </span><span class="s1">(canSkipFlex) {</span>
          <span class="s0">// If we skipped the flex step, then we can't rely on the measuredDims</span>
          <span class="s0">// because they weren't computed. This means we can't call</span>
          <span class="s0">// YGNodeDimWithMargin.</span>
          <span class="s1">collectedFlexItemsValues.mainDim += betweenMainDim +</span>
              <span class="s1">child-&gt;getMarginForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth).unwrap() +</span>
              <span class="s1">childLayout.computedFlexBasis.unwrap()</span><span class="s5">;</span>
          <span class="s1">collectedFlexItemsValues.crossDim = availableInnerCrossDim</span><span class="s5">;</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
          <span class="s0">// The main dimension is the sum of all the elements dimension plus</span>
          <span class="s0">// the spacing.</span>
          <span class="s1">collectedFlexItemsValues.mainDim += betweenMainDim +</span>
              <span class="s1">YGNodeDimWithMargin(child</span><span class="s5">, </span><span class="s1">mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span><span class="s5">;</span>

          <span class="s5">if </span><span class="s1">(isNodeBaselineLayout) {</span>
            <span class="s0">// If the child is baseline aligned then the cross dimension is</span>
            <span class="s0">// calculated by adding maxAscent and maxDescent from the baseline.</span>
            <span class="s5">const float </span><span class="s1">ascent = YGBaseline(child</span><span class="s5">, </span><span class="s1">layoutContext) +</span>
                <span class="s1">child</span>
                    <span class="s1">-&gt;getLeadingMargin(</span>
                        <span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                    <span class="s1">.unwrap()</span><span class="s5">;</span>
            <span class="s5">const float </span><span class="s1">descent =</span>
                <span class="s1">child-&gt;getLayout().measuredDimensions[YGDimensionHeight] +</span>
                <span class="s1">child</span>
                    <span class="s1">-&gt;getMarginForAxis(</span>
                        <span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                    <span class="s1">.unwrap() -</span>
                <span class="s1">ascent</span><span class="s5">;</span>

            <span class="s1">maxAscentForCurrentLine =</span>
                <span class="s1">YGFloatMax(maxAscentForCurrentLine</span><span class="s5">, </span><span class="s1">ascent)</span><span class="s5">;</span>
            <span class="s1">maxDescentForCurrentLine =</span>
                <span class="s1">YGFloatMax(maxDescentForCurrentLine</span><span class="s5">, </span><span class="s1">descent)</span><span class="s5">;</span>
          <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
            <span class="s0">// The cross dimension is the max of the elements dimension since</span>
            <span class="s0">// there can only be one element in that cross dimension in the case</span>
            <span class="s0">// when the items are not baseline aligned</span>
            <span class="s1">collectedFlexItemsValues.crossDim = YGFloatMax(</span>
                <span class="s1">collectedFlexItemsValues.crossDim</span><span class="s5">,</span>
                <span class="s1">YGNodeDimWithMargin(child</span><span class="s5">, </span><span class="s1">crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth))</span><span class="s5">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s5">else if </span><span class="s1">(performLayout) {</span>
        <span class="s1">child-&gt;setLayoutPosition(</span>
            <span class="s1">childLayout.position[pos[mainAxis]] +</span>
                <span class="s1">node-&gt;getLeadingBorder(mainAxis) + leadingMainDim</span><span class="s5">,</span>
            <span class="s1">pos[mainAxis])</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">collectedFlexItemsValues.mainDim += trailingPaddingAndBorderMain</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(isNodeBaselineLayout) {</span>
    <span class="s1">collectedFlexItemsValues.crossDim =</span>
        <span class="s1">maxAscentForCurrentLine + maxDescentForCurrentLine</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// This is the main routine that implements a subset of the flexbox layout</span>
<span class="s0">// algorithm described in the W3C CSS documentation:</span>
<span class="s0">// https://www.w3.org/TR/CSS3-flexbox/.</span>
<span class="s0">//</span>
<span class="s0">// Limitations of this algorithm, compared to the full standard:</span>
<span class="s0">//  * Display property is always assumed to be 'flex' except for Text nodes,</span>
<span class="s0">//    which are assumed to be 'inline-flex'.</span>
<span class="s0">//  * The 'zIndex' property (or any form of z ordering) is not supported. Nodes</span>
<span class="s0">//    are stacked in document order.</span>
<span class="s0">//  * The 'order' property is not supported. The order of flex items is always</span>
<span class="s0">//    defined by document order.</span>
<span class="s0">//  * The 'visibility' property is always assumed to be 'visible'. Values of</span>
<span class="s0">//    'collapse' and 'hidden' are not supported.</span>
<span class="s0">//  * There is no support for forced breaks.</span>
<span class="s0">//  * It does not support vertical inline directions (top-to-bottom or</span>
<span class="s0">//    bottom-to-top text).</span>
<span class="s0">//</span>
<span class="s0">// Deviations from standard:</span>
<span class="s0">//  * Section 4.5 of the spec indicates that all flex items have a default</span>
<span class="s0">//    minimum main size. For text blocks, for example, this is the width of the</span>
<span class="s0">//    widest word. Calculating the minimum width is expensive, so we forego it</span>
<span class="s0">//    and assume a default minimum main size of 0.</span>
<span class="s0">//  * Min/Max sizes in the main axis are not honored when resolving flexible</span>
<span class="s0">//    lengths.</span>
<span class="s0">//  * The spec indicates that the default value for 'flexDirection' is 'row',</span>
<span class="s0">//    but the algorithm below assumes a default of 'column'.</span>
<span class="s0">//</span>
<span class="s0">// Input parameters:</span>
<span class="s0">//    - node: current node to be sized and laid out</span>
<span class="s0">//    - availableWidth &amp; availableHeight: available size to be used for sizing</span>
<span class="s0">//      the node or YGUndefined if the size is not available; interpretation</span>
<span class="s0">//      depends on layout flags</span>
<span class="s0">//    - ownerDirection: the inline (text) direction within the owner</span>
<span class="s0">//      (left-to-right or right-to-left)</span>
<span class="s0">//    - widthMeasureMode: indicates the sizing rules for the width (see below</span>
<span class="s0">//      for explanation)</span>
<span class="s0">//    - heightMeasureMode: indicates the sizing rules for the height (see below</span>
<span class="s0">//      for explanation)</span>
<span class="s0">//    - performLayout: specifies whether the caller is interested in just the</span>
<span class="s0">//      dimensions of the node or it requires the entire node and its subtree to</span>
<span class="s0">//      be laid out (with final positions)</span>
<span class="s0">//</span>
<span class="s0">// Details:</span>
<span class="s0">//    This routine is called recursively to lay out subtrees of flexbox</span>
<span class="s0">//    elements. It uses the information in node.style, which is treated as a</span>
<span class="s0">//    read-only input. It is responsible for setting the layout.direction and</span>
<span class="s0">//    layout.measuredDimensions fields for the input node as well as the</span>
<span class="s0">//    layout.position and layout.lineIndex fields for its child nodes. The</span>
<span class="s0">//    layout.measuredDimensions field includes any border or padding for the</span>
<span class="s0">//    node but does not include margins.</span>
<span class="s0">//</span>
<span class="s0">//    The spec describes four different layout modes: &quot;fill available&quot;, &quot;max</span>
<span class="s0">//    content&quot;, &quot;min content&quot;, and &quot;fit content&quot;. Of these, we don't use &quot;min</span>
<span class="s0">//    content&quot; because we don't support default minimum main sizes (see above</span>
<span class="s0">//    for details). Each of our measure modes maps to a layout mode from the</span>
<span class="s0">//    spec (https://www.w3.org/TR/CSS3-sizing/#terms):</span>
<span class="s0">//      - YGMeasureModeUndefined: max content</span>
<span class="s0">//      - YGMeasureModeExactly: fill available</span>
<span class="s0">//      - YGMeasureModeAtMost: fit content</span>
<span class="s0">//</span>
<span class="s0">//    When calling YGNodelayoutImpl and YGLayoutNodeInternal, if the caller</span>
<span class="s0">//    passes an available size of undefined then it must also pass a measure</span>
<span class="s0">//    mode of YGMeasureModeUndefined in that dimension.</span>
<span class="s0">//</span>
<span class="s5">static void </span><span class="s1">YGNodelayoutImpl(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection ownerDirection</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMeasureMode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMeasureMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">performLayout</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">LayoutPassReason reason) {</span>
  <span class="s1">YGAssertWithNode(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">YGFloatIsUndefined(availableWidth)</span>
          <span class="s1">? widthMeasureMode == YGMeasureModeUndefined</span>
          <span class="s1">: </span><span class="s5">true,</span>
      <span class="s3">&quot;availableWidth is indefinite so widthMeasureMode must be &quot;</span>
      <span class="s3">&quot;YGMeasureModeUndefined&quot;</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">YGAssertWithNode(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">YGFloatIsUndefined(availableHeight)</span>
          <span class="s1">? heightMeasureMode == YGMeasureModeUndefined</span>
          <span class="s1">: </span><span class="s5">true,</span>
      <span class="s3">&quot;availableHeight is indefinite so heightMeasureMode must be &quot;</span>
      <span class="s3">&quot;YGMeasureModeUndefined&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s1">(performLayout ? layoutMarkerData.layouts : layoutMarkerData.measures) += </span><span class="s4">1</span><span class="s5">;</span>

  <span class="s0">// Set the resolved resolution in the node's layout.</span>
  <span class="s5">const </span><span class="s1">YGDirection direction = node-&gt;resolveDirection(ownerDirection)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutDirection(direction)</span><span class="s5">;</span>

  <span class="s5">const </span><span class="s1">YGFlexDirection flexRowDirection =</span>
      <span class="s1">YGResolveFlexDirection(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">direction)</span><span class="s5">;</span>
  <span class="s5">const </span><span class="s1">YGFlexDirection flexColumnDirection =</span>
      <span class="s1">YGResolveFlexDirection(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">direction)</span><span class="s5">;</span>

  <span class="s5">const </span><span class="s1">YGEdge startEdge =</span>
      <span class="s1">direction == YGDirectionLTR ? YGEdgeLeft : YGEdgeRight</span><span class="s5">;</span>
  <span class="s5">const </span><span class="s1">YGEdge endEdge = direction == YGDirectionLTR ? YGEdgeRight : YGEdgeLeft</span><span class="s5">;</span>

  <span class="s5">const float </span><span class="s1">marginRowLeading =</span>
      <span class="s1">node-&gt;getLeadingMargin(flexRowDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutMargin(marginRowLeading</span><span class="s5">, </span><span class="s1">startEdge)</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">marginRowTrailing =</span>
      <span class="s1">node-&gt;getTrailingMargin(flexRowDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutMargin(marginRowTrailing</span><span class="s5">, </span><span class="s1">endEdge)</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">marginColumnLeading =</span>
      <span class="s1">node-&gt;getLeadingMargin(flexColumnDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutMargin(marginColumnLeading</span><span class="s5">, </span><span class="s1">YGEdgeTop)</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">marginColumnTrailing =</span>
      <span class="s1">node-&gt;getTrailingMargin(flexColumnDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutMargin(marginColumnTrailing</span><span class="s5">, </span><span class="s1">YGEdgeBottom)</span><span class="s5">;</span>

  <span class="s5">const float </span><span class="s1">marginAxisRow = marginRowLeading + marginRowTrailing</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">marginAxisColumn = marginColumnLeading + marginColumnTrailing</span><span class="s5">;</span>

  <span class="s1">node-&gt;setLayoutBorder(node-&gt;getLeadingBorder(flexRowDirection)</span><span class="s5">, </span><span class="s1">startEdge)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutBorder(node-&gt;getTrailingBorder(flexRowDirection)</span><span class="s5">, </span><span class="s1">endEdge)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutBorder(node-&gt;getLeadingBorder(flexColumnDirection)</span><span class="s5">, </span><span class="s1">YGEdgeTop)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutBorder(</span>
      <span class="s1">node-&gt;getTrailingBorder(flexColumnDirection)</span><span class="s5">, </span><span class="s1">YGEdgeBottom)</span><span class="s5">;</span>

  <span class="s1">node-&gt;setLayoutPadding(</span>
      <span class="s1">node-&gt;getLeadingPadding(flexRowDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">,</span>
      <span class="s1">startEdge)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutPadding(</span>
      <span class="s1">node-&gt;getTrailingPadding(flexRowDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">, </span><span class="s1">endEdge)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutPadding(</span>
      <span class="s1">node-&gt;getLeadingPadding(flexColumnDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">,</span>
      <span class="s1">YGEdgeTop)</span><span class="s5">;</span>
  <span class="s1">node-&gt;setLayoutPadding(</span>
      <span class="s1">node-&gt;getTrailingPadding(flexColumnDirection</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">,</span>
      <span class="s1">YGEdgeBottom)</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(node-&gt;hasMeasureFunc()) {</span>
    <span class="s1">YGNodeWithMeasureFuncSetMeasuredDimensions(</span>
        <span class="s1">node</span><span class="s5">,</span>
        <span class="s1">availableWidth - marginAxisRow</span><span class="s5">,</span>
        <span class="s1">availableHeight - marginAxisColumn</span><span class="s5">,</span>
        <span class="s1">widthMeasureMode</span><span class="s5">,</span>
        <span class="s1">heightMeasureMode</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">ownerHeight</span><span class="s5">,</span>
        <span class="s1">layoutMarkerData</span><span class="s5">,</span>
        <span class="s1">layoutContext</span><span class="s5">,</span>
        <span class="s1">reason)</span><span class="s5">;</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s5">const </span><span class="s1">uint32_t childCount = YGNodeGetChildCount(node)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(childCount == </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">YGNodeEmptyContainerSetMeasuredDimensions(</span>
        <span class="s1">node</span><span class="s5">,</span>
        <span class="s1">availableWidth - marginAxisRow</span><span class="s5">,</span>
        <span class="s1">availableHeight - marginAxisColumn</span><span class="s5">,</span>
        <span class="s1">widthMeasureMode</span><span class="s5">,</span>
        <span class="s1">heightMeasureMode</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">ownerHeight)</span><span class="s5">;</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s0">// If we're not being asked to perform a full layout we can skip the algorithm</span>
  <span class="s0">// if we already know the size</span>
  <span class="s5">if </span><span class="s1">(!performLayout &amp;&amp;</span>
      <span class="s1">YGNodeFixedSizeSetMeasuredDimensions(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">availableWidth - marginAxisRow</span><span class="s5">,</span>
          <span class="s1">availableHeight - marginAxisColumn</span><span class="s5">,</span>
          <span class="s1">widthMeasureMode</span><span class="s5">,</span>
          <span class="s1">heightMeasureMode</span><span class="s5">,</span>
          <span class="s1">ownerWidth</span><span class="s5">,</span>
          <span class="s1">ownerHeight)) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s0">// At this point we know we're going to perform work. Ensure that each child</span>
  <span class="s0">// has a mutable copy.</span>
  <span class="s1">node-&gt;cloneChildrenIfNeeded(layoutContext)</span><span class="s5">;</span>
  <span class="s0">// Reset layout flags, as they could have changed.</span>
  <span class="s1">node-&gt;setLayoutHadOverflow(</span><span class="s5">false</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s0">// STEP 1: CALCULATE VALUES FOR REMAINDER OF ALGORITHM</span>
  <span class="s5">const </span><span class="s1">YGFlexDirection mainAxis =</span>
      <span class="s1">YGResolveFlexDirection(node-&gt;getStyle().flexDirection()</span><span class="s5">, </span><span class="s1">direction)</span><span class="s5">;</span>
  <span class="s5">const </span><span class="s1">YGFlexDirection crossAxis = YGFlexDirectionCross(mainAxis</span><span class="s5">, </span><span class="s1">direction)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isMainAxisRow = YGFlexDirectionIsRow(mainAxis)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">isNodeFlexWrap = node-&gt;getStyle().flexWrap() != YGWrapNoWrap</span><span class="s5">;</span>

  <span class="s5">const float </span><span class="s1">mainAxisownerSize = isMainAxisRow ? ownerWidth : ownerHeight</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">crossAxisownerSize = isMainAxisRow ? ownerHeight : ownerWidth</span><span class="s5">;</span>

  <span class="s5">const float </span><span class="s1">paddingAndBorderAxisMain =</span>
      <span class="s1">YGNodePaddingAndBorderForAxis(node</span><span class="s5">, </span><span class="s1">mainAxis</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">leadingPaddingAndBorderCross =</span>
      <span class="s1">node-&gt;getLeadingPaddingAndBorder(crossAxis</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">trailingPaddingAndBorderCross =</span>
      <span class="s1">node-&gt;getTrailingPaddingAndBorder(crossAxis</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">paddingAndBorderAxisCross =</span>
      <span class="s1">leadingPaddingAndBorderCross + trailingPaddingAndBorderCross</span><span class="s5">;</span>

  <span class="s1">YGMeasureMode measureModeMainDim =</span>
      <span class="s1">isMainAxisRow ? widthMeasureMode : heightMeasureMode</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode measureModeCrossDim =</span>
      <span class="s1">isMainAxisRow ? heightMeasureMode : widthMeasureMode</span><span class="s5">;</span>

  <span class="s5">const float </span><span class="s1">paddingAndBorderAxisRow =</span>
      <span class="s1">isMainAxisRow ? paddingAndBorderAxisMain : paddingAndBorderAxisCross</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">paddingAndBorderAxisColumn =</span>
      <span class="s1">isMainAxisRow ? paddingAndBorderAxisCross : paddingAndBorderAxisMain</span><span class="s5">;</span>

  <span class="s0">// STEP 2: DETERMINE AVAILABLE SIZE IN MAIN AND CROSS DIRECTIONS</span>

  <span class="s5">float </span><span class="s1">availableInnerWidth = YGNodeCalculateAvailableInnerDim(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">YGDimensionWidth</span><span class="s5">,</span>
      <span class="s1">availableWidth - marginAxisRow</span><span class="s5">,</span>
      <span class="s1">paddingAndBorderAxisRow</span><span class="s5">,</span>
      <span class="s1">ownerWidth)</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">availableInnerHeight = YGNodeCalculateAvailableInnerDim(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">YGDimensionHeight</span><span class="s5">,</span>
      <span class="s1">availableHeight - marginAxisColumn</span><span class="s5">,</span>
      <span class="s1">paddingAndBorderAxisColumn</span><span class="s5">,</span>
      <span class="s1">ownerHeight)</span><span class="s5">;</span>

  <span class="s5">float </span><span class="s1">availableInnerMainDim =</span>
      <span class="s1">isMainAxisRow ? availableInnerWidth : availableInnerHeight</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">availableInnerCrossDim =</span>
      <span class="s1">isMainAxisRow ? availableInnerHeight : availableInnerWidth</span><span class="s5">;</span>

  <span class="s0">// STEP 3: DETERMINE FLEX BASIS FOR EACH ITEM</span>

  <span class="s0">// Computed basis + margins + gap</span>
  <span class="s5">float </span><span class="s1">totalMainDim = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s1">totalMainDim += YGNodeComputeFlexBasisForChildren(</span>
      <span class="s1">node</span><span class="s5">,</span>
      <span class="s1">availableInnerWidth</span><span class="s5">,</span>
      <span class="s1">availableInnerHeight</span><span class="s5">,</span>
      <span class="s1">widthMeasureMode</span><span class="s5">,</span>
      <span class="s1">heightMeasureMode</span><span class="s5">,</span>
      <span class="s1">direction</span><span class="s5">,</span>
      <span class="s1">mainAxis</span><span class="s5">,</span>
      <span class="s1">config</span><span class="s5">,</span>
      <span class="s1">performLayout</span><span class="s5">,</span>
      <span class="s1">layoutMarkerData</span><span class="s5">,</span>
      <span class="s1">layoutContext</span><span class="s5">,</span>
      <span class="s1">depth</span><span class="s5">,</span>
      <span class="s1">generationCount)</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(childCount &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">totalMainDim +=</span>
        <span class="s1">node-&gt;getGapForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim).unwrap() *</span>
        <span class="s1">(childCount - </span><span class="s4">1</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">const bool </span><span class="s1">mainAxisOverflows =</span>
      <span class="s1">(measureModeMainDim != YGMeasureModeUndefined) &amp;&amp;</span>
      <span class="s1">totalMainDim &gt; availableInnerMainDim</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(isNodeFlexWrap &amp;&amp; mainAxisOverflows &amp;&amp;</span>
      <span class="s1">measureModeMainDim == YGMeasureModeAtMost) {</span>
    <span class="s1">measureModeMainDim = YGMeasureModeExactly</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s0">// STEP 4: COLLECT FLEX ITEMS INTO FLEX LINES</span>

  <span class="s0">// Indexes of children that represent the first and last items in the line.</span>
  <span class="s1">uint32_t startOfLineIndex = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s1">uint32_t endOfLineIndex = </span><span class="s4">0</span><span class="s5">;</span>

  <span class="s0">// Number of lines.</span>
  <span class="s1">uint32_t lineCount = </span><span class="s4">0</span><span class="s5">;</span>

  <span class="s0">// Accumulated cross dimensions of all lines so far.</span>
  <span class="s5">float </span><span class="s1">totalLineCrossDim = </span><span class="s4">0</span><span class="s5">;</span>

  <span class="s5">const float </span><span class="s1">crossAxisGap =</span>
      <span class="s1">node-&gt;getGapForAxis(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim).unwrap()</span><span class="s5">;</span>

  <span class="s0">// Max main dimension of all the lines.</span>
  <span class="s5">float </span><span class="s1">maxLineMainDim = </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s1">YGCollectFlexItemsRowValues collectedFlexItemsValues</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(</span><span class="s5">; </span><span class="s1">endOfLineIndex &lt; childCount</span><span class="s5">;</span>
       <span class="s1">lineCount++</span><span class="s5">, </span><span class="s1">startOfLineIndex = endOfLineIndex) {</span>
    <span class="s1">collectedFlexItemsValues = YGCalculateCollectFlexItemsRowValues(</span>
        <span class="s1">node</span><span class="s5">,</span>
        <span class="s1">ownerDirection</span><span class="s5">,</span>
        <span class="s1">mainAxisownerSize</span><span class="s5">,</span>
        <span class="s1">availableInnerWidth</span><span class="s5">,</span>
        <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
        <span class="s1">startOfLineIndex</span><span class="s5">,</span>
        <span class="s1">lineCount)</span><span class="s5">;</span>
    <span class="s1">endOfLineIndex = collectedFlexItemsValues.endOfLineIndex</span><span class="s5">;</span>

    <span class="s0">// If we don't need to measure the cross axis, we can skip the entire flex</span>
    <span class="s0">// step.</span>
    <span class="s5">const bool </span><span class="s1">canSkipFlex =</span>
        <span class="s1">!performLayout &amp;&amp; measureModeCrossDim == YGMeasureModeExactly</span><span class="s5">;</span>

    <span class="s0">// STEP 5: RESOLVING FLEXIBLE LENGTHS ON MAIN AXIS</span>
    <span class="s0">// Calculate the remaining available space that needs to be allocated. If</span>
    <span class="s0">// the main dimension size isn't known, it is computed based on the line</span>
    <span class="s0">// length, so there's no more space left to distribute.</span>

    <span class="s5">bool </span><span class="s1">sizeBasedOnContent = </span><span class="s5">false;</span>
    <span class="s0">// If we don't measure with exact main dimension we want to ensure we don't</span>
    <span class="s0">// violate min and max</span>
    <span class="s5">if </span><span class="s1">(measureModeMainDim != YGMeasureModeExactly) {</span>
      <span class="s5">const auto</span><span class="s1">&amp; minDimensions = node-&gt;getStyle().minDimensions()</span><span class="s5">;</span>
      <span class="s5">const auto</span><span class="s1">&amp; maxDimensions = node-&gt;getStyle().maxDimensions()</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">minInnerWidth =</span>
          <span class="s1">YGResolveValue(minDimensions[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap() -</span>
          <span class="s1">paddingAndBorderAxisRow</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">maxInnerWidth =</span>
          <span class="s1">YGResolveValue(maxDimensions[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap() -</span>
          <span class="s1">paddingAndBorderAxisRow</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">minInnerHeight =</span>
          <span class="s1">YGResolveValue(minDimensions[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">ownerHeight)</span>
              <span class="s1">.unwrap() -</span>
          <span class="s1">paddingAndBorderAxisColumn</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">maxInnerHeight =</span>
          <span class="s1">YGResolveValue(maxDimensions[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">ownerHeight)</span>
              <span class="s1">.unwrap() -</span>
          <span class="s1">paddingAndBorderAxisColumn</span><span class="s5">;</span>

      <span class="s5">const float </span><span class="s1">minInnerMainDim =</span>
          <span class="s1">isMainAxisRow ? minInnerWidth : minInnerHeight</span><span class="s5">;</span>
      <span class="s5">const float </span><span class="s1">maxInnerMainDim =</span>
          <span class="s1">isMainAxisRow ? maxInnerWidth : maxInnerHeight</span><span class="s5">;</span>

      <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(minInnerMainDim) &amp;&amp;</span>
          <span class="s1">collectedFlexItemsValues.sizeConsumedOnCurrentLine &lt;</span>
              <span class="s1">minInnerMainDim) {</span>
        <span class="s1">availableInnerMainDim = minInnerMainDim</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
          <span class="s1">!YGFloatIsUndefined(maxInnerMainDim) &amp;&amp;</span>
          <span class="s1">collectedFlexItemsValues.sizeConsumedOnCurrentLine &gt;</span>
              <span class="s1">maxInnerMainDim) {</span>
        <span class="s1">availableInnerMainDim = maxInnerMainDim</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
        <span class="s5">if </span><span class="s1">(!node-&gt;getConfig()-&gt;useLegacyStretchBehaviour &amp;&amp;</span>
            <span class="s1">((!YGFloatIsUndefined(</span>
                  <span class="s1">collectedFlexItemsValues.totalFlexGrowFactors) &amp;&amp;</span>
              <span class="s1">collectedFlexItemsValues.totalFlexGrowFactors == </span><span class="s4">0</span><span class="s1">) ||</span>
             <span class="s1">(!YGFloatIsUndefined(node-&gt;resolveFlexGrow()) &amp;&amp;</span>
              <span class="s1">node-&gt;resolveFlexGrow() == </span><span class="s4">0</span><span class="s1">))) {</span>
          <span class="s0">// If we don't have any children to flex or we can't flex the node</span>
          <span class="s0">// itself, space we've used is all space we need. Root node also</span>
          <span class="s0">// should be shrunk to minimum</span>
          <span class="s1">availableInnerMainDim =</span>
              <span class="s1">collectedFlexItemsValues.sizeConsumedOnCurrentLine</span><span class="s5">;</span>
        <span class="s1">}</span>

        <span class="s1">sizeBasedOnContent = !node-&gt;getConfig()-&gt;useLegacyStretchBehaviour</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(!sizeBasedOnContent &amp;&amp; !YGFloatIsUndefined(availableInnerMainDim)) {</span>
      <span class="s1">collectedFlexItemsValues.remainingFreeSpace = availableInnerMainDim -</span>
          <span class="s1">collectedFlexItemsValues.sizeConsumedOnCurrentLine</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else if </span><span class="s1">(collectedFlexItemsValues.sizeConsumedOnCurrentLine &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">// availableInnerMainDim is indefinite which means the node is being sized</span>
      <span class="s0">// based on its content. sizeConsumedOnCurrentLine is negative which means</span>
      <span class="s0">// the node will allocate 0 points for its content. Consequently,</span>
      <span class="s0">// remainingFreeSpace is 0 - sizeConsumedOnCurrentLine.</span>
      <span class="s1">collectedFlexItemsValues.remainingFreeSpace =</span>
          <span class="s1">-collectedFlexItemsValues.sizeConsumedOnCurrentLine</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s5">if </span><span class="s1">(!canSkipFlex) {</span>
      <span class="s1">YGResolveFlexibleLength(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">collectedFlexItemsValues</span><span class="s5">,</span>
          <span class="s1">mainAxis</span><span class="s5">,</span>
          <span class="s1">crossAxis</span><span class="s5">,</span>
          <span class="s1">mainAxisownerSize</span><span class="s5">,</span>
          <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
          <span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
          <span class="s1">availableInnerWidth</span><span class="s5">,</span>
          <span class="s1">availableInnerHeight</span><span class="s5">,</span>
          <span class="s1">mainAxisOverflows</span><span class="s5">,</span>
          <span class="s1">measureModeCrossDim</span><span class="s5">,</span>
          <span class="s1">performLayout</span><span class="s5">,</span>
          <span class="s1">config</span><span class="s5">,</span>
          <span class="s1">layoutMarkerData</span><span class="s5">,</span>
          <span class="s1">layoutContext</span><span class="s5">,</span>
          <span class="s1">depth</span><span class="s5">,</span>
          <span class="s1">generationCount)</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">node-&gt;setLayoutHadOverflow(</span>
        <span class="s1">node-&gt;getLayout().hadOverflow() |</span>
        <span class="s1">(collectedFlexItemsValues.remainingFreeSpace &lt; </span><span class="s4">0</span><span class="s1">))</span><span class="s5">;</span>

    <span class="s0">// STEP 6: MAIN-AXIS JUSTIFICATION &amp; CROSS-AXIS SIZE DETERMINATION</span>

    <span class="s0">// At this point, all the children have their dimensions set in the main</span>
    <span class="s0">// axis. Their dimensions are also set in the cross axis with the exception</span>
    <span class="s0">// of items that are aligned &quot;stretch&quot;. We need to compute these stretch</span>
    <span class="s0">// values and set the final positions.</span>

    <span class="s1">YGJustifyMainAxis(</span>
        <span class="s1">node</span><span class="s5">,</span>
        <span class="s1">collectedFlexItemsValues</span><span class="s5">,</span>
        <span class="s1">startOfLineIndex</span><span class="s5">,</span>
        <span class="s1">mainAxis</span><span class="s5">,</span>
        <span class="s1">crossAxis</span><span class="s5">,</span>
        <span class="s1">measureModeMainDim</span><span class="s5">,</span>
        <span class="s1">measureModeCrossDim</span><span class="s5">,</span>
        <span class="s1">mainAxisownerSize</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
        <span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
        <span class="s1">availableInnerWidth</span><span class="s5">,</span>
        <span class="s1">performLayout</span><span class="s5">,</span>
        <span class="s1">layoutContext)</span><span class="s5">;</span>

    <span class="s5">float </span><span class="s1">containerCrossAxis = availableInnerCrossDim</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(measureModeCrossDim == YGMeasureModeUndefined ||</span>
        <span class="s1">measureModeCrossDim == YGMeasureModeAtMost) {</span>
      <span class="s0">// Compute the cross axis from the max cross dimension of the children.</span>
      <span class="s1">containerCrossAxis =</span>
          <span class="s1">YGNodeBoundAxis(</span>
              <span class="s1">node</span><span class="s5">,</span>
              <span class="s1">crossAxis</span><span class="s5">,</span>
              <span class="s1">collectedFlexItemsValues.crossDim + paddingAndBorderAxisCross</span><span class="s5">,</span>
              <span class="s1">crossAxisownerSize</span><span class="s5">,</span>
              <span class="s1">ownerWidth) -</span>
          <span class="s1">paddingAndBorderAxisCross</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s0">// If there's no flex wrap, the cross dimension is defined by the container.</span>
    <span class="s5">if </span><span class="s1">(!isNodeFlexWrap &amp;&amp; measureModeCrossDim == YGMeasureModeExactly) {</span>
      <span class="s1">collectedFlexItemsValues.crossDim = availableInnerCrossDim</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s0">// Clamp to the min/max size specified on the container.</span>
    <span class="s1">collectedFlexItemsValues.crossDim =</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">,</span>
            <span class="s1">crossAxis</span><span class="s5">,</span>
            <span class="s1">collectedFlexItemsValues.crossDim + paddingAndBorderAxisCross</span><span class="s5">,</span>
            <span class="s1">crossAxisownerSize</span><span class="s5">,</span>
            <span class="s1">ownerWidth) -</span>
        <span class="s1">paddingAndBorderAxisCross</span><span class="s5">;</span>

    <span class="s0">// STEP 7: CROSS-AXIS ALIGNMENT</span>
    <span class="s0">// We can skip child alignment if we're just measuring the container.</span>
    <span class="s5">if </span><span class="s1">(performLayout) {</span>
      <span class="s5">for </span><span class="s1">(uint32_t i = startOfLineIndex</span><span class="s5">; </span><span class="s1">i &lt; endOfLineIndex</span><span class="s5">; </span><span class="s1">i++) {</span>
        <span class="s5">const </span><span class="s1">YGNodeRef child = node-&gt;getChild(i)</span><span class="s5">;</span>
        <span class="s5">if </span><span class="s1">(child-&gt;getStyle().display() == YGDisplayNone) {</span>
          <span class="s5">continue;</span>
        <span class="s1">}</span>
        <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() == YGPositionTypeAbsolute) {</span>
          <span class="s0">// If the child is absolutely positioned and has a</span>
          <span class="s0">// top/left/bottom/right set, override all the previously computed</span>
          <span class="s0">// positions to set it correctly.</span>
          <span class="s5">const bool </span><span class="s1">isChildLeadingPosDefined =</span>
              <span class="s1">child-&gt;isLeadingPositionDefined(crossAxis)</span><span class="s5">;</span>
          <span class="s5">if </span><span class="s1">(isChildLeadingPosDefined) {</span>
            <span class="s1">child-&gt;setLayoutPosition(</span>
                <span class="s1">child-&gt;getLeadingPosition(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim)</span>
                        <span class="s1">.unwrap() +</span>
                    <span class="s1">node-&gt;getLeadingBorder(crossAxis) +</span>
                    <span class="s1">child-&gt;getLeadingMargin(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                        <span class="s1">.unwrap()</span><span class="s5">,</span>
                <span class="s1">pos[crossAxis])</span><span class="s5">;</span>
          <span class="s1">}</span>
          <span class="s0">// If leading position is not defined or calculations result in Nan,</span>
          <span class="s0">// default to border + margin</span>
          <span class="s5">if </span><span class="s1">(!isChildLeadingPosDefined ||</span>
              <span class="s1">YGFloatIsUndefined(child-&gt;getLayout().position[pos[crossAxis]])) {</span>
            <span class="s1">child-&gt;setLayoutPosition(</span>
                <span class="s1">node-&gt;getLeadingBorder(crossAxis) +</span>
                    <span class="s1">child-&gt;getLeadingMargin(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                        <span class="s1">.unwrap()</span><span class="s5">,</span>
                <span class="s1">pos[crossAxis])</span><span class="s5">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
          <span class="s5">float </span><span class="s1">leadingCrossDim = leadingPaddingAndBorderCross</span><span class="s5">;</span>

          <span class="s0">// For a relative children, we're either using alignItems (owner) or</span>
          <span class="s0">// alignSelf (child) in order to determine the position in the cross</span>
          <span class="s0">// axis</span>
          <span class="s5">const </span><span class="s1">YGAlign alignItem = YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child)</span><span class="s5">;</span>

          <span class="s0">// If the child uses align stretch, we need to lay it out one more</span>
          <span class="s0">// time, this time forcing the cross-axis size to be the computed</span>
          <span class="s0">// cross size for the current line.</span>
          <span class="s5">if </span><span class="s1">(alignItem == YGAlignStretch &amp;&amp;</span>
              <span class="s1">child-&gt;marginLeadingValue(crossAxis).unit != YGUnitAuto &amp;&amp;</span>
              <span class="s1">child-&gt;marginTrailingValue(crossAxis).unit != YGUnitAuto) {</span>
            <span class="s0">// If the child defines a definite size for its cross axis, there's</span>
            <span class="s0">// no need to stretch.</span>
            <span class="s5">if </span><span class="s1">(!YGNodeIsStyleDimDefined(</span>
                    <span class="s1">child</span><span class="s5">, </span><span class="s1">crossAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim)) {</span>
              <span class="s5">float </span><span class="s1">childMainSize =</span>
                  <span class="s1">child-&gt;getLayout().measuredDimensions[dim[mainAxis]]</span><span class="s5">;</span>
              <span class="s5">const auto</span><span class="s1">&amp; childStyle = child-&gt;getStyle()</span><span class="s5">;</span>
              <span class="s5">float </span><span class="s1">childCrossSize = !childStyle.aspectRatio().isUndefined()</span>
                  <span class="s1">? child-&gt;getMarginForAxis(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                          <span class="s1">.unwrap() +</span>
                      <span class="s1">(isMainAxisRow</span>
                           <span class="s1">? childMainSize / childStyle.aspectRatio().unwrap()</span>
                           <span class="s1">: childMainSize * childStyle.aspectRatio().unwrap())</span>
                  <span class="s1">: collectedFlexItemsValues.crossDim</span><span class="s5">;</span>

              <span class="s1">childMainSize +=</span>
                  <span class="s1">child-&gt;getMarginForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                      <span class="s1">.unwrap()</span><span class="s5">;</span>

              <span class="s1">YGMeasureMode childMainMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
              <span class="s1">YGMeasureMode childCrossMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
              <span class="s1">YGConstrainMaxSizeForMode(</span>
                  <span class="s1">child</span><span class="s5">,</span>
                  <span class="s1">mainAxis</span><span class="s5">,</span>
                  <span class="s1">availableInnerMainDim</span><span class="s5">,</span>
                  <span class="s1">availableInnerWidth</span><span class="s5">,</span>
                  <span class="s1">&amp;childMainMeasureMode</span><span class="s5">,</span>
                  <span class="s1">&amp;childMainSize)</span><span class="s5">;</span>
              <span class="s1">YGConstrainMaxSizeForMode(</span>
                  <span class="s1">child</span><span class="s5">,</span>
                  <span class="s1">crossAxis</span><span class="s5">,</span>
                  <span class="s1">availableInnerCrossDim</span><span class="s5">,</span>
                  <span class="s1">availableInnerWidth</span><span class="s5">,</span>
                  <span class="s1">&amp;childCrossMeasureMode</span><span class="s5">,</span>
                  <span class="s1">&amp;childCrossSize)</span><span class="s5">;</span>

              <span class="s5">const float </span><span class="s1">childWidth =</span>
                  <span class="s1">isMainAxisRow ? childMainSize : childCrossSize</span><span class="s5">;</span>
              <span class="s5">const float </span><span class="s1">childHeight =</span>
                  <span class="s1">!isMainAxisRow ? childMainSize : childCrossSize</span><span class="s5">;</span>

              <span class="s5">auto </span><span class="s1">alignContent = node-&gt;getStyle().alignContent()</span><span class="s5">;</span>
              <span class="s5">auto </span><span class="s1">crossAxisDoesNotGrow =</span>
                  <span class="s1">alignContent != YGAlignStretch &amp;&amp; isNodeFlexWrap</span><span class="s5">;</span>
              <span class="s5">const </span><span class="s1">YGMeasureMode childWidthMeasureMode =</span>
                  <span class="s1">YGFloatIsUndefined(childWidth) ||</span>
                      <span class="s1">(!isMainAxisRow &amp;&amp; crossAxisDoesNotGrow)</span>
                  <span class="s1">? YGMeasureModeUndefined</span>
                  <span class="s1">: YGMeasureModeExactly</span><span class="s5">;</span>
              <span class="s5">const </span><span class="s1">YGMeasureMode childHeightMeasureMode =</span>
                  <span class="s1">YGFloatIsUndefined(childHeight) ||</span>
                      <span class="s1">(isMainAxisRow &amp;&amp; crossAxisDoesNotGrow)</span>
                  <span class="s1">? YGMeasureModeUndefined</span>
                  <span class="s1">: YGMeasureModeExactly</span><span class="s5">;</span>

              <span class="s1">YGLayoutNodeInternal(</span>
                  <span class="s1">child</span><span class="s5">,</span>
                  <span class="s1">childWidth</span><span class="s5">,</span>
                  <span class="s1">childHeight</span><span class="s5">,</span>
                  <span class="s1">direction</span><span class="s5">,</span>
                  <span class="s1">childWidthMeasureMode</span><span class="s5">,</span>
                  <span class="s1">childHeightMeasureMode</span><span class="s5">,</span>
                  <span class="s1">availableInnerWidth</span><span class="s5">,</span>
                  <span class="s1">availableInnerHeight</span><span class="s5">,</span>
                  <span class="s5">true,</span>
                  <span class="s1">LayoutPassReason::kStretch</span><span class="s5">,</span>
                  <span class="s1">config</span><span class="s5">,</span>
                  <span class="s1">layoutMarkerData</span><span class="s5">,</span>
                  <span class="s1">layoutContext</span><span class="s5">,</span>
                  <span class="s1">depth</span><span class="s5">,</span>
                  <span class="s1">generationCount)</span><span class="s5">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
            <span class="s5">const float </span><span class="s1">remainingCrossDim = containerCrossAxis -</span>
                <span class="s1">YGNodeDimWithMargin(child</span><span class="s5">, </span><span class="s1">crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span><span class="s5">;</span>

            <span class="s5">if </span><span class="s1">(child-&gt;marginLeadingValue(crossAxis).unit == YGUnitAuto &amp;&amp;</span>
                <span class="s1">child-&gt;marginTrailingValue(crossAxis).unit == YGUnitAuto) {</span>
              <span class="s1">leadingCrossDim += YGFloatMax(</span><span class="s4">0.0f</span><span class="s5">, </span><span class="s1">remainingCrossDim / </span><span class="s4">2</span><span class="s1">)</span><span class="s5">;</span>
            <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
                <span class="s1">child-&gt;marginTrailingValue(crossAxis).unit == YGUnitAuto) {</span>
              <span class="s0">// No-Op</span>
            <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
                <span class="s1">child-&gt;marginLeadingValue(crossAxis).unit == YGUnitAuto) {</span>
              <span class="s1">leadingCrossDim += YGFloatMax(</span><span class="s4">0.0f</span><span class="s5">, </span><span class="s1">remainingCrossDim)</span><span class="s5">;</span>
            <span class="s1">} </span><span class="s5">else if </span><span class="s1">(alignItem == YGAlignFlexStart) {</span>
              <span class="s0">// No-Op</span>
            <span class="s1">} </span><span class="s5">else if </span><span class="s1">(alignItem == YGAlignCenter) {</span>
              <span class="s1">leadingCrossDim += remainingCrossDim / </span><span class="s4">2</span><span class="s5">;</span>
            <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
              <span class="s1">leadingCrossDim += remainingCrossDim</span><span class="s5">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">// And we apply the position</span>
          <span class="s1">child-&gt;setLayoutPosition(</span>
              <span class="s1">child-&gt;getLayout().position[pos[crossAxis]] + totalLineCrossDim +</span>
                  <span class="s1">leadingCrossDim</span><span class="s5">,</span>
              <span class="s1">pos[crossAxis])</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s5">const float </span><span class="s1">appliedCrossGap = lineCount != </span><span class="s4">0 </span><span class="s1">? crossAxisGap : </span><span class="s4">0.0f</span><span class="s5">;</span>
    <span class="s1">totalLineCrossDim += collectedFlexItemsValues.crossDim + appliedCrossGap</span><span class="s5">;</span>
    <span class="s1">maxLineMainDim =</span>
        <span class="s1">YGFloatMax(maxLineMainDim</span><span class="s5">, </span><span class="s1">collectedFlexItemsValues.mainDim)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// STEP 8: MULTI-LINE CONTENT ALIGNMENT</span>
  <span class="s0">// currentLead stores the size of the cross dim</span>
  <span class="s5">if </span><span class="s1">(performLayout &amp;&amp; (isNodeFlexWrap || YGIsBaselineLayout(node))) {</span>
    <span class="s5">float </span><span class="s1">crossDimLead = </span><span class="s4">0</span><span class="s5">;</span>
    <span class="s5">float </span><span class="s1">currentLead = leadingPaddingAndBorderCross</span><span class="s5">;</span>
    <span class="s5">if </span><span class="s1">(!YGFloatIsUndefined(availableInnerCrossDim)) {</span>
      <span class="s5">const float </span><span class="s1">remainingAlignContentDim =</span>
          <span class="s1">availableInnerCrossDim - totalLineCrossDim</span><span class="s5">;</span>
      <span class="s5">switch </span><span class="s1">(node-&gt;getStyle().alignContent()) {</span>
        <span class="s5">case </span><span class="s1">YGAlignFlexEnd:</span>
          <span class="s1">currentLead += remainingAlignContentDim</span><span class="s5">;</span>
          <span class="s5">break;</span>
        <span class="s5">case </span><span class="s1">YGAlignCenter:</span>
          <span class="s1">currentLead += remainingAlignContentDim / </span><span class="s4">2</span><span class="s5">;</span>
          <span class="s5">break;</span>
        <span class="s5">case </span><span class="s1">YGAlignStretch:</span>
          <span class="s5">if </span><span class="s1">(availableInnerCrossDim &gt; totalLineCrossDim) {</span>
            <span class="s1">crossDimLead = remainingAlignContentDim / lineCount</span><span class="s5">;</span>
          <span class="s1">}</span>
          <span class="s5">break;</span>
        <span class="s5">case </span><span class="s1">YGAlignSpaceAround:</span>
          <span class="s5">if </span><span class="s1">(availableInnerCrossDim &gt; totalLineCrossDim) {</span>
            <span class="s1">currentLead += remainingAlignContentDim / (</span><span class="s4">2 </span><span class="s1">* lineCount)</span><span class="s5">;</span>
            <span class="s5">if </span><span class="s1">(lineCount &gt; </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">crossDimLead = remainingAlignContentDim / lineCount</span><span class="s5">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
            <span class="s1">currentLead += remainingAlignContentDim / </span><span class="s4">2</span><span class="s5">;</span>
          <span class="s1">}</span>
          <span class="s5">break;</span>
        <span class="s5">case </span><span class="s1">YGAlignSpaceBetween:</span>
          <span class="s5">if </span><span class="s1">(availableInnerCrossDim &gt; totalLineCrossDim &amp;&amp; lineCount &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">crossDimLead = remainingAlignContentDim / (lineCount - </span><span class="s4">1</span><span class="s1">)</span><span class="s5">;</span>
          <span class="s1">}</span>
          <span class="s5">break;</span>
        <span class="s5">case </span><span class="s1">YGAlignAuto:</span>
        <span class="s5">case </span><span class="s1">YGAlignFlexStart:</span>
        <span class="s5">case </span><span class="s1">YGAlignBaseline:</span>
          <span class="s5">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">uint32_t endIndex = </span><span class="s4">0</span><span class="s5">;</span>
    <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; lineCount</span><span class="s5">; </span><span class="s1">i++) {</span>
      <span class="s5">const </span><span class="s1">uint32_t startIndex = endIndex</span><span class="s5">;</span>
      <span class="s1">uint32_t ii</span><span class="s5">;</span>

      <span class="s0">// compute the line's height and find the endIndex</span>
      <span class="s5">float </span><span class="s1">lineHeight = </span><span class="s4">0</span><span class="s5">;</span>
      <span class="s5">float </span><span class="s1">maxAscentForCurrentLine = </span><span class="s4">0</span><span class="s5">;</span>
      <span class="s5">float </span><span class="s1">maxDescentForCurrentLine = </span><span class="s4">0</span><span class="s5">;</span>
      <span class="s5">for </span><span class="s1">(ii = startIndex</span><span class="s5">; </span><span class="s1">ii &lt; childCount</span><span class="s5">; </span><span class="s1">ii++) {</span>
        <span class="s5">const </span><span class="s1">YGNodeRef child = node-&gt;getChild(ii)</span><span class="s5">;</span>
        <span class="s5">if </span><span class="s1">(child-&gt;getStyle().display() == YGDisplayNone) {</span>
          <span class="s5">continue;</span>
        <span class="s1">}</span>
        <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() != YGPositionTypeAbsolute) {</span>
          <span class="s5">if </span><span class="s1">(child-&gt;getLineIndex() != i) {</span>
            <span class="s5">break;</span>
          <span class="s1">}</span>
          <span class="s5">if </span><span class="s1">(YGNodeIsLayoutDimDefined(child</span><span class="s5">, </span><span class="s1">crossAxis)) {</span>
            <span class="s1">lineHeight = YGFloatMax(</span>
                <span class="s1">lineHeight</span><span class="s5">,</span>
                <span class="s1">child-&gt;getLayout().measuredDimensions[dim[crossAxis]] +</span>
                    <span class="s1">child-&gt;getMarginForAxis(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                        <span class="s1">.unwrap())</span><span class="s5">;</span>
          <span class="s1">}</span>
          <span class="s5">if </span><span class="s1">(YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child) == YGAlignBaseline) {</span>
            <span class="s5">const float </span><span class="s1">ascent = YGBaseline(child</span><span class="s5">, </span><span class="s1">layoutContext) +</span>
                <span class="s1">child</span>
                    <span class="s1">-&gt;getLeadingMargin(</span>
                        <span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                    <span class="s1">.unwrap()</span><span class="s5">;</span>
            <span class="s5">const float </span><span class="s1">descent =</span>
                <span class="s1">child-&gt;getLayout().measuredDimensions[YGDimensionHeight] +</span>
                <span class="s1">child</span>
                    <span class="s1">-&gt;getMarginForAxis(</span>
                        <span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                    <span class="s1">.unwrap() -</span>
                <span class="s1">ascent</span><span class="s5">;</span>
            <span class="s1">maxAscentForCurrentLine =</span>
                <span class="s1">YGFloatMax(maxAscentForCurrentLine</span><span class="s5">, </span><span class="s1">ascent)</span><span class="s5">;</span>
            <span class="s1">maxDescentForCurrentLine =</span>
                <span class="s1">YGFloatMax(maxDescentForCurrentLine</span><span class="s5">, </span><span class="s1">descent)</span><span class="s5">;</span>
            <span class="s1">lineHeight = YGFloatMax(</span>
                <span class="s1">lineHeight</span><span class="s5">, </span><span class="s1">maxAscentForCurrentLine + maxDescentForCurrentLine)</span><span class="s5">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">endIndex = ii</span><span class="s5">;</span>
      <span class="s1">lineHeight += crossDimLead</span><span class="s5">;</span>
      <span class="s1">currentLead += i != </span><span class="s4">0 </span><span class="s1">? crossAxisGap : </span><span class="s4">0</span><span class="s5">;</span>

      <span class="s5">if </span><span class="s1">(performLayout) {</span>
        <span class="s5">for </span><span class="s1">(ii = startIndex</span><span class="s5">; </span><span class="s1">ii &lt; endIndex</span><span class="s5">; </span><span class="s1">ii++) {</span>
          <span class="s5">const </span><span class="s1">YGNodeRef child = node-&gt;getChild(ii)</span><span class="s5">;</span>
          <span class="s5">if </span><span class="s1">(child-&gt;getStyle().display() == YGDisplayNone) {</span>
            <span class="s5">continue;</span>
          <span class="s1">}</span>
          <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() != YGPositionTypeAbsolute) {</span>
            <span class="s5">switch </span><span class="s1">(YGNodeAlignItem(node</span><span class="s5">, </span><span class="s1">child)) {</span>
              <span class="s5">case </span><span class="s1">YGAlignFlexStart: {</span>
                <span class="s1">child-&gt;setLayoutPosition(</span>
                    <span class="s1">currentLead +</span>
                        <span class="s1">child-&gt;getLeadingMargin(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                            <span class="s1">.unwrap()</span><span class="s5">,</span>
                    <span class="s1">pos[crossAxis])</span><span class="s5">;</span>
                <span class="s5">break;</span>
              <span class="s1">}</span>
              <span class="s5">case </span><span class="s1">YGAlignFlexEnd: {</span>
                <span class="s1">child-&gt;setLayoutPosition(</span>
                    <span class="s1">currentLead + lineHeight -</span>
                        <span class="s1">child-&gt;getTrailingMargin(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                            <span class="s1">.unwrap() -</span>
                        <span class="s1">child-&gt;getLayout().measuredDimensions[dim[crossAxis]]</span><span class="s5">,</span>
                    <span class="s1">pos[crossAxis])</span><span class="s5">;</span>
                <span class="s5">break;</span>
              <span class="s1">}</span>
              <span class="s5">case </span><span class="s1">YGAlignCenter: {</span>
                <span class="s5">float </span><span class="s1">childHeight =</span>
                    <span class="s1">child-&gt;getLayout().measuredDimensions[dim[crossAxis]]</span><span class="s5">;</span>

                <span class="s1">child-&gt;setLayoutPosition(</span>
                    <span class="s1">currentLead + (lineHeight - childHeight) / </span><span class="s4">2</span><span class="s5">,</span>
                    <span class="s1">pos[crossAxis])</span><span class="s5">;</span>
                <span class="s5">break;</span>
              <span class="s1">}</span>
              <span class="s5">case </span><span class="s1">YGAlignStretch: {</span>
                <span class="s1">child-&gt;setLayoutPosition(</span>
                    <span class="s1">currentLead +</span>
                        <span class="s1">child-&gt;getLeadingMargin(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                            <span class="s1">.unwrap()</span><span class="s5">,</span>
                    <span class="s1">pos[crossAxis])</span><span class="s5">;</span>

                <span class="s0">// Remeasure child with the line height as it as been only</span>
                <span class="s0">// measured with the owners height yet.</span>
                <span class="s5">if </span><span class="s1">(!YGNodeIsStyleDimDefined(</span>
                        <span class="s1">child</span><span class="s5">, </span><span class="s1">crossAxis</span><span class="s5">, </span><span class="s1">availableInnerCrossDim)) {</span>
                  <span class="s5">const float </span><span class="s1">childWidth = isMainAxisRow</span>
                      <span class="s1">? (child-&gt;getLayout()</span>
                             <span class="s1">.measuredDimensions[YGDimensionWidth] +</span>
                         <span class="s1">child-&gt;getMarginForAxis(mainAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                             <span class="s1">.unwrap())</span>
                      <span class="s1">: lineHeight</span><span class="s5">;</span>

                  <span class="s5">const float </span><span class="s1">childHeight = !isMainAxisRow</span>
                      <span class="s1">? (child-&gt;getLayout()</span>
                             <span class="s1">.measuredDimensions[YGDimensionHeight] +</span>
                         <span class="s1">child-&gt;getMarginForAxis(crossAxis</span><span class="s5">, </span><span class="s1">availableInnerWidth)</span>
                             <span class="s1">.unwrap())</span>
                      <span class="s1">: lineHeight</span><span class="s5">;</span>

                  <span class="s5">if </span><span class="s1">(!(YGFloatsEqual(</span>
                            <span class="s1">childWidth</span><span class="s5">,</span>
                            <span class="s1">child-&gt;getLayout()</span>
                                <span class="s1">.measuredDimensions[YGDimensionWidth]) &amp;&amp;</span>
                        <span class="s1">YGFloatsEqual(</span>
                            <span class="s1">childHeight</span><span class="s5">,</span>
                            <span class="s1">child-&gt;getLayout()</span>
                                <span class="s1">.measuredDimensions[YGDimensionHeight]))) {</span>
                    <span class="s1">YGLayoutNodeInternal(</span>
                        <span class="s1">child</span><span class="s5">,</span>
                        <span class="s1">childWidth</span><span class="s5">,</span>
                        <span class="s1">childHeight</span><span class="s5">,</span>
                        <span class="s1">direction</span><span class="s5">,</span>
                        <span class="s1">YGMeasureModeExactly</span><span class="s5">,</span>
                        <span class="s1">YGMeasureModeExactly</span><span class="s5">,</span>
                        <span class="s1">availableInnerWidth</span><span class="s5">,</span>
                        <span class="s1">availableInnerHeight</span><span class="s5">,</span>
                        <span class="s5">true,</span>
                        <span class="s1">LayoutPassReason::kMultilineStretch</span><span class="s5">,</span>
                        <span class="s1">config</span><span class="s5">,</span>
                        <span class="s1">layoutMarkerData</span><span class="s5">,</span>
                        <span class="s1">layoutContext</span><span class="s5">,</span>
                        <span class="s1">depth</span><span class="s5">,</span>
                        <span class="s1">generationCount)</span><span class="s5">;</span>
                  <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s5">break;</span>
              <span class="s1">}</span>
              <span class="s5">case </span><span class="s1">YGAlignBaseline: {</span>
                <span class="s1">child-&gt;setLayoutPosition(</span>
                    <span class="s1">currentLead + maxAscentForCurrentLine -</span>
                        <span class="s1">YGBaseline(child</span><span class="s5">, </span><span class="s1">layoutContext) +</span>
                        <span class="s1">child</span>
                            <span class="s1">-&gt;getLeadingPosition(</span>
                                <span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">availableInnerCrossDim)</span>
                            <span class="s1">.unwrap()</span><span class="s5">,</span>
                    <span class="s1">YGEdgeTop)</span><span class="s5">;</span>

                <span class="s5">break;</span>
              <span class="s1">}</span>
              <span class="s5">case </span><span class="s1">YGAlignAuto:</span>
              <span class="s5">case </span><span class="s1">YGAlignSpaceBetween:</span>
              <span class="s5">case </span><span class="s1">YGAlignSpaceAround:</span>
                <span class="s5">break;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">currentLead += lineHeight</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// STEP 9: COMPUTING FINAL DIMENSIONS</span>

  <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
      <span class="s1">YGNodeBoundAxis(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGFlexDirectionRow</span><span class="s5">,</span>
          <span class="s1">availableWidth - marginAxisRow</span><span class="s5">,</span>
          <span class="s1">ownerWidth</span><span class="s5">,</span>
          <span class="s1">ownerWidth)</span><span class="s5">,</span>
      <span class="s1">YGDimensionWidth)</span><span class="s5">;</span>

  <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
      <span class="s1">YGNodeBoundAxis(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGFlexDirectionColumn</span><span class="s5">,</span>
          <span class="s1">availableHeight - marginAxisColumn</span><span class="s5">,</span>
          <span class="s1">ownerHeight</span><span class="s5">,</span>
          <span class="s1">ownerWidth)</span><span class="s5">,</span>
      <span class="s1">YGDimensionHeight)</span><span class="s5">;</span>

  <span class="s0">// If the user didn't specify a width or height for the node, set the</span>
  <span class="s0">// dimensions based on the children.</span>
  <span class="s5">if </span><span class="s1">(measureModeMainDim == YGMeasureModeUndefined ||</span>
      <span class="s1">(node-&gt;getStyle().overflow() != YGOverflowScroll &amp;&amp;</span>
       <span class="s1">measureModeMainDim == YGMeasureModeAtMost)) {</span>
    <span class="s0">// Clamp the size to the min/max size, if specified, and make sure it</span>
    <span class="s0">// doesn't go below the padding and border amount.</span>
    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">, </span><span class="s1">mainAxis</span><span class="s5">, </span><span class="s1">maxLineMainDim</span><span class="s5">, </span><span class="s1">mainAxisownerSize</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">dim[mainAxis])</span><span class="s5">;</span>

  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">measureModeMainDim == YGMeasureModeAtMost &amp;&amp;</span>
      <span class="s1">node-&gt;getStyle().overflow() == YGOverflowScroll) {</span>
    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGFloatMax(</span>
            <span class="s1">YGFloatMin(</span>
                <span class="s1">availableInnerMainDim + paddingAndBorderAxisMain</span><span class="s5">,</span>
                <span class="s1">YGNodeBoundAxisWithinMinAndMax(</span>
                    <span class="s1">node</span><span class="s5">,</span>
                    <span class="s1">mainAxis</span><span class="s5">,</span>
                    <span class="s1">YGFloatOptional{maxLineMainDim}</span><span class="s5">,</span>
                    <span class="s1">mainAxisownerSize)</span>
                    <span class="s1">.unwrap())</span><span class="s5">,</span>
            <span class="s1">paddingAndBorderAxisMain)</span><span class="s5">,</span>
        <span class="s1">dim[mainAxis])</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(measureModeCrossDim == YGMeasureModeUndefined ||</span>
      <span class="s1">(node-&gt;getStyle().overflow() != YGOverflowScroll &amp;&amp;</span>
       <span class="s1">measureModeCrossDim == YGMeasureModeAtMost)) {</span>
    <span class="s0">// Clamp the size to the min/max size, if specified, and make sure it</span>
    <span class="s0">// doesn't go below the padding and border amount.</span>
    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGNodeBoundAxis(</span>
            <span class="s1">node</span><span class="s5">,</span>
            <span class="s1">crossAxis</span><span class="s5">,</span>
            <span class="s1">totalLineCrossDim + paddingAndBorderAxisCross</span><span class="s5">,</span>
            <span class="s1">crossAxisownerSize</span><span class="s5">,</span>
            <span class="s1">ownerWidth)</span><span class="s5">,</span>
        <span class="s1">dim[crossAxis])</span><span class="s5">;</span>

  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(</span>
      <span class="s1">measureModeCrossDim == YGMeasureModeAtMost &amp;&amp;</span>
      <span class="s1">node-&gt;getStyle().overflow() == YGOverflowScroll) {</span>
    <span class="s1">node-&gt;setLayoutMeasuredDimension(</span>
        <span class="s1">YGFloatMax(</span>
            <span class="s1">YGFloatMin(</span>
                <span class="s1">availableInnerCrossDim + paddingAndBorderAxisCross</span><span class="s5">,</span>
                <span class="s1">YGNodeBoundAxisWithinMinAndMax(</span>
                    <span class="s1">node</span><span class="s5">,</span>
                    <span class="s1">crossAxis</span><span class="s5">,</span>
                    <span class="s1">YGFloatOptional{</span>
                        <span class="s1">totalLineCrossDim + paddingAndBorderAxisCross}</span><span class="s5">,</span>
                    <span class="s1">crossAxisownerSize)</span>
                    <span class="s1">.unwrap())</span><span class="s5">,</span>
            <span class="s1">paddingAndBorderAxisCross)</span><span class="s5">,</span>
        <span class="s1">dim[crossAxis])</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s0">// As we only wrapped in normal direction yet, we need to reverse the</span>
  <span class="s0">// positions on wrap-reverse.</span>
  <span class="s5">if </span><span class="s1">(performLayout &amp;&amp; node-&gt;getStyle().flexWrap() == YGWrapWrapReverse) {</span>
    <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; childCount</span><span class="s5">; </span><span class="s1">i++) {</span>
      <span class="s5">const </span><span class="s1">YGNodeRef child = YGNodeGetChild(node</span><span class="s5">, </span><span class="s1">i)</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(child-&gt;getStyle().positionType() != YGPositionTypeAbsolute) {</span>
        <span class="s1">child-&gt;setLayoutPosition(</span>
            <span class="s1">node-&gt;getLayout().measuredDimensions[dim[crossAxis]] -</span>
                <span class="s1">child-&gt;getLayout().position[pos[crossAxis]] -</span>
                <span class="s1">child-&gt;getLayout().measuredDimensions[dim[crossAxis]]</span><span class="s5">,</span>
            <span class="s1">pos[crossAxis])</span><span class="s5">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(performLayout) {</span>
    <span class="s0">// STEP 10: SIZING AND POSITIONING ABSOLUTE CHILDREN</span>
    <span class="s5">for </span><span class="s1">(</span><span class="s5">auto </span><span class="s1">child : node-&gt;getChildren()) {</span>
      <span class="s5">if </span><span class="s1">(child-&gt;getStyle().display() == YGDisplayNone ||</span>
          <span class="s1">child-&gt;getStyle().positionType() != YGPositionTypeAbsolute) {</span>
        <span class="s5">continue;</span>
      <span class="s1">}</span>
      <span class="s1">YGNodeAbsoluteLayoutChild(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">child</span><span class="s5">,</span>
          <span class="s1">YGConfigIsExperimentalFeatureEnabled(</span>
              <span class="s1">node-&gt;getConfig()</span><span class="s5">,</span>
              <span class="s1">YGExperimentalFeatureAbsolutePercentageAgainstPaddingEdge)</span>
              <span class="s1">? node-&gt;getLayout().measuredDimensions[YGDimensionWidth]</span>
              <span class="s1">: availableInnerWidth</span><span class="s5">,</span>
          <span class="s1">isMainAxisRow ? measureModeMainDim : measureModeCrossDim</span><span class="s5">,</span>
          <span class="s1">YGConfigIsExperimentalFeatureEnabled(</span>
              <span class="s1">node-&gt;getConfig()</span><span class="s5">,</span>
              <span class="s1">YGExperimentalFeatureAbsolutePercentageAgainstPaddingEdge)</span>
              <span class="s1">? node-&gt;getLayout().measuredDimensions[YGDimensionHeight]</span>
              <span class="s1">: availableInnerHeight</span><span class="s5">,</span>
          <span class="s1">direction</span><span class="s5">,</span>
          <span class="s1">config</span><span class="s5">,</span>
          <span class="s1">layoutMarkerData</span><span class="s5">,</span>
          <span class="s1">layoutContext</span><span class="s5">,</span>
          <span class="s1">depth</span><span class="s5">,</span>
          <span class="s1">generationCount)</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s0">// STEP 11: SETTING TRAILING POSITIONS FOR CHILDREN</span>
    <span class="s5">const bool </span><span class="s1">needsMainTrailingPos = mainAxis == YGFlexDirectionRowReverse ||</span>
        <span class="s1">mainAxis == YGFlexDirectionColumnReverse</span><span class="s5">;</span>
    <span class="s5">const bool </span><span class="s1">needsCrossTrailingPos = crossAxis == YGFlexDirectionRowReverse ||</span>
        <span class="s1">crossAxis == YGFlexDirectionColumnReverse</span><span class="s5">;</span>

    <span class="s0">// Set trailing position if necessary.</span>
    <span class="s5">if </span><span class="s1">(needsMainTrailingPos || needsCrossTrailingPos) {</span>
      <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; childCount</span><span class="s5">; </span><span class="s1">i++) {</span>
        <span class="s5">const </span><span class="s1">YGNodeRef child = node-&gt;getChild(i)</span><span class="s5">;</span>
        <span class="s5">if </span><span class="s1">(child-&gt;getStyle().display() == YGDisplayNone) {</span>
          <span class="s5">continue;</span>
        <span class="s1">}</span>
        <span class="s5">if </span><span class="s1">(needsMainTrailingPos) {</span>
          <span class="s1">YGNodeSetChildTrailingPosition(node</span><span class="s5">, </span><span class="s1">child</span><span class="s5">, </span><span class="s1">mainAxis)</span><span class="s5">;</span>
        <span class="s1">}</span>

        <span class="s5">if </span><span class="s1">(needsCrossTrailingPos) {</span>
          <span class="s1">YGNodeSetChildTrailingPosition(node</span><span class="s5">, </span><span class="s1">child</span><span class="s5">, </span><span class="s1">crossAxis)</span><span class="s5">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">bool </span><span class="s1">gPrintChanges = </span><span class="s5">false;</span>
<span class="s5">bool </span><span class="s1">gPrintSkips = </span><span class="s5">false;</span>

<span class="s5">static const char</span><span class="s1">* spacer =</span>
    <span class="s3">&quot;                                                            &quot;</span><span class="s5">;</span>

<span class="s5">static const char</span><span class="s1">* YGSpacer(</span><span class="s5">const unsigned long </span><span class="s1">level) {</span>
  <span class="s5">const </span><span class="s1">size_t spacerLen = strlen(spacer)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(level &gt; spacerLen) {</span>
    <span class="s5">return </span><span class="s1">&amp;spacer[</span><span class="s4">0</span><span class="s1">]</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s5">return </span><span class="s1">&amp;spacer[spacerLen - level]</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">static const char</span><span class="s1">* YGMeasureModeName(</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode mode</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">performLayout) {</span>
  <span class="s5">constexpr auto </span><span class="s1">N = enums::count&lt;YGMeasureMode&gt;()</span><span class="s5">;</span>
  <span class="s5">const char</span><span class="s1">* kMeasureModeNames[N] = {</span><span class="s3">&quot;UNDEFINED&quot;</span><span class="s5">, </span><span class="s3">&quot;EXACTLY&quot;</span><span class="s5">, </span><span class="s3">&quot;AT_MOST&quot;</span><span class="s1">}</span><span class="s5">;</span>
  <span class="s5">const char</span><span class="s1">* kLayoutModeNames[N] = {</span>
      <span class="s3">&quot;LAY_UNDEFINED&quot;</span><span class="s5">, </span><span class="s3">&quot;LAY_EXACTLY&quot;</span><span class="s5">, </span><span class="s3">&quot;LAY_AT_MOST&quot;</span><span class="s1">}</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(mode &gt;= N) {</span>
    <span class="s5">return </span><span class="s3">&quot;&quot;</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">return </span><span class="s1">performLayout ? kLayoutModeNames[mode] : kMeasureModeNames[mode]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static inline bool </span><span class="s1">YGMeasureModeSizeIsExactAndMatchesOldMeasuredSize(</span>
    <span class="s1">YGMeasureMode sizeMode</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">size</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">lastComputedSize) {</span>
  <span class="s5">return </span><span class="s1">sizeMode == YGMeasureModeExactly &amp;&amp;</span>
      <span class="s1">YGFloatsEqual(size</span><span class="s5">, </span><span class="s1">lastComputedSize)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static inline bool </span><span class="s1">YGMeasureModeOldSizeIsUnspecifiedAndStillFits(</span>
    <span class="s1">YGMeasureMode sizeMode</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">size</span><span class="s5">,</span>
    <span class="s1">YGMeasureMode lastSizeMode</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">lastComputedSize) {</span>
  <span class="s5">return </span><span class="s1">sizeMode == YGMeasureModeAtMost &amp;&amp;</span>
      <span class="s1">lastSizeMode == YGMeasureModeUndefined &amp;&amp;</span>
      <span class="s1">(size &gt;= lastComputedSize || YGFloatsEqual(size</span><span class="s5">, </span><span class="s1">lastComputedSize))</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static inline bool </span><span class="s1">YGMeasureModeNewMeasureSizeIsStricterAndStillValid(</span>
    <span class="s1">YGMeasureMode sizeMode</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">size</span><span class="s5">,</span>
    <span class="s1">YGMeasureMode lastSizeMode</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">lastSize</span><span class="s5">,</span>
    <span class="s5">float </span><span class="s1">lastComputedSize) {</span>
  <span class="s5">return </span><span class="s1">lastSizeMode == YGMeasureModeAtMost &amp;&amp;</span>
      <span class="s1">sizeMode == YGMeasureModeAtMost &amp;&amp; !YGFloatIsUndefined(lastSize) &amp;&amp;</span>
      <span class="s1">!YGFloatIsUndefined(size) &amp;&amp; !YGFloatIsUndefined(lastComputedSize) &amp;&amp;</span>
      <span class="s1">lastSize &gt; size &amp;&amp;</span>
      <span class="s1">(lastComputedSize &lt;= size || YGFloatsEqual(size</span><span class="s5">, </span><span class="s1">lastComputedSize))</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">float </span><span class="s1">YGRoundValueToPixelGrid(</span>
    <span class="s5">const double </span><span class="s1">value</span><span class="s5">,</span>
    <span class="s5">const double </span><span class="s1">pointScaleFactor</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">forceCeil</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">forceFloor) {</span>
  <span class="s5">double </span><span class="s1">scaledValue = value * pointScaleFactor</span><span class="s5">;</span>
  <span class="s0">// We want to calculate `fractial` such that `floor(scaledValue) = scaledValue</span>
  <span class="s0">// - fractial`.</span>
  <span class="s5">double </span><span class="s1">fractial = fmod(scaledValue</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(fractial &lt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">// This branch is for handling negative numbers for `value`.</span>
    <span class="s0">//</span>
    <span class="s0">// Regarding `floor` and `ceil`. Note that for a number x, `floor(x) &lt;= x &lt;=</span>
    <span class="s0">// ceil(x)` even for negative numbers. Here are a couple of examples:</span>
    <span class="s0">//   - x =  2.2: floor( 2.2) =  2, ceil( 2.2) =  3</span>
    <span class="s0">//   - x = -2.2: floor(-2.2) = -3, ceil(-2.2) = -2</span>
    <span class="s0">//</span>
    <span class="s0">// Regarding `fmodf`. For fractional negative numbers, `fmodf` returns a</span>
    <span class="s0">// negative number. For example, `fmodf(-2.2) = -0.2`. However, we want</span>
    <span class="s0">// `fractial` to be the number such that subtracting it from `value` will</span>
    <span class="s0">// give us `floor(value)`. In the case of negative numbers, adding 1 to</span>
    <span class="s0">// `fmodf(value)` gives us this. Let's continue the example from above:</span>
    <span class="s0">//   - fractial = fmodf(-2.2) = -0.2</span>
    <span class="s0">//   - Add 1 to the fraction: fractial2 = fractial + 1 = -0.2 + 1 = 0.8</span>
    <span class="s0">//   - Finding the `floor`: -2.2 - fractial2 = -2.2 - 0.8 = -3</span>
    <span class="s1">++fractial</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">if </span><span class="s1">(YGDoubleEqual(fractial</span><span class="s5">, </span><span class="s4">0</span><span class="s1">)) {</span>
    <span class="s0">// First we check if the value is already rounded</span>
    <span class="s1">scaledValue = scaledValue - fractial</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(YGDoubleEqual(fractial</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)) {</span>
    <span class="s1">scaledValue = scaledValue - fractial + </span><span class="s4">1.0</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(forceCeil) {</span>
    <span class="s0">// Next we check if we need to use forced rounding</span>
    <span class="s1">scaledValue = scaledValue - fractial + </span><span class="s4">1.0</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(forceFloor) {</span>
    <span class="s1">scaledValue = scaledValue - fractial</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s0">// Finally we just round the value</span>
    <span class="s1">scaledValue = scaledValue - fractial +</span>
        <span class="s1">(!YGDoubleIsUndefined(fractial) &amp;&amp;</span>
                 <span class="s1">(fractial &gt; </span><span class="s4">0.5 </span><span class="s1">|| YGDoubleEqual(fractial</span><span class="s5">, </span><span class="s4">0.5</span><span class="s1">))</span>
             <span class="s1">? </span><span class="s4">1.0</span>
             <span class="s1">: </span><span class="s4">0.0</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">return </span><span class="s1">(YGDoubleIsUndefined(scaledValue) ||</span>
          <span class="s1">YGDoubleIsUndefined(pointScaleFactor))</span>
      <span class="s1">? YGUndefined</span>
      <span class="s1">: (</span><span class="s5">float</span><span class="s1">) (scaledValue / pointScaleFactor)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGNodeCanUseCachedMeasurement(</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">width</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">height</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode lastWidthMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">lastWidth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode lastHeightMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">lastHeight</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">lastComputedWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">lastComputedHeight</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">marginRow</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">marginColumn</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config) {</span>
  <span class="s5">if </span><span class="s1">((!YGFloatIsUndefined(lastComputedHeight) &amp;&amp; lastComputedHeight &lt; </span><span class="s4">0</span><span class="s1">) ||</span>
      <span class="s1">(!YGFloatIsUndefined(lastComputedWidth) &amp;&amp; lastComputedWidth &lt; </span><span class="s4">0</span><span class="s1">)) {</span>
    <span class="s5">return false;</span>
  <span class="s1">}</span>
  <span class="s5">bool </span><span class="s1">useRoundedComparison =</span>
      <span class="s1">config != </span><span class="s5">nullptr </span><span class="s1">&amp;&amp; config-&gt;pointScaleFactor != </span><span class="s4">0</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">effectiveWidth = useRoundedComparison</span>
      <span class="s1">? YGRoundValueToPixelGrid(width</span><span class="s5">, </span><span class="s1">config-&gt;pointScaleFactor</span><span class="s5">, false, false</span><span class="s1">)</span>
      <span class="s1">: width</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">effectiveHeight = useRoundedComparison</span>
      <span class="s1">? YGRoundValueToPixelGrid(height</span><span class="s5">, </span><span class="s1">config-&gt;pointScaleFactor</span><span class="s5">, false, false</span><span class="s1">)</span>
      <span class="s1">: height</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">effectiveLastWidth = useRoundedComparison</span>
      <span class="s1">? YGRoundValueToPixelGrid(</span>
            <span class="s1">lastWidth</span><span class="s5">, </span><span class="s1">config-&gt;pointScaleFactor</span><span class="s5">, false, false</span><span class="s1">)</span>
      <span class="s1">: lastWidth</span><span class="s5">;</span>
  <span class="s5">const float </span><span class="s1">effectiveLastHeight = useRoundedComparison</span>
      <span class="s1">? YGRoundValueToPixelGrid(</span>
            <span class="s1">lastHeight</span><span class="s5">, </span><span class="s1">config-&gt;pointScaleFactor</span><span class="s5">, false, false</span><span class="s1">)</span>
      <span class="s1">: lastHeight</span><span class="s5">;</span>

  <span class="s5">const bool </span><span class="s1">hasSameWidthSpec = lastWidthMode == widthMode &amp;&amp;</span>
      <span class="s1">YGFloatsEqual(effectiveLastWidth</span><span class="s5">, </span><span class="s1">effectiveWidth)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">hasSameHeightSpec = lastHeightMode == heightMode &amp;&amp;</span>
      <span class="s1">YGFloatsEqual(effectiveLastHeight</span><span class="s5">, </span><span class="s1">effectiveHeight)</span><span class="s5">;</span>

  <span class="s5">const bool </span><span class="s1">widthIsCompatible =</span>
      <span class="s1">hasSameWidthSpec ||</span>
      <span class="s1">YGMeasureModeSizeIsExactAndMatchesOldMeasuredSize(</span>
          <span class="s1">widthMode</span><span class="s5">, </span><span class="s1">width - marginRow</span><span class="s5">, </span><span class="s1">lastComputedWidth) ||</span>
      <span class="s1">YGMeasureModeOldSizeIsUnspecifiedAndStillFits(</span>
          <span class="s1">widthMode</span><span class="s5">, </span><span class="s1">width - marginRow</span><span class="s5">, </span><span class="s1">lastWidthMode</span><span class="s5">, </span><span class="s1">lastComputedWidth) ||</span>
      <span class="s1">YGMeasureModeNewMeasureSizeIsStricterAndStillValid(</span>
          <span class="s1">widthMode</span><span class="s5">,</span>
          <span class="s1">width - marginRow</span><span class="s5">,</span>
          <span class="s1">lastWidthMode</span><span class="s5">,</span>
          <span class="s1">lastWidth</span><span class="s5">,</span>
          <span class="s1">lastComputedWidth)</span><span class="s5">;</span>

  <span class="s5">const bool </span><span class="s1">heightIsCompatible =</span>
      <span class="s1">hasSameHeightSpec ||</span>
      <span class="s1">YGMeasureModeSizeIsExactAndMatchesOldMeasuredSize(</span>
          <span class="s1">heightMode</span><span class="s5">, </span><span class="s1">height - marginColumn</span><span class="s5">, </span><span class="s1">lastComputedHeight) ||</span>
      <span class="s1">YGMeasureModeOldSizeIsUnspecifiedAndStillFits(</span>
          <span class="s1">heightMode</span><span class="s5">,</span>
          <span class="s1">height - marginColumn</span><span class="s5">,</span>
          <span class="s1">lastHeightMode</span><span class="s5">,</span>
          <span class="s1">lastComputedHeight) ||</span>
      <span class="s1">YGMeasureModeNewMeasureSizeIsStricterAndStillValid(</span>
          <span class="s1">heightMode</span><span class="s5">,</span>
          <span class="s1">height - marginColumn</span><span class="s5">,</span>
          <span class="s1">lastHeightMode</span><span class="s5">,</span>
          <span class="s1">lastHeight</span><span class="s5">,</span>
          <span class="s1">lastComputedHeight)</span><span class="s5">;</span>

  <span class="s5">return </span><span class="s1">widthIsCompatible &amp;&amp; heightIsCompatible</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// This is a wrapper around the YGNodelayoutImpl function. It determines whether</span>
<span class="s0">// the layout request is redundant and can be skipped.</span>
<span class="s0">//</span>
<span class="s0">// Parameters:</span>
<span class="s0">//  Input parameters are the same as YGNodelayoutImpl (see above)</span>
<span class="s0">//  Return parameter is true if layout was performed, false if skipped</span>
<span class="s0">//</span>
<span class="s5">bool </span><span class="s1">YGLayoutNodeInternal(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">availableHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection ownerDirection</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode widthMeasureMode</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGMeasureMode heightMeasureMode</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">performLayout</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">LayoutPassReason reason</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s1">LayoutData&amp; layoutMarkerData</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* </span><span class="s5">const </span><span class="s1">layoutContext</span><span class="s5">,</span>
    <span class="s1">uint32_t depth</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">uint32_t generationCount) {</span>
  <span class="s1">YGLayout* layout = &amp;node-&gt;getLayout()</span><span class="s5">;</span>

  <span class="s1">depth++</span><span class="s5">;</span>

  <span class="s5">const bool </span><span class="s1">needToVisitNode =</span>
      <span class="s1">(node-&gt;isDirty() &amp;&amp; layout-&gt;generationCount != generationCount) ||</span>
      <span class="s1">layout-&gt;lastOwnerDirection != ownerDirection</span><span class="s5">;</span>

  <span class="s5">if </span><span class="s1">(needToVisitNode) {</span>
    <span class="s0">// Invalidate the cached results.</span>
    <span class="s1">layout-&gt;nextCachedMeasurementsIndex = </span><span class="s4">0</span><span class="s5">;</span>
    <span class="s1">layout-&gt;cachedLayout.availableWidth = -</span><span class="s4">1</span><span class="s5">;</span>
    <span class="s1">layout-&gt;cachedLayout.availableHeight = -</span><span class="s4">1</span><span class="s5">;</span>
    <span class="s1">layout-&gt;cachedLayout.widthMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>
    <span class="s1">layout-&gt;cachedLayout.heightMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>
    <span class="s1">layout-&gt;cachedLayout.computedWidth = -</span><span class="s4">1</span><span class="s5">;</span>
    <span class="s1">layout-&gt;cachedLayout.computedHeight = -</span><span class="s4">1</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">YGCachedMeasurement* cachedResults = </span><span class="s5">nullptr;</span>

  <span class="s0">// Determine whether the results are already cached. We maintain a separate</span>
  <span class="s0">// cache for layouts and measurements. A layout operation modifies the</span>
  <span class="s0">// positions and dimensions for nodes in the subtree. The algorithm assumes</span>
  <span class="s0">// that each node gets laid out a maximum of one time per tree layout, but</span>
  <span class="s0">// multiple measurements may be required to resolve all of the flex</span>
  <span class="s0">// dimensions. We handle nodes with measure functions specially here because</span>
  <span class="s0">// they are the most expensive to measure, so it's worth avoiding redundant</span>
  <span class="s0">// measurements if at all possible.</span>
  <span class="s5">if </span><span class="s1">(node-&gt;hasMeasureFunc()) {</span>
    <span class="s5">const float </span><span class="s1">marginAxisRow =</span>
        <span class="s1">node-&gt;getMarginForAxis(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
    <span class="s5">const float </span><span class="s1">marginAxisColumn =</span>
        <span class="s1">node-&gt;getMarginForAxis(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>

    <span class="s0">// First, try to use the layout cache.</span>
    <span class="s5">if </span><span class="s1">(YGNodeCanUseCachedMeasurement(</span>
            <span class="s1">widthMeasureMode</span><span class="s5">,</span>
            <span class="s1">availableWidth</span><span class="s5">,</span>
            <span class="s1">heightMeasureMode</span><span class="s5">,</span>
            <span class="s1">availableHeight</span><span class="s5">,</span>
            <span class="s1">layout-&gt;cachedLayout.widthMeasureMode</span><span class="s5">,</span>
            <span class="s1">layout-&gt;cachedLayout.availableWidth</span><span class="s5">,</span>
            <span class="s1">layout-&gt;cachedLayout.heightMeasureMode</span><span class="s5">,</span>
            <span class="s1">layout-&gt;cachedLayout.availableHeight</span><span class="s5">,</span>
            <span class="s1">layout-&gt;cachedLayout.computedWidth</span><span class="s5">,</span>
            <span class="s1">layout-&gt;cachedLayout.computedHeight</span><span class="s5">,</span>
            <span class="s1">marginAxisRow</span><span class="s5">,</span>
            <span class="s1">marginAxisColumn</span><span class="s5">,</span>
            <span class="s1">config)) {</span>
      <span class="s1">cachedResults = &amp;layout-&gt;cachedLayout</span><span class="s5">;</span>
    <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
      <span class="s0">// Try to use the measurement cache.</span>
      <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; layout-&gt;nextCachedMeasurementsIndex</span><span class="s5">; </span><span class="s1">i++) {</span>
        <span class="s5">if </span><span class="s1">(YGNodeCanUseCachedMeasurement(</span>
                <span class="s1">widthMeasureMode</span><span class="s5">,</span>
                <span class="s1">availableWidth</span><span class="s5">,</span>
                <span class="s1">heightMeasureMode</span><span class="s5">,</span>
                <span class="s1">availableHeight</span><span class="s5">,</span>
                <span class="s1">layout-&gt;cachedMeasurements[i].widthMeasureMode</span><span class="s5">,</span>
                <span class="s1">layout-&gt;cachedMeasurements[i].availableWidth</span><span class="s5">,</span>
                <span class="s1">layout-&gt;cachedMeasurements[i].heightMeasureMode</span><span class="s5">,</span>
                <span class="s1">layout-&gt;cachedMeasurements[i].availableHeight</span><span class="s5">,</span>
                <span class="s1">layout-&gt;cachedMeasurements[i].computedWidth</span><span class="s5">,</span>
                <span class="s1">layout-&gt;cachedMeasurements[i].computedHeight</span><span class="s5">,</span>
                <span class="s1">marginAxisRow</span><span class="s5">,</span>
                <span class="s1">marginAxisColumn</span><span class="s5">,</span>
                <span class="s1">config)) {</span>
          <span class="s1">cachedResults = &amp;layout-&gt;cachedMeasurements[i]</span><span class="s5">;</span>
          <span class="s5">break;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(performLayout) {</span>
    <span class="s5">if </span><span class="s1">(YGFloatsEqual(layout-&gt;cachedLayout.availableWidth</span><span class="s5">, </span><span class="s1">availableWidth) &amp;&amp;</span>
        <span class="s1">YGFloatsEqual(layout-&gt;cachedLayout.availableHeight</span><span class="s5">, </span><span class="s1">availableHeight) &amp;&amp;</span>
        <span class="s1">layout-&gt;cachedLayout.widthMeasureMode == widthMeasureMode &amp;&amp;</span>
        <span class="s1">layout-&gt;cachedLayout.heightMeasureMode == heightMeasureMode) {</span>
      <span class="s1">cachedResults = &amp;layout-&gt;cachedLayout</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; layout-&gt;nextCachedMeasurementsIndex</span><span class="s5">; </span><span class="s1">i++) {</span>
      <span class="s5">if </span><span class="s1">(YGFloatsEqual(</span>
              <span class="s1">layout-&gt;cachedMeasurements[i].availableWidth</span><span class="s5">, </span><span class="s1">availableWidth) &amp;&amp;</span>
          <span class="s1">YGFloatsEqual(</span>
              <span class="s1">layout-&gt;cachedMeasurements[i].availableHeight</span><span class="s5">, </span><span class="s1">availableHeight) &amp;&amp;</span>
          <span class="s1">layout-&gt;cachedMeasurements[i].widthMeasureMode == widthMeasureMode &amp;&amp;</span>
          <span class="s1">layout-&gt;cachedMeasurements[i].heightMeasureMode ==</span>
              <span class="s1">heightMeasureMode) {</span>
        <span class="s1">cachedResults = &amp;layout-&gt;cachedMeasurements[i]</span><span class="s5">;</span>
        <span class="s5">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(!needToVisitNode &amp;&amp; cachedResults != </span><span class="s5">nullptr</span><span class="s1">) {</span>
    <span class="s1">layout-&gt;measuredDimensions[YGDimensionWidth] = cachedResults-&gt;computedWidth</span><span class="s5">;</span>
    <span class="s1">layout-&gt;measuredDimensions[YGDimensionHeight] =</span>
        <span class="s1">cachedResults-&gt;computedHeight</span><span class="s5">;</span>

    <span class="s1">(performLayout ? layoutMarkerData.cachedLayouts</span>
                   <span class="s1">: layoutMarkerData.cachedMeasures) += </span><span class="s4">1</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(gPrintChanges &amp;&amp; gPrintSkips) {</span>
      <span class="s1">Log::log(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGLogLevelVerbose</span><span class="s5">,</span>
          <span class="s5">nullptr,</span>
          <span class="s3">&quot;%s%d.{[skipped] &quot;</span><span class="s5">,</span>
          <span class="s1">YGSpacer(depth)</span><span class="s5">,</span>
          <span class="s1">depth)</span><span class="s5">;</span>
      <span class="s1">node-&gt;print(layoutContext)</span><span class="s5">;</span>
      <span class="s1">Log::log(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGLogLevelVerbose</span><span class="s5">,</span>
          <span class="s5">nullptr,</span>
          <span class="s3">&quot;wm: %s, hm: %s, aw: %f ah: %f =&gt; d: (%f, %f) %s</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s5">,</span>
          <span class="s1">YGMeasureModeName(widthMeasureMode</span><span class="s5">, </span><span class="s1">performLayout)</span><span class="s5">,</span>
          <span class="s1">YGMeasureModeName(heightMeasureMode</span><span class="s5">, </span><span class="s1">performLayout)</span><span class="s5">,</span>
          <span class="s1">availableWidth</span><span class="s5">,</span>
          <span class="s1">availableHeight</span><span class="s5">,</span>
          <span class="s1">cachedResults-&gt;computedWidth</span><span class="s5">,</span>
          <span class="s1">cachedResults-&gt;computedHeight</span><span class="s5">,</span>
          <span class="s1">LayoutPassReasonToString(reason))</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s5">if </span><span class="s1">(gPrintChanges) {</span>
      <span class="s1">Log::log(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGLogLevelVerbose</span><span class="s5">,</span>
          <span class="s5">nullptr,</span>
          <span class="s3">&quot;%s%d.{%s&quot;</span><span class="s5">,</span>
          <span class="s1">YGSpacer(depth)</span><span class="s5">,</span>
          <span class="s1">depth</span><span class="s5">,</span>
          <span class="s1">needToVisitNode ? </span><span class="s3">&quot;*&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
      <span class="s1">node-&gt;print(layoutContext)</span><span class="s5">;</span>
      <span class="s1">Log::log(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGLogLevelVerbose</span><span class="s5">,</span>
          <span class="s5">nullptr,</span>
          <span class="s3">&quot;wm: %s, hm: %s, aw: %f ah: %f %s</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s5">,</span>
          <span class="s1">YGMeasureModeName(widthMeasureMode</span><span class="s5">, </span><span class="s1">performLayout)</span><span class="s5">,</span>
          <span class="s1">YGMeasureModeName(heightMeasureMode</span><span class="s5">, </span><span class="s1">performLayout)</span><span class="s5">,</span>
          <span class="s1">availableWidth</span><span class="s5">,</span>
          <span class="s1">availableHeight</span><span class="s5">,</span>
          <span class="s1">LayoutPassReasonToString(reason))</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">YGNodelayoutImpl(</span>
        <span class="s1">node</span><span class="s5">,</span>
        <span class="s1">availableWidth</span><span class="s5">,</span>
        <span class="s1">availableHeight</span><span class="s5">,</span>
        <span class="s1">ownerDirection</span><span class="s5">,</span>
        <span class="s1">widthMeasureMode</span><span class="s5">,</span>
        <span class="s1">heightMeasureMode</span><span class="s5">,</span>
        <span class="s1">ownerWidth</span><span class="s5">,</span>
        <span class="s1">ownerHeight</span><span class="s5">,</span>
        <span class="s1">performLayout</span><span class="s5">,</span>
        <span class="s1">config</span><span class="s5">,</span>
        <span class="s1">layoutMarkerData</span><span class="s5">,</span>
        <span class="s1">layoutContext</span><span class="s5">,</span>
        <span class="s1">depth</span><span class="s5">,</span>
        <span class="s1">generationCount</span><span class="s5">,</span>
        <span class="s1">reason)</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(gPrintChanges) {</span>
      <span class="s1">Log::log(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGLogLevelVerbose</span><span class="s5">,</span>
          <span class="s5">nullptr,</span>
          <span class="s3">&quot;%s%d.}%s&quot;</span><span class="s5">,</span>
          <span class="s1">YGSpacer(depth)</span><span class="s5">,</span>
          <span class="s1">depth</span><span class="s5">,</span>
          <span class="s1">needToVisitNode ? </span><span class="s3">&quot;*&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s5">;</span>
      <span class="s1">node-&gt;print(layoutContext)</span><span class="s5">;</span>
      <span class="s1">Log::log(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">YGLogLevelVerbose</span><span class="s5">,</span>
          <span class="s5">nullptr,</span>
          <span class="s3">&quot;wm: %s, hm: %s, d: (%f, %f) %s</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s5">,</span>
          <span class="s1">YGMeasureModeName(widthMeasureMode</span><span class="s5">, </span><span class="s1">performLayout)</span><span class="s5">,</span>
          <span class="s1">YGMeasureModeName(heightMeasureMode</span><span class="s5">, </span><span class="s1">performLayout)</span><span class="s5">,</span>
          <span class="s1">layout-&gt;measuredDimensions[YGDimensionWidth]</span><span class="s5">,</span>
          <span class="s1">layout-&gt;measuredDimensions[YGDimensionHeight]</span><span class="s5">,</span>
          <span class="s1">LayoutPassReasonToString(reason))</span><span class="s5">;</span>
    <span class="s1">}</span>

    <span class="s1">layout-&gt;lastOwnerDirection = ownerDirection</span><span class="s5">;</span>

    <span class="s5">if </span><span class="s1">(cachedResults == </span><span class="s5">nullptr</span><span class="s1">) {</span>
      <span class="s5">if </span><span class="s1">(layout-&gt;nextCachedMeasurementsIndex + </span><span class="s4">1 </span><span class="s1">&gt;</span>
          <span class="s1">(uint32_t) layoutMarkerData.maxMeasureCache) {</span>
        <span class="s1">layoutMarkerData.maxMeasureCache =</span>
            <span class="s1">layout-&gt;nextCachedMeasurementsIndex + </span><span class="s4">1</span><span class="s5">;</span>
      <span class="s1">}</span>
      <span class="s5">if </span><span class="s1">(layout-&gt;nextCachedMeasurementsIndex == YG_MAX_CACHED_RESULT_COUNT) {</span>
        <span class="s5">if </span><span class="s1">(gPrintChanges) {</span>
          <span class="s1">Log::log(node</span><span class="s5">, </span><span class="s1">YGLogLevelVerbose</span><span class="s5">, nullptr, </span><span class="s3">&quot;Out of cache entries!</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s5">;</span>
        <span class="s1">}</span>
        <span class="s1">layout-&gt;nextCachedMeasurementsIndex = </span><span class="s4">0</span><span class="s5">;</span>
      <span class="s1">}</span>

      <span class="s1">YGCachedMeasurement* newCacheEntry</span><span class="s5">;</span>
      <span class="s5">if </span><span class="s1">(performLayout) {</span>
        <span class="s0">// Use the single layout cache entry.</span>
        <span class="s1">newCacheEntry = &amp;layout-&gt;cachedLayout</span><span class="s5">;</span>
      <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
        <span class="s0">// Allocate a new measurement cache entry.</span>
        <span class="s1">newCacheEntry =</span>
            <span class="s1">&amp;layout-&gt;cachedMeasurements[layout-&gt;nextCachedMeasurementsIndex]</span><span class="s5">;</span>
        <span class="s1">layout-&gt;nextCachedMeasurementsIndex++</span><span class="s5">;</span>
      <span class="s1">}</span>

      <span class="s1">newCacheEntry-&gt;availableWidth = availableWidth</span><span class="s5">;</span>
      <span class="s1">newCacheEntry-&gt;availableHeight = availableHeight</span><span class="s5">;</span>
      <span class="s1">newCacheEntry-&gt;widthMeasureMode = widthMeasureMode</span><span class="s5">;</span>
      <span class="s1">newCacheEntry-&gt;heightMeasureMode = heightMeasureMode</span><span class="s5">;</span>
      <span class="s1">newCacheEntry-&gt;computedWidth =</span>
          <span class="s1">layout-&gt;measuredDimensions[YGDimensionWidth]</span><span class="s5">;</span>
      <span class="s1">newCacheEntry-&gt;computedHeight =</span>
          <span class="s1">layout-&gt;measuredDimensions[YGDimensionHeight]</span><span class="s5">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s5">if </span><span class="s1">(performLayout) {</span>
    <span class="s1">node-&gt;setLayoutDimension(</span>
        <span class="s1">node-&gt;getLayout().measuredDimensions[YGDimensionWidth]</span><span class="s5">,</span>
        <span class="s1">YGDimensionWidth)</span><span class="s5">;</span>
    <span class="s1">node-&gt;setLayoutDimension(</span>
        <span class="s1">node-&gt;getLayout().measuredDimensions[YGDimensionHeight]</span><span class="s5">,</span>
        <span class="s1">YGDimensionHeight)</span><span class="s5">;</span>

    <span class="s1">node-&gt;setHasNewLayout(</span><span class="s5">true</span><span class="s1">)</span><span class="s5">;</span>
    <span class="s1">node-&gt;setDirty(</span><span class="s5">false</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s1">layout-&gt;generationCount = generationCount</span><span class="s5">;</span>

  <span class="s1">LayoutType layoutType</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(performLayout) {</span>
    <span class="s1">layoutType = !needToVisitNode &amp;&amp; cachedResults == &amp;layout-&gt;cachedLayout</span>
        <span class="s1">? LayoutType::kCachedLayout</span>
        <span class="s1">: LayoutType::kLayout</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">layoutType = cachedResults != </span><span class="s5">nullptr </span><span class="s1">? LayoutType::kCachedMeasure</span>
                                          <span class="s1">: LayoutType::kMeasure</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s1">Event::publish&lt;Event::NodeLayout&gt;(node</span><span class="s5">, </span><span class="s1">{layoutType</span><span class="s5">, </span><span class="s1">layoutContext})</span><span class="s5">;</span>

  <span class="s5">return </span><span class="s1">(needToVisitNode || cachedResults == </span><span class="s5">nullptr</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetPointScaleFactor(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">pixelsInPoint) {</span>
  <span class="s1">YGAssertWithConfig(</span>
      <span class="s1">config</span><span class="s5">,</span>
      <span class="s1">pixelsInPoint &gt;= </span><span class="s4">0.0f</span><span class="s5">,</span>
      <span class="s3">&quot;Scale factor should not be less than zero&quot;</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s0">// We store points for Pixel as we will use it for rounding</span>
  <span class="s5">if </span><span class="s1">(pixelsInPoint == </span><span class="s4">0.0f</span><span class="s1">) {</span>
    <span class="s0">// Zero is used to skip rounding</span>
    <span class="s1">config-&gt;pointScaleFactor = </span><span class="s4">0.0f</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">config-&gt;pointScaleFactor = pixelsInPoint</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGRoundToPixelGrid(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const double </span><span class="s1">pointScaleFactor</span><span class="s5">,</span>
    <span class="s5">const double </span><span class="s1">absoluteLeft</span><span class="s5">,</span>
    <span class="s5">const double </span><span class="s1">absoluteTop) {</span>
  <span class="s5">if </span><span class="s1">(pointScaleFactor == </span><span class="s4">0.0f</span><span class="s1">) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>

  <span class="s5">const double </span><span class="s1">nodeLeft = node-&gt;getLayout().position[YGEdgeLeft]</span><span class="s5">;</span>
  <span class="s5">const double </span><span class="s1">nodeTop = node-&gt;getLayout().position[YGEdgeTop]</span><span class="s5">;</span>

  <span class="s5">const double </span><span class="s1">nodeWidth = node-&gt;getLayout().dimensions[YGDimensionWidth]</span><span class="s5">;</span>
  <span class="s5">const double </span><span class="s1">nodeHeight = node-&gt;getLayout().dimensions[YGDimensionHeight]</span><span class="s5">;</span>

  <span class="s5">const double </span><span class="s1">absoluteNodeLeft = absoluteLeft + nodeLeft</span><span class="s5">;</span>
  <span class="s5">const double </span><span class="s1">absoluteNodeTop = absoluteTop + nodeTop</span><span class="s5">;</span>

  <span class="s5">const double </span><span class="s1">absoluteNodeRight = absoluteNodeLeft + nodeWidth</span><span class="s5">;</span>
  <span class="s5">const double </span><span class="s1">absoluteNodeBottom = absoluteNodeTop + nodeHeight</span><span class="s5">;</span>

  <span class="s0">// If a node has a custom measure function we never want to round down its</span>
  <span class="s0">// size as this could lead to unwanted text truncation.</span>
  <span class="s5">const bool </span><span class="s1">textRounding = node-&gt;getNodeType() == YGNodeTypeText</span><span class="s5">;</span>

  <span class="s1">node-&gt;setLayoutPosition(</span>
      <span class="s1">YGRoundValueToPixelGrid(nodeLeft</span><span class="s5">, </span><span class="s1">pointScaleFactor</span><span class="s5">, false, </span><span class="s1">textRounding)</span><span class="s5">,</span>
      <span class="s1">YGEdgeLeft)</span><span class="s5">;</span>

  <span class="s1">node-&gt;setLayoutPosition(</span>
      <span class="s1">YGRoundValueToPixelGrid(nodeTop</span><span class="s5">, </span><span class="s1">pointScaleFactor</span><span class="s5">, false, </span><span class="s1">textRounding)</span><span class="s5">,</span>
      <span class="s1">YGEdgeTop)</span><span class="s5">;</span>

  <span class="s0">// We multiply dimension by scale factor and if the result is close to the</span>
  <span class="s0">// whole number, we don't have any fraction To verify if the result is close</span>
  <span class="s0">// to whole number we want to check both floor and ceil numbers</span>
  <span class="s5">const bool </span><span class="s1">hasFractionalWidth =</span>
      <span class="s1">!YGDoubleEqual(fmod(nodeWidth * pointScaleFactor</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s5">, </span><span class="s4">0</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">!YGDoubleEqual(fmod(nodeWidth * pointScaleFactor</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s5">;</span>
  <span class="s5">const bool </span><span class="s1">hasFractionalHeight =</span>
      <span class="s1">!YGDoubleEqual(fmod(nodeHeight * pointScaleFactor</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s5">, </span><span class="s4">0</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">!YGDoubleEqual(fmod(nodeHeight * pointScaleFactor</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s5">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s5">;</span>

  <span class="s1">node-&gt;setLayoutDimension(</span>
      <span class="s1">YGRoundValueToPixelGrid(</span>
          <span class="s1">absoluteNodeRight</span><span class="s5">,</span>
          <span class="s1">pointScaleFactor</span><span class="s5">,</span>
          <span class="s1">(textRounding &amp;&amp; hasFractionalWidth)</span><span class="s5">,</span>
          <span class="s1">(textRounding &amp;&amp; !hasFractionalWidth)) -</span>
          <span class="s1">YGRoundValueToPixelGrid(</span>
              <span class="s1">absoluteNodeLeft</span><span class="s5">, </span><span class="s1">pointScaleFactor</span><span class="s5">, false, </span><span class="s1">textRounding)</span><span class="s5">,</span>
      <span class="s1">YGDimensionWidth)</span><span class="s5">;</span>

  <span class="s1">node-&gt;setLayoutDimension(</span>
      <span class="s1">YGRoundValueToPixelGrid(</span>
          <span class="s1">absoluteNodeBottom</span><span class="s5">,</span>
          <span class="s1">pointScaleFactor</span><span class="s5">,</span>
          <span class="s1">(textRounding &amp;&amp; hasFractionalHeight)</span><span class="s5">,</span>
          <span class="s1">(textRounding &amp;&amp; !hasFractionalHeight)) -</span>
          <span class="s1">YGRoundValueToPixelGrid(</span>
              <span class="s1">absoluteNodeTop</span><span class="s5">, </span><span class="s1">pointScaleFactor</span><span class="s5">, false, </span><span class="s1">textRounding)</span><span class="s5">,</span>
      <span class="s1">YGDimensionHeight)</span><span class="s5">;</span>

  <span class="s5">const </span><span class="s1">uint32_t childCount = YGNodeGetChildCount(node)</span><span class="s5">;</span>
  <span class="s5">for </span><span class="s1">(uint32_t i = </span><span class="s4">0</span><span class="s5">; </span><span class="s1">i &lt; childCount</span><span class="s5">; </span><span class="s1">i++) {</span>
    <span class="s1">YGRoundToPixelGrid(</span>
        <span class="s1">YGNodeGetChild(node</span><span class="s5">, </span><span class="s1">i)</span><span class="s5">,</span>
        <span class="s1">pointScaleFactor</span><span class="s5">,</span>
        <span class="s1">absoluteNodeLeft</span><span class="s5">,</span>
        <span class="s1">absoluteNodeTop)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeCalculateLayoutWithContext(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection ownerDirection</span><span class="s5">,</span>
    <span class="s5">void</span><span class="s1">* layoutContext) {</span>

  <span class="s1">Event::publish&lt;Event::LayoutPassStart&gt;(node</span><span class="s5">, </span><span class="s1">{layoutContext})</span><span class="s5">;</span>
  <span class="s1">LayoutData markerData = {}</span><span class="s5">;</span>

  <span class="s0">// Increment the generation count. This will force the recursive routine to</span>
  <span class="s0">// visit all dirty nodes at least once. Subsequent visits will be skipped if</span>
  <span class="s0">// the input parameters don't change.</span>
  <span class="s1">gCurrentGenerationCount.fetch_add(</span><span class="s4">1</span><span class="s5">, </span><span class="s1">std::memory_order_relaxed)</span><span class="s5">;</span>
  <span class="s1">node-&gt;resolveDimension()</span><span class="s5">;</span>
  <span class="s5">float </span><span class="s1">width = YGUndefined</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode widthMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>
  <span class="s5">const auto</span><span class="s1">&amp; maxDimensions = node-&gt;getStyle().maxDimensions()</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(YGNodeIsStyleDimDefined(node</span><span class="s5">, </span><span class="s1">YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">ownerWidth)) {</span>
    <span class="s1">width =</span>
        <span class="s1">(YGResolveValue(</span>
             <span class="s1">node-&gt;getResolvedDimension(dim[YGFlexDirectionRow])</span><span class="s5">, </span><span class="s1">ownerWidth) +</span>
         <span class="s1">node-&gt;getMarginForAxis(YGFlexDirectionRow</span><span class="s5">, </span><span class="s1">ownerWidth))</span>
            <span class="s1">.unwrap()</span><span class="s5">;</span>
    <span class="s1">widthMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(!YGResolveValue(maxDimensions[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">ownerWidth)</span>
                  <span class="s1">.isUndefined()) {</span>
    <span class="s1">width =</span>
        <span class="s1">YGResolveValue(maxDimensions[YGDimensionWidth]</span><span class="s5">, </span><span class="s1">ownerWidth).unwrap()</span><span class="s5">;</span>
    <span class="s1">widthMeasureMode = YGMeasureModeAtMost</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">width = ownerWidth</span><span class="s5">;</span>
    <span class="s1">widthMeasureMode = YGFloatIsUndefined(width) ? YGMeasureModeUndefined</span>
                                                 <span class="s1">: YGMeasureModeExactly</span><span class="s5">;</span>
  <span class="s1">}</span>

  <span class="s5">float </span><span class="s1">height = YGUndefined</span><span class="s5">;</span>
  <span class="s1">YGMeasureMode heightMeasureMode = YGMeasureModeUndefined</span><span class="s5">;</span>
  <span class="s5">if </span><span class="s1">(YGNodeIsStyleDimDefined(node</span><span class="s5">, </span><span class="s1">YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">ownerHeight)) {</span>
    <span class="s1">height = (YGResolveValue(</span>
                  <span class="s1">node-&gt;getResolvedDimension(dim[YGFlexDirectionColumn])</span><span class="s5">,</span>
                  <span class="s1">ownerHeight) +</span>
              <span class="s1">node-&gt;getMarginForAxis(YGFlexDirectionColumn</span><span class="s5">, </span><span class="s1">ownerWidth))</span>
                 <span class="s1">.unwrap()</span><span class="s5">;</span>
    <span class="s1">heightMeasureMode = YGMeasureModeExactly</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else if </span><span class="s1">(!YGResolveValue(maxDimensions[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">ownerHeight)</span>
                  <span class="s1">.isUndefined()) {</span>
    <span class="s1">height =</span>
        <span class="s1">YGResolveValue(maxDimensions[YGDimensionHeight]</span><span class="s5">, </span><span class="s1">ownerHeight).unwrap()</span><span class="s5">;</span>
    <span class="s1">heightMeasureMode = YGMeasureModeAtMost</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
    <span class="s1">height = ownerHeight</span><span class="s5">;</span>
    <span class="s1">heightMeasureMode = YGFloatIsUndefined(height) ? YGMeasureModeUndefined</span>
                                                   <span class="s1">: YGMeasureModeExactly</span><span class="s5">;</span>
  <span class="s1">}</span>
  <span class="s5">if </span><span class="s1">(YGLayoutNodeInternal(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">width</span><span class="s5">,</span>
          <span class="s1">height</span><span class="s5">,</span>
          <span class="s1">ownerDirection</span><span class="s5">,</span>
          <span class="s1">widthMeasureMode</span><span class="s5">,</span>
          <span class="s1">heightMeasureMode</span><span class="s5">,</span>
          <span class="s1">ownerWidth</span><span class="s5">,</span>
          <span class="s1">ownerHeight</span><span class="s5">,</span>
          <span class="s5">true,</span>
          <span class="s1">LayoutPassReason::kInitial</span><span class="s5">,</span>
          <span class="s1">node-&gt;getConfig()</span><span class="s5">,</span>
          <span class="s1">markerData</span><span class="s5">,</span>
          <span class="s1">layoutContext</span><span class="s5">,</span>
          <span class="s4">0</span><span class="s5">, </span><span class="s0">// tree root</span>
          <span class="s1">gCurrentGenerationCount.load(std::memory_order_relaxed))) {</span>
    <span class="s1">node-&gt;setPosition(</span>
        <span class="s1">node-&gt;getLayout().direction()</span><span class="s5">, </span><span class="s1">ownerWidth</span><span class="s5">, </span><span class="s1">ownerHeight</span><span class="s5">, </span><span class="s1">ownerWidth)</span><span class="s5">;</span>
    <span class="s1">YGRoundToPixelGrid(node</span><span class="s5">, </span><span class="s1">node-&gt;getConfig()-&gt;pointScaleFactor</span><span class="s5">, </span><span class="s4">0.0f</span><span class="s5">, </span><span class="s4">0.0f</span><span class="s1">)</span><span class="s5">;</span>

<span class="s2">#ifdef </span><span class="s1">DEBUG</span>
    <span class="s5">if </span><span class="s1">(node-&gt;getConfig()-&gt;printTree) {</span>
      <span class="s1">YGNodePrint(</span>
          <span class="s1">node</span><span class="s5">,</span>
          <span class="s1">(YGPrintOptions) (YGPrintOptionsLayout | YGPrintOptionsChildren | YGPrintOptionsStyle))</span><span class="s5">;</span>
    <span class="s1">}</span>
<span class="s2">#endif</span>
  <span class="s1">}</span>

  <span class="s1">Event::publish&lt;Event::LayoutPassEnd&gt;(node</span><span class="s5">, </span><span class="s1">{layoutContext</span><span class="s5">, </span><span class="s1">&amp;markerData})</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGNodeCalculateLayout(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerWidth</span><span class="s5">,</span>
    <span class="s5">const float </span><span class="s1">ownerHeight</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGDirection ownerDirection) {</span>
  <span class="s1">YGNodeCalculateLayoutWithContext(</span>
      <span class="s1">node</span><span class="s5">, </span><span class="s1">ownerWidth</span><span class="s5">, </span><span class="s1">ownerHeight</span><span class="s5">, </span><span class="s1">ownerDirection</span><span class="s5">, nullptr</span><span class="s1">)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetLogger(</span><span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">, </span><span class="s1">YGLogger logger) {</span>
  <span class="s5">if </span><span class="s1">(logger != </span><span class="s5">nullptr</span><span class="s1">) {</span>
    <span class="s1">config-&gt;setLogger(logger)</span><span class="s5">;</span>
  <span class="s1">} </span><span class="s5">else </span><span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">ANDROID</span>
    <span class="s1">config-&gt;setLogger(&amp;YGAndroidLog)</span><span class="s5">;</span>
<span class="s2">#else</span>
    <span class="s1">config-&gt;setLogger(&amp;YGDefaultLog)</span><span class="s5">;</span>
<span class="s2">#endif</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">void </span><span class="s1">YGAssert(</span><span class="s5">const bool </span><span class="s1">condition</span><span class="s5">, const char</span><span class="s1">* message) {</span>
  <span class="s5">if </span><span class="s1">(!condition) {</span>
    <span class="s1">Log::log(YGNodeRef{</span><span class="s5">nullptr</span><span class="s1">}</span><span class="s5">, </span><span class="s1">YGLogLevelFatal</span><span class="s5">, nullptr, </span><span class="s3">&quot;%s</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s5">, </span><span class="s1">message)</span><span class="s5">;</span>
    <span class="s1">throwLogicalErrorWithMessage(message)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">void </span><span class="s1">YGAssertWithNode(</span>
    <span class="s5">const </span><span class="s1">YGNodeRef node</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">condition</span><span class="s5">,</span>
    <span class="s5">const char</span><span class="s1">* message) {</span>
  <span class="s5">if </span><span class="s1">(!condition) {</span>
    <span class="s1">Log::log(node</span><span class="s5">, </span><span class="s1">YGLogLevelFatal</span><span class="s5">, nullptr, </span><span class="s3">&quot;%s</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s5">, </span><span class="s1">message)</span><span class="s5">;</span>
    <span class="s1">throwLogicalErrorWithMessage(message)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">void </span><span class="s1">YGAssertWithConfig(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">condition</span><span class="s5">,</span>
    <span class="s5">const char</span><span class="s1">* message) {</span>
  <span class="s5">if </span><span class="s1">(!condition) {</span>
    <span class="s1">Log::log(config</span><span class="s5">, </span><span class="s1">YGLogLevelFatal</span><span class="s5">, nullptr, </span><span class="s3">&quot;%s</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s5">, </span><span class="s1">message)</span><span class="s5">;</span>
    <span class="s1">throwLogicalErrorWithMessage(message)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetExperimentalFeatureEnabled(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGExperimentalFeature feature</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">enabled) {</span>
  <span class="s1">config-&gt;experimentalFeatures[feature] = enabled</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGConfigIsExperimentalFeatureEnabled(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGExperimentalFeature feature) {</span>
  <span class="s5">return </span><span class="s1">config-&gt;experimentalFeatures[feature]</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetUseWebDefaults(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">enabled) {</span>
  <span class="s1">config-&gt;useWebDefaults = enabled</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">bool </span><span class="s1">YGConfigGetUseLegacyStretchBehaviour(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config) {</span>
  <span class="s5">return </span><span class="s1">config-&gt;useLegacyStretchBehaviour</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetUseLegacyStretchBehaviour(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const bool </span><span class="s1">useLegacyStretchBehaviour) {</span>
  <span class="s1">config-&gt;useLegacyStretchBehaviour = useLegacyStretchBehaviour</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">bool </span><span class="s1">YGConfigGetUseWebDefaults(</span><span class="s5">const </span><span class="s1">YGConfigRef config) {</span>
  <span class="s5">return </span><span class="s1">config-&gt;useWebDefaults</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetContext(</span><span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">, void</span><span class="s1">* context) {</span>
  <span class="s1">config-&gt;context = context</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void</span><span class="s1">* YGConfigGetContext(</span><span class="s5">const </span><span class="s1">YGConfigRef config) {</span>
  <span class="s5">return </span><span class="s1">config-&gt;context</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s1">YOGA_EXPORT </span><span class="s5">void </span><span class="s1">YGConfigSetCloneNodeFunc(</span>
    <span class="s5">const </span><span class="s1">YGConfigRef config</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">YGCloneNodeFunc callback) {</span>
  <span class="s1">config-&gt;setCloneNodeCallback(callback)</span><span class="s5">;</span>
<span class="s1">}</span>

<span class="s5">static void </span><span class="s1">YGTraverseChildrenPreOrder(</span>
    <span class="s5">const </span><span class="s1">YGVector&amp; children</span><span class="s5">,</span>
    <span class="s5">const </span><span class="s1">std::function&lt;</span><span class="s5">void</span><span class="s1">(YGNodeRef node)&gt;&amp; f) {</span>
  <span class="s5">for </span><span class="s1">(YGNodeRef node : children) {</span>
    <span class="s1">f(node)</span><span class="s5">;</span>
    <span class="s1">YGTraverseChildrenPreOrder(node-&gt;getChildren()</span><span class="s5">, </span><span class="s1">f)</span><span class="s5">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">void </span><span class="s1">YGTraversePreOrder(</span>
    <span class="s1">YGNodeRef </span><span class="s5">const </span><span class="s1">node</span><span class="s5">,</span>
    <span class="s1">std::function&lt;</span><span class="s5">void</span><span class="s1">(YGNodeRef node)&gt;&amp;&amp; f) {</span>
  <span class="s5">if </span><span class="s1">(!node) {</span>
    <span class="s5">return;</span>
  <span class="s1">}</span>
  <span class="s1">f(node)</span><span class="s5">;</span>
  <span class="s1">YGTraverseChildrenPreOrder(node-&gt;getChildren()</span><span class="s5">, </span><span class="s1">f)</span><span class="s5">;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
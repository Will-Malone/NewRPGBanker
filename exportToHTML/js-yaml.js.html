<html>
<head>
<title>js-yaml.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
js-yaml.js</font>
</center></td></tr></table>
<pre><span class="s0">/*! js-yaml 3.14.1 https://github.com/nodeca/js-yaml */</span><span class="s1">(</span><span class="s2">function</span><span class="s1">(f){</span><span class="s2">if</span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">exports===</span><span class="s3">&quot;object&quot;</span><span class="s1">&amp;&amp;</span><span class="s2">typeof </span><span class="s1">module!==</span><span class="s3">&quot;undefined&quot;</span><span class="s1">){module.exports=f()}</span><span class="s2">else if</span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">define===</span><span class="s3">&quot;function&quot;</span><span class="s1">&amp;&amp;define.amd){define([],f)}</span><span class="s2">else</span><span class="s1">{</span><span class="s2">var </span><span class="s1">g;</span><span class="s2">if</span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window!==</span><span class="s3">&quot;undefined&quot;</span><span class="s1">){g=window}</span><span class="s2">else if</span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">global!==</span><span class="s3">&quot;undefined&quot;</span><span class="s1">){g=global}</span><span class="s2">else if</span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">self!==</span><span class="s3">&quot;undefined&quot;</span><span class="s1">){g=self}</span><span class="s2">else</span><span class="s1">{g=</span><span class="s2">this</span><span class="s1">}g.jsyaml = f()}})(</span><span class="s2">function</span><span class="s1">(){</span><span class="s2">var </span><span class="s1">define,module,exports;</span><span class="s2">return </span><span class="s1">(</span><span class="s2">function</span><span class="s1">(){</span><span class="s2">function </span><span class="s1">r(e,n,t){</span><span class="s2">function </span><span class="s1">o(i,f){</span><span class="s2">if</span><span class="s1">(!n[i]){</span><span class="s2">if</span><span class="s1">(!e[i]){</span><span class="s2">var </span><span class="s1">c=</span><span class="s3">&quot;function&quot;</span><span class="s1">==</span><span class="s2">typeof </span><span class="s1">require&amp;&amp;require;</span><span class="s2">if</span><span class="s1">(!f&amp;&amp;c)</span><span class="s2">return </span><span class="s1">c(i,!</span><span class="s4">0</span><span class="s1">);</span><span class="s2">if</span><span class="s1">(u)</span><span class="s2">return </span><span class="s1">u(i,!</span><span class="s4">0</span><span class="s1">);</span><span class="s2">var </span><span class="s1">a=</span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">&quot;Cannot find module '&quot;</span><span class="s1">+i+</span><span class="s3">&quot;'&quot;</span><span class="s1">);</span><span class="s2">throw </span><span class="s1">a.code=</span><span class="s3">&quot;MODULE_NOT_FOUND&quot;</span><span class="s1">,a}</span><span class="s2">var </span><span class="s1">p=n[i]={exports:{}};e[i][</span><span class="s4">0</span><span class="s1">].call(p.exports,</span><span class="s2">function</span><span class="s1">(r){</span><span class="s2">var </span><span class="s1">n=e[i][</span><span class="s4">1</span><span class="s1">][r];</span><span class="s2">return </span><span class="s1">o(n||r)},p,p.exports,r,e,n,t)}</span><span class="s2">return </span><span class="s1">n[i].exports}</span><span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">u=</span><span class="s3">&quot;function&quot;</span><span class="s1">==</span><span class="s2">typeof </span><span class="s1">require&amp;&amp;require,i=</span><span class="s4">0</span><span class="s1">;i&lt;t.length;i++)o(t[i]);</span><span class="s2">return </span><span class="s1">o}</span><span class="s2">return </span><span class="s1">r})()({</span><span class="s4">1</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">loader = require(</span><span class="s3">'./js-yaml/loader'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">dumper = require(</span><span class="s3">'./js-yaml/dumper'</span><span class="s1">);</span>


<span class="s2">function </span><span class="s1">deprecated(name) {</span>
  <span class="s2">return function </span><span class="s1">() {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Function ' </span><span class="s1">+ name + </span><span class="s3">' is deprecated and cannot be used.'</span><span class="s1">);</span>
  <span class="s1">};</span>
<span class="s1">}</span>


<span class="s1">module.exports.Type                = require(</span><span class="s3">'./js-yaml/type'</span><span class="s1">);</span>
<span class="s1">module.exports.Schema              = require(</span><span class="s3">'./js-yaml/schema'</span><span class="s1">);</span>
<span class="s1">module.exports.FAILSAFE_SCHEMA     = require(</span><span class="s3">'./js-yaml/schema/failsafe'</span><span class="s1">);</span>
<span class="s1">module.exports.JSON_SCHEMA         = require(</span><span class="s3">'./js-yaml/schema/json'</span><span class="s1">);</span>
<span class="s1">module.exports.CORE_SCHEMA         = require(</span><span class="s3">'./js-yaml/schema/core'</span><span class="s1">);</span>
<span class="s1">module.exports.DEFAULT_SAFE_SCHEMA = require(</span><span class="s3">'./js-yaml/schema/default_safe'</span><span class="s1">);</span>
<span class="s1">module.exports.DEFAULT_FULL_SCHEMA = require(</span><span class="s3">'./js-yaml/schema/default_full'</span><span class="s1">);</span>
<span class="s1">module.exports.load                = loader.load;</span>
<span class="s1">module.exports.loadAll             = loader.loadAll;</span>
<span class="s1">module.exports.safeLoad            = loader.safeLoad;</span>
<span class="s1">module.exports.safeLoadAll         = loader.safeLoadAll;</span>
<span class="s1">module.exports.dump                = dumper.dump;</span>
<span class="s1">module.exports.safeDump            = dumper.safeDump;</span>
<span class="s1">module.exports.YAMLException       = require(</span><span class="s3">'./js-yaml/exception'</span><span class="s1">);</span>

<span class="s0">// Deprecated schema names from JS-YAML 2.0.x</span>
<span class="s1">module.exports.MINIMAL_SCHEMA = require(</span><span class="s3">'./js-yaml/schema/failsafe'</span><span class="s1">);</span>
<span class="s1">module.exports.SAFE_SCHEMA    = require(</span><span class="s3">'./js-yaml/schema/default_safe'</span><span class="s1">);</span>
<span class="s1">module.exports.DEFAULT_SCHEMA = require(</span><span class="s3">'./js-yaml/schema/default_full'</span><span class="s1">);</span>

<span class="s0">// Deprecated functions from JS-YAML 1.x.x</span>
<span class="s1">module.exports.scan           = deprecated(</span><span class="s3">'scan'</span><span class="s1">);</span>
<span class="s1">module.exports.parse          = deprecated(</span><span class="s3">'parse'</span><span class="s1">);</span>
<span class="s1">module.exports.compose        = deprecated(</span><span class="s3">'compose'</span><span class="s1">);</span>
<span class="s1">module.exports.addConstructor = deprecated(</span><span class="s3">'addConstructor'</span><span class="s1">);</span>

<span class="s1">},{</span><span class="s3">&quot;./js-yaml/dumper&quot;</span><span class="s1">:</span><span class="s4">3</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/exception&quot;</span><span class="s1">:</span><span class="s4">4</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/loader&quot;</span><span class="s1">:</span><span class="s4">5</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/schema&quot;</span><span class="s1">:</span><span class="s4">7</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/schema/core&quot;</span><span class="s1">:</span><span class="s4">8</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/schema/default_full&quot;</span><span class="s1">:</span><span class="s4">9</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/schema/default_safe&quot;</span><span class="s1">:</span><span class="s4">10</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/schema/failsafe&quot;</span><span class="s1">:</span><span class="s4">11</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/schema/json&quot;</span><span class="s1">:</span><span class="s4">12</span><span class="s1">,</span><span class="s3">&quot;./js-yaml/type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">2</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">function </span><span class="s1">isNothing(subject) {</span>
  <span class="s2">return </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">subject === </span><span class="s3">'undefined'</span><span class="s1">) || (subject === </span><span class="s2">null</span><span class="s1">);</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">isObject(subject) {</span>
  <span class="s2">return </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">subject === </span><span class="s3">'object'</span><span class="s1">) &amp;&amp; (subject !== </span><span class="s2">null</span><span class="s1">);</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">toArray(sequence) {</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(sequence)) </span><span class="s2">return </span><span class="s1">sequence;</span>
  <span class="s2">else if </span><span class="s1">(isNothing(sequence)) </span><span class="s2">return </span><span class="s1">[];</span>

  <span class="s2">return </span><span class="s1">[ sequence ];</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">extend(target, source) {</span>
  <span class="s2">var </span><span class="s1">index, length, key, sourceKeys;</span>

  <span class="s2">if </span><span class="s1">(source) {</span>
    <span class="s1">sourceKeys = Object.keys(source);</span>

    <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = sourceKeys.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">key = sourceKeys[index];</span>
      <span class="s1">target[key] = source[key];</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">target;</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">repeat(string, count) {</span>
  <span class="s2">var </span><span class="s1">result = </span><span class="s3">''</span><span class="s1">, cycle;</span>

  <span class="s2">for </span><span class="s1">(cycle = </span><span class="s4">0</span><span class="s1">; cycle &lt; count; cycle += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">result += string;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">isNegativeZero(number) {</span>
  <span class="s2">return </span><span class="s1">(number === </span><span class="s4">0</span><span class="s1">) &amp;&amp; (Number.NEGATIVE_INFINITY === </span><span class="s4">1 </span><span class="s1">/ number);</span>
<span class="s1">}</span>


<span class="s1">module.exports.isNothing      = isNothing;</span>
<span class="s1">module.exports.isObject       = isObject;</span>
<span class="s1">module.exports.toArray        = toArray;</span>
<span class="s1">module.exports.repeat         = repeat;</span>
<span class="s1">module.exports.isNegativeZero = isNegativeZero;</span>
<span class="s1">module.exports.extend         = extend;</span>

<span class="s1">},{}],</span><span class="s4">3</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s0">/*eslint-disable no-use-before-define*/</span>

<span class="s2">var </span><span class="s1">common              = require(</span><span class="s3">'./common'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">YAMLException       = require(</span><span class="s3">'./exception'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">DEFAULT_FULL_SCHEMA = require(</span><span class="s3">'./schema/default_full'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">DEFAULT_SAFE_SCHEMA = require(</span><span class="s3">'./schema/default_safe'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_toString       = Object.prototype.toString;</span>
<span class="s2">var </span><span class="s1">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s2">var </span><span class="s1">CHAR_TAB                  = </span><span class="s4">0</span><span class="s1">x09; </span><span class="s0">/* Tab */</span>
<span class="s2">var </span><span class="s1">CHAR_LINE_FEED            = </span><span class="s4">0</span><span class="s1">x0A; </span><span class="s0">/* LF */</span>
<span class="s2">var </span><span class="s1">CHAR_CARRIAGE_RETURN      = </span><span class="s4">0</span><span class="s1">x0D; </span><span class="s0">/* CR */</span>
<span class="s2">var </span><span class="s1">CHAR_SPACE                = </span><span class="s4">0</span><span class="s1">x20; </span><span class="s0">/* Space */</span>
<span class="s2">var </span><span class="s1">CHAR_EXCLAMATION          = </span><span class="s4">0</span><span class="s1">x21; </span><span class="s0">/* ! */</span>
<span class="s2">var </span><span class="s1">CHAR_DOUBLE_QUOTE         = </span><span class="s4">0</span><span class="s1">x22; </span><span class="s0">/* &quot; */</span>
<span class="s2">var </span><span class="s1">CHAR_SHARP                = </span><span class="s4">0</span><span class="s1">x23; </span><span class="s0">/* # */</span>
<span class="s2">var </span><span class="s1">CHAR_PERCENT              = </span><span class="s4">0</span><span class="s1">x25; </span><span class="s0">/* % */</span>
<span class="s2">var </span><span class="s1">CHAR_AMPERSAND            = </span><span class="s4">0</span><span class="s1">x26; </span><span class="s0">/* &amp; */</span>
<span class="s2">var </span><span class="s1">CHAR_SINGLE_QUOTE         = </span><span class="s4">0</span><span class="s1">x27; </span><span class="s0">/* ' */</span>
<span class="s2">var </span><span class="s1">CHAR_ASTERISK             = </span><span class="s4">0</span><span class="s1">x2A; </span><span class="s0">/* * */</span>
<span class="s2">var </span><span class="s1">CHAR_COMMA                = </span><span class="s4">0</span><span class="s1">x2C; </span><span class="s0">/* , */</span>
<span class="s2">var </span><span class="s1">CHAR_MINUS                = </span><span class="s4">0</span><span class="s1">x2D; </span><span class="s0">/* - */</span>
<span class="s2">var </span><span class="s1">CHAR_COLON                = </span><span class="s4">0</span><span class="s1">x3A; </span><span class="s0">/* : */</span>
<span class="s2">var </span><span class="s1">CHAR_EQUALS               = </span><span class="s4">0</span><span class="s1">x3D; </span><span class="s0">/* = */</span>
<span class="s2">var </span><span class="s1">CHAR_GREATER_THAN         = </span><span class="s4">0</span><span class="s1">x3E; </span><span class="s0">/* &gt; */</span>
<span class="s2">var </span><span class="s1">CHAR_QUESTION             = </span><span class="s4">0</span><span class="s1">x3F; </span><span class="s0">/* ? */</span>
<span class="s2">var </span><span class="s1">CHAR_COMMERCIAL_AT        = </span><span class="s4">0</span><span class="s1">x40; </span><span class="s0">/* @ */</span>
<span class="s2">var </span><span class="s1">CHAR_LEFT_SQUARE_BRACKET  = </span><span class="s4">0</span><span class="s1">x5B; </span><span class="s0">/* [ */</span>
<span class="s2">var </span><span class="s1">CHAR_RIGHT_SQUARE_BRACKET = </span><span class="s4">0</span><span class="s1">x5D; </span><span class="s0">/* ] */</span>
<span class="s2">var </span><span class="s1">CHAR_GRAVE_ACCENT         = </span><span class="s4">0</span><span class="s1">x60; </span><span class="s0">/* ` */</span>
<span class="s2">var </span><span class="s1">CHAR_LEFT_CURLY_BRACKET   = </span><span class="s4">0</span><span class="s1">x7B; </span><span class="s0">/* { */</span>
<span class="s2">var </span><span class="s1">CHAR_VERTICAL_LINE        = </span><span class="s4">0</span><span class="s1">x7C; </span><span class="s0">/* | */</span>
<span class="s2">var </span><span class="s1">CHAR_RIGHT_CURLY_BRACKET  = </span><span class="s4">0</span><span class="s1">x7D; </span><span class="s0">/* } */</span>

<span class="s2">var </span><span class="s1">ESCAPE_SEQUENCES = {};</span>

<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x00]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">0'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x07]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">a'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x08]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">b'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x09]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">t'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0A]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">n'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0B]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">v'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0C]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">f'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0D]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">r'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x1B]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">e'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x22]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">&quot;'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x5C]   = </span><span class="s3">'</span><span class="s5">\\\\</span><span class="s3">'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x85]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">N'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">xA0]   = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">_'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x2028] = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">L'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x2029] = </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">P'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">DEPRECATED_BOOLEANS_SYNTAX = [</span>
  <span class="s3">'y'</span><span class="s1">, </span><span class="s3">'Y'</span><span class="s1">, </span><span class="s3">'yes'</span><span class="s1">, </span><span class="s3">'Yes'</span><span class="s1">, </span><span class="s3">'YES'</span><span class="s1">, </span><span class="s3">'on'</span><span class="s1">, </span><span class="s3">'On'</span><span class="s1">, </span><span class="s3">'ON'</span><span class="s1">,</span>
  <span class="s3">'n'</span><span class="s1">, </span><span class="s3">'N'</span><span class="s1">, </span><span class="s3">'no'</span><span class="s1">, </span><span class="s3">'No'</span><span class="s1">, </span><span class="s3">'NO'</span><span class="s1">, </span><span class="s3">'off'</span><span class="s1">, </span><span class="s3">'Off'</span><span class="s1">, </span><span class="s3">'OFF'</span>
<span class="s1">];</span>

<span class="s2">function </span><span class="s1">compileStyleMap(schema, map) {</span>
  <span class="s2">var </span><span class="s1">result, keys, index, length, tag, style, type;</span>

  <span class="s2">if </span><span class="s1">(map === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">{};</span>

  <span class="s1">result = {};</span>
  <span class="s1">keys = Object.keys(map);</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = keys.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">tag = keys[index];</span>
    <span class="s1">style = String(map[tag]);</span>

    <span class="s2">if </span><span class="s1">(tag.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">) === </span><span class="s3">'!!'</span><span class="s1">) {</span>
      <span class="s1">tag = </span><span class="s3">'tag:yaml.org,2002:' </span><span class="s1">+ tag.slice(</span><span class="s4">2</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">type = schema.compiledTypeMap[</span><span class="s3">'fallback'</span><span class="s1">][tag];</span>

    <span class="s2">if </span><span class="s1">(type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {</span>
      <span class="s1">style = type.styleAliases[style];</span>
    <span class="s1">}</span>

    <span class="s1">result[tag] = style;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">encodeHex(character) {</span>
  <span class="s2">var </span><span class="s1">string, handle, length;</span>

  <span class="s1">string = character.toString(</span><span class="s4">16</span><span class="s1">).toUpperCase();</span>

  <span class="s2">if </span><span class="s1">(character &lt;= </span><span class="s4">0</span><span class="s1">xFF) {</span>
    <span class="s1">handle = </span><span class="s3">'x'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(character &lt;= </span><span class="s4">0</span><span class="s1">xFFFF) {</span>
    <span class="s1">handle = </span><span class="s3">'u'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(character &lt;= </span><span class="s4">0</span><span class="s1">xFFFFFFFF) {</span>
    <span class="s1">handle = </span><span class="s3">'U'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'code point within a string may not be greater than 0xFFFFFFFF'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s3">'</span><span class="s5">\\</span><span class="s3">' </span><span class="s1">+ handle + common.repeat(</span><span class="s3">'0'</span><span class="s1">, length - string.length) + string;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">State(options) {</span>
  <span class="s2">this</span><span class="s1">.schema        = options[</span><span class="s3">'schema'</span><span class="s1">] || DEFAULT_FULL_SCHEMA;</span>
  <span class="s2">this</span><span class="s1">.indent        = Math.max(</span><span class="s4">1</span><span class="s1">, (options[</span><span class="s3">'indent'</span><span class="s1">] || </span><span class="s4">2</span><span class="s1">));</span>
  <span class="s2">this</span><span class="s1">.noArrayIndent = options[</span><span class="s3">'noArrayIndent'</span><span class="s1">] || </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.skipInvalid   = options[</span><span class="s3">'skipInvalid'</span><span class="s1">] || </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.flowLevel     = (common.isNothing(options[</span><span class="s3">'flowLevel'</span><span class="s1">]) ? -</span><span class="s4">1 </span><span class="s1">: options[</span><span class="s3">'flowLevel'</span><span class="s1">]);</span>
  <span class="s2">this</span><span class="s1">.styleMap      = compileStyleMap(</span><span class="s2">this</span><span class="s1">.schema, options[</span><span class="s3">'styles'</span><span class="s1">] || </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">this</span><span class="s1">.sortKeys      = options[</span><span class="s3">'sortKeys'</span><span class="s1">] || </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.lineWidth     = options[</span><span class="s3">'lineWidth'</span><span class="s1">] || </span><span class="s4">80</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.noRefs        = options[</span><span class="s3">'noRefs'</span><span class="s1">] || </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.noCompatMode  = options[</span><span class="s3">'noCompatMode'</span><span class="s1">] || </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.condenseFlow  = options[</span><span class="s3">'condenseFlow'</span><span class="s1">] || </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">this</span><span class="s1">.implicitTypes = </span><span class="s2">this</span><span class="s1">.schema.compiledImplicit;</span>
  <span class="s2">this</span><span class="s1">.explicitTypes = </span><span class="s2">this</span><span class="s1">.schema.compiledExplicit;</span>

  <span class="s2">this</span><span class="s1">.tag = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.result = </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s2">this</span><span class="s1">.duplicates = [];</span>
  <span class="s2">this</span><span class="s1">.usedDuplicates = </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// Indents every line in a string. Empty lines (\n only) are not indented.</span>
<span class="s2">function </span><span class="s1">indentString(string, spaces) {</span>
  <span class="s2">var </span><span class="s1">ind = common.repeat(</span><span class="s3">' '</span><span class="s1">, spaces),</span>
      <span class="s1">position = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">next = -</span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">result = </span><span class="s3">''</span><span class="s1">,</span>
      <span class="s1">line,</span>
      <span class="s1">length = string.length;</span>

  <span class="s2">while </span><span class="s1">(position &lt; length) {</span>
    <span class="s1">next = string.indexOf(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, position);</span>
    <span class="s2">if </span><span class="s1">(next === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">line = string.slice(position);</span>
      <span class="s1">position = length;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">line = string.slice(position, next + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">position = next + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(line.length &amp;&amp; line !== </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">) result += ind;</span>

    <span class="s1">result += line;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">generateNextLine(state, level) {</span>
  <span class="s2">return </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ common.repeat(</span><span class="s3">' '</span><span class="s1">, state.indent * level);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">testImplicitResolving(state, str) {</span>
  <span class="s2">var </span><span class="s1">index, length, type;</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = state.implicitTypes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">type = state.implicitTypes[index];</span>

    <span class="s2">if </span><span class="s1">(type.resolve(str)) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// [33] s-white ::= s-space | s-tab</span>
<span class="s2">function </span><span class="s1">isWhitespace(c) {</span>
  <span class="s2">return </span><span class="s1">c === CHAR_SPACE || c === CHAR_TAB;</span>
<span class="s1">}</span>

<span class="s0">// Returns true if the character can be printed without escaping.</span>
<span class="s0">// From YAML 1.2: &quot;any allowed characters known to be non-printable</span>
<span class="s0">// should also be escaped. [However,] This isn’t mandatory&quot;</span>
<span class="s0">// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.</span>
<span class="s2">function </span><span class="s1">isPrintable(c) {</span>
  <span class="s2">return  </span><span class="s1">(</span><span class="s4">0</span><span class="s1">x00020 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x00007E)</span>
      <span class="s1">|| ((</span><span class="s4">0</span><span class="s1">x000A1 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x00D7FF) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">x2028 &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">x2029)</span>
      <span class="s1">|| ((</span><span class="s4">0</span><span class="s1">x0E000 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x00FFFD) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF </span><span class="s0">/* BOM */</span><span class="s1">)</span>
      <span class="s1">||  (</span><span class="s4">0</span><span class="s1">x10000 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x10FFFF);</span>
<span class="s1">}</span>

<span class="s0">// [34] ns-char ::= nb-char - s-white</span>
<span class="s0">// [27] nb-char ::= c-printable - b-char - c-byte-order-mark</span>
<span class="s0">// [26] b-char  ::= b-line-feed | b-carriage-return</span>
<span class="s0">// [24] b-line-feed       ::=     #xA    /* LF */</span>
<span class="s0">// [25] b-carriage-return ::=     #xD    /* CR */</span>
<span class="s0">// [3]  c-byte-order-mark ::=     #xFEFF</span>
<span class="s2">function </span><span class="s1">isNsChar(c) {</span>
  <span class="s2">return </span><span class="s1">isPrintable(c) &amp;&amp; !isWhitespace(c)</span>
    <span class="s0">// byte-order-mark</span>
    <span class="s1">&amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF</span>
    <span class="s0">// b-char</span>
    <span class="s1">&amp;&amp; c !== CHAR_CARRIAGE_RETURN</span>
    <span class="s1">&amp;&amp; c !== CHAR_LINE_FEED;</span>
<span class="s1">}</span>

<span class="s0">// Simplified test for values allowed after the first character in plain style.</span>
<span class="s2">function </span><span class="s1">isPlainSafe(c, prev) {</span>
  <span class="s0">// Uses a subset of nb-char - c-flow-indicator - &quot;:&quot; - &quot;#&quot;</span>
  <span class="s0">// where nb-char ::= c-printable - b-char - c-byte-order-mark.</span>
  <span class="s2">return </span><span class="s1">isPrintable(c) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF</span>
    <span class="s0">// - c-flow-indicator</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMA</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s0">// - &quot;:&quot; - &quot;#&quot;</span>
    <span class="s0">// /* An ns-char preceding */ &quot;#&quot;</span>
    <span class="s1">&amp;&amp; c !== CHAR_COLON</span>
    <span class="s1">&amp;&amp; ((c !== CHAR_SHARP) || (prev &amp;&amp; isNsChar(prev)));</span>
<span class="s1">}</span>

<span class="s0">// Simplified test for values allowed as the first character in plain style.</span>
<span class="s2">function </span><span class="s1">isPlainSafeFirst(c) {</span>
  <span class="s0">// Uses a subset of ns-char - c-indicator</span>
  <span class="s0">// where ns-char = nb-char - s-white.</span>
  <span class="s2">return </span><span class="s1">isPrintable(c) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF</span>
    <span class="s1">&amp;&amp; !isWhitespace(c) </span><span class="s0">// - s-white</span>
    <span class="s0">// - (c-indicator ::=</span>
    <span class="s0">// “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”</span>
    <span class="s1">&amp;&amp; c !== CHAR_MINUS</span>
    <span class="s1">&amp;&amp; c !== CHAR_QUESTION</span>
    <span class="s1">&amp;&amp; c !== CHAR_COLON</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMA</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s0">// | “#” | “&amp;” | “*” | “!” | “|” | “=” | “&gt;” | “'” | “&quot;”</span>
    <span class="s1">&amp;&amp; c !== CHAR_SHARP</span>
    <span class="s1">&amp;&amp; c !== CHAR_AMPERSAND</span>
    <span class="s1">&amp;&amp; c !== CHAR_ASTERISK</span>
    <span class="s1">&amp;&amp; c !== CHAR_EXCLAMATION</span>
    <span class="s1">&amp;&amp; c !== CHAR_VERTICAL_LINE</span>
    <span class="s1">&amp;&amp; c !== CHAR_EQUALS</span>
    <span class="s1">&amp;&amp; c !== CHAR_GREATER_THAN</span>
    <span class="s1">&amp;&amp; c !== CHAR_SINGLE_QUOTE</span>
    <span class="s1">&amp;&amp; c !== CHAR_DOUBLE_QUOTE</span>
    <span class="s0">// | “%” | “@” | “`”)</span>
    <span class="s1">&amp;&amp; c !== CHAR_PERCENT</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMERCIAL_AT</span>
    <span class="s1">&amp;&amp; c !== CHAR_GRAVE_ACCENT;</span>
<span class="s1">}</span>

<span class="s0">// Determines whether block indentation indicator is required.</span>
<span class="s2">function </span><span class="s1">needIndentIndicator(string) {</span>
  <span class="s2">var </span><span class="s1">leadingSpaceRe = /^\n* /;</span>
  <span class="s2">return </span><span class="s1">leadingSpaceRe.test(string);</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">STYLE_PLAIN   = </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">STYLE_SINGLE  = </span><span class="s4">2</span><span class="s1">,</span>
    <span class="s1">STYLE_LITERAL = </span><span class="s4">3</span><span class="s1">,</span>
    <span class="s1">STYLE_FOLDED  = </span><span class="s4">4</span><span class="s1">,</span>
    <span class="s1">STYLE_DOUBLE  = </span><span class="s4">5</span><span class="s1">;</span>

<span class="s0">// Determines which scalar styles are possible and returns the preferred style.</span>
<span class="s0">// lineWidth = -1 =&gt; no limit.</span>
<span class="s0">// Pre-conditions: str.length &gt; 0.</span>
<span class="s0">// Post-conditions:</span>
<span class="s0">//    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.</span>
<span class="s0">//    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).</span>
<span class="s0">//    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).</span>
<span class="s2">function </span><span class="s1">chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {</span>
  <span class="s2">var </span><span class="s1">i;</span>
  <span class="s2">var </span><span class="s1">char, prev_char;</span>
  <span class="s2">var </span><span class="s1">hasLineBreak = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">hasFoldableLine = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// only checked if shouldTrackWidth</span>
  <span class="s2">var </span><span class="s1">shouldTrackWidth = lineWidth !== -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">previousLineBreak = -</span><span class="s4">1</span><span class="s1">; </span><span class="s0">// count the first line correctly</span>
  <span class="s2">var </span><span class="s1">plain = isPlainSafeFirst(string.charCodeAt(</span><span class="s4">0</span><span class="s1">))</span>
          <span class="s1">&amp;&amp; !isWhitespace(string.charCodeAt(string.length - </span><span class="s4">1</span><span class="s1">));</span>

  <span class="s2">if </span><span class="s1">(singleLineOnly) {</span>
    <span class="s0">// Case: no block styles.</span>
    <span class="s0">// Check for disallowed characters to rule out plain and single.</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; i++) {</span>
      <span class="s1">char = string.charCodeAt(i);</span>
      <span class="s2">if </span><span class="s1">(!isPrintable(char)) {</span>
        <span class="s2">return </span><span class="s1">STYLE_DOUBLE;</span>
      <span class="s1">}</span>
      <span class="s1">prev_char = i &gt; </span><span class="s4">0 </span><span class="s1">? string.charCodeAt(i - </span><span class="s4">1</span><span class="s1">) : </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">plain = plain &amp;&amp; isPlainSafe(char, prev_char);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s0">// Case: block styles permitted.</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; i++) {</span>
      <span class="s1">char = string.charCodeAt(i);</span>
      <span class="s2">if </span><span class="s1">(char === CHAR_LINE_FEED) {</span>
        <span class="s1">hasLineBreak = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">// Check if any line can be folded.</span>
        <span class="s2">if </span><span class="s1">(shouldTrackWidth) {</span>
          <span class="s1">hasFoldableLine = hasFoldableLine ||</span>
            <span class="s0">// Foldable line = too long, and not more-indented.</span>
            <span class="s1">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s1">&gt; lineWidth &amp;&amp;</span>
             <span class="s1">string[previousLineBreak + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s3">' '</span><span class="s1">);</span>
          <span class="s1">previousLineBreak = i;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isPrintable(char)) {</span>
        <span class="s2">return </span><span class="s1">STYLE_DOUBLE;</span>
      <span class="s1">}</span>
      <span class="s1">prev_char = i &gt; </span><span class="s4">0 </span><span class="s1">? string.charCodeAt(i - </span><span class="s4">1</span><span class="s1">) : </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">plain = plain &amp;&amp; isPlainSafe(char, prev_char);</span>
    <span class="s1">}</span>
    <span class="s0">// in case the end is missing a \n</span>
    <span class="s1">hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;</span>
      <span class="s1">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s1">&gt; lineWidth &amp;&amp;</span>
       <span class="s1">string[previousLineBreak + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s3">' '</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s0">// Although every style can represent \n without escaping, prefer block styles</span>
  <span class="s0">// for multiline, since they're more readable and they don't add empty lines.</span>
  <span class="s0">// Also prefer folding a super-long line.</span>
  <span class="s2">if </span><span class="s1">(!hasLineBreak &amp;&amp; !hasFoldableLine) {</span>
    <span class="s0">// Strings interpretable as another type have to be quoted;</span>
    <span class="s0">// e.g. the string 'true' vs. the boolean true.</span>
    <span class="s2">return </span><span class="s1">plain &amp;&amp; !testAmbiguousType(string)</span>
      <span class="s1">? STYLE_PLAIN : STYLE_SINGLE;</span>
  <span class="s1">}</span>
  <span class="s0">// Edge case: block indentation indicator can only have one digit.</span>
  <span class="s2">if </span><span class="s1">(indentPerLevel &gt; </span><span class="s4">9 </span><span class="s1">&amp;&amp; needIndentIndicator(string)) {</span>
    <span class="s2">return </span><span class="s1">STYLE_DOUBLE;</span>
  <span class="s1">}</span>
  <span class="s0">// At this point we know block styles are valid.</span>
  <span class="s0">// Prefer literal style unless we want to fold.</span>
  <span class="s2">return </span><span class="s1">hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;</span>
<span class="s1">}</span>

<span class="s0">// Note: line breaking/folding is implemented for only the folded style.</span>
<span class="s0">// NB. We drop the last trailing newline (if any) of a returned block scalar</span>
<span class="s0">//  since the dumper adds its own newline. This always works:</span>
<span class="s0">//    • No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.</span>
<span class="s0">//    • Ending newline    =&gt; removed then restored.</span>
<span class="s0">//  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.</span>
<span class="s2">function </span><span class="s1">writeScalar(state, string, level, iskey) {</span>
  <span class="s1">state.dump = (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">if </span><span class="s1">(string.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s3">&quot;''&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!state.noCompatMode &amp;&amp;</span>
        <span class="s1">DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s3">&quot;'&quot; </span><span class="s1">+ string + </span><span class="s3">&quot;'&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">indent = state.indent * Math.max(</span><span class="s4">1</span><span class="s1">, level); </span><span class="s0">// no 0-indent scalars</span>
    <span class="s0">// As indentation gets deeper, let the width decrease monotonically</span>
    <span class="s0">// to the lower bound min(state.lineWidth, 40).</span>
    <span class="s0">// Note that this implies</span>
    <span class="s0">//  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.</span>
    <span class="s0">//  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.</span>
    <span class="s0">// This behaves better than a constant minimum width which disallows narrower options,</span>
    <span class="s0">// or an indent threshold which causes the width to suddenly increase.</span>
    <span class="s2">var </span><span class="s1">lineWidth = state.lineWidth === -</span><span class="s4">1</span>
      <span class="s1">? -</span><span class="s4">1 </span><span class="s1">: Math.max(Math.min(state.lineWidth, </span><span class="s4">40</span><span class="s1">), state.lineWidth - indent);</span>

    <span class="s0">// Without knowing if keys are implicit/explicit, assume implicit for safety.</span>
    <span class="s2">var </span><span class="s1">singleLineOnly = iskey</span>
      <span class="s0">// No block styles in flow mode.</span>
      <span class="s1">|| (state.flowLevel &gt; -</span><span class="s4">1 </span><span class="s1">&amp;&amp; level &gt;= state.flowLevel);</span>
    <span class="s2">function </span><span class="s1">testAmbiguity(string) {</span>
      <span class="s2">return </span><span class="s1">testImplicitResolving(state, string);</span>
    <span class="s1">}</span>

    <span class="s2">switch </span><span class="s1">(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {</span>
      <span class="s2">case </span><span class="s1">STYLE_PLAIN:</span>
        <span class="s2">return </span><span class="s1">string;</span>
      <span class="s2">case </span><span class="s1">STYLE_SINGLE:</span>
        <span class="s2">return </span><span class="s3">&quot;'&quot; </span><span class="s1">+ string.replace(/</span><span class="s3">'/g, &quot;''&quot;) + &quot;'&quot;;</span>
      <span class="s2">case </span><span class="s1">STYLE_LITERAL:</span>
        <span class="s2">return </span><span class="s3">'|' </span><span class="s1">+ blockHeader(string, state.indent)</span>
          <span class="s1">+ dropEndingNewline(indentString(string, indent));</span>
      <span class="s2">case </span><span class="s1">STYLE_FOLDED:</span>
        <span class="s2">return </span><span class="s3">'&gt;' </span><span class="s1">+ blockHeader(string, state.indent)</span>
          <span class="s1">+ dropEndingNewline(indentString(foldString(string, lineWidth), indent));</span>
      <span class="s2">case </span><span class="s1">STYLE_DOUBLE:</span>
        <span class="s2">return </span><span class="s3">'&quot;' </span><span class="s1">+ escapeString(string, lineWidth) + </span><span class="s3">'&quot;'</span><span class="s1">;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'impossible error: invalid scalar style'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}());</span>
<span class="s1">}</span>

<span class="s0">// Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.</span>
<span class="s2">function </span><span class="s1">blockHeader(string, indentPerLevel) {</span>
  <span class="s2">var </span><span class="s1">indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s0">// note the special case: the string '\n' counts as a &quot;trailing&quot; empty line.</span>
  <span class="s2">var </span><span class="s1">clip =          string[string.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">keep = clip &amp;&amp; (string[string.length - </span><span class="s4">2</span><span class="s1">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">|| string === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">chomp = keep ? </span><span class="s3">'+' </span><span class="s1">: (clip ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">'-'</span><span class="s1">);</span>

  <span class="s2">return </span><span class="s1">indentIndicator + chomp + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// (See the note for writeScalar.)</span>
<span class="s2">function </span><span class="s1">dropEndingNewline(string) {</span>
  <span class="s2">return </span><span class="s1">string[string.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">? string.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">) : string;</span>
<span class="s1">}</span>

<span class="s0">// Note: a long line without a suitable break point will exceed the width limit.</span>
<span class="s0">// Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.</span>
<span class="s2">function </span><span class="s1">foldString(string, width) {</span>
  <span class="s0">// In folded style, $k$ consecutive newlines output as $k+1$ newlines—</span>
  <span class="s0">// unless they're before or after a more-indented line, or at the very</span>
  <span class="s0">// beginning or end, in which case $k$ maps to $k$.</span>
  <span class="s0">// Therefore, parse each chunk as newline(s) followed by a content line.</span>
  <span class="s2">var </span><span class="s1">lineRe = /(\n+)([^\n]*)/g;</span>

  <span class="s0">// first line (possibly an empty line)</span>
  <span class="s2">var </span><span class="s1">result = (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">nextLF = string.indexOf(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">);</span>
    <span class="s1">nextLF = nextLF !== -</span><span class="s4">1 </span><span class="s1">? nextLF : string.length;</span>
    <span class="s1">lineRe.lastIndex = nextLF;</span>
    <span class="s2">return </span><span class="s1">foldLine(string.slice(</span><span class="s4">0</span><span class="s1">, nextLF), width);</span>
  <span class="s1">}());</span>
  <span class="s0">// If we haven't reached the first content line yet, don't add an extra \n.</span>
  <span class="s2">var </span><span class="s1">prevMoreIndented = string[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">|| string[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">' '</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">moreIndented;</span>

  <span class="s0">// rest of the lines</span>
  <span class="s2">var </span><span class="s1">match;</span>
  <span class="s2">while </span><span class="s1">((match = lineRe.exec(string))) {</span>
    <span class="s2">var </span><span class="s1">prefix = match[</span><span class="s4">1</span><span class="s1">], line = match[</span><span class="s4">2</span><span class="s1">];</span>
    <span class="s1">moreIndented = (line[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">' '</span><span class="s1">);</span>
    <span class="s1">result += prefix</span>
      <span class="s1">+ (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== </span><span class="s3">''</span>
        <span class="s1">? </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span>
      <span class="s1">+ foldLine(line, width);</span>
    <span class="s1">prevMoreIndented = moreIndented;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">// Greedy line breaking.</span>
<span class="s0">// Picks the longest line under the limit each time,</span>
<span class="s0">// otherwise settles for the shortest line over the limit.</span>
<span class="s0">// NB. More-indented lines *cannot* be folded, as that would add an extra \n.</span>
<span class="s2">function </span><span class="s1">foldLine(line, width) {</span>
  <span class="s2">if </span><span class="s1">(line === </span><span class="s3">'' </span><span class="s1">|| line[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">' '</span><span class="s1">) </span><span class="s2">return </span><span class="s1">line;</span>

  <span class="s0">// Since a more-indented line adds a \n, breaks can't be followed by a space.</span>
  <span class="s2">var </span><span class="s1">breakRe = / [^ ]/g; </span><span class="s0">// note: the match index will always be &lt;= length-2.</span>
  <span class="s2">var </span><span class="s1">match;</span>
  <span class="s0">// start is an inclusive index. end, curr, and next are exclusive.</span>
  <span class="s2">var </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">, end, curr = </span><span class="s4">0</span><span class="s1">, next = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">result = </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s0">// Invariants: 0 &lt;= start &lt;= length-1.</span>
  <span class="s0">//   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.</span>
  <span class="s0">// Inside the loop:</span>
  <span class="s0">//   A match implies length &gt;= 2, so curr and next are &lt;= length-2.</span>
  <span class="s2">while </span><span class="s1">((match = breakRe.exec(line))) {</span>
    <span class="s1">next = match.index;</span>
    <span class="s0">// maintain invariant: curr - start &lt;= width</span>
    <span class="s2">if </span><span class="s1">(next - start &gt; width) {</span>
      <span class="s1">end = (curr &gt; start) ? curr : next; </span><span class="s0">// derive end &lt;= length-2</span>
      <span class="s1">result += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ line.slice(start, end);</span>
      <span class="s0">// skip the space that was output as \n</span>
      <span class="s1">start = end + </span><span class="s4">1</span><span class="s1">;                    </span><span class="s0">// derive start &lt;= length-1</span>
    <span class="s1">}</span>
    <span class="s1">curr = next;</span>
  <span class="s1">}</span>

  <span class="s0">// By the invariants, start &lt;= length-1, so there is something left over.</span>
  <span class="s0">// It is either the whole string or a part starting from non-whitespace.</span>
  <span class="s1">result += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
  <span class="s0">// Insert a break if the remainder is too long and there is a break available.</span>
  <span class="s2">if </span><span class="s1">(line.length - start &gt; width &amp;&amp; curr &gt; start) {</span>
    <span class="s1">result += line.slice(start, curr) + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ line.slice(curr + </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">result += line.slice(start);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result.slice(</span><span class="s4">1</span><span class="s1">); </span><span class="s0">// drop extra \n joiner</span>
<span class="s1">}</span>

<span class="s0">// Escapes a double-quoted string.</span>
<span class="s2">function </span><span class="s1">escapeString(string) {</span>
  <span class="s2">var </span><span class="s1">result = </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">char, nextChar;</span>
  <span class="s2">var </span><span class="s1">escapeSeq;</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; i++) {</span>
    <span class="s1">char = string.charCodeAt(i);</span>
    <span class="s0">// Check for surrogate pairs (reference Unicode 3.0 section &quot;3.7 Surrogates&quot;).</span>
    <span class="s2">if </span><span class="s1">(char &gt;= </span><span class="s4">0</span><span class="s1">xD800 &amp;&amp; char &lt;= </span><span class="s4">0</span><span class="s1">xDBFF</span><span class="s0">/* high surrogate */</span><span class="s1">) {</span>
      <span class="s1">nextChar = string.charCodeAt(i + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(nextChar &gt;= </span><span class="s4">0</span><span class="s1">xDC00 &amp;&amp; nextChar &lt;= </span><span class="s4">0</span><span class="s1">xDFFF</span><span class="s0">/* low surrogate */</span><span class="s1">) {</span>
        <span class="s0">// Combine the surrogate pair and store it escaped.</span>
        <span class="s1">result += encodeHex((char - </span><span class="s4">0</span><span class="s1">xD800) * </span><span class="s4">0</span><span class="s1">x400 + nextChar - </span><span class="s4">0</span><span class="s1">xDC00 + </span><span class="s4">0</span><span class="s1">x10000);</span>
        <span class="s0">// Advance index one extra since we already used that char here.</span>
        <span class="s1">i++; </span><span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">escapeSeq = ESCAPE_SEQUENCES[char];</span>
    <span class="s1">result += !escapeSeq &amp;&amp; isPrintable(char)</span>
      <span class="s1">? string[i]</span>
      <span class="s1">: escapeSeq || encodeHex(char);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">writeFlowSequence(state, level, object) {</span>
  <span class="s2">var </span><span class="s1">_result = </span><span class="s3">''</span><span class="s1">,</span>
      <span class="s1">_tag    = state.tag,</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s0">// Write only valid elements.</span>
    <span class="s2">if </span><span class="s1">(writeNode(state, level, object[index], </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(index !== </span><span class="s4">0</span><span class="s1">) _result += </span><span class="s3">',' </span><span class="s1">+ (!state.condenseFlow ? </span><span class="s3">' ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s1">_result += state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = </span><span class="s3">'[' </span><span class="s1">+ _result + </span><span class="s3">']'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">writeBlockSequence(state, level, object, compact) {</span>
  <span class="s2">var </span><span class="s1">_result = </span><span class="s3">''</span><span class="s1">,</span>
      <span class="s1">_tag    = state.tag,</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s0">// Write only valid elements.</span>
    <span class="s2">if </span><span class="s1">(writeNode(state, level + </span><span class="s4">1</span><span class="s1">, object[index], </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(!compact || index !== </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">_result += generateNextLine(state, level);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">_result += </span><span class="s3">'-'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">_result += </span><span class="s3">'- '</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">_result += state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = _result || </span><span class="s3">'[]'</span><span class="s1">; </span><span class="s0">// Empty sequence if no valid values.</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">writeFlowMapping(state, level, object) {</span>
  <span class="s2">var </span><span class="s1">_result       = </span><span class="s3">''</span><span class="s1">,</span>
      <span class="s1">_tag          = state.tag,</span>
      <span class="s1">objectKeyList = Object.keys(object),</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">objectKey,</span>
      <span class="s1">objectValue,</span>
      <span class="s1">pairBuffer;</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>

    <span class="s1">pairBuffer = </span><span class="s3">''</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(index !== </span><span class="s4">0</span><span class="s1">) pairBuffer += </span><span class="s3">', '</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(state.condenseFlow) pairBuffer += </span><span class="s3">'&quot;'</span><span class="s1">;</span>

    <span class="s1">objectKey = objectKeyList[index];</span>
    <span class="s1">objectValue = object[objectKey];</span>

    <span class="s2">if </span><span class="s1">(!writeNode(state, level, objectKey, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">)) {</span>
      <span class="s2">continue</span><span class="s1">; </span><span class="s0">// Skip this pair because of invalid key;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(state.dump.length &gt; </span><span class="s4">1024</span><span class="s1">) pairBuffer += </span><span class="s3">'? '</span><span class="s1">;</span>

    <span class="s1">pairBuffer += state.dump + (state.condenseFlow ? </span><span class="s3">'&quot;' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">) + </span><span class="s3">':' </span><span class="s1">+ (state.condenseFlow ? </span><span class="s3">'' </span><span class="s1">: </span><span class="s3">' '</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(!writeNode(state, level, objectValue, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">false</span><span class="s1">)) {</span>
      <span class="s2">continue</span><span class="s1">; </span><span class="s0">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s0">// Both key and value are valid.</span>
    <span class="s1">_result += pairBuffer;</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = </span><span class="s3">'{' </span><span class="s1">+ _result + </span><span class="s3">'}'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">writeBlockMapping(state, level, object, compact) {</span>
  <span class="s2">var </span><span class="s1">_result       = </span><span class="s3">''</span><span class="s1">,</span>
      <span class="s1">_tag          = state.tag,</span>
      <span class="s1">objectKeyList = Object.keys(object),</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">objectKey,</span>
      <span class="s1">objectValue,</span>
      <span class="s1">explicitPair,</span>
      <span class="s1">pairBuffer;</span>

  <span class="s0">// Allow sorting keys so that the output file is deterministic</span>
  <span class="s2">if </span><span class="s1">(state.sortKeys === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s0">// Default sorting</span>
    <span class="s1">objectKeyList.sort();</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">state.sortKeys === </span><span class="s3">'function'</span><span class="s1">) {</span>
    <span class="s0">// Custom sort function</span>
    <span class="s1">objectKeyList.sort(state.sortKeys);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.sortKeys) {</span>
    <span class="s0">// Something is wrong</span>
    <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'sortKeys must be a boolean or a function'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">pairBuffer = </span><span class="s3">''</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(!compact || index !== </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pairBuffer += generateNextLine(state, level);</span>
    <span class="s1">}</span>

    <span class="s1">objectKey = objectKeyList[index];</span>
    <span class="s1">objectValue = object[objectKey];</span>

    <span class="s2">if </span><span class="s1">(!writeNode(state, level + </span><span class="s4">1</span><span class="s1">, objectKey, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">)) {</span>
      <span class="s2">continue</span><span class="s1">; </span><span class="s0">// Skip this pair because of invalid key.</span>
    <span class="s1">}</span>

    <span class="s1">explicitPair = (state.tag !== </span><span class="s2">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s3">'?'</span><span class="s1">) ||</span>
                   <span class="s1">(state.dump &amp;&amp; state.dump.length &gt; </span><span class="s4">1024</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(explicitPair) {</span>
      <span class="s2">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">pairBuffer += </span><span class="s3">'?'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">pairBuffer += </span><span class="s3">'? '</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s2">if </span><span class="s1">(explicitPair) {</span>
      <span class="s1">pairBuffer += generateNextLine(state, level);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!writeNode(state, level + </span><span class="s4">1</span><span class="s1">, objectValue, </span><span class="s2">true</span><span class="s1">, explicitPair)) {</span>
      <span class="s2">continue</span><span class="s1">; </span><span class="s0">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s1">pairBuffer += </span><span class="s3">':'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">pairBuffer += </span><span class="s3">': '</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s0">// Both key and value are valid.</span>
    <span class="s1">_result += pairBuffer;</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = _result || </span><span class="s3">'{}'</span><span class="s1">; </span><span class="s0">// Empty mapping if no valid pairs.</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">detectType(state, object, explicit) {</span>
  <span class="s2">var </span><span class="s1">_result, typeList, index, length, type, style;</span>

  <span class="s1">typeList = explicit ? state.explicitTypes : state.implicitTypes;</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = typeList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">type = typeList[index];</span>

    <span class="s2">if </span><span class="s1">((type.instanceOf  || type.predicate) &amp;&amp;</span>
        <span class="s1">(!type.instanceOf || ((</span><span class="s2">typeof </span><span class="s1">object === </span><span class="s3">'object'</span><span class="s1">) &amp;&amp; (object </span><span class="s2">instanceof </span><span class="s1">type.instanceOf))) &amp;&amp;</span>
        <span class="s1">(!type.predicate  || type.predicate(object))) {</span>

      <span class="s1">state.tag = explicit ? type.tag : </span><span class="s3">'?'</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(type.represent) {</span>
        <span class="s1">style = state.styleMap[type.tag] || type.defaultStyle;</span>

        <span class="s2">if </span><span class="s1">(_toString.call(type.represent) === </span><span class="s3">'[object Function]'</span><span class="s1">) {</span>
          <span class="s1">_result = type.represent(object, style);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_hasOwnProperty.call(type.represent, style)) {</span>
          <span class="s1">_result = type.represent[style](object, style);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'!&lt;' </span><span class="s1">+ type.tag + </span><span class="s3">'&gt; tag resolver accepts not &quot;' </span><span class="s1">+ style + </span><span class="s3">'&quot; style'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">state.dump = _result;</span>
      <span class="s1">}</span>

      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">// Serializes `object` and writes it to global `result`.</span>
<span class="s0">// Returns true on success, or false on invalid object.</span>
<span class="s0">//</span>
<span class="s2">function </span><span class="s1">writeNode(state, level, object, block, compact, iskey) {</span>
  <span class="s1">state.tag = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">state.dump = object;</span>

  <span class="s2">if </span><span class="s1">(!detectType(state, object, </span><span class="s2">false</span><span class="s1">)) {</span>
    <span class="s1">detectType(state, object, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">type = _toString.call(state.dump);</span>

  <span class="s2">if </span><span class="s1">(block) {</span>
    <span class="s1">block = (state.flowLevel &lt; </span><span class="s4">0 </span><span class="s1">|| state.flowLevel &gt; level);</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">objectOrArray = type === </span><span class="s3">'[object Object]' </span><span class="s1">|| type === </span><span class="s3">'[object Array]'</span><span class="s1">,</span>
      <span class="s1">duplicateIndex,</span>
      <span class="s1">duplicate;</span>

  <span class="s2">if </span><span class="s1">(objectOrArray) {</span>
    <span class="s1">duplicateIndex = state.duplicates.indexOf(object);</span>
    <span class="s1">duplicate = duplicateIndex !== -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">((state.tag !== </span><span class="s2">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s3">'?'</span><span class="s1">) || duplicate || (state.indent !== </span><span class="s4">2 </span><span class="s1">&amp;&amp; level &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
    <span class="s1">compact = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {</span>
    <span class="s1">state.dump = </span><span class="s3">'*ref_' </span><span class="s1">+ duplicateIndex;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {</span>
      <span class="s1">state.usedDuplicates[duplicateIndex] = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">'[object Object]'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(block &amp;&amp; (Object.keys(state.dump).length !== </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">writeBlockMapping(state, level, state.dump, compact);</span>
        <span class="s2">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s1">+ duplicateIndex + state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">writeFlowMapping(state, level, state.dump);</span>
        <span class="s2">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s1">+ duplicateIndex + </span><span class="s3">' ' </span><span class="s1">+ state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s3">'[object Array]'</span><span class="s1">) {</span>
      <span class="s2">var </span><span class="s1">arrayLevel = (state.noArrayIndent &amp;&amp; (level &gt; </span><span class="s4">0</span><span class="s1">)) ? level - </span><span class="s4">1 </span><span class="s1">: level;</span>
      <span class="s2">if </span><span class="s1">(block &amp;&amp; (state.dump.length !== </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">writeBlockSequence(state, arrayLevel, state.dump, compact);</span>
        <span class="s2">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s1">+ duplicateIndex + state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">writeFlowSequence(state, arrayLevel, state.dump);</span>
        <span class="s2">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s3">'&amp;ref_' </span><span class="s1">+ duplicateIndex + </span><span class="s3">' ' </span><span class="s1">+ state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s3">'[object String]'</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(state.tag !== </span><span class="s3">'?'</span><span class="s1">) {</span>
        <span class="s1">writeScalar(state, state.dump, level, iskey);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(state.skipInvalid) </span><span class="s2">return false</span><span class="s1">;</span>
      <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'unacceptable kind of an object to dump ' </span><span class="s1">+ type);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(state.tag !== </span><span class="s2">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s3">'?'</span><span class="s1">) {</span>
      <span class="s1">state.dump = </span><span class="s3">'!&lt;' </span><span class="s1">+ state.tag + </span><span class="s3">'&gt; ' </span><span class="s1">+ state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getDuplicateReferences(object, state) {</span>
  <span class="s2">var </span><span class="s1">objects = [],</span>
      <span class="s1">duplicatesIndexes = [],</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s1">inspectNode(object, objects, duplicatesIndexes);</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = duplicatesIndexes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">state.duplicates.push(objects[duplicatesIndexes[index]]);</span>
  <span class="s1">}</span>
  <span class="s1">state.usedDuplicates = </span><span class="s2">new </span><span class="s1">Array(length);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">inspectNode(object, objects, duplicatesIndexes) {</span>
  <span class="s2">var </span><span class="s1">objectKeyList,</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s2">if </span><span class="s1">(object !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">object === </span><span class="s3">'object'</span><span class="s1">) {</span>
    <span class="s1">index = objects.indexOf(object);</span>
    <span class="s2">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(duplicatesIndexes.indexOf(index) === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">duplicatesIndexes.push(index);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">objects.push(object);</span>

      <span class="s2">if </span><span class="s1">(Array.isArray(object)) {</span>
        <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">inspectNode(object[index], objects, duplicatesIndexes);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">objectKeyList = Object.keys(object);</span>

        <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">dump(input, options) {</span>
  <span class="s1">options = options || {};</span>

  <span class="s2">var </span><span class="s1">state = </span><span class="s2">new </span><span class="s1">State(options);</span>

  <span class="s2">if </span><span class="s1">(!state.noRefs) getDuplicateReferences(input, state);</span>

  <span class="s2">if </span><span class="s1">(writeNode(state, </span><span class="s4">0</span><span class="s1">, input, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">)) </span><span class="s2">return </span><span class="s1">state.dump + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>

  <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">safeDump(input, options) {</span>
  <span class="s2">return </span><span class="s1">dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));</span>
<span class="s1">}</span>

<span class="s1">module.exports.dump     = dump;</span>
<span class="s1">module.exports.safeDump = safeDump;</span>

<span class="s1">},{</span><span class="s3">&quot;./common&quot;</span><span class="s1">:</span><span class="s4">2</span><span class="s1">,</span><span class="s3">&quot;./exception&quot;</span><span class="s1">:</span><span class="s4">4</span><span class="s1">,</span><span class="s3">&quot;./schema/default_full&quot;</span><span class="s1">:</span><span class="s4">9</span><span class="s1">,</span><span class="s3">&quot;./schema/default_safe&quot;</span><span class="s1">:</span><span class="s4">10</span><span class="s1">}],</span><span class="s4">4</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s0">// YAML error class. http://stackoverflow.com/questions/8458984</span>
<span class="s0">//</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">function </span><span class="s1">YAMLException(reason, mark) {</span>
  <span class="s0">// Super constructor</span>
  <span class="s1">Error.call(</span><span class="s2">this</span><span class="s1">);</span>

  <span class="s2">this</span><span class="s1">.name = </span><span class="s3">'YAMLException'</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.reason = reason;</span>
  <span class="s2">this</span><span class="s1">.mark = mark;</span>
  <span class="s2">this</span><span class="s1">.message = (</span><span class="s2">this</span><span class="s1">.reason || </span><span class="s3">'(unknown reason)'</span><span class="s1">) + (</span><span class="s2">this</span><span class="s1">.mark ? </span><span class="s3">' ' </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.mark.toString() : </span><span class="s3">''</span><span class="s1">);</span>

  <span class="s0">// Include stack trace in error object</span>
  <span class="s2">if </span><span class="s1">(Error.captureStackTrace) {</span>
    <span class="s0">// Chrome and NodeJS</span>
    <span class="s1">Error.captureStackTrace(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.constructor);</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s0">// FF, IE 10+ and Safari 6+. Fallback for others</span>
    <span class="s2">this</span><span class="s1">.stack = (</span><span class="s2">new </span><span class="s1">Error()).stack || </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s0">// Inherit from Error</span>
<span class="s1">YAMLException.prototype = Object.create(Error.prototype);</span>
<span class="s1">YAMLException.prototype.constructor = YAMLException;</span>


<span class="s1">YAMLException.prototype.toString = </span><span class="s2">function </span><span class="s1">toString(compact) {</span>
  <span class="s2">var </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.name + </span><span class="s3">': '</span><span class="s1">;</span>

  <span class="s1">result += </span><span class="s2">this</span><span class="s1">.reason || </span><span class="s3">'(unknown reason)'</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(!compact &amp;&amp; </span><span class="s2">this</span><span class="s1">.mark) {</span>
    <span class="s1">result += </span><span class="s3">' ' </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.mark.toString();</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>


<span class="s1">module.exports = YAMLException;</span>

<span class="s1">},{}],</span><span class="s4">5</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s0">/*eslint-disable max-len,no-use-before-define*/</span>

<span class="s2">var </span><span class="s1">common              = require(</span><span class="s3">'./common'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">YAMLException       = require(</span><span class="s3">'./exception'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">Mark                = require(</span><span class="s3">'./mark'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">DEFAULT_SAFE_SCHEMA = require(</span><span class="s3">'./schema/default_safe'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">DEFAULT_FULL_SCHEMA = require(</span><span class="s3">'./schema/default_full'</span><span class="s1">);</span>


<span class="s2">var </span><span class="s1">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>


<span class="s2">var </span><span class="s1">CONTEXT_FLOW_IN   = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">CONTEXT_FLOW_OUT  = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">CONTEXT_BLOCK_IN  = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">CONTEXT_BLOCK_OUT = </span><span class="s4">4</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">CHOMPING_CLIP  = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">CHOMPING_STRIP = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">CHOMPING_KEEP  = </span><span class="s4">3</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;</span>
<span class="s2">var </span><span class="s1">PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;</span>
<span class="s2">var </span><span class="s1">PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;</span>
<span class="s2">var </span><span class="s1">PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;</span>
<span class="s2">var </span><span class="s1">PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">a-f]{</span><span class="s4">2</span><span class="s1">}|[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">a-z\-#;\/\?:@&amp;=\+\$,_\.!~\*</span><span class="s3">'</span><span class="s6">\(\)\[\]</span><span class="s3">])*$/i;</span>


<span class="s2">function </span><span class="s1">_class(obj) { </span><span class="s2">return </span><span class="s1">Object.prototype.toString.call(obj); }</span>

<span class="s2">function </span><span class="s1">is_EOL(c) {</span>
  <span class="s2">return </span><span class="s1">(c === </span><span class="s4">0</span><span class="s1">x0A</span><span class="s0">/* LF */</span><span class="s1">) || (c === </span><span class="s4">0</span><span class="s1">x0D</span><span class="s0">/* CR */</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">is_WHITE_SPACE(c) {</span>
  <span class="s2">return </span><span class="s1">(c === </span><span class="s4">0</span><span class="s1">x09</span><span class="s0">/* Tab */</span><span class="s1">) || (c === </span><span class="s4">0</span><span class="s1">x20</span><span class="s0">/* Space */</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">is_WS_OR_EOL(c) {</span>
  <span class="s2">return </span><span class="s1">(c === </span><span class="s4">0</span><span class="s1">x09</span><span class="s0">/* Tab */</span><span class="s1">) ||</span>
         <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x20</span><span class="s0">/* Space */</span><span class="s1">) ||</span>
         <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x0A</span><span class="s0">/* LF */</span><span class="s1">) ||</span>
         <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x0D</span><span class="s0">/* CR */</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">is_FLOW_INDICATOR(c) {</span>
  <span class="s2">return </span><span class="s1">c === </span><span class="s4">0</span><span class="s1">x2C</span><span class="s0">/* , */ </span><span class="s1">||</span>
         <span class="s1">c === </span><span class="s4">0</span><span class="s1">x5B</span><span class="s0">/* [ */ </span><span class="s1">||</span>
         <span class="s1">c === </span><span class="s4">0</span><span class="s1">x5D</span><span class="s0">/* ] */ </span><span class="s1">||</span>
         <span class="s1">c === </span><span class="s4">0</span><span class="s1">x7B</span><span class="s0">/* { */ </span><span class="s1">||</span>
         <span class="s1">c === </span><span class="s4">0</span><span class="s1">x7D</span><span class="s0">/* } */</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">fromHexCode(c) {</span>
  <span class="s2">var </span><span class="s1">lc;</span>

  <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">x30</span><span class="s0">/* 0 */ </span><span class="s1">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0</span><span class="s1">x39</span><span class="s0">/* 9 */</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">c - </span><span class="s4">0</span><span class="s1">x30;</span>
  <span class="s1">}</span>

  <span class="s0">/*eslint-disable no-bitwise*/</span>
  <span class="s1">lc = c | </span><span class="s4">0</span><span class="s1">x20;</span>

  <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">x61</span><span class="s0">/* a */ </span><span class="s1">&lt;= lc) &amp;&amp; (lc &lt;= </span><span class="s4">0</span><span class="s1">x66</span><span class="s0">/* f */</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">lc - </span><span class="s4">0</span><span class="s1">x61 + </span><span class="s4">10</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">escapedHexLen(c) {</span>
  <span class="s2">if </span><span class="s1">(c === </span><span class="s4">0</span><span class="s1">x78</span><span class="s0">/* x */</span><span class="s1">) { </span><span class="s2">return </span><span class="s4">2</span><span class="s1">; }</span>
  <span class="s2">if </span><span class="s1">(c === </span><span class="s4">0</span><span class="s1">x75</span><span class="s0">/* u */</span><span class="s1">) { </span><span class="s2">return </span><span class="s4">4</span><span class="s1">; }</span>
  <span class="s2">if </span><span class="s1">(c === </span><span class="s4">0</span><span class="s1">x55</span><span class="s0">/* U */</span><span class="s1">) { </span><span class="s2">return </span><span class="s4">8</span><span class="s1">; }</span>
  <span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">fromDecimalCode(c) {</span>
  <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">x30</span><span class="s0">/* 0 */ </span><span class="s1">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0</span><span class="s1">x39</span><span class="s0">/* 9 */</span><span class="s1">)) {</span>
    <span class="s2">return </span><span class="s1">c - </span><span class="s4">0</span><span class="s1">x30;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">simpleEscapeSequence(c) {</span>
  <span class="s0">/* eslint-disable indent */</span>
  <span class="s2">return </span><span class="s1">(c === </span><span class="s4">0</span><span class="s1">x30</span><span class="s0">/* 0 */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">00' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x61</span><span class="s0">/* a */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">07' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x62</span><span class="s0">/* b */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">08' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x74</span><span class="s0">/* t */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">09' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x09</span><span class="s0">/* Tab */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">09' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x6E</span><span class="s0">/* n */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">0A' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x76</span><span class="s0">/* v */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">0B' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x66</span><span class="s0">/* f */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">0C' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x72</span><span class="s0">/* r */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">0D' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x65</span><span class="s0">/* e */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">1B' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x20</span><span class="s0">/* Space */</span><span class="s1">) ? </span><span class="s3">' ' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x22</span><span class="s0">/* &quot; */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">22' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x2F</span><span class="s0">/* / */</span><span class="s1">) ? </span><span class="s3">'/' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x5C</span><span class="s0">/* \ */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">5C' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x4E</span><span class="s0">/* N */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">85' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x5F</span><span class="s0">/* _ */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">A0' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x4C</span><span class="s0">/* L */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\u2028</span><span class="s3">' </span><span class="s1">:</span>
        <span class="s1">(c === </span><span class="s4">0</span><span class="s1">x50</span><span class="s0">/* P */</span><span class="s1">) ? </span><span class="s3">'</span><span class="s5">\u2029</span><span class="s3">' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">charFromCodepoint(c) {</span>
  <span class="s2">if </span><span class="s1">(c &lt;= </span><span class="s4">0</span><span class="s1">xFFFF) {</span>
    <span class="s2">return </span><span class="s1">String.fromCharCode(c);</span>
  <span class="s1">}</span>
  <span class="s0">// Encode UTF-16 surrogate pair</span>
  <span class="s0">// https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF</span>
  <span class="s2">return </span><span class="s1">String.fromCharCode(</span>
    <span class="s1">((c - </span><span class="s4">0</span><span class="s1">x010000) &gt;&gt; </span><span class="s4">10</span><span class="s1">) + </span><span class="s4">0</span><span class="s1">xD800,</span>
    <span class="s1">((c - </span><span class="s4">0</span><span class="s1">x010000) &amp; </span><span class="s4">0</span><span class="s1">x03FF) + </span><span class="s4">0</span><span class="s1">xDC00</span>
  <span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">simpleEscapeCheck = </span><span class="s2">new </span><span class="s1">Array(</span><span class="s4">256</span><span class="s1">); </span><span class="s0">// integer, for fast access</span>
<span class="s2">var </span><span class="s1">simpleEscapeMap = </span><span class="s2">new </span><span class="s1">Array(</span><span class="s4">256</span><span class="s1">);</span>
<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s4">256</span><span class="s1">; i++) {</span>
  <span class="s1">simpleEscapeCheck[i] = simpleEscapeSequence(i) ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">simpleEscapeMap[i] = simpleEscapeSequence(i);</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">State(input, options) {</span>
  <span class="s2">this</span><span class="s1">.input = input;</span>

  <span class="s2">this</span><span class="s1">.filename  = options[</span><span class="s3">'filename'</span><span class="s1">]  || </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.schema    = options[</span><span class="s3">'schema'</span><span class="s1">]    || DEFAULT_FULL_SCHEMA;</span>
  <span class="s2">this</span><span class="s1">.onWarning = options[</span><span class="s3">'onWarning'</span><span class="s1">] || </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.legacy    = options[</span><span class="s3">'legacy'</span><span class="s1">]    || </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.json      = options[</span><span class="s3">'json'</span><span class="s1">]      || </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.listener  = options[</span><span class="s3">'listener'</span><span class="s1">]  || </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s2">this</span><span class="s1">.implicitTypes = </span><span class="s2">this</span><span class="s1">.schema.compiledImplicit;</span>
  <span class="s2">this</span><span class="s1">.typeMap       = </span><span class="s2">this</span><span class="s1">.schema.compiledTypeMap;</span>

  <span class="s2">this</span><span class="s1">.length     = input.length;</span>
  <span class="s2">this</span><span class="s1">.position   = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.line       = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.lineStart  = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.lineIndent = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s2">this</span><span class="s1">.documents = [];</span>

  <span class="s0">/* 
  this.version; 
  this.checkLineBreaks; 
  this.tagMap; 
  this.anchorMap; 
  this.tag; 
  this.anchor; 
  this.kind; 
  this.result;*/</span>

<span class="s1">}</span>


<span class="s2">function </span><span class="s1">generateError(state, message) {</span>
  <span class="s2">return new </span><span class="s1">YAMLException(</span>
    <span class="s1">message,</span>
    <span class="s2">new </span><span class="s1">Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">throwError(state, message) {</span>
  <span class="s2">throw </span><span class="s1">generateError(state, message);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">throwWarning(state, message) {</span>
  <span class="s2">if </span><span class="s1">(state.onWarning) {</span>
    <span class="s1">state.onWarning.call(</span><span class="s2">null</span><span class="s1">, generateError(state, message));</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s2">var </span><span class="s1">directiveHandlers = {</span>

  <span class="s1">YAML: </span><span class="s2">function </span><span class="s1">handleYamlDirective(state, name, args) {</span>

    <span class="s2">var </span><span class="s1">match, major, minor;</span>

    <span class="s2">if </span><span class="s1">(state.version !== </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'duplication of %YAML directive'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(args.length !== </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'YAML directive accepts exactly one argument'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">match = /^([</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]+)\.([</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]+)$/.exec(args[</span><span class="s4">0</span><span class="s1">]);</span>

    <span class="s2">if </span><span class="s1">(match === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'ill-formed argument of the YAML directive'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">major = parseInt(match[</span><span class="s4">1</span><span class="s1">], </span><span class="s4">10</span><span class="s1">);</span>
    <span class="s1">minor = parseInt(match[</span><span class="s4">2</span><span class="s1">], </span><span class="s4">10</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(major !== </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'unacceptable YAML version of the document'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">state.version = args[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">state.checkLineBreaks = (minor &lt; </span><span class="s4">2</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(minor !== </span><span class="s4">1 </span><span class="s1">&amp;&amp; minor !== </span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s1">throwWarning(state, </span><span class="s3">'unsupported YAML version of the document'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">},</span>

  <span class="s1">TAG: </span><span class="s2">function </span><span class="s1">handleTagDirective(state, name, args) {</span>

    <span class="s2">var </span><span class="s1">handle, prefix;</span>

    <span class="s2">if </span><span class="s1">(args.length !== </span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'TAG directive accepts exactly two arguments'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">handle = args[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">prefix = args[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s2">if </span><span class="s1">(!PATTERN_TAG_HANDLE.test(handle)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'ill-formed tag handle (first argument) of the TAG directive'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(_hasOwnProperty.call(state.tagMap, handle)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'there is a previously declared suffix for &quot;' </span><span class="s1">+ handle + </span><span class="s3">'&quot; tag handle'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!PATTERN_TAG_URI.test(prefix)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'ill-formed tag prefix (second argument) of the TAG directive'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">state.tagMap[handle] = prefix;</span>
  <span class="s1">}</span>
<span class="s1">};</span>


<span class="s2">function </span><span class="s1">captureSegment(state, start, end, checkJson) {</span>
  <span class="s2">var </span><span class="s1">_position, _length, _character, _result;</span>

  <span class="s2">if </span><span class="s1">(start &lt; end) {</span>
    <span class="s1">_result = state.input.slice(start, end);</span>

    <span class="s2">if </span><span class="s1">(checkJson) {</span>
      <span class="s2">for </span><span class="s1">(_position = </span><span class="s4">0</span><span class="s1">, _length = _result.length; _position &lt; _length; _position += </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">_character = _result.charCodeAt(_position);</span>
        <span class="s2">if </span><span class="s1">(!(_character === </span><span class="s4">0</span><span class="s1">x09 ||</span>
              <span class="s1">(</span><span class="s4">0</span><span class="s1">x20 &lt;= _character &amp;&amp; _character &lt;= </span><span class="s4">0</span><span class="s1">x10FFFF))) {</span>
          <span class="s1">throwError(state, </span><span class="s3">'expected valid JSON character'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(PATTERN_NON_PRINTABLE.test(_result)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'the stream contains non-printable characters'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">state.result += _result;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">mergeMappings(state, destination, source, overridableKeys) {</span>
  <span class="s2">var </span><span class="s1">sourceKeys, key, index, quantity;</span>

  <span class="s2">if </span><span class="s1">(!common.isObject(source)) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'cannot merge mappings; the provided source object is unacceptable'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">sourceKeys = Object.keys(source);</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, quantity = sourceKeys.length; index &lt; quantity; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">key = sourceKeys[index];</span>

    <span class="s2">if </span><span class="s1">(!_hasOwnProperty.call(destination, key)) {</span>
      <span class="s1">destination[key] = source[key];</span>
      <span class="s1">overridableKeys[key] = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {</span>
  <span class="s2">var </span><span class="s1">index, quantity;</span>

  <span class="s0">// The output is a plain object here, so keys can only be strings.</span>
  <span class="s0">// We need to convert keyNode to a string, but doing so can hang the process</span>
  <span class="s0">// (deeply nested arrays that explode exponentially using aliases).</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(keyNode)) {</span>
    <span class="s1">keyNode = Array.prototype.slice.call(keyNode);</span>

    <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, quantity = keyNode.length; index &lt; quantity; index += </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(Array.isArray(keyNode[index])) {</span>
        <span class="s1">throwError(state, </span><span class="s3">'nested arrays are not supported inside keys'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">keyNode === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; _class(keyNode[index]) === </span><span class="s3">'[object Object]'</span><span class="s1">) {</span>
        <span class="s1">keyNode[index] = </span><span class="s3">'[object Object]'</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Avoid code execution in load() via toString property</span>
  <span class="s0">// (still use its own toString for arrays, timestamps,</span>
  <span class="s0">// and whatever user schema extensions happen to have @@toStringTag)</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">keyNode === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; _class(keyNode) === </span><span class="s3">'[object Object]'</span><span class="s1">) {</span>
    <span class="s1">keyNode = </span><span class="s3">'[object Object]'</span><span class="s1">;</span>
  <span class="s1">}</span>


  <span class="s1">keyNode = String(keyNode);</span>

  <span class="s2">if </span><span class="s1">(_result === </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">_result = {};</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(keyTag === </span><span class="s3">'tag:yaml.org,2002:merge'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(valueNode)) {</span>
      <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, quantity = valueNode.length; index &lt; quantity; index += </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">mergeMappings(state, _result, valueNode[index], overridableKeys);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mergeMappings(state, _result, valueNode, overridableKeys);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!state.json &amp;&amp;</span>
        <span class="s1">!_hasOwnProperty.call(overridableKeys, keyNode) &amp;&amp;</span>
        <span class="s1">_hasOwnProperty.call(_result, keyNode)) {</span>
      <span class="s1">state.line = startLine || state.line;</span>
      <span class="s1">state.position = startPos || state.position;</span>
      <span class="s1">throwError(state, </span><span class="s3">'duplicated mapping key'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">_result[keyNode] = valueNode;</span>
    <span class="s2">delete </span><span class="s1">overridableKeys[keyNode];</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">_result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readLineBreak(state) {</span>
  <span class="s2">var </span><span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x0A</span><span class="s0">/* LF */</span><span class="s1">) {</span>
    <span class="s1">state.position++;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x0D</span><span class="s0">/* CR */</span><span class="s1">) {</span>
    <span class="s1">state.position++;</span>
    <span class="s2">if </span><span class="s1">(state.input.charCodeAt(state.position) === </span><span class="s4">0</span><span class="s1">x0A</span><span class="s0">/* LF */</span><span class="s1">) {</span>
      <span class="s1">state.position++;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">throwError(state, </span><span class="s3">'a line break is expected'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">state.line += </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">state.lineStart = state.position;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">skipSeparationSpace(state, allowComments, checkIndent) {</span>
  <span class="s2">var </span><span class="s1">lineBreaks = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">while </span><span class="s1">(is_WHITE_SPACE(ch)) {</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(allowComments &amp;&amp; ch === </span><span class="s4">0</span><span class="s1">x23</span><span class="s0">/* # */</span><span class="s1">) {</span>
      <span class="s2">do </span><span class="s1">{</span>
        <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s1">} </span><span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">x0A</span><span class="s0">/* LF */ </span><span class="s1">&amp;&amp; ch !== </span><span class="s4">0</span><span class="s1">x0D</span><span class="s0">/* CR */ </span><span class="s1">&amp;&amp; ch !== </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(is_EOL(ch)) {</span>
      <span class="s1">readLineBreak(state);</span>

      <span class="s1">ch = state.input.charCodeAt(state.position);</span>
      <span class="s1">lineBreaks++;</span>
      <span class="s1">state.lineIndent = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x20</span><span class="s0">/* Space */</span><span class="s1">) {</span>
        <span class="s1">state.lineIndent++;</span>
        <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(checkIndent !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; lineBreaks !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; state.lineIndent &lt; checkIndent) {</span>
    <span class="s1">throwWarning(state, </span><span class="s3">'deficient indentation'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">lineBreaks;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">testDocumentSeparator(state) {</span>
  <span class="s2">var </span><span class="s1">_position = state.position,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(_position);</span>

  <span class="s0">// Condition state.position === state.lineStart is tested</span>
  <span class="s0">// in parent on each call, for efficiency. No needs to test here again.</span>
  <span class="s2">if </span><span class="s1">((ch === </span><span class="s4">0</span><span class="s1">x2D</span><span class="s0">/* - */ </span><span class="s1">|| ch === </span><span class="s4">0</span><span class="s1">x2E</span><span class="s0">/* . */</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">ch === state.input.charCodeAt(_position + </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
      <span class="s1">ch === state.input.charCodeAt(_position + </span><span class="s4">2</span><span class="s1">)) {</span>

    <span class="s1">_position += </span><span class="s4">3</span><span class="s1">;</span>

    <span class="s1">ch = state.input.charCodeAt(_position);</span>

    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0 </span><span class="s1">|| is_WS_OR_EOL(ch)) {</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">writeFoldedLines(state, count) {</span>
  <span class="s2">if </span><span class="s1">(count === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">state.result += </span><span class="s3">' '</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(count &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, count - </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">readPlainScalar(state, nodeIndent, withinFlowCollection) {</span>
  <span class="s2">var </span><span class="s1">preceding,</span>
      <span class="s1">following,</span>
      <span class="s1">captureStart,</span>
      <span class="s1">captureEnd,</span>
      <span class="s1">hasPendingContent,</span>
      <span class="s1">_line,</span>
      <span class="s1">_lineStart,</span>
      <span class="s1">_lineIndent,</span>
      <span class="s1">_kind = state.kind,</span>
      <span class="s1">_result = state.result,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(is_WS_OR_EOL(ch)      ||</span>
      <span class="s1">is_FLOW_INDICATOR(ch) ||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x23</span><span class="s0">/* # */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x26</span><span class="s0">/* &amp; */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x2A</span><span class="s0">/* * */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x21</span><span class="s0">/* ! */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x7C</span><span class="s0">/* | */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x3E</span><span class="s0">/* &gt; */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x27</span><span class="s0">/* ' */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x22</span><span class="s0">/* &quot; */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x25</span><span class="s0">/* % */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x40</span><span class="s0">/* @ */    </span><span class="s1">||</span>
      <span class="s1">ch === </span><span class="s4">0</span><span class="s1">x60</span><span class="s0">/* ` */</span><span class="s1">) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x3F</span><span class="s0">/* ? */ </span><span class="s1">|| ch === </span><span class="s4">0</span><span class="s1">x2D</span><span class="s0">/* - */</span><span class="s1">) {</span>
    <span class="s1">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(is_WS_OR_EOL(following) ||</span>
        <span class="s1">withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.kind = </span><span class="s3">'scalar'</span><span class="s1">;</span>
  <span class="s1">state.result = </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">captureStart = captureEnd = state.position;</span>
  <span class="s1">hasPendingContent = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x3A</span><span class="s0">/* : */</span><span class="s1">) {</span>
      <span class="s1">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(is_WS_OR_EOL(following) ||</span>
          <span class="s1">withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(following)) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x23</span><span class="s0">/* # */</span><span class="s1">) {</span>
      <span class="s1">preceding = state.input.charCodeAt(state.position - </span><span class="s4">1</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(is_WS_OR_EOL(preceding)) {</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) ||</span>
               <span class="s1">withinFlowCollection &amp;&amp; is_FLOW_INDICATOR(ch)) {</span>
      <span class="s2">break</span><span class="s1">;</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(is_EOL(ch)) {</span>
      <span class="s1">_line = state.line;</span>
      <span class="s1">_lineStart = state.lineStart;</span>
      <span class="s1">_lineIndent = state.lineIndent;</span>
      <span class="s1">skipSeparationSpace(state, </span><span class="s2">false</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(state.lineIndent &gt;= nodeIndent) {</span>
        <span class="s1">hasPendingContent = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">ch = state.input.charCodeAt(state.position);</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">state.position = captureEnd;</span>
        <span class="s1">state.line = _line;</span>
        <span class="s1">state.lineStart = _lineStart;</span>
        <span class="s1">state.lineIndent = _lineIndent;</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(hasPendingContent) {</span>
      <span class="s1">captureSegment(state, captureStart, captureEnd, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s1">writeFoldedLines(state, state.line - _line);</span>
      <span class="s1">captureStart = captureEnd = state.position;</span>
      <span class="s1">hasPendingContent = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!is_WHITE_SPACE(ch)) {</span>
      <span class="s1">captureEnd = state.position + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s1">}</span>

  <span class="s1">captureSegment(state, captureStart, captureEnd, </span><span class="s2">false</span><span class="s1">);</span>

  <span class="s2">if </span><span class="s1">(state.result) {</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">state.kind = _kind;</span>
  <span class="s1">state.result = _result;</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readSingleQuotedScalar(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s1">ch,</span>
      <span class="s1">captureStart, captureEnd;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">x27</span><span class="s0">/* ' */</span><span class="s1">) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">state.kind = </span><span class="s3">'scalar'</span><span class="s1">;</span>
  <span class="s1">state.result = </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">state.position++;</span>
  <span class="s1">captureStart = captureEnd = state.position;</span>

  <span class="s2">while </span><span class="s1">((ch = state.input.charCodeAt(state.position)) !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x27</span><span class="s0">/* ' */</span><span class="s1">) {</span>
      <span class="s1">captureSegment(state, captureStart, state.position, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

      <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x27</span><span class="s0">/* ' */</span><span class="s1">) {</span>
        <span class="s1">captureStart = state.position;</span>
        <span class="s1">state.position++;</span>
        <span class="s1">captureEnd = state.position;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(is_EOL(ch)) {</span>
      <span class="s1">captureSegment(state, captureStart, captureEnd, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">writeFoldedLines(state, skipSeparationSpace(state, </span><span class="s2">false</span><span class="s1">, nodeIndent));</span>
      <span class="s1">captureStart = captureEnd = state.position;</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'unexpected end of the document within a single quoted scalar'</span><span class="s1">);</span>

    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">state.position++;</span>
      <span class="s1">captureEnd = state.position;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">throwError(state, </span><span class="s3">'unexpected end of the stream within a single quoted scalar'</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readDoubleQuotedScalar(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s1">captureStart,</span>
      <span class="s1">captureEnd,</span>
      <span class="s1">hexLength,</span>
      <span class="s1">hexResult,</span>
      <span class="s1">tmp,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">x22</span><span class="s0">/* &quot; */</span><span class="s1">) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">state.kind = </span><span class="s3">'scalar'</span><span class="s1">;</span>
  <span class="s1">state.result = </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">state.position++;</span>
  <span class="s1">captureStart = captureEnd = state.position;</span>

  <span class="s2">while </span><span class="s1">((ch = state.input.charCodeAt(state.position)) !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x22</span><span class="s0">/* &quot; */</span><span class="s1">) {</span>
      <span class="s1">captureSegment(state, captureStart, state.position, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">state.position++;</span>
      <span class="s2">return true</span><span class="s1">;</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x5C</span><span class="s0">/* \ */</span><span class="s1">) {</span>
      <span class="s1">captureSegment(state, captureStart, state.position, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

      <span class="s2">if </span><span class="s1">(is_EOL(ch)) {</span>
        <span class="s1">skipSeparationSpace(state, </span><span class="s2">false</span><span class="s1">, nodeIndent);</span>

        <span class="s0">// TODO: rework to inline fn with no type cast?</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch &lt; </span><span class="s4">256 </span><span class="s1">&amp;&amp; simpleEscapeCheck[ch]) {</span>
        <span class="s1">state.result += simpleEscapeMap[ch];</span>
        <span class="s1">state.position++;</span>

      <span class="s1">} </span><span class="s2">else if </span><span class="s1">((tmp = escapedHexLen(ch)) &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">hexLength = tmp;</span>
        <span class="s1">hexResult = </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s2">for </span><span class="s1">(; hexLength &gt; </span><span class="s4">0</span><span class="s1">; hexLength--) {</span>
          <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

          <span class="s2">if </span><span class="s1">((tmp = fromHexCode(ch)) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">hexResult = (hexResult &lt;&lt; </span><span class="s4">4</span><span class="s1">) + tmp;</span>

          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">throwError(state, </span><span class="s3">'expected hexadecimal character'</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">state.result += charFromCodepoint(hexResult);</span>

        <span class="s1">state.position++;</span>

      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">throwError(state, </span><span class="s3">'unknown escape sequence'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">captureStart = captureEnd = state.position;</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(is_EOL(ch)) {</span>
      <span class="s1">captureSegment(state, captureStart, captureEnd, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">writeFoldedLines(state, skipSeparationSpace(state, </span><span class="s2">false</span><span class="s1">, nodeIndent));</span>
      <span class="s1">captureStart = captureEnd = state.position;</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'unexpected end of the document within a double quoted scalar'</span><span class="s1">);</span>

    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">state.position++;</span>
      <span class="s1">captureEnd = state.position;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">throwError(state, </span><span class="s3">'unexpected end of the stream within a double quoted scalar'</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readFlowCollection(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s1">readNext = </span><span class="s2">true</span><span class="s1">,</span>
      <span class="s1">_line,</span>
      <span class="s1">_tag     = state.tag,</span>
      <span class="s1">_result,</span>
      <span class="s1">_anchor  = state.anchor,</span>
      <span class="s1">following,</span>
      <span class="s1">terminator,</span>
      <span class="s1">isPair,</span>
      <span class="s1">isExplicitPair,</span>
      <span class="s1">isMapping,</span>
      <span class="s1">overridableKeys = {},</span>
      <span class="s1">keyNode,</span>
      <span class="s1">keyTag,</span>
      <span class="s1">valueNode,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x5B</span><span class="s0">/* [ */</span><span class="s1">) {</span>
    <span class="s1">terminator = </span><span class="s4">0</span><span class="s1">x5D;</span><span class="s0">/* ] */</span>
    <span class="s1">isMapping = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">_result = [];</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x7B</span><span class="s0">/* { */</span><span class="s1">) {</span>
    <span class="s1">terminator = </span><span class="s4">0</span><span class="s1">x7D;</span><span class="s0">/* } */</span>
    <span class="s1">isMapping = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">_result = {};</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">state.anchorMap[state.anchor] = _result;</span>
  <span class="s1">}</span>

  <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, nodeIndent);</span>

    <span class="s1">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s1">(ch === terminator) {</span>
      <span class="s1">state.position++;</span>
      <span class="s1">state.tag = _tag;</span>
      <span class="s1">state.anchor = _anchor;</span>
      <span class="s1">state.kind = isMapping ? </span><span class="s3">'mapping' </span><span class="s1">: </span><span class="s3">'sequence'</span><span class="s1">;</span>
      <span class="s1">state.result = _result;</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!readNext) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'missed comma between flow collection entries'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">isPair = isExplicitPair = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x3F</span><span class="s0">/* ? */</span><span class="s1">) {</span>
      <span class="s1">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(is_WS_OR_EOL(following)) {</span>
        <span class="s1">isPair = isExplicitPair = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">state.position++;</span>
        <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, nodeIndent);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_line = state.line;</span>
    <span class="s1">composeNode(state, nodeIndent, CONTEXT_FLOW_IN, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">keyTag = state.tag;</span>
    <span class="s1">keyNode = state.result;</span>
    <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, nodeIndent);</span>

    <span class="s1">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s1">((isExplicitPair || state.line === _line) &amp;&amp; ch === </span><span class="s4">0</span><span class="s1">x3A</span><span class="s0">/* : */</span><span class="s1">) {</span>
      <span class="s1">isPair = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, nodeIndent);</span>
      <span class="s1">composeNode(state, nodeIndent, CONTEXT_FLOW_IN, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">valueNode = state.result;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isMapping) {</span>
      <span class="s1">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isPair) {</span>
      <span class="s1">_result.push(storeMappingPair(state, </span><span class="s2">null</span><span class="s1">, overridableKeys, keyTag, keyNode, valueNode));</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">_result.push(keyNode);</span>
    <span class="s1">}</span>

    <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, nodeIndent);</span>

    <span class="s1">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x2C</span><span class="s0">/* , */</span><span class="s1">) {</span>
      <span class="s1">readNext = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">readNext = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">throwError(state, </span><span class="s3">'unexpected end of the stream within a flow collection'</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readBlockScalar(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s1">captureStart,</span>
      <span class="s1">folding,</span>
      <span class="s1">chomping       = CHOMPING_CLIP,</span>
      <span class="s1">didReadContent = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">detectedIndent = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">textIndent     = nodeIndent,</span>
      <span class="s1">emptyLines     = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">atMoreIndented = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">tmp,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x7C</span><span class="s0">/* | */</span><span class="s1">) {</span>
    <span class="s1">folding = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x3E</span><span class="s0">/* &gt; */</span><span class="s1">) {</span>
    <span class="s1">folding = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">state.kind = </span><span class="s3">'scalar'</span><span class="s1">;</span>
  <span class="s1">state.result = </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x2B</span><span class="s0">/* + */ </span><span class="s1">|| ch === </span><span class="s4">0</span><span class="s1">x2D</span><span class="s0">/* - */</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(CHOMPING_CLIP === chomping) {</span>
        <span class="s1">chomping = (ch === </span><span class="s4">0</span><span class="s1">x2B</span><span class="s0">/* + */</span><span class="s1">) ? CHOMPING_KEEP : CHOMPING_STRIP;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">throwError(state, </span><span class="s3">'repeat of a chomping mode identifier'</span><span class="s1">);</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">((tmp = fromDecimalCode(ch)) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(tmp === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">throwError(state, </span><span class="s3">'bad explicit indentation width of a block scalar; it cannot be less than one'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!detectedIndent) {</span>
        <span class="s1">textIndent = nodeIndent + tmp - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">detectedIndent = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">throwError(state, </span><span class="s3">'repeat of an indentation width identifier'</span><span class="s1">);</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(is_WHITE_SPACE(ch)) {</span>
    <span class="s2">do </span><span class="s1">{ ch = state.input.charCodeAt(++state.position); }</span>
    <span class="s2">while </span><span class="s1">(is_WHITE_SPACE(ch));</span>

    <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x23</span><span class="s0">/* # */</span><span class="s1">) {</span>
      <span class="s2">do </span><span class="s1">{ ch = state.input.charCodeAt(++state.position); }</span>
      <span class="s2">while </span><span class="s1">(!is_EOL(ch) &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s1">));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">readLineBreak(state);</span>
    <span class="s1">state.lineIndent = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s1">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">while </span><span class="s1">((!detectedIndent || state.lineIndent &lt; textIndent) &amp;&amp;</span>
           <span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x20</span><span class="s0">/* Space */</span><span class="s1">)) {</span>
      <span class="s1">state.lineIndent++;</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!detectedIndent &amp;&amp; state.lineIndent &gt; textIndent) {</span>
      <span class="s1">textIndent = state.lineIndent;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(is_EOL(ch)) {</span>
      <span class="s1">emptyLines++;</span>
      <span class="s2">continue</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// End of the scalar.</span>
    <span class="s2">if </span><span class="s1">(state.lineIndent &lt; textIndent) {</span>

      <span class="s0">// Perform the chomping.</span>
      <span class="s2">if </span><span class="s1">(chomping === CHOMPING_KEEP) {</span>
        <span class="s1">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, didReadContent ? </span><span class="s4">1 </span><span class="s1">+ emptyLines : emptyLines);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(chomping === CHOMPING_CLIP) {</span>
        <span class="s2">if </span><span class="s1">(didReadContent) { </span><span class="s0">// i.e. only if the scalar is not empty.</span>
          <span class="s1">state.result += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// Break this `while` cycle and go to the funciton's epilogue.</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Folded style: use fancy rules to handle line breaks.</span>
    <span class="s2">if </span><span class="s1">(folding) {</span>

      <span class="s0">// Lines starting with white space characters (more-indented lines) are not folded.</span>
      <span class="s2">if </span><span class="s1">(is_WHITE_SPACE(ch)) {</span>
        <span class="s1">atMoreIndented = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s0">// except for the first content line (cf. Example 8.1)</span>
        <span class="s1">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, didReadContent ? </span><span class="s4">1 </span><span class="s1">+ emptyLines : emptyLines);</span>

      <span class="s0">// End of more-indented block.</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(atMoreIndented) {</span>
        <span class="s1">atMoreIndented = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, emptyLines + </span><span class="s4">1</span><span class="s1">);</span>

      <span class="s0">// Just one line break - perceive as the same line.</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(emptyLines === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(didReadContent) { </span><span class="s0">// i.e. only if we have already read some scalar content.</span>
          <span class="s1">state.result += </span><span class="s3">' '</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s0">// Several line breaks - perceive as different lines.</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, emptyLines);</span>
      <span class="s1">}</span>

    <span class="s0">// Literal style: just add exact number of line breaks between content lines.</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// Keep all line breaks except the header line break.</span>
      <span class="s1">state.result += common.repeat(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, didReadContent ? </span><span class="s4">1 </span><span class="s1">+ emptyLines : emptyLines);</span>
    <span class="s1">}</span>

    <span class="s1">didReadContent = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">detectedIndent = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">emptyLines = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">captureStart = state.position;</span>

    <span class="s2">while </span><span class="s1">(!is_EOL(ch) &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">}</span>

    <span class="s1">captureSegment(state, captureStart, state.position, </span><span class="s2">false</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readBlockSequence(state, nodeIndent) {</span>
  <span class="s2">var </span><span class="s1">_line,</span>
      <span class="s1">_tag      = state.tag,</span>
      <span class="s1">_anchor   = state.anchor,</span>
      <span class="s1">_result   = [],</span>
      <span class="s1">following,</span>
      <span class="s1">detected  = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">ch;</span>

  <span class="s2">if </span><span class="s1">(state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">state.anchorMap[state.anchor] = _result;</span>
  <span class="s1">}</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>

    <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">x2D</span><span class="s0">/* - */</span><span class="s1">) {</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(!is_WS_OR_EOL(following)) {</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">detected = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">state.position++;</span>

    <span class="s2">if </span><span class="s1">(skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(state.lineIndent &lt;= nodeIndent) {</span>
        <span class="s1">_result.push(</span><span class="s2">null</span><span class="s1">);</span>
        <span class="s1">ch = state.input.charCodeAt(state.position);</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">_line = state.line;</span>
    <span class="s1">composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">_result.push(state.result);</span>
    <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

    <span class="s1">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s1">((state.line === _line || state.lineIndent &gt; nodeIndent) &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'bad indentation of a sequence entry'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.lineIndent &lt; nodeIndent) {</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(detected) {</span>
    <span class="s1">state.tag = _tag;</span>
    <span class="s1">state.anchor = _anchor;</span>
    <span class="s1">state.kind = </span><span class="s3">'sequence'</span><span class="s1">;</span>
    <span class="s1">state.result = _result;</span>
    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readBlockMapping(state, nodeIndent, flowIndent) {</span>
  <span class="s2">var </span><span class="s1">following,</span>
      <span class="s1">allowCompact,</span>
      <span class="s1">_line,</span>
      <span class="s1">_pos,</span>
      <span class="s1">_tag          = state.tag,</span>
      <span class="s1">_anchor       = state.anchor,</span>
      <span class="s1">_result       = {},</span>
      <span class="s1">overridableKeys = {},</span>
      <span class="s1">keyTag        = </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">keyNode       = </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">valueNode     = </span><span class="s2">null</span><span class="s1">,</span>
      <span class="s1">atExplicitKey = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">detected      = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">ch;</span>

  <span class="s2">if </span><span class="s1">(state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">state.anchorMap[state.anchor] = _result;</span>
  <span class="s1">}</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">following = state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">_line = state.line; </span><span class="s0">// Save the current line.</span>
    <span class="s1">_pos = state.position;</span>

    <span class="s0">//</span>
    <span class="s0">// Explicit notation case. There are two separate blocks:</span>
    <span class="s0">// first for the key (denoted by &quot;?&quot;) and second for the value (denoted by &quot;:&quot;)</span>
    <span class="s0">//</span>
    <span class="s2">if </span><span class="s1">((ch === </span><span class="s4">0</span><span class="s1">x3F</span><span class="s0">/* ? */ </span><span class="s1">|| ch === </span><span class="s4">0</span><span class="s1">x3A</span><span class="s0">/* : */</span><span class="s1">) &amp;&amp; is_WS_OR_EOL(following)) {</span>

      <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x3F</span><span class="s0">/* ? */</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(atExplicitKey) {</span>
          <span class="s1">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, </span><span class="s2">null</span><span class="s1">);</span>
          <span class="s1">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">detected = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">atExplicitKey = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">allowCompact = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(atExplicitKey) {</span>
        <span class="s0">// i.e. 0x3A/* : */ === character after the explicit key.</span>
        <span class="s1">atExplicitKey = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">allowCompact = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">throwError(state, </span><span class="s3">'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">state.position += </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">ch = following;</span>

    <span class="s0">//</span>
    <span class="s0">// Implicit notation case. Flow-style node as the key first, then &quot;:&quot;, and the value.</span>
    <span class="s0">//</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(composeNode(state, flowIndent, CONTEXT_FLOW_OUT, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">)) {</span>

      <span class="s2">if </span><span class="s1">(state.line === _line) {</span>
        <span class="s1">ch = state.input.charCodeAt(state.position);</span>

        <span class="s2">while </span><span class="s1">(is_WHITE_SPACE(ch)) {</span>
          <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x3A</span><span class="s0">/* : */</span><span class="s1">) {</span>
          <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

          <span class="s2">if </span><span class="s1">(!is_WS_OR_EOL(ch)) {</span>
            <span class="s1">throwError(state, </span><span class="s3">'a whitespace character is expected after the key-value separator within a block mapping'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s2">if </span><span class="s1">(atExplicitKey) {</span>
            <span class="s1">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s1">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">detected = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">atExplicitKey = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s1">allowCompact = </span><span class="s2">false</span><span class="s1">;</span>
          <span class="s1">keyTag = state.tag;</span>
          <span class="s1">keyNode = state.result;</span>

        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(detected) {</span>
          <span class="s1">throwError(state, </span><span class="s3">'can not read an implicit mapping pair; a colon is missed'</span><span class="s1">);</span>

        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">state.tag = _tag;</span>
          <span class="s1">state.anchor = _anchor;</span>
          <span class="s2">return true</span><span class="s1">; </span><span class="s0">// Keep the result of `composeNode`.</span>
        <span class="s1">}</span>

      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(detected) {</span>
        <span class="s1">throwError(state, </span><span class="s3">'can not read a block mapping entry; a multiline key may not be an implicit key'</span><span class="s1">);</span>

      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">state.tag = _tag;</span>
        <span class="s1">state.anchor = _anchor;</span>
        <span class="s2">return true</span><span class="s1">; </span><span class="s0">// Keep the result of `composeNode`.</span>
      <span class="s1">}</span>

    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">break</span><span class="s1">; </span><span class="s0">// Reading is done. Go to the epilogue.</span>
    <span class="s1">}</span>

    <span class="s0">//</span>
    <span class="s0">// Common reading code for both explicit and implicit notations.</span>
    <span class="s0">//</span>
    <span class="s2">if </span><span class="s1">(state.line === _line || state.lineIndent &gt; nodeIndent) {</span>
      <span class="s2">if </span><span class="s1">(composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, </span><span class="s2">true</span><span class="s1">, allowCompact)) {</span>
        <span class="s2">if </span><span class="s1">(atExplicitKey) {</span>
          <span class="s1">keyNode = state.result;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">valueNode = state.result;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!atExplicitKey) {</span>
        <span class="s1">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);</span>
        <span class="s1">keyTag = keyNode = valueNode = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">ch = state.input.charCodeAt(state.position);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(state.lineIndent &gt; nodeIndent &amp;&amp; (ch !== </span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'bad indentation of a mapping entry'</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.lineIndent &lt; nodeIndent) {</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">//</span>
  <span class="s0">// Epilogue.</span>
  <span class="s0">//</span>

  <span class="s0">// Special case: last mapping's node contains only the key in explicit notation.</span>
  <span class="s2">if </span><span class="s1">(atExplicitKey) {</span>
    <span class="s1">storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">// Expose the resulting mapping.</span>
  <span class="s2">if </span><span class="s1">(detected) {</span>
    <span class="s1">state.tag = _tag;</span>
    <span class="s1">state.anchor = _anchor;</span>
    <span class="s1">state.kind = </span><span class="s3">'mapping'</span><span class="s1">;</span>
    <span class="s1">state.result = _result;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">detected;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readTagProperty(state) {</span>
  <span class="s2">var </span><span class="s1">_position,</span>
      <span class="s1">isVerbatim = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">isNamed    = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">tagHandle,</span>
      <span class="s1">tagName,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">x21</span><span class="s0">/* ! */</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(state.tag !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'duplication of a tag property'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x3C</span><span class="s0">/* &lt; */</span><span class="s1">) {</span>
    <span class="s1">isVerbatim = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x21</span><span class="s0">/* ! */</span><span class="s1">) {</span>
    <span class="s1">isNamed = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">tagHandle = </span><span class="s3">'!!'</span><span class="s1">;</span>
    <span class="s1">ch = state.input.charCodeAt(++state.position);</span>

  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">tagHandle = </span><span class="s3">'!'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">_position = state.position;</span>

  <span class="s2">if </span><span class="s1">(isVerbatim) {</span>
    <span class="s2">do </span><span class="s1">{ ch = state.input.charCodeAt(++state.position); }</span>
    <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; ch !== </span><span class="s4">0</span><span class="s1">x3E</span><span class="s0">/* &gt; */</span><span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(state.position &lt; state.length) {</span>
      <span class="s1">tagName = state.input.slice(_position, state.position);</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">throwError(state, </span><span class="s3">'unexpected end of the stream within a verbatim tag'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !is_WS_OR_EOL(ch)) {</span>

      <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x21</span><span class="s0">/* ! */</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!isNamed) {</span>
          <span class="s1">tagHandle = state.input.slice(_position - </span><span class="s4">1</span><span class="s1">, state.position + </span><span class="s4">1</span><span class="s1">);</span>

          <span class="s2">if </span><span class="s1">(!PATTERN_TAG_HANDLE.test(tagHandle)) {</span>
            <span class="s1">throwError(state, </span><span class="s3">'named tag handle cannot contain such characters'</span><span class="s1">);</span>
          <span class="s1">}</span>

          <span class="s1">isNamed = </span><span class="s2">true</span><span class="s1">;</span>
          <span class="s1">_position = state.position + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">throwError(state, </span><span class="s3">'tag suffix cannot contain exclamation marks'</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">}</span>

    <span class="s1">tagName = state.input.slice(_position, state.position);</span>

    <span class="s2">if </span><span class="s1">(PATTERN_FLOW_INDICATORS.test(tagName)) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'tag suffix cannot contain flow indicator characters'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(tagName &amp;&amp; !PATTERN_TAG_URI.test(tagName)) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'tag name cannot contain such characters: ' </span><span class="s1">+ tagName);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(isVerbatim) {</span>
    <span class="s1">state.tag = tagName;</span>

  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_hasOwnProperty.call(state.tagMap, tagHandle)) {</span>
    <span class="s1">state.tag = state.tagMap[tagHandle] + tagName;</span>

  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tagHandle === </span><span class="s3">'!'</span><span class="s1">) {</span>
    <span class="s1">state.tag = </span><span class="s3">'!' </span><span class="s1">+ tagName;</span>

  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tagHandle === </span><span class="s3">'!!'</span><span class="s1">) {</span>
    <span class="s1">state.tag = </span><span class="s3">'tag:yaml.org,2002:' </span><span class="s1">+ tagName;</span>

  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">throwError(state, </span><span class="s3">'undeclared tag handle &quot;' </span><span class="s1">+ tagHandle + </span><span class="s3">'&quot;'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readAnchorProperty(state) {</span>
  <span class="s2">var </span><span class="s1">_position,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">x26</span><span class="s0">/* &amp; */</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'duplication of an anchor property'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s1">_position = state.position;</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {</span>
    <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.position === _position) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'name of an anchor node must contain at least one character'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">state.anchor = state.input.slice(_position, state.position);</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readAlias(state) {</span>
  <span class="s2">var </span><span class="s1">_position, alias,</span>
      <span class="s1">ch;</span>

  <span class="s1">ch = state.input.charCodeAt(state.position);</span>

  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">x2A</span><span class="s0">/* * */</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s1">_position = state.position;</span>

  <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !is_WS_OR_EOL(ch) &amp;&amp; !is_FLOW_INDICATOR(ch)) {</span>
    <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.position === _position) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'name of an alias node must contain at least one character'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">alias = state.input.slice(_position, state.position);</span>

  <span class="s2">if </span><span class="s1">(!_hasOwnProperty.call(state.anchorMap, alias)) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'unidentified alias &quot;' </span><span class="s1">+ alias + </span><span class="s3">'&quot;'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">state.result = state.anchorMap[alias];</span>
  <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {</span>
  <span class="s2">var </span><span class="s1">allowBlockStyles,</span>
      <span class="s1">allowBlockScalars,</span>
      <span class="s1">allowBlockCollections,</span>
      <span class="s1">indentStatus = </span><span class="s4">1</span><span class="s1">, </span><span class="s0">// 1: this&gt;parent, 0: this=parent, -1: this&lt;parent</span>
      <span class="s1">atNewLine  = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">hasContent = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">typeIndex,</span>
      <span class="s1">typeQuantity,</span>
      <span class="s1">type,</span>
      <span class="s1">flowIndent,</span>
      <span class="s1">blockIndent;</span>

  <span class="s2">if </span><span class="s1">(state.listener !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">state.listener(</span><span class="s3">'open'</span><span class="s1">, state);</span>
  <span class="s1">}</span>

  <span class="s1">state.tag    = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">state.anchor = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">state.kind   = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">state.result = </span><span class="s2">null</span><span class="s1">;</span>

  <span class="s1">allowBlockStyles = allowBlockScalars = allowBlockCollections =</span>
    <span class="s1">CONTEXT_BLOCK_OUT === nodeContext ||</span>
    <span class="s1">CONTEXT_BLOCK_IN  === nodeContext;</span>

  <span class="s2">if </span><span class="s1">(allowToSeek) {</span>
    <span class="s2">if </span><span class="s1">(skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">)) {</span>
      <span class="s1">atNewLine = </span><span class="s2">true</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(state.lineIndent &gt; parentIndent) {</span>
        <span class="s1">indentStatus = </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.lineIndent === parentIndent) {</span>
        <span class="s1">indentStatus = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.lineIndent &lt; parentIndent) {</span>
        <span class="s1">indentStatus = -</span><span class="s4">1</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(indentStatus === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">while </span><span class="s1">(readTagProperty(state) || readAnchorProperty(state)) {</span>
      <span class="s2">if </span><span class="s1">(skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">)) {</span>
        <span class="s1">atNewLine = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">allowBlockCollections = allowBlockStyles;</span>

        <span class="s2">if </span><span class="s1">(state.lineIndent &gt; parentIndent) {</span>
          <span class="s1">indentStatus = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.lineIndent === parentIndent) {</span>
          <span class="s1">indentStatus = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state.lineIndent &lt; parentIndent) {</span>
          <span class="s1">indentStatus = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">allowBlockCollections = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(allowBlockCollections) {</span>
    <span class="s1">allowBlockCollections = atNewLine || allowCompact;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(indentStatus === </span><span class="s4">1 </span><span class="s1">|| CONTEXT_BLOCK_OUT === nodeContext) {</span>
    <span class="s2">if </span><span class="s1">(CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {</span>
      <span class="s1">flowIndent = parentIndent;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">flowIndent = parentIndent + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">blockIndent = state.position - state.lineStart;</span>

    <span class="s2">if </span><span class="s1">(indentStatus === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(allowBlockCollections &amp;&amp;</span>
          <span class="s1">(readBlockSequence(state, blockIndent) ||</span>
           <span class="s1">readBlockMapping(state, blockIndent, flowIndent)) ||</span>
          <span class="s1">readFlowCollection(state, flowIndent)) {</span>
        <span class="s1">hasContent = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">((allowBlockScalars &amp;&amp; readBlockScalar(state, flowIndent)) ||</span>
            <span class="s1">readSingleQuotedScalar(state, flowIndent) ||</span>
            <span class="s1">readDoubleQuotedScalar(state, flowIndent)) {</span>
          <span class="s1">hasContent = </span><span class="s2">true</span><span class="s1">;</span>

        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(readAlias(state)) {</span>
          <span class="s1">hasContent = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(state.tag !== </span><span class="s2">null </span><span class="s1">|| state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">throwError(state, </span><span class="s3">'alias node should not have any properties'</span><span class="s1">);</span>
          <span class="s1">}</span>

        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {</span>
          <span class="s1">hasContent = </span><span class="s2">true</span><span class="s1">;</span>

          <span class="s2">if </span><span class="s1">(state.tag === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">state.tag = </span><span class="s3">'?'</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">state.anchorMap[state.anchor] = state.result;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(indentStatus === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">// Special case: block sequences are allowed to have same indentation level as the parent.</span>
      <span class="s0">// http://www.yaml.org/spec/1.2/spec.html#id2799784</span>
      <span class="s1">hasContent = allowBlockCollections &amp;&amp; readBlockSequence(state, blockIndent);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.tag !== </span><span class="s2">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s3">'!'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(state.tag === </span><span class="s3">'?'</span><span class="s1">) {</span>
      <span class="s0">// Implicit resolving is not allowed for non-scalar types, and '?'</span>
      <span class="s0">// non-specific tag is only automatically assigned to plain scalars.</span>
      <span class="s0">//</span>
      <span class="s0">// We only need to check kind conformity in case user explicitly assigns '?'</span>
      <span class="s0">// tag, for example like this: &quot;!&lt;?&gt; [0]&quot;</span>
      <span class="s0">//</span>
      <span class="s2">if </span><span class="s1">(state.result !== </span><span class="s2">null </span><span class="s1">&amp;&amp; state.kind !== </span><span class="s3">'scalar'</span><span class="s1">) {</span>
        <span class="s1">throwError(state, </span><span class="s3">'unacceptable node kind for !&lt;?&gt; tag; it should be &quot;scalar&quot;, not &quot;' </span><span class="s1">+ state.kind + </span><span class="s3">'&quot;'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">for </span><span class="s1">(typeIndex = </span><span class="s4">0</span><span class="s1">, typeQuantity = state.implicitTypes.length; typeIndex &lt; typeQuantity; typeIndex += </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">type = state.implicitTypes[typeIndex];</span>

        <span class="s2">if </span><span class="s1">(type.resolve(state.result)) { </span><span class="s0">// `state.result` updated in resolver if matched</span>
          <span class="s1">state.result = type.construct(state.result);</span>
          <span class="s1">state.tag = type.tag;</span>
          <span class="s2">if </span><span class="s1">(state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">state.anchorMap[state.anchor] = state.result;</span>
          <span class="s1">}</span>
          <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_hasOwnProperty.call(state.typeMap[state.kind || </span><span class="s3">'fallback'</span><span class="s1">], state.tag)) {</span>
      <span class="s1">type = state.typeMap[state.kind || </span><span class="s3">'fallback'</span><span class="s1">][state.tag];</span>

      <span class="s2">if </span><span class="s1">(state.result !== </span><span class="s2">null </span><span class="s1">&amp;&amp; type.kind !== state.kind) {</span>
        <span class="s1">throwError(state, </span><span class="s3">'unacceptable node kind for !&lt;' </span><span class="s1">+ state.tag + </span><span class="s3">'&gt; tag; it should be &quot;' </span><span class="s1">+ type.kind + </span><span class="s3">'&quot;, not &quot;' </span><span class="s1">+ state.kind + </span><span class="s3">'&quot;'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!type.resolve(state.result)) { </span><span class="s0">// `state.result` updated in resolver if matched</span>
        <span class="s1">throwError(state, </span><span class="s3">'cannot resolve a node with !&lt;' </span><span class="s1">+ state.tag + </span><span class="s3">'&gt; explicit tag'</span><span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">state.result = type.construct(state.result);</span>
        <span class="s2">if </span><span class="s1">(state.anchor !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">state.anchorMap[state.anchor] = state.result;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">throwError(state, </span><span class="s3">'unknown tag !&lt;' </span><span class="s1">+ state.tag + </span><span class="s3">'&gt;'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.listener !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">state.listener(</span><span class="s3">'close'</span><span class="s1">, state);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">state.tag !== </span><span class="s2">null </span><span class="s1">||  state.anchor !== </span><span class="s2">null </span><span class="s1">|| hasContent;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">readDocument(state) {</span>
  <span class="s2">var </span><span class="s1">documentStart = state.position,</span>
      <span class="s1">_position,</span>
      <span class="s1">directiveName,</span>
      <span class="s1">directiveArgs,</span>
      <span class="s1">hasDirectives = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">ch;</span>

  <span class="s1">state.version = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">state.checkLineBreaks = state.legacy;</span>
  <span class="s1">state.tagMap = {};</span>
  <span class="s1">state.anchorMap = {};</span>

  <span class="s2">while </span><span class="s1">((ch = state.input.charCodeAt(state.position)) !== </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

    <span class="s1">ch = state.input.charCodeAt(state.position);</span>

    <span class="s2">if </span><span class="s1">(state.lineIndent &gt; </span><span class="s4">0 </span><span class="s1">|| ch !== </span><span class="s4">0</span><span class="s1">x25</span><span class="s0">/* % */</span><span class="s1">) {</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">hasDirectives = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">_position = state.position;</span>

    <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !is_WS_OR_EOL(ch)) {</span>
      <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
    <span class="s1">}</span>

    <span class="s1">directiveName = state.input.slice(_position, state.position);</span>
    <span class="s1">directiveArgs = [];</span>

    <span class="s2">if </span><span class="s1">(directiveName.length &lt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">throwError(state, </span><span class="s3">'directive name must not be less than one character in length'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">while </span><span class="s1">(is_WHITE_SPACE(ch)) {</span>
        <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(ch === </span><span class="s4">0</span><span class="s1">x23</span><span class="s0">/* # */</span><span class="s1">) {</span>
        <span class="s2">do </span><span class="s1">{ ch = state.input.charCodeAt(++state.position); }</span>
        <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !is_EOL(ch));</span>
        <span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(is_EOL(ch)) </span><span class="s2">break</span><span class="s1">;</span>

      <span class="s1">_position = state.position;</span>

      <span class="s2">while </span><span class="s1">(ch !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !is_WS_OR_EOL(ch)) {</span>
        <span class="s1">ch = state.input.charCodeAt(++state.position);</span>
      <span class="s1">}</span>

      <span class="s1">directiveArgs.push(state.input.slice(_position, state.position));</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(ch !== </span><span class="s4">0</span><span class="s1">) readLineBreak(state);</span>

    <span class="s2">if </span><span class="s1">(_hasOwnProperty.call(directiveHandlers, directiveName)) {</span>
      <span class="s1">directiveHandlers[directiveName](state, directiveName, directiveArgs);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">throwWarning(state, </span><span class="s3">'unknown document directive &quot;' </span><span class="s1">+ directiveName + </span><span class="s3">'&quot;'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

  <span class="s2">if </span><span class="s1">(state.lineIndent === </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">state.input.charCodeAt(state.position)     === </span><span class="s4">0</span><span class="s1">x2D</span><span class="s0">/* - */ </span><span class="s1">&amp;&amp;</span>
      <span class="s1">state.input.charCodeAt(state.position + </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">x2D</span><span class="s0">/* - */ </span><span class="s1">&amp;&amp;</span>
      <span class="s1">state.input.charCodeAt(state.position + </span><span class="s4">2</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">x2D</span><span class="s0">/* - */</span><span class="s1">) {</span>
    <span class="s1">state.position += </span><span class="s4">3</span><span class="s1">;</span>
    <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasDirectives) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'directives end mark is expected'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">composeNode(state, state.lineIndent - </span><span class="s4">1</span><span class="s1">, CONTEXT_BLOCK_OUT, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>

  <span class="s2">if </span><span class="s1">(state.checkLineBreaks &amp;&amp;</span>
      <span class="s1">PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {</span>
    <span class="s1">throwWarning(state, </span><span class="s3">'non-ASCII line breaks are interpreted as content'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">state.documents.push(state.result);</span>

  <span class="s2">if </span><span class="s1">(state.position === state.lineStart &amp;&amp; testDocumentSeparator(state)) {</span>

    <span class="s2">if </span><span class="s1">(state.input.charCodeAt(state.position) === </span><span class="s4">0</span><span class="s1">x2E</span><span class="s0">/* . */</span><span class="s1">) {</span>
      <span class="s1">state.position += </span><span class="s4">3</span><span class="s1">;</span>
      <span class="s1">skipSeparationSpace(state, </span><span class="s2">true</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(state.position &lt; (state.length - </span><span class="s4">1</span><span class="s1">)) {</span>
    <span class="s1">throwError(state, </span><span class="s3">'end of the stream or a document separator is expected'</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">loadDocuments(input, options) {</span>
  <span class="s1">input = String(input);</span>
  <span class="s1">options = options || {};</span>

  <span class="s2">if </span><span class="s1">(input.length !== </span><span class="s4">0</span><span class="s1">) {</span>

    <span class="s0">// Add tailing `\n` if not exists</span>
    <span class="s2">if </span><span class="s1">(input.charCodeAt(input.length - </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">x0A</span><span class="s0">/* LF */ </span><span class="s1">&amp;&amp;</span>
        <span class="s1">input.charCodeAt(input.length - </span><span class="s4">1</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">x0D</span><span class="s0">/* CR */</span><span class="s1">) {</span>
      <span class="s1">input += </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Strip BOM</span>
    <span class="s2">if </span><span class="s1">(input.charCodeAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">xFEFF) {</span>
      <span class="s1">input = input.slice(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">state = </span><span class="s2">new </span><span class="s1">State(input, options);</span>

  <span class="s2">var </span><span class="s1">nullpos = input.indexOf(</span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">);</span>

  <span class="s2">if </span><span class="s1">(nullpos !== -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">state.position = nullpos;</span>
    <span class="s1">throwError(state, </span><span class="s3">'null byte is not allowed in input'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">// Use 0 as string terminator. That significantly simplifies bounds check.</span>
  <span class="s1">state.input += </span><span class="s3">'</span><span class="s5">\0</span><span class="s3">'</span><span class="s1">;</span>

  <span class="s2">while </span><span class="s1">(state.input.charCodeAt(state.position) === </span><span class="s4">0</span><span class="s1">x20</span><span class="s0">/* Space */</span><span class="s1">) {</span>
    <span class="s1">state.lineIndent += </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">state.position += </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">while </span><span class="s1">(state.position &lt; (state.length - </span><span class="s4">1</span><span class="s1">)) {</span>
    <span class="s1">readDocument(state);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">state.documents;</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">loadAll(input, iterator, options) {</span>
  <span class="s2">if </span><span class="s1">(iterator !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">iterator === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
    <span class="s1">options = iterator;</span>
    <span class="s1">iterator = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">documents = loadDocuments(input, options);</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">iterator !== </span><span class="s3">'function'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">documents;</span>
  <span class="s1">}</span>

  <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">index = </span><span class="s4">0</span><span class="s1">, length = documents.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">iterator(documents[index]);</span>
  <span class="s1">}</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">load(input, options) {</span>
  <span class="s2">var </span><span class="s1">documents = loadDocuments(input, options);</span>

  <span class="s2">if </span><span class="s1">(documents.length === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s0">/*eslint-disable no-undefined*/</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(documents.length === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">documents[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>
  <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'expected a single document in the stream, but found more'</span><span class="s1">);</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">safeLoadAll(input, iterator, options) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">iterator === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; iterator !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">'undefined'</span><span class="s1">) {</span>
    <span class="s1">options = iterator;</span>
    <span class="s1">iterator = </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">safeLoad(input, options) {</span>
  <span class="s2">return </span><span class="s1">load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));</span>
<span class="s1">}</span>


<span class="s1">module.exports.loadAll     = loadAll;</span>
<span class="s1">module.exports.load        = load;</span>
<span class="s1">module.exports.safeLoadAll = safeLoadAll;</span>
<span class="s1">module.exports.safeLoad    = safeLoad;</span>

<span class="s1">},{</span><span class="s3">&quot;./common&quot;</span><span class="s1">:</span><span class="s4">2</span><span class="s1">,</span><span class="s3">&quot;./exception&quot;</span><span class="s1">:</span><span class="s4">4</span><span class="s1">,</span><span class="s3">&quot;./mark&quot;</span><span class="s1">:</span><span class="s4">6</span><span class="s1">,</span><span class="s3">&quot;./schema/default_full&quot;</span><span class="s1">:</span><span class="s4">9</span><span class="s1">,</span><span class="s3">&quot;./schema/default_safe&quot;</span><span class="s1">:</span><span class="s4">10</span><span class="s1">}],</span><span class="s4">6</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">common = require(</span><span class="s3">'./common'</span><span class="s1">);</span>


<span class="s2">function </span><span class="s1">Mark(name, buffer, position, line, column) {</span>
  <span class="s2">this</span><span class="s1">.name     = name;</span>
  <span class="s2">this</span><span class="s1">.buffer   = buffer;</span>
  <span class="s2">this</span><span class="s1">.position = position;</span>
  <span class="s2">this</span><span class="s1">.line     = line;</span>
  <span class="s2">this</span><span class="s1">.column   = column;</span>
<span class="s1">}</span>


<span class="s1">Mark.prototype.getSnippet = </span><span class="s2">function </span><span class="s1">getSnippet(indent, maxLength) {</span>
  <span class="s2">var </span><span class="s1">head, start, tail, end, snippet;</span>

  <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.buffer) </span><span class="s2">return null</span><span class="s1">;</span>

  <span class="s1">indent = indent || </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s1">maxLength = maxLength || </span><span class="s4">75</span><span class="s1">;</span>

  <span class="s1">head = </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">start = </span><span class="s2">this</span><span class="s1">.position;</span>

  <span class="s2">while </span><span class="s1">(start &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">00</span><span class="s5">\r\n\x</span><span class="s3">85</span><span class="s5">\u2028\u2029</span><span class="s3">'</span><span class="s1">.indexOf(</span><span class="s2">this</span><span class="s1">.buffer.charAt(start - </span><span class="s4">1</span><span class="s1">)) === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">start -= </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.position - start &gt; (maxLength / </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">)) {</span>
      <span class="s1">head = </span><span class="s3">' ... '</span><span class="s1">;</span>
      <span class="s1">start += </span><span class="s4">5</span><span class="s1">;</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">tail = </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">end = </span><span class="s2">this</span><span class="s1">.position;</span>

  <span class="s2">while </span><span class="s1">(end &lt; </span><span class="s2">this</span><span class="s1">.buffer.length &amp;&amp; </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">00</span><span class="s5">\r\n\x</span><span class="s3">85</span><span class="s5">\u2028\u2029</span><span class="s3">'</span><span class="s1">.indexOf(</span><span class="s2">this</span><span class="s1">.buffer.charAt(end)) === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">end += </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(end - </span><span class="s2">this</span><span class="s1">.position &gt; (maxLength / </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">)) {</span>
      <span class="s1">tail = </span><span class="s3">' ... '</span><span class="s1">;</span>
      <span class="s1">end -= </span><span class="s4">5</span><span class="s1">;</span>
      <span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">snippet = </span><span class="s2">this</span><span class="s1">.buffer.slice(start, end);</span>

  <span class="s2">return </span><span class="s1">common.repeat(</span><span class="s3">' '</span><span class="s1">, indent) + head + snippet + tail + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+</span>
         <span class="s1">common.repeat(</span><span class="s3">' '</span><span class="s1">, indent + </span><span class="s2">this</span><span class="s1">.position - start + head.length) + </span><span class="s3">'^'</span><span class="s1">;</span>
<span class="s1">};</span>


<span class="s1">Mark.prototype.toString = </span><span class="s2">function </span><span class="s1">toString(compact) {</span>
  <span class="s2">var </span><span class="s1">snippet, where = </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.name) {</span>
    <span class="s1">where += </span><span class="s3">'in &quot;' </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.name + </span><span class="s3">'&quot; '</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">where += </span><span class="s3">'at line ' </span><span class="s1">+ (</span><span class="s2">this</span><span class="s1">.line + </span><span class="s4">1</span><span class="s1">) + </span><span class="s3">', column ' </span><span class="s1">+ (</span><span class="s2">this</span><span class="s1">.column + </span><span class="s4">1</span><span class="s1">);</span>

  <span class="s2">if </span><span class="s1">(!compact) {</span>
    <span class="s1">snippet = </span><span class="s2">this</span><span class="s1">.getSnippet();</span>

    <span class="s2">if </span><span class="s1">(snippet) {</span>
      <span class="s1">where += </span><span class="s3">':</span><span class="s5">\n</span><span class="s3">' </span><span class="s1">+ snippet;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">where;</span>
<span class="s1">};</span>


<span class="s1">module.exports = Mark;</span>

<span class="s1">},{</span><span class="s3">&quot;./common&quot;</span><span class="s1">:</span><span class="s4">2</span><span class="s1">}],</span><span class="s4">7</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s0">/*eslint-disable max-len*/</span>

<span class="s2">var </span><span class="s1">common        = require(</span><span class="s3">'./common'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">YAMLException = require(</span><span class="s3">'./exception'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">Type          = require(</span><span class="s3">'./type'</span><span class="s1">);</span>


<span class="s2">function </span><span class="s1">compileList(schema, name, result) {</span>
  <span class="s2">var </span><span class="s1">exclude = [];</span>

  <span class="s1">schema.include.forEach(</span><span class="s2">function </span><span class="s1">(includedSchema) {</span>
    <span class="s1">result = compileList(includedSchema, name, result);</span>
  <span class="s1">});</span>

  <span class="s1">schema[name].forEach(</span><span class="s2">function </span><span class="s1">(currentType) {</span>
    <span class="s1">result.forEach(</span><span class="s2">function </span><span class="s1">(previousType, previousIndex) {</span>
      <span class="s2">if </span><span class="s1">(previousType.tag === currentType.tag &amp;&amp; previousType.kind === currentType.kind) {</span>
        <span class="s1">exclude.push(previousIndex);</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s1">result.push(currentType);</span>
  <span class="s1">});</span>

  <span class="s2">return </span><span class="s1">result.filter(</span><span class="s2">function </span><span class="s1">(type, index) {</span>
    <span class="s2">return </span><span class="s1">exclude.indexOf(index) === -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">});</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">compileMap(</span><span class="s0">/* lists... */</span><span class="s1">) {</span>
  <span class="s2">var </span><span class="s1">result = {</span>
        <span class="s1">scalar: {},</span>
        <span class="s1">sequence: {},</span>
        <span class="s1">mapping: {},</span>
        <span class="s1">fallback: {}</span>
      <span class="s1">}, index, length;</span>

  <span class="s2">function </span><span class="s1">collectType(type) {</span>
    <span class="s1">result[type.kind][type.tag] = result[</span><span class="s3">'fallback'</span><span class="s1">][type.tag] = type;</span>
  <span class="s1">}</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = arguments.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">arguments[index].forEach(collectType);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s2">function </span><span class="s1">Schema(definition) {</span>
  <span class="s2">this</span><span class="s1">.include  = definition.include  || [];</span>
  <span class="s2">this</span><span class="s1">.implicit = definition.implicit || [];</span>
  <span class="s2">this</span><span class="s1">.explicit = definition.explicit || [];</span>

  <span class="s2">this</span><span class="s1">.implicit.forEach(</span><span class="s2">function </span><span class="s1">(type) {</span>
    <span class="s2">if </span><span class="s1">(type.loadKind &amp;&amp; type.loadKind !== </span><span class="s3">'scalar'</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s2">this</span><span class="s1">.compiledImplicit = compileList(</span><span class="s2">this</span><span class="s1">, </span><span class="s3">'implicit'</span><span class="s1">, []);</span>
  <span class="s2">this</span><span class="s1">.compiledExplicit = compileList(</span><span class="s2">this</span><span class="s1">, </span><span class="s3">'explicit'</span><span class="s1">, []);</span>
  <span class="s2">this</span><span class="s1">.compiledTypeMap  = compileMap(</span><span class="s2">this</span><span class="s1">.compiledImplicit, </span><span class="s2">this</span><span class="s1">.compiledExplicit);</span>
<span class="s1">}</span>


<span class="s1">Schema.DEFAULT = </span><span class="s2">null</span><span class="s1">;</span>


<span class="s1">Schema.create = </span><span class="s2">function </span><span class="s1">createSchema() {</span>
  <span class="s2">var </span><span class="s1">schemas, types;</span>

  <span class="s2">switch </span><span class="s1">(arguments.length) {</span>
    <span class="s2">case </span><span class="s4">1</span><span class="s1">:</span>
      <span class="s1">schemas = Schema.DEFAULT;</span>
      <span class="s1">types = arguments[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s2">break</span><span class="s1">;</span>

    <span class="s2">case </span><span class="s4">2</span><span class="s1">:</span>
      <span class="s1">schemas = arguments[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s1">types = arguments[</span><span class="s4">1</span><span class="s1">];</span>
      <span class="s2">break</span><span class="s1">;</span>

    <span class="s2">default</span><span class="s1">:</span>
      <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'Wrong number of arguments for Schema.create function'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">schemas = common.toArray(schemas);</span>
  <span class="s1">types = common.toArray(types);</span>

  <span class="s2">if </span><span class="s1">(!schemas.every(</span><span class="s2">function </span><span class="s1">(schema) { </span><span class="s2">return </span><span class="s1">schema </span><span class="s2">instanceof </span><span class="s1">Schema; })) {</span>
    <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'Specified list of super schemas (or a single Schema object) contains a non-Schema object.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(!types.every(</span><span class="s2">function </span><span class="s1">(type) { </span><span class="s2">return </span><span class="s1">type </span><span class="s2">instanceof </span><span class="s1">Type; })) {</span>
    <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'Specified list of YAML types (or a single Type object) contains a non-Type object.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">return new </span><span class="s1">Schema({</span>
    <span class="s1">include: schemas,</span>
    <span class="s1">explicit: types</span>
  <span class="s1">});</span>
<span class="s1">};</span>


<span class="s1">module.exports = Schema;</span>

<span class="s1">},{</span><span class="s3">&quot;./common&quot;</span><span class="s1">:</span><span class="s4">2</span><span class="s1">,</span><span class="s3">&quot;./exception&quot;</span><span class="s1">:</span><span class="s4">4</span><span class="s1">,</span><span class="s3">&quot;./type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">8</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s0">// Standard YAML's Core schema.</span>
<span class="s0">// http://www.yaml.org/spec/1.2/spec.html#id2804923</span>
<span class="s0">//</span>
<span class="s0">// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.</span>
<span class="s0">// So, Core schema has no distinctions from JSON schema is JS-YAML.</span>


<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">Schema = require(</span><span class="s3">'../schema'</span><span class="s1">);</span>


<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Schema({</span>
  <span class="s1">include: [</span>
    <span class="s1">require(</span><span class="s3">'./json'</span><span class="s1">)</span>
  <span class="s1">]</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../schema&quot;</span><span class="s1">:</span><span class="s4">7</span><span class="s1">,</span><span class="s3">&quot;./json&quot;</span><span class="s1">:</span><span class="s4">12</span><span class="s1">}],</span><span class="s4">9</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s0">// JS-YAML's default schema for `load` function.</span>
<span class="s0">// It is not described in the YAML specification.</span>
<span class="s0">//</span>
<span class="s0">// This schema is based on JS-YAML's default safe schema and includes</span>
<span class="s0">// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.</span>
<span class="s0">//</span>
<span class="s0">// Also this schema is used as default base schema at `Schema.create` function.</span>


<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">Schema = require(</span><span class="s3">'../schema'</span><span class="s1">);</span>


<span class="s1">module.exports = Schema.DEFAULT = </span><span class="s2">new </span><span class="s1">Schema({</span>
  <span class="s1">include: [</span>
    <span class="s1">require(</span><span class="s3">'./default_safe'</span><span class="s1">)</span>
  <span class="s1">],</span>
  <span class="s1">explicit: [</span>
    <span class="s1">require(</span><span class="s3">'../type/js/undefined'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/js/regexp'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/js/function'</span><span class="s1">)</span>
  <span class="s1">]</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../schema&quot;</span><span class="s1">:</span><span class="s4">7</span><span class="s1">,</span><span class="s3">&quot;../type/js/function&quot;</span><span class="s1">:</span><span class="s4">18</span><span class="s1">,</span><span class="s3">&quot;../type/js/regexp&quot;</span><span class="s1">:</span><span class="s4">19</span><span class="s1">,</span><span class="s3">&quot;../type/js/undefined&quot;</span><span class="s1">:</span><span class="s4">20</span><span class="s1">,</span><span class="s3">&quot;./default_safe&quot;</span><span class="s1">:</span><span class="s4">10</span><span class="s1">}],</span><span class="s4">10</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s0">// JS-YAML's default schema for `safeLoad` function.</span>
<span class="s0">// It is not described in the YAML specification.</span>
<span class="s0">//</span>
<span class="s0">// This schema is based on standard YAML's Core schema and includes most of</span>
<span class="s0">// extra types described at YAML tag repository. (http://yaml.org/type/)</span>


<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">Schema = require(</span><span class="s3">'../schema'</span><span class="s1">);</span>


<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Schema({</span>
  <span class="s1">include: [</span>
    <span class="s1">require(</span><span class="s3">'./core'</span><span class="s1">)</span>
  <span class="s1">],</span>
  <span class="s1">implicit: [</span>
    <span class="s1">require(</span><span class="s3">'../type/timestamp'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/merge'</span><span class="s1">)</span>
  <span class="s1">],</span>
  <span class="s1">explicit: [</span>
    <span class="s1">require(</span><span class="s3">'../type/binary'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/omap'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/pairs'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/set'</span><span class="s1">)</span>
  <span class="s1">]</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../schema&quot;</span><span class="s1">:</span><span class="s4">7</span><span class="s1">,</span><span class="s3">&quot;../type/binary&quot;</span><span class="s1">:</span><span class="s4">14</span><span class="s1">,</span><span class="s3">&quot;../type/merge&quot;</span><span class="s1">:</span><span class="s4">22</span><span class="s1">,</span><span class="s3">&quot;../type/omap&quot;</span><span class="s1">:</span><span class="s4">24</span><span class="s1">,</span><span class="s3">&quot;../type/pairs&quot;</span><span class="s1">:</span><span class="s4">25</span><span class="s1">,</span><span class="s3">&quot;../type/set&quot;</span><span class="s1">:</span><span class="s4">27</span><span class="s1">,</span><span class="s3">&quot;../type/timestamp&quot;</span><span class="s1">:</span><span class="s4">29</span><span class="s1">,</span><span class="s3">&quot;./core&quot;</span><span class="s1">:</span><span class="s4">8</span><span class="s1">}],</span><span class="s4">11</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s0">// Standard YAML's Failsafe schema.</span>
<span class="s0">// http://www.yaml.org/spec/1.2/spec.html#id2802346</span>


<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">Schema = require(</span><span class="s3">'../schema'</span><span class="s1">);</span>


<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Schema({</span>
  <span class="s1">explicit: [</span>
    <span class="s1">require(</span><span class="s3">'../type/str'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/seq'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/map'</span><span class="s1">)</span>
  <span class="s1">]</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../schema&quot;</span><span class="s1">:</span><span class="s4">7</span><span class="s1">,</span><span class="s3">&quot;../type/map&quot;</span><span class="s1">:</span><span class="s4">21</span><span class="s1">,</span><span class="s3">&quot;../type/seq&quot;</span><span class="s1">:</span><span class="s4">26</span><span class="s1">,</span><span class="s3">&quot;../type/str&quot;</span><span class="s1">:</span><span class="s4">28</span><span class="s1">}],</span><span class="s4">12</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s0">// Standard YAML's JSON schema.</span>
<span class="s0">// http://www.yaml.org/spec/1.2/spec.html#id2803231</span>
<span class="s0">//</span>
<span class="s0">// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.</span>
<span class="s0">// So, this schema is not such strict as defined in the YAML specification.</span>
<span class="s0">// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.</span>


<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">Schema = require(</span><span class="s3">'../schema'</span><span class="s1">);</span>


<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Schema({</span>
  <span class="s1">include: [</span>
    <span class="s1">require(</span><span class="s3">'./failsafe'</span><span class="s1">)</span>
  <span class="s1">],</span>
  <span class="s1">implicit: [</span>
    <span class="s1">require(</span><span class="s3">'../type/null'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/bool'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/int'</span><span class="s1">),</span>
    <span class="s1">require(</span><span class="s3">'../type/float'</span><span class="s1">)</span>
  <span class="s1">]</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../schema&quot;</span><span class="s1">:</span><span class="s4">7</span><span class="s1">,</span><span class="s3">&quot;../type/bool&quot;</span><span class="s1">:</span><span class="s4">15</span><span class="s1">,</span><span class="s3">&quot;../type/float&quot;</span><span class="s1">:</span><span class="s4">16</span><span class="s1">,</span><span class="s3">&quot;../type/int&quot;</span><span class="s1">:</span><span class="s4">17</span><span class="s1">,</span><span class="s3">&quot;../type/null&quot;</span><span class="s1">:</span><span class="s4">23</span><span class="s1">,</span><span class="s3">&quot;./failsafe&quot;</span><span class="s1">:</span><span class="s4">11</span><span class="s1">}],</span><span class="s4">13</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">YAMLException = require(</span><span class="s3">'./exception'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">TYPE_CONSTRUCTOR_OPTIONS = [</span>
  <span class="s3">'kind'</span><span class="s1">,</span>
  <span class="s3">'resolve'</span><span class="s1">,</span>
  <span class="s3">'construct'</span><span class="s1">,</span>
  <span class="s3">'instanceOf'</span><span class="s1">,</span>
  <span class="s3">'predicate'</span><span class="s1">,</span>
  <span class="s3">'represent'</span><span class="s1">,</span>
  <span class="s3">'defaultStyle'</span><span class="s1">,</span>
  <span class="s3">'styleAliases'</span>
<span class="s1">];</span>

<span class="s2">var </span><span class="s1">YAML_NODE_KINDS = [</span>
  <span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s3">'sequence'</span><span class="s1">,</span>
  <span class="s3">'mapping'</span>
<span class="s1">];</span>

<span class="s2">function </span><span class="s1">compileStyleAliases(map) {</span>
  <span class="s2">var </span><span class="s1">result = {};</span>

  <span class="s2">if </span><span class="s1">(map !== </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">Object.keys(map).forEach(</span><span class="s2">function </span><span class="s1">(style) {</span>
      <span class="s1">map[style].forEach(</span><span class="s2">function </span><span class="s1">(alias) {</span>
        <span class="s1">result[String(alias)] = style;</span>
      <span class="s1">});</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">Type(tag, options) {</span>
  <span class="s1">options = options || {};</span>

  <span class="s1">Object.keys(options).forEach(</span><span class="s2">function </span><span class="s1">(name) {</span>
    <span class="s2">if </span><span class="s1">(TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'Unknown option &quot;' </span><span class="s1">+ name + </span><span class="s3">'&quot; is met in definition of &quot;' </span><span class="s1">+ tag + </span><span class="s3">'&quot; YAML type.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">});</span>

  <span class="s0">// TODO: Add tag format check.</span>
  <span class="s2">this</span><span class="s1">.tag          = tag;</span>
  <span class="s2">this</span><span class="s1">.kind         = options[</span><span class="s3">'kind'</span><span class="s1">]         || </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.resolve      = options[</span><span class="s3">'resolve'</span><span class="s1">]      || </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return true</span><span class="s1">; };</span>
  <span class="s2">this</span><span class="s1">.construct    = options[</span><span class="s3">'construct'</span><span class="s1">]    || </span><span class="s2">function </span><span class="s1">(data) { </span><span class="s2">return </span><span class="s1">data; };</span>
  <span class="s2">this</span><span class="s1">.instanceOf   = options[</span><span class="s3">'instanceOf'</span><span class="s1">]   || </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.predicate    = options[</span><span class="s3">'predicate'</span><span class="s1">]    || </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.represent    = options[</span><span class="s3">'represent'</span><span class="s1">]    || </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.defaultStyle = options[</span><span class="s3">'defaultStyle'</span><span class="s1">] || </span><span class="s2">null</span><span class="s1">;</span>
  <span class="s2">this</span><span class="s1">.styleAliases = compileStyleAliases(options[</span><span class="s3">'styleAliases'</span><span class="s1">] || </span><span class="s2">null</span><span class="s1">);</span>

  <span class="s2">if </span><span class="s1">(YAML_NODE_KINDS.indexOf(</span><span class="s2">this</span><span class="s1">.kind) === -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">YAMLException(</span><span class="s3">'Unknown kind &quot;' </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">.kind + </span><span class="s3">'&quot; is specified for &quot;' </span><span class="s1">+ tag + </span><span class="s3">'&quot; YAML type.'</span><span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">module.exports = Type;</span>

<span class="s1">},{</span><span class="s3">&quot;./exception&quot;</span><span class="s1">:</span><span class="s4">4</span><span class="s1">}],</span><span class="s4">14</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s0">/*eslint-disable no-bitwise*/</span>

<span class="s2">var </span><span class="s1">NodeBuffer;</span>

<span class="s2">try </span><span class="s1">{</span>
  <span class="s0">// A trick for browserified version, to not include `Buffer` shim</span>
  <span class="s2">var </span><span class="s1">_require = require;</span>
  <span class="s1">NodeBuffer = _require(</span><span class="s3">'buffer'</span><span class="s1">).Buffer;</span>
<span class="s1">} </span><span class="s2">catch </span><span class="s1">(__) {}</span>

<span class="s2">var </span><span class="s1">Type       = require(</span><span class="s3">'../type'</span><span class="s1">);</span>


<span class="s0">// [ 64, 65, 66 ] -&gt; [ padding, CR, LF ]</span>
<span class="s2">var </span><span class="s1">BASE64_MAP = </span><span class="s3">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</span><span class="s5">\n\r</span><span class="s3">'</span><span class="s1">;</span>


<span class="s2">function </span><span class="s1">resolveYamlBinary(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">code, idx, bitlen = </span><span class="s4">0</span><span class="s1">, max = data.length, map = BASE64_MAP;</span>

  <span class="s0">// Convert one by one.</span>
  <span class="s2">for </span><span class="s1">(idx = </span><span class="s4">0</span><span class="s1">; idx &lt; max; idx++) {</span>
    <span class="s1">code = map.indexOf(data.charAt(idx));</span>

    <span class="s0">// Skip CR/LF</span>
    <span class="s2">if </span><span class="s1">(code &gt; </span><span class="s4">64</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>

    <span class="s0">// Fail on illegal characters</span>
    <span class="s2">if </span><span class="s1">(code &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

    <span class="s1">bitlen += </span><span class="s4">6</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// If there are any bits left, source was corrupted</span>
  <span class="s2">return </span><span class="s1">(bitlen % </span><span class="s4">8</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlBinary(data) {</span>
  <span class="s2">var </span><span class="s1">idx, tailbits,</span>
      <span class="s1">input = data.replace(/[\r\n=]/g, </span><span class="s3">''</span><span class="s1">), </span><span class="s0">// remove CR/LF &amp; padding to simplify scan</span>
      <span class="s1">max = input.length,</span>
      <span class="s1">map = BASE64_MAP,</span>
      <span class="s1">bits = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">result = [];</span>

  <span class="s0">// Collect by 6*4 bits (3 bytes)</span>

  <span class="s2">for </span><span class="s1">(idx = </span><span class="s4">0</span><span class="s1">; idx &lt; max; idx++) {</span>
    <span class="s2">if </span><span class="s1">((idx % </span><span class="s4">4 </span><span class="s1">=== </span><span class="s4">0</span><span class="s1">) &amp;&amp; idx) {</span>
      <span class="s1">result.push((bits &gt;&gt; </span><span class="s4">16</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
      <span class="s1">result.push((bits &gt;&gt; </span><span class="s4">8</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
      <span class="s1">result.push(bits &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
    <span class="s1">}</span>

    <span class="s1">bits = (bits &lt;&lt; </span><span class="s4">6</span><span class="s1">) | map.indexOf(input.charAt(idx));</span>
  <span class="s1">}</span>

  <span class="s0">// Dump tail</span>

  <span class="s1">tailbits = (max % </span><span class="s4">4</span><span class="s1">) * </span><span class="s4">6</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(tailbits === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">result.push((bits &gt;&gt; </span><span class="s4">16</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
    <span class="s1">result.push((bits &gt;&gt; </span><span class="s4">8</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
    <span class="s1">result.push(bits &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tailbits === </span><span class="s4">18</span><span class="s1">) {</span>
    <span class="s1">result.push((bits &gt;&gt; </span><span class="s4">10</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
    <span class="s1">result.push((bits &gt;&gt; </span><span class="s4">2</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tailbits === </span><span class="s4">12</span><span class="s1">) {</span>
    <span class="s1">result.push((bits &gt;&gt; </span><span class="s4">4</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">xFF);</span>
  <span class="s1">}</span>

  <span class="s0">// Wrap into Buffer for NodeJS and leave Array for browser</span>
  <span class="s2">if </span><span class="s1">(NodeBuffer) {</span>
    <span class="s0">// Support node 6.+ Buffer API when available</span>
    <span class="s2">return </span><span class="s1">NodeBuffer.from ? NodeBuffer.from(result) : </span><span class="s2">new </span><span class="s1">NodeBuffer(result);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">representYamlBinary(object </span><span class="s0">/*, style*/</span><span class="s1">) {</span>
  <span class="s2">var </span><span class="s1">result = </span><span class="s3">''</span><span class="s1">, bits = </span><span class="s4">0</span><span class="s1">, idx, tail,</span>
      <span class="s1">max = object.length,</span>
      <span class="s1">map = BASE64_MAP;</span>

  <span class="s0">// Convert every three bytes to 4 ASCII characters.</span>

  <span class="s2">for </span><span class="s1">(idx = </span><span class="s4">0</span><span class="s1">; idx &lt; max; idx++) {</span>
    <span class="s2">if </span><span class="s1">((idx % </span><span class="s4">3 </span><span class="s1">=== </span><span class="s4">0</span><span class="s1">) &amp;&amp; idx) {</span>
      <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">18</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
      <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">12</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
      <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">6</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
      <span class="s1">result += map[bits &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">}</span>

    <span class="s1">bits = (bits &lt;&lt; </span><span class="s4">8</span><span class="s1">) + object[idx];</span>
  <span class="s1">}</span>

  <span class="s0">// Dump tail</span>

  <span class="s1">tail = max % </span><span class="s4">3</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(tail === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">18</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">12</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">6</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[bits &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tail === </span><span class="s4">2</span><span class="s1">) {</span>
    <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">10</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">4</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[(bits &lt;&lt; </span><span class="s4">2</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[</span><span class="s4">64</span><span class="s1">];</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(tail === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">result += map[(bits &gt;&gt; </span><span class="s4">2</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[(bits &lt;&lt; </span><span class="s4">4</span><span class="s1">) &amp; </span><span class="s4">0</span><span class="s1">x3F];</span>
    <span class="s1">result += map[</span><span class="s4">64</span><span class="s1">];</span>
    <span class="s1">result += map[</span><span class="s4">64</span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isBinary(object) {</span>
  <span class="s2">return </span><span class="s1">NodeBuffer &amp;&amp; NodeBuffer.isBuffer(object);</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:binary'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlBinary,</span>
  <span class="s1">construct: constructYamlBinary,</span>
  <span class="s1">predicate: isBinary,</span>
  <span class="s1">represent: representYamlBinary</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">15</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">resolveYamlBoolean(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">max = data.length;</span>

  <span class="s2">return </span><span class="s1">(max === </span><span class="s4">4 </span><span class="s1">&amp;&amp; (data === </span><span class="s3">'true' </span><span class="s1">|| data === </span><span class="s3">'True' </span><span class="s1">|| data === </span><span class="s3">'TRUE'</span><span class="s1">)) ||</span>
         <span class="s1">(max === </span><span class="s4">5 </span><span class="s1">&amp;&amp; (data === </span><span class="s3">'false' </span><span class="s1">|| data === </span><span class="s3">'False' </span><span class="s1">|| data === </span><span class="s3">'FALSE'</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlBoolean(data) {</span>
  <span class="s2">return </span><span class="s1">data === </span><span class="s3">'true' </span><span class="s1">||</span>
         <span class="s1">data === </span><span class="s3">'True' </span><span class="s1">||</span>
         <span class="s1">data === </span><span class="s3">'TRUE'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isBoolean(object) {</span>
  <span class="s2">return </span><span class="s1">Object.prototype.toString.call(object) === </span><span class="s3">'[object Boolean]'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:bool'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlBoolean,</span>
  <span class="s1">construct: constructYamlBoolean,</span>
  <span class="s1">predicate: isBoolean,</span>
  <span class="s1">represent: {</span>
    <span class="s1">lowercase: </span><span class="s2">function </span><span class="s1">(object) { </span><span class="s2">return </span><span class="s1">object ? </span><span class="s3">'true' </span><span class="s1">: </span><span class="s3">'false'</span><span class="s1">; },</span>
    <span class="s1">uppercase: </span><span class="s2">function </span><span class="s1">(object) { </span><span class="s2">return </span><span class="s1">object ? </span><span class="s3">'TRUE' </span><span class="s1">: </span><span class="s3">'FALSE'</span><span class="s1">; },</span>
    <span class="s1">camelcase: </span><span class="s2">function </span><span class="s1">(object) { </span><span class="s2">return </span><span class="s1">object ? </span><span class="s3">'True' </span><span class="s1">: </span><span class="s3">'False'</span><span class="s1">; }</span>
  <span class="s1">},</span>
  <span class="s1">defaultStyle: </span><span class="s3">'lowercase'</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">16</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">common = require(</span><span class="s3">'../common'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">Type   = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">YAML_FLOAT_PATTERN = </span><span class="s2">new </span><span class="s1">RegExp(</span>
  <span class="s0">// 2.5e4, 2.5 and integers</span>
  <span class="s3">'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:</span><span class="s5">\\</span><span class="s3">.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' </span><span class="s1">+</span>
  <span class="s0">// .2e4, .2</span>
  <span class="s0">// special case, seems not from spec</span>
  <span class="s3">'|</span><span class="s5">\\</span><span class="s3">.[0-9_]+(?:[eE][-+]?[0-9]+)?' </span><span class="s1">+</span>
  <span class="s0">// 20:59</span>
  <span class="s3">'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+</span><span class="s5">\\</span><span class="s3">.[0-9_]*' </span><span class="s1">+</span>
  <span class="s0">// .inf</span>
  <span class="s3">'|[-+]?</span><span class="s5">\\</span><span class="s3">.(?:inf|Inf|INF)' </span><span class="s1">+</span>
  <span class="s0">// .nan</span>
  <span class="s3">'|</span><span class="s5">\\</span><span class="s3">.(?:nan|NaN|NAN))$'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">resolveYamlFloat(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(!YAML_FLOAT_PATTERN.test(data) ||</span>
      <span class="s0">// Quick hack to not allow integers end with `_`</span>
      <span class="s0">// Probably should update regexp &amp; check speed</span>
      <span class="s1">data[data.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'_'</span><span class="s1">) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlFloat(data) {</span>
  <span class="s2">var </span><span class="s1">value, sign, base, digits;</span>

  <span class="s1">value  = data.replace(/_/g, </span><span class="s3">''</span><span class="s1">).toLowerCase();</span>
  <span class="s1">sign   = value[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'-' </span><span class="s1">? -</span><span class="s4">1 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">digits = [];</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s3">'+-'</span><span class="s1">.indexOf(value[</span><span class="s4">0</span><span class="s1">]) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">value = value.slice(</span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'.inf'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">(sign === </span><span class="s4">1</span><span class="s1">) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;</span>

  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value === </span><span class="s3">'.nan'</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">NaN;</span>

  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value.indexOf(</span><span class="s3">':'</span><span class="s1">) &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">value.split(</span><span class="s3">':'</span><span class="s1">).forEach(</span><span class="s2">function </span><span class="s1">(v) {</span>
      <span class="s1">digits.unshift(parseFloat(v, </span><span class="s4">10</span><span class="s1">));</span>
    <span class="s1">});</span>

    <span class="s1">value = </span><span class="s4">0.0</span><span class="s1">;</span>
    <span class="s1">base = </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s1">digits.forEach(</span><span class="s2">function </span><span class="s1">(d) {</span>
      <span class="s1">value += d * base;</span>
      <span class="s1">base *= </span><span class="s4">60</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s2">return </span><span class="s1">sign * value;</span>

  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">sign * parseFloat(value, </span><span class="s4">10</span><span class="s1">);</span>
<span class="s1">}</span>


<span class="s2">var </span><span class="s1">SCIENTIFIC_WITHOUT_DOT = /^[-+]?[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">]+e/;</span>

<span class="s2">function </span><span class="s1">representYamlFloat(object, style) {</span>
  <span class="s2">var </span><span class="s1">res;</span>

  <span class="s2">if </span><span class="s1">(isNaN(object)) {</span>
    <span class="s2">switch </span><span class="s1">(style) {</span>
      <span class="s2">case </span><span class="s3">'lowercase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'.nan'</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s3">'uppercase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'.NAN'</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s3">'camelcase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'.NaN'</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Number.POSITIVE_INFINITY === object) {</span>
    <span class="s2">switch </span><span class="s1">(style) {</span>
      <span class="s2">case </span><span class="s3">'lowercase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'.inf'</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s3">'uppercase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'.INF'</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s3">'camelcase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'.Inf'</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Number.NEGATIVE_INFINITY === object) {</span>
    <span class="s2">switch </span><span class="s1">(style) {</span>
      <span class="s2">case </span><span class="s3">'lowercase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'-.inf'</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s3">'uppercase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'-.INF'</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s3">'camelcase'</span><span class="s1">: </span><span class="s2">return </span><span class="s3">'-.Inf'</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(common.isNegativeZero(object)) {</span>
    <span class="s2">return </span><span class="s3">'-0.0'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s1">res = object.toString(</span><span class="s4">10</span><span class="s1">);</span>

  <span class="s0">// JS stringifier can build scientific format without dots: 5e-100,</span>
  <span class="s0">// while YAML requres dot: 5.e-100. Fix it with simple hack</span>

  <span class="s2">return </span><span class="s1">SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(</span><span class="s3">'e'</span><span class="s1">, </span><span class="s3">'.e'</span><span class="s1">) : res;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isFloat(object) {</span>
  <span class="s2">return </span><span class="s1">(Object.prototype.toString.call(object) === </span><span class="s3">'[object Number]'</span><span class="s1">) &amp;&amp;</span>
         <span class="s1">(object % </span><span class="s4">1 </span><span class="s1">!== </span><span class="s4">0 </span><span class="s1">|| common.isNegativeZero(object));</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:float'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlFloat,</span>
  <span class="s1">construct: constructYamlFloat,</span>
  <span class="s1">predicate: isFloat,</span>
  <span class="s1">represent: representYamlFloat,</span>
  <span class="s1">defaultStyle: </span><span class="s3">'lowercase'</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../common&quot;</span><span class="s1">:</span><span class="s4">2</span><span class="s1">,</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">17</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">common = require(</span><span class="s3">'../common'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">Type   = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">isHexCode(c) {</span>
  <span class="s2">return </span><span class="s1">((</span><span class="s4">0</span><span class="s1">x30</span><span class="s0">/* 0 */ </span><span class="s1">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0</span><span class="s1">x39</span><span class="s0">/* 9 */</span><span class="s1">)) ||</span>
         <span class="s1">((</span><span class="s4">0</span><span class="s1">x41</span><span class="s0">/* A */ </span><span class="s1">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0</span><span class="s1">x46</span><span class="s0">/* F */</span><span class="s1">)) ||</span>
         <span class="s1">((</span><span class="s4">0</span><span class="s1">x61</span><span class="s0">/* a */ </span><span class="s1">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0</span><span class="s1">x66</span><span class="s0">/* f */</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isOctCode(c) {</span>
  <span class="s2">return </span><span class="s1">((</span><span class="s4">0</span><span class="s1">x30</span><span class="s0">/* 0 */ </span><span class="s1">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0</span><span class="s1">x37</span><span class="s0">/* 7 */</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isDecCode(c) {</span>
  <span class="s2">return </span><span class="s1">((</span><span class="s4">0</span><span class="s1">x30</span><span class="s0">/* 0 */ </span><span class="s1">&lt;= c) &amp;&amp; (c &lt;= </span><span class="s4">0</span><span class="s1">x39</span><span class="s0">/* 9 */</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">resolveYamlInteger(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">max = data.length,</span>
      <span class="s1">index = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">hasDigits = </span><span class="s2">false</span><span class="s1">,</span>
      <span class="s1">ch;</span>

  <span class="s2">if </span><span class="s1">(!max) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s1">ch = data[index];</span>

  <span class="s0">// sign</span>
  <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'-' </span><span class="s1">|| ch === </span><span class="s3">'+'</span><span class="s1">) {</span>
    <span class="s1">ch = data[++index];</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'0'</span><span class="s1">) {</span>
    <span class="s0">// 0</span>
    <span class="s2">if </span><span class="s1">(index + </span><span class="s4">1 </span><span class="s1">=== max) </span><span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">ch = data[++index];</span>

    <span class="s0">// base 2, base 8, base 16</span>

    <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'b'</span><span class="s1">) {</span>
      <span class="s0">// base 2</span>
      <span class="s1">index++;</span>

      <span class="s2">for </span><span class="s1">(; index &lt; max; index++) {</span>
        <span class="s1">ch = data[index];</span>
        <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'_'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(ch !== </span><span class="s3">'0' </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">'1'</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">hasDigits = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">hasDigits &amp;&amp; ch !== </span><span class="s3">'_'</span><span class="s1">;</span>
    <span class="s1">}</span>


    <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'x'</span><span class="s1">) {</span>
      <span class="s0">// base 16</span>
      <span class="s1">index++;</span>

      <span class="s2">for </span><span class="s1">(; index &lt; max; index++) {</span>
        <span class="s1">ch = data[index];</span>
        <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'_'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!isHexCode(data.charCodeAt(index))) </span><span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">hasDigits = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">hasDigits &amp;&amp; ch !== </span><span class="s3">'_'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// base 8</span>
    <span class="s2">for </span><span class="s1">(; index &lt; max; index++) {</span>
      <span class="s1">ch = data[index];</span>
      <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'_'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(!isOctCode(data.charCodeAt(index))) </span><span class="s2">return false</span><span class="s1">;</span>
      <span class="s1">hasDigits = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">hasDigits &amp;&amp; ch !== </span><span class="s3">'_'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// base 10 (except 0) or base 60</span>

  <span class="s0">// value should not start with `_`;</span>
  <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'_'</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">for </span><span class="s1">(; index &lt; max; index++) {</span>
    <span class="s1">ch = data[index];</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'_'</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">':'</span><span class="s1">) </span><span class="s2">break</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(!isDecCode(data.charCodeAt(index))) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">hasDigits = </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">// Should have digits and should not end with `_`</span>
  <span class="s2">if </span><span class="s1">(!hasDigits || ch === </span><span class="s3">'_'</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s0">// if !base60 - done;</span>
  <span class="s2">if </span><span class="s1">(ch !== </span><span class="s3">':'</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>

  <span class="s0">// base60 almost not used, no needs to optimize</span>
  <span class="s2">return </span><span class="s1">/^(:[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">5</span><span class="s1">]?[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">])+$/.test(data.slice(index));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlInteger(data) {</span>
  <span class="s2">var </span><span class="s1">value = data, sign = </span><span class="s4">1</span><span class="s1">, ch, base, digits = [];</span>

  <span class="s2">if </span><span class="s1">(value.indexOf(</span><span class="s3">'_'</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">value = value.replace(/_/g, </span><span class="s3">''</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">ch = value[</span><span class="s4">0</span><span class="s1">];</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'-' </span><span class="s1">|| ch === </span><span class="s3">'+'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'-'</span><span class="s1">) sign = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">value = value.slice(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">ch = value[</span><span class="s4">0</span><span class="s1">];</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(value === </span><span class="s3">'0'</span><span class="s1">) </span><span class="s2">return </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(ch === </span><span class="s3">'0'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(value[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'b'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">sign * parseInt(value.slice(</span><span class="s4">2</span><span class="s1">), </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(value[</span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'x'</span><span class="s1">) </span><span class="s2">return </span><span class="s1">sign * parseInt(value, </span><span class="s4">16</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">sign * parseInt(value, </span><span class="s4">8</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(value.indexOf(</span><span class="s3">':'</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">value.split(</span><span class="s3">':'</span><span class="s1">).forEach(</span><span class="s2">function </span><span class="s1">(v) {</span>
      <span class="s1">digits.unshift(parseInt(v, </span><span class="s4">10</span><span class="s1">));</span>
    <span class="s1">});</span>

    <span class="s1">value = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">base = </span><span class="s4">1</span><span class="s1">;</span>

    <span class="s1">digits.forEach(</span><span class="s2">function </span><span class="s1">(d) {</span>
      <span class="s1">value += (d * base);</span>
      <span class="s1">base *= </span><span class="s4">60</span><span class="s1">;</span>
    <span class="s1">});</span>

    <span class="s2">return </span><span class="s1">sign * value;</span>

  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">sign * parseInt(value, </span><span class="s4">10</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isInteger(object) {</span>
  <span class="s2">return </span><span class="s1">(Object.prototype.toString.call(object)) === </span><span class="s3">'[object Number]' </span><span class="s1">&amp;&amp;</span>
         <span class="s1">(object % </span><span class="s4">1 </span><span class="s1">=== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !common.isNegativeZero(object));</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:int'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlInteger,</span>
  <span class="s1">construct: constructYamlInteger,</span>
  <span class="s1">predicate: isInteger,</span>
  <span class="s1">represent: {</span>
    <span class="s1">binary:      </span><span class="s2">function </span><span class="s1">(obj) { </span><span class="s2">return </span><span class="s1">obj &gt;= </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'0b' </span><span class="s1">+ obj.toString(</span><span class="s4">2</span><span class="s1">) : </span><span class="s3">'-0b' </span><span class="s1">+ obj.toString(</span><span class="s4">2</span><span class="s1">).slice(</span><span class="s4">1</span><span class="s1">); },</span>
    <span class="s1">octal:       </span><span class="s2">function </span><span class="s1">(obj) { </span><span class="s2">return </span><span class="s1">obj &gt;= </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'0'  </span><span class="s1">+ obj.toString(</span><span class="s4">8</span><span class="s1">) : </span><span class="s3">'-0'  </span><span class="s1">+ obj.toString(</span><span class="s4">8</span><span class="s1">).slice(</span><span class="s4">1</span><span class="s1">); },</span>
    <span class="s1">decimal:     </span><span class="s2">function </span><span class="s1">(obj) { </span><span class="s2">return </span><span class="s1">obj.toString(</span><span class="s4">10</span><span class="s1">); },</span>
    <span class="s0">/* eslint-disable max-len */</span>
    <span class="s1">hexadecimal: </span><span class="s2">function </span><span class="s1">(obj) { </span><span class="s2">return </span><span class="s1">obj &gt;= </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'0x' </span><span class="s1">+ obj.toString(</span><span class="s4">16</span><span class="s1">).toUpperCase() :  </span><span class="s3">'-0x' </span><span class="s1">+ obj.toString(</span><span class="s4">16</span><span class="s1">).toUpperCase().slice(</span><span class="s4">1</span><span class="s1">); }</span>
  <span class="s1">},</span>
  <span class="s1">defaultStyle: </span><span class="s3">'decimal'</span><span class="s1">,</span>
  <span class="s1">styleAliases: {</span>
    <span class="s1">binary:      [ </span><span class="s4">2</span><span class="s1">,  </span><span class="s3">'bin' </span><span class="s1">],</span>
    <span class="s1">octal:       [ </span><span class="s4">8</span><span class="s1">,  </span><span class="s3">'oct' </span><span class="s1">],</span>
    <span class="s1">decimal:     [ </span><span class="s4">10</span><span class="s1">, </span><span class="s3">'dec' </span><span class="s1">],</span>
    <span class="s1">hexadecimal: [ </span><span class="s4">16</span><span class="s1">, </span><span class="s3">'hex' </span><span class="s1">]</span>
  <span class="s1">}</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../common&quot;</span><span class="s1">:</span><span class="s4">2</span><span class="s1">,</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">18</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">esprima;</span>

<span class="s0">// Browserified version does not have esprima</span>
<span class="s0">//</span>
<span class="s0">// 1. For node.js just require module as deps</span>
<span class="s0">// 2. For browser try to require mudule via external AMD system.</span>
<span class="s0">//    If not found - try to fallback to window.esprima. If not</span>
<span class="s0">//    found too - then fail to parse.</span>
<span class="s0">//</span>
<span class="s2">try </span><span class="s1">{</span>
  <span class="s0">// workaround to exclude package from browserify list.</span>
  <span class="s2">var </span><span class="s1">_require = require;</span>
  <span class="s1">esprima = _require(</span><span class="s3">'esprima'</span><span class="s1">);</span>
<span class="s1">} </span><span class="s2">catch </span><span class="s1">(_) {</span>
  <span class="s0">/* eslint-disable no-redeclare */</span>
  <span class="s0">/* global window */</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">'undefined'</span><span class="s1">) esprima = window.esprima;</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../../type'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">resolveJavascriptFunction(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">var </span><span class="s1">source = </span><span class="s3">'(' </span><span class="s1">+ data + </span><span class="s3">')'</span><span class="s1">,</span>
        <span class="s1">ast    = esprima.parse(source, { range: </span><span class="s2">true </span><span class="s1">});</span>

    <span class="s2">if </span><span class="s1">(ast.type                    !== </span><span class="s3">'Program'             </span><span class="s1">||</span>
        <span class="s1">ast.body.length             !== </span><span class="s4">1                     </span><span class="s1">||</span>
        <span class="s1">ast.body[</span><span class="s4">0</span><span class="s1">].type            !== </span><span class="s3">'ExpressionStatement' </span><span class="s1">||</span>
        <span class="s1">(ast.body[</span><span class="s4">0</span><span class="s1">].expression.type !== </span><span class="s3">'ArrowFunctionExpression' </span><span class="s1">&amp;&amp;</span>
          <span class="s1">ast.body[</span><span class="s4">0</span><span class="s1">].expression.type !== </span><span class="s3">'FunctionExpression'</span><span class="s1">)) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return true</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructJavascriptFunction(data) {</span>
  <span class="s0">/*jslint evil:true*/</span>

  <span class="s2">var </span><span class="s1">source = </span><span class="s3">'(' </span><span class="s1">+ data + </span><span class="s3">')'</span><span class="s1">,</span>
      <span class="s1">ast    = esprima.parse(source, { range: </span><span class="s2">true </span><span class="s1">}),</span>
      <span class="s1">params = [],</span>
      <span class="s1">body;</span>

  <span class="s2">if </span><span class="s1">(ast.type                    !== </span><span class="s3">'Program'             </span><span class="s1">||</span>
      <span class="s1">ast.body.length             !== </span><span class="s4">1                     </span><span class="s1">||</span>
      <span class="s1">ast.body[</span><span class="s4">0</span><span class="s1">].type            !== </span><span class="s3">'ExpressionStatement' </span><span class="s1">||</span>
      <span class="s1">(ast.body[</span><span class="s4">0</span><span class="s1">].expression.type !== </span><span class="s3">'ArrowFunctionExpression' </span><span class="s1">&amp;&amp;</span>
        <span class="s1">ast.body[</span><span class="s4">0</span><span class="s1">].expression.type !== </span><span class="s3">'FunctionExpression'</span><span class="s1">)) {</span>
    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Failed to resolve function'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">ast.body[</span><span class="s4">0</span><span class="s1">].expression.params.forEach(</span><span class="s2">function </span><span class="s1">(param) {</span>
    <span class="s1">params.push(param.name);</span>
  <span class="s1">});</span>

  <span class="s1">body = ast.body[</span><span class="s4">0</span><span class="s1">].expression.body.range;</span>

  <span class="s0">// Esprima's ranges include the first '{' and the last '}' characters on</span>
  <span class="s0">// function expressions. So cut them out.</span>
  <span class="s2">if </span><span class="s1">(ast.body[</span><span class="s4">0</span><span class="s1">].expression.body.type === </span><span class="s3">'BlockStatement'</span><span class="s1">) {</span>
    <span class="s0">/*eslint-disable no-new-func*/</span>
    <span class="s2">return new </span><span class="s1">Function(params, source.slice(body[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">, body[</span><span class="s4">1</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s0">// ES6 arrow functions can omit the BlockStatement. In that case, just return</span>
  <span class="s0">// the body.</span>
  <span class="s0">/*eslint-disable no-new-func*/</span>
  <span class="s2">return new </span><span class="s1">Function(params, </span><span class="s3">'return ' </span><span class="s1">+ source.slice(body[</span><span class="s4">0</span><span class="s1">], body[</span><span class="s4">1</span><span class="s1">]));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">representJavascriptFunction(object </span><span class="s0">/*, style*/</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s1">object.toString();</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isFunction(object) {</span>
  <span class="s2">return </span><span class="s1">Object.prototype.toString.call(object) === </span><span class="s3">'[object Function]'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:js/function'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveJavascriptFunction,</span>
  <span class="s1">construct: constructJavascriptFunction,</span>
  <span class="s1">predicate: isFunction,</span>
  <span class="s1">represent: representJavascriptFunction</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">19</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../../type'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">resolveJavascriptRegExp(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(data.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">regexp = data,</span>
      <span class="s1">tail   = /\/([gim]*)$/.exec(data),</span>
      <span class="s1">modifiers = </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s0">// if regexp starts with '/' it can have modifiers and must be properly closed</span>
  <span class="s0">// `/foo/gim` - modifiers tail can be maximum 3 chars</span>
  <span class="s2">if </span><span class="s1">(regexp[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'/'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(tail) modifiers = tail[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s2">if </span><span class="s1">(modifiers.length &gt; </span><span class="s4">3</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
    <span class="s0">// if expression starts with /, is should be properly terminated</span>
    <span class="s2">if </span><span class="s1">(regexp[regexp.length - modifiers.length - </span><span class="s4">1</span><span class="s1">] !== </span><span class="s3">'/'</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructJavascriptRegExp(data) {</span>
  <span class="s2">var </span><span class="s1">regexp = data,</span>
      <span class="s1">tail   = /\/([gim]*)$/.exec(data),</span>
      <span class="s1">modifiers = </span><span class="s3">''</span><span class="s1">;</span>

  <span class="s0">// `/foo/gim` - tail can be maximum 4 chars</span>
  <span class="s2">if </span><span class="s1">(regexp[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'/'</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(tail) modifiers = tail[</span><span class="s4">1</span><span class="s1">];</span>
    <span class="s1">regexp = regexp.slice(</span><span class="s4">1</span><span class="s1">, regexp.length - modifiers.length - </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">return new </span><span class="s1">RegExp(regexp, modifiers);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">representJavascriptRegExp(object </span><span class="s0">/*, style*/</span><span class="s1">) {</span>
  <span class="s2">var </span><span class="s1">result = </span><span class="s3">'/' </span><span class="s1">+ object.source + </span><span class="s3">'/'</span><span class="s1">;</span>

  <span class="s2">if </span><span class="s1">(object.global) result += </span><span class="s3">'g'</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(object.multiline) result += </span><span class="s3">'m'</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(object.ignoreCase) result += </span><span class="s3">'i'</span><span class="s1">;</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isRegExp(object) {</span>
  <span class="s2">return </span><span class="s1">Object.prototype.toString.call(object) === </span><span class="s3">'[object RegExp]'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:js/regexp'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveJavascriptRegExp,</span>
  <span class="s1">construct: constructJavascriptRegExp,</span>
  <span class="s1">predicate: isRegExp,</span>
  <span class="s1">represent: representJavascriptRegExp</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">20</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../../type'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">resolveJavascriptUndefined() {</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructJavascriptUndefined() {</span>
  <span class="s0">/*eslint-disable no-undefined*/</span>
  <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">representJavascriptUndefined() {</span>
  <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isUndefined(object) {</span>
  <span class="s2">return typeof </span><span class="s1">object === </span><span class="s3">'undefined'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:js/undefined'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveJavascriptUndefined,</span>
  <span class="s1">construct: constructJavascriptUndefined,</span>
  <span class="s1">predicate: isUndefined,</span>
  <span class="s1">represent: representJavascriptUndefined</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">21</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:map'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'mapping'</span><span class="s1">,</span>
  <span class="s1">construct: </span><span class="s2">function </span><span class="s1">(data) { </span><span class="s2">return </span><span class="s1">data !== </span><span class="s2">null </span><span class="s1">? data : {}; }</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">22</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">resolveYamlMerge(data) {</span>
  <span class="s2">return </span><span class="s1">data === </span><span class="s3">'&lt;&lt;' </span><span class="s1">|| data === </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:merge'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlMerge</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">23</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">resolveYamlNull(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">max = data.length;</span>

  <span class="s2">return </span><span class="s1">(max === </span><span class="s4">1 </span><span class="s1">&amp;&amp; data === </span><span class="s3">'~'</span><span class="s1">) ||</span>
         <span class="s1">(max === </span><span class="s4">4 </span><span class="s1">&amp;&amp; (data === </span><span class="s3">'null' </span><span class="s1">|| data === </span><span class="s3">'Null' </span><span class="s1">|| data === </span><span class="s3">'NULL'</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlNull() {</span>
  <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isNull(object) {</span>
  <span class="s2">return </span><span class="s1">object === </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:null'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlNull,</span>
  <span class="s1">construct: constructYamlNull,</span>
  <span class="s1">predicate: isNull,</span>
  <span class="s1">represent: {</span>
    <span class="s1">canonical: </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s3">'~'</span><span class="s1">;    },</span>
    <span class="s1">lowercase: </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s3">'null'</span><span class="s1">; },</span>
    <span class="s1">uppercase: </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s3">'NULL'</span><span class="s1">; },</span>
    <span class="s1">camelcase: </span><span class="s2">function </span><span class="s1">() { </span><span class="s2">return </span><span class="s3">'Null'</span><span class="s1">; }</span>
  <span class="s1">},</span>
  <span class="s1">defaultStyle: </span><span class="s3">'lowercase'</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">24</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>
<span class="s2">var </span><span class="s1">_toString       = Object.prototype.toString;</span>

<span class="s2">function </span><span class="s1">resolveYamlOmap(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">objectKeys = [], index, length, pair, pairKey, pairHasKey,</span>
      <span class="s1">object = data;</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">pair = object[index];</span>
    <span class="s1">pairHasKey = </span><span class="s2">false</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(_toString.call(pair) !== </span><span class="s3">'[object Object]'</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

    <span class="s2">for </span><span class="s1">(pairKey </span><span class="s2">in </span><span class="s1">pair) {</span>
      <span class="s2">if </span><span class="s1">(_hasOwnProperty.call(pair, pairKey)) {</span>
        <span class="s2">if </span><span class="s1">(!pairHasKey) pairHasKey = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">else return false</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!pairHasKey) </span><span class="s2">return false</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(objectKeys.indexOf(pairKey) === -</span><span class="s4">1</span><span class="s1">) objectKeys.push(pairKey);</span>
    <span class="s2">else return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlOmap(data) {</span>
  <span class="s2">return </span><span class="s1">data !== </span><span class="s2">null </span><span class="s1">? data : [];</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:omap'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'sequence'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlOmap,</span>
  <span class="s1">construct: constructYamlOmap</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">25</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_toString = Object.prototype.toString;</span>

<span class="s2">function </span><span class="s1">resolveYamlPairs(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">index, length, pair, keys, result,</span>
      <span class="s1">object = data;</span>

  <span class="s1">result = </span><span class="s2">new </span><span class="s1">Array(object.length);</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">pair = object[index];</span>

    <span class="s2">if </span><span class="s1">(_toString.call(pair) !== </span><span class="s3">'[object Object]'</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

    <span class="s1">keys = Object.keys(pair);</span>

    <span class="s2">if </span><span class="s1">(keys.length !== </span><span class="s4">1</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>

    <span class="s1">result[index] = [ keys[</span><span class="s4">0</span><span class="s1">], pair[keys[</span><span class="s4">0</span><span class="s1">]] ];</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlPairs(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">[];</span>

  <span class="s2">var </span><span class="s1">index, length, pair, keys, result,</span>
      <span class="s1">object = data;</span>

  <span class="s1">result = </span><span class="s2">new </span><span class="s1">Array(object.length);</span>

  <span class="s2">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">pair = object[index];</span>

    <span class="s1">keys = Object.keys(pair);</span>

    <span class="s1">result[index] = [ keys[</span><span class="s4">0</span><span class="s1">], pair[keys[</span><span class="s4">0</span><span class="s1">]] ];</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:pairs'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'sequence'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlPairs,</span>
  <span class="s1">construct: constructYamlPairs</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">26</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:seq'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'sequence'</span><span class="s1">,</span>
  <span class="s1">construct: </span><span class="s2">function </span><span class="s1">(data) { </span><span class="s2">return </span><span class="s1">data !== </span><span class="s2">null </span><span class="s1">? data : []; }</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">27</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s2">function </span><span class="s1">resolveYamlSet(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>

  <span class="s2">var </span><span class="s1">key, object = data;</span>

  <span class="s2">for </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">object) {</span>
    <span class="s2">if </span><span class="s1">(_hasOwnProperty.call(object, key)) {</span>
      <span class="s2">if </span><span class="s1">(object[key] !== </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlSet(data) {</span>
  <span class="s2">return </span><span class="s1">data !== </span><span class="s2">null </span><span class="s1">? data : {};</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:set'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'mapping'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlSet,</span>
  <span class="s1">construct: constructYamlSet</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">28</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:str'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">construct: </span><span class="s2">function </span><span class="s1">(data) { </span><span class="s2">return </span><span class="s1">data !== </span><span class="s2">null </span><span class="s1">? data : </span><span class="s3">''</span><span class="s1">; }</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s4">29</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">Type = require(</span><span class="s3">'../type'</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">YAML_DATE_REGEXP = </span><span class="s2">new </span><span class="s1">RegExp(</span>
  <span class="s3">'^([0-9][0-9][0-9][0-9])'          </span><span class="s1">+ </span><span class="s0">// [1] year</span>
  <span class="s3">'-([0-9][0-9])'                    </span><span class="s1">+ </span><span class="s0">// [2] month</span>
  <span class="s3">'-([0-9][0-9])$'</span><span class="s1">);                   </span><span class="s0">// [3] day</span>

<span class="s2">var </span><span class="s1">YAML_TIMESTAMP_REGEXP = </span><span class="s2">new </span><span class="s1">RegExp(</span>
  <span class="s3">'^([0-9][0-9][0-9][0-9])'          </span><span class="s1">+ </span><span class="s0">// [1] year</span>
  <span class="s3">'-([0-9][0-9]?)'                   </span><span class="s1">+ </span><span class="s0">// [2] month</span>
  <span class="s3">'-([0-9][0-9]?)'                   </span><span class="s1">+ </span><span class="s0">// [3] day</span>
  <span class="s3">'(?:[Tt]|[ </span><span class="s5">\\</span><span class="s3">t]+)'                 </span><span class="s1">+ </span><span class="s0">// ...</span>
  <span class="s3">'([0-9][0-9]?)'                    </span><span class="s1">+ </span><span class="s0">// [4] hour</span>
  <span class="s3">':([0-9][0-9])'                    </span><span class="s1">+ </span><span class="s0">// [5] minute</span>
  <span class="s3">':([0-9][0-9])'                    </span><span class="s1">+ </span><span class="s0">// [6] second</span>
  <span class="s3">'(?:</span><span class="s5">\\</span><span class="s3">.([0-9]*))?'                 </span><span class="s1">+ </span><span class="s0">// [7] fraction</span>
  <span class="s3">'(?:[ </span><span class="s5">\\</span><span class="s3">t]*(Z|([-+])([0-9][0-9]?)' </span><span class="s1">+ </span><span class="s0">// [8] tz [9] tz_sign [10] tz_hour</span>
  <span class="s3">'(?::([0-9][0-9]))?))?$'</span><span class="s1">);           </span><span class="s0">// [11] tz_minute</span>

<span class="s2">function </span><span class="s1">resolveYamlTimestamp(data) {</span>
  <span class="s2">if </span><span class="s1">(data === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(YAML_DATE_REGEXP.exec(data) !== </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(YAML_TIMESTAMP_REGEXP.exec(data) !== </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return true</span><span class="s1">;</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">constructYamlTimestamp(data) {</span>
  <span class="s2">var </span><span class="s1">match, year, month, day, hour, minute, second, fraction = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">delta = </span><span class="s2">null</span><span class="s1">, tz_hour, tz_minute, date;</span>

  <span class="s1">match = YAML_DATE_REGEXP.exec(data);</span>
  <span class="s2">if </span><span class="s1">(match === </span><span class="s2">null</span><span class="s1">) match = YAML_TIMESTAMP_REGEXP.exec(data);</span>

  <span class="s2">if </span><span class="s1">(match === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">'Date resolve error'</span><span class="s1">);</span>

  <span class="s0">// match: [1] year [2] month [3] day</span>

  <span class="s1">year = +(match[</span><span class="s4">1</span><span class="s1">]);</span>
  <span class="s1">month = +(match[</span><span class="s4">2</span><span class="s1">]) - </span><span class="s4">1</span><span class="s1">; </span><span class="s0">// JS month starts with 0</span>
  <span class="s1">day = +(match[</span><span class="s4">3</span><span class="s1">]);</span>

  <span class="s2">if </span><span class="s1">(!match[</span><span class="s4">4</span><span class="s1">]) { </span><span class="s0">// no hour</span>
    <span class="s2">return new </span><span class="s1">Date(Date.UTC(year, month, day));</span>
  <span class="s1">}</span>

  <span class="s0">// match: [4] hour [5] minute [6] second [7] fraction</span>

  <span class="s1">hour = +(match[</span><span class="s4">4</span><span class="s1">]);</span>
  <span class="s1">minute = +(match[</span><span class="s4">5</span><span class="s1">]);</span>
  <span class="s1">second = +(match[</span><span class="s4">6</span><span class="s1">]);</span>

  <span class="s2">if </span><span class="s1">(match[</span><span class="s4">7</span><span class="s1">]) {</span>
    <span class="s1">fraction = match[</span><span class="s4">7</span><span class="s1">].slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">3</span><span class="s1">);</span>
    <span class="s2">while </span><span class="s1">(fraction.length &lt; </span><span class="s4">3</span><span class="s1">) { </span><span class="s0">// milli-seconds</span>
      <span class="s1">fraction += </span><span class="s3">'0'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">fraction = +fraction;</span>
  <span class="s1">}</span>

  <span class="s0">// match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute</span>

  <span class="s2">if </span><span class="s1">(match[</span><span class="s4">9</span><span class="s1">]) {</span>
    <span class="s1">tz_hour = +(match[</span><span class="s4">10</span><span class="s1">]);</span>
    <span class="s1">tz_minute = +(match[</span><span class="s4">11</span><span class="s1">] || </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">delta = (tz_hour * </span><span class="s4">60 </span><span class="s1">+ tz_minute) * </span><span class="s4">60000</span><span class="s1">; </span><span class="s0">// delta in mili-seconds</span>
    <span class="s2">if </span><span class="s1">(match[</span><span class="s4">9</span><span class="s1">] === </span><span class="s3">'-'</span><span class="s1">) delta = -delta;</span>
  <span class="s1">}</span>

  <span class="s1">date = </span><span class="s2">new </span><span class="s1">Date(Date.UTC(year, month, day, hour, minute, second, fraction));</span>

  <span class="s2">if </span><span class="s1">(delta) date.setTime(date.getTime() - delta);</span>

  <span class="s2">return </span><span class="s1">date;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">representYamlTimestamp(object </span><span class="s0">/*, style*/</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s1">object.toISOString();</span>
<span class="s1">}</span>

<span class="s1">module.exports = </span><span class="s2">new </span><span class="s1">Type(</span><span class="s3">'tag:yaml.org,2002:timestamp'</span><span class="s1">, {</span>
  <span class="s1">kind: </span><span class="s3">'scalar'</span><span class="s1">,</span>
  <span class="s1">resolve: resolveYamlTimestamp,</span>
  <span class="s1">construct: constructYamlTimestamp,</span>
  <span class="s1">instanceOf: Date,</span>
  <span class="s1">represent: representYamlTimestamp</span>
<span class="s1">});</span>

<span class="s1">},{</span><span class="s3">&quot;../type&quot;</span><span class="s1">:</span><span class="s4">13</span><span class="s1">}],</span><span class="s3">&quot;/&quot;</span><span class="s1">:[</span><span class="s2">function</span><span class="s1">(require,module,exports){</span>
<span class="s3">'use strict'</span><span class="s1">;</span>


<span class="s2">var </span><span class="s1">yaml = require(</span><span class="s3">'./lib/js-yaml.js'</span><span class="s1">);</span>


<span class="s1">module.exports = yaml;</span>

<span class="s1">},{</span><span class="s3">&quot;./lib/js-yaml.js&quot;</span><span class="s1">:</span><span class="s4">1</span><span class="s1">}]},{},[])(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
<span class="s1">});</span>
</pre>
</body>
</html>
<html>
<head>
<title>index.es.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.es.js</font>
</center></td></tr></table>
<pre><span class="s0">process.emitWarning(</span><span class="s1">&quot;The .es.js file is deprecated. Use .mjs instead.&quot;</span><span class="s0">);</span>

<span class="s0">import Stream from </span><span class="s1">'stream'</span><span class="s0">;</span>
<span class="s0">import http from </span><span class="s1">'http'</span><span class="s0">;</span>
<span class="s0">import Url from </span><span class="s1">'url'</span><span class="s0">;</span>
<span class="s0">import whatwgUrl from </span><span class="s1">'whatwg-url'</span><span class="s0">;</span>
<span class="s0">import https from </span><span class="s1">'https'</span><span class="s0">;</span>
<span class="s0">import zlib from </span><span class="s1">'zlib'</span><span class="s0">;</span>

<span class="s2">// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js</span>

<span class="s2">// fix for &quot;Readable&quot; isn't a named export issue</span>
<span class="s0">const Readable = Stream.Readable;</span>

<span class="s0">const BUFFER = Symbol(</span><span class="s1">'buffer'</span><span class="s0">);</span>
<span class="s0">const TYPE = Symbol(</span><span class="s1">'type'</span><span class="s0">);</span>

<span class="s0">class Blob {</span>
	<span class="s0">constructor() {</span>
		<span class="s3">this</span><span class="s0">[TYPE] = </span><span class="s1">''</span><span class="s0">;</span>

		<span class="s0">const blobParts = arguments[</span><span class="s4">0</span><span class="s0">];</span>
		<span class="s0">const options = arguments[</span><span class="s4">1</span><span class="s0">];</span>

		<span class="s0">const buffers = [];</span>
		<span class="s0">let size = </span><span class="s4">0</span><span class="s0">;</span>

		<span class="s3">if </span><span class="s0">(blobParts) {</span>
			<span class="s0">const a = blobParts;</span>
			<span class="s0">const length = Number(a.length);</span>
			<span class="s3">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; length; i++) {</span>
				<span class="s0">const element = a[i];</span>
				<span class="s0">let buffer;</span>
				<span class="s3">if </span><span class="s0">(element </span><span class="s3">instanceof </span><span class="s0">Buffer) {</span>
					<span class="s0">buffer = element;</span>
				<span class="s0">} </span><span class="s3">else if </span><span class="s0">(ArrayBuffer.isView(element)) {</span>
					<span class="s0">buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);</span>
				<span class="s0">} </span><span class="s3">else if </span><span class="s0">(element </span><span class="s3">instanceof </span><span class="s0">ArrayBuffer) {</span>
					<span class="s0">buffer = Buffer.from(element);</span>
				<span class="s0">} </span><span class="s3">else if </span><span class="s0">(element </span><span class="s3">instanceof </span><span class="s0">Blob) {</span>
					<span class="s0">buffer = element[BUFFER];</span>
				<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
					<span class="s0">buffer = Buffer.from(</span><span class="s3">typeof </span><span class="s0">element === </span><span class="s1">'string' </span><span class="s0">? element : String(element));</span>
				<span class="s0">}</span>
				<span class="s0">size += buffer.length;</span>
				<span class="s0">buffers.push(buffer);</span>
			<span class="s0">}</span>
		<span class="s0">}</span>

		<span class="s3">this</span><span class="s0">[BUFFER] = Buffer.concat(buffers);</span>

		<span class="s0">let type = options &amp;&amp; options.type !== undefined &amp;&amp; String(options.type).toLowerCase();</span>
		<span class="s3">if </span><span class="s0">(type &amp;&amp; !/[^\u0020-\u007E]/.test(type)) {</span>
			<span class="s3">this</span><span class="s0">[TYPE] = type;</span>
		<span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">get size() {</span>
		<span class="s3">return this</span><span class="s0">[BUFFER].length;</span>
	<span class="s0">}</span>
	<span class="s0">get type() {</span>
		<span class="s3">return this</span><span class="s0">[TYPE];</span>
	<span class="s0">}</span>
	<span class="s0">text() {</span>
		<span class="s3">return </span><span class="s0">Promise.resolve(</span><span class="s3">this</span><span class="s0">[BUFFER].toString());</span>
	<span class="s0">}</span>
	<span class="s0">arrayBuffer() {</span>
		<span class="s0">const buf = </span><span class="s3">this</span><span class="s0">[BUFFER];</span>
		<span class="s0">const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);</span>
		<span class="s3">return </span><span class="s0">Promise.resolve(ab);</span>
	<span class="s0">}</span>
	<span class="s0">stream() {</span>
		<span class="s0">const readable = </span><span class="s3">new </span><span class="s0">Readable();</span>
		<span class="s0">readable._read = </span><span class="s3">function </span><span class="s0">() {};</span>
		<span class="s0">readable.push(</span><span class="s3">this</span><span class="s0">[BUFFER]);</span>
		<span class="s0">readable.push(</span><span class="s3">null</span><span class="s0">);</span>
		<span class="s3">return </span><span class="s0">readable;</span>
	<span class="s0">}</span>
	<span class="s0">toString() {</span>
		<span class="s3">return </span><span class="s1">'[object Blob]'</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s0">slice() {</span>
		<span class="s0">const size = </span><span class="s3">this</span><span class="s0">.size;</span>

		<span class="s0">const start = arguments[</span><span class="s4">0</span><span class="s0">];</span>
		<span class="s0">const end = arguments[</span><span class="s4">1</span><span class="s0">];</span>
		<span class="s0">let relativeStart, relativeEnd;</span>
		<span class="s3">if </span><span class="s0">(start === undefined) {</span>
			<span class="s0">relativeStart = </span><span class="s4">0</span><span class="s0">;</span>
		<span class="s0">} </span><span class="s3">else if </span><span class="s0">(start &lt; </span><span class="s4">0</span><span class="s0">) {</span>
			<span class="s0">relativeStart = Math.max(size + start, </span><span class="s4">0</span><span class="s0">);</span>
		<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
			<span class="s0">relativeStart = Math.min(start, size);</span>
		<span class="s0">}</span>
		<span class="s3">if </span><span class="s0">(end === undefined) {</span>
			<span class="s0">relativeEnd = size;</span>
		<span class="s0">} </span><span class="s3">else if </span><span class="s0">(end &lt; </span><span class="s4">0</span><span class="s0">) {</span>
			<span class="s0">relativeEnd = Math.max(size + end, </span><span class="s4">0</span><span class="s0">);</span>
		<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
			<span class="s0">relativeEnd = Math.min(end, size);</span>
		<span class="s0">}</span>
		<span class="s0">const span = Math.max(relativeEnd - relativeStart, </span><span class="s4">0</span><span class="s0">);</span>

		<span class="s0">const buffer = </span><span class="s3">this</span><span class="s0">[BUFFER];</span>
		<span class="s0">const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);</span>
		<span class="s0">const blob = </span><span class="s3">new </span><span class="s0">Blob([], { type: arguments[</span><span class="s4">2</span><span class="s0">] });</span>
		<span class="s0">blob[BUFFER] = slicedBuffer;</span>
		<span class="s3">return </span><span class="s0">blob;</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">Object.defineProperties(Blob.prototype, {</span>
	<span class="s0">size: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">type: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">slice: { enumerable: </span><span class="s3">true </span><span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">Object.defineProperty(Blob.prototype, Symbol.toStringTag, {</span>
	<span class="s0">value: </span><span class="s1">'Blob'</span><span class="s0">,</span>
	<span class="s0">writable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">enumerable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">configurable: </span><span class="s3">true</span>
<span class="s0">});</span>

<span class="s2">/** 
 * fetch-error.js 
 * 
 * FetchError interface for operational errors 
 */</span>

<span class="s2">/** 
 * Create FetchError instance 
 * 
 * @param   String      message      Error message for human 
 * @param   String      type         Error type for machine 
 * @param   String      systemError  For Node.js system error 
 * @return  FetchError 
 */</span>
<span class="s3">function </span><span class="s0">FetchError(message, type, systemError) {</span>
  <span class="s0">Error.call(</span><span class="s3">this</span><span class="s0">, message);</span>

  <span class="s3">this</span><span class="s0">.message = message;</span>
  <span class="s3">this</span><span class="s0">.type = type;</span>

  <span class="s2">// when err.type is `system`, err.code contains system error code</span>
  <span class="s3">if </span><span class="s0">(systemError) {</span>
    <span class="s3">this</span><span class="s0">.code = </span><span class="s3">this</span><span class="s0">.errno = systemError.code;</span>
  <span class="s0">}</span>

  <span class="s2">// hide custom error implementation details from end-users</span>
  <span class="s0">Error.captureStackTrace(</span><span class="s3">this</span><span class="s0">, </span><span class="s3">this</span><span class="s0">.constructor);</span>
<span class="s0">}</span>

<span class="s0">FetchError.prototype = Object.create(Error.prototype);</span>
<span class="s0">FetchError.prototype.constructor = FetchError;</span>
<span class="s0">FetchError.prototype.name = </span><span class="s1">'FetchError'</span><span class="s0">;</span>

<span class="s0">let convert;</span>
<span class="s3">try </span><span class="s0">{</span>
	<span class="s0">convert = require(</span><span class="s1">'encoding'</span><span class="s0">).convert;</span>
<span class="s0">} </span><span class="s3">catch </span><span class="s0">(e) {}</span>

<span class="s0">const INTERNALS = Symbol(</span><span class="s1">'Body internals'</span><span class="s0">);</span>

<span class="s2">// fix an issue where &quot;PassThrough&quot; isn't a named export for node &lt;10</span>
<span class="s0">const PassThrough = Stream.PassThrough;</span>

<span class="s2">/** 
 * Body mixin 
 * 
 * Ref: https://fetch.spec.whatwg.org/#body 
 * 
 * @param   Stream  body  Readable stream 
 * @param   Object  opts  Response options 
 * @return  Void 
 */</span>
<span class="s3">function </span><span class="s0">Body(body) {</span>
	<span class="s3">var </span><span class="s0">_this = </span><span class="s3">this</span><span class="s0">;</span>

	<span class="s3">var </span><span class="s0">_ref = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : {},</span>
	    <span class="s0">_ref$size = _ref.size;</span>

	<span class="s0">let size = _ref$size === undefined ? </span><span class="s4">0 </span><span class="s0">: _ref$size;</span>
	<span class="s3">var </span><span class="s0">_ref$timeout = _ref.timeout;</span>
	<span class="s0">let timeout = _ref$timeout === undefined ? </span><span class="s4">0 </span><span class="s0">: _ref$timeout;</span>

	<span class="s3">if </span><span class="s0">(body == </span><span class="s3">null</span><span class="s0">) {</span>
		<span class="s2">// body is undefined or null</span>
		<span class="s0">body = </span><span class="s3">null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(isURLSearchParams(body)) {</span>
		<span class="s2">// body is a URLSearchParams</span>
		<span class="s0">body = Buffer.from(body.toString());</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(isBlob(body)) ; </span><span class="s3">else if </span><span class="s0">(Buffer.isBuffer(body)) ; </span><span class="s3">else if </span><span class="s0">(Object.prototype.toString.call(body) === </span><span class="s1">'[object ArrayBuffer]'</span><span class="s0">) {</span>
		<span class="s2">// body is ArrayBuffer</span>
		<span class="s0">body = Buffer.from(body);</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(ArrayBuffer.isView(body)) {</span>
		<span class="s2">// body is ArrayBufferView</span>
		<span class="s0">body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(body </span><span class="s3">instanceof </span><span class="s0">Stream) ; </span><span class="s3">else </span><span class="s0">{</span>
		<span class="s2">// none of the above</span>
		<span class="s2">// coerce to string then buffer</span>
		<span class="s0">body = Buffer.from(String(body));</span>
	<span class="s0">}</span>
	<span class="s3">this</span><span class="s0">[INTERNALS] = {</span>
		<span class="s0">body,</span>
		<span class="s0">disturbed: </span><span class="s3">false</span><span class="s0">,</span>
		<span class="s0">error: </span><span class="s3">null</span>
	<span class="s0">};</span>
	<span class="s3">this</span><span class="s0">.size = size;</span>
	<span class="s3">this</span><span class="s0">.timeout = timeout;</span>

	<span class="s3">if </span><span class="s0">(body </span><span class="s3">instanceof </span><span class="s0">Stream) {</span>
		<span class="s0">body.on(</span><span class="s1">'error'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(err) {</span>
			<span class="s0">const error = err.name === </span><span class="s1">'AbortError' </span><span class="s0">? err : </span><span class="s3">new </span><span class="s0">FetchError(`Invalid response body </span><span class="s3">while </span><span class="s0">trying to fetch ${_this.url}: ${err.message}`, </span><span class="s1">'system'</span><span class="s0">, err);</span>
			<span class="s0">_this[INTERNALS].error = error;</span>
		<span class="s0">});</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">Body.prototype = {</span>
	<span class="s0">get body() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS].body;</span>
	<span class="s0">},</span>

	<span class="s0">get bodyUsed() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS].disturbed;</span>
	<span class="s0">},</span>

	<span class="s2">/** 
  * Decode response as ArrayBuffer 
  * 
  * @return  Promise 
  */</span>
	<span class="s0">arrayBuffer() {</span>
		<span class="s3">return </span><span class="s0">consumeBody.call(</span><span class="s3">this</span><span class="s0">).then(</span><span class="s3">function </span><span class="s0">(buf) {</span>
			<span class="s3">return </span><span class="s0">buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);</span>
		<span class="s0">});</span>
	<span class="s0">},</span>

	<span class="s2">/** 
  * Return raw response as Blob 
  * 
  * @return Promise 
  */</span>
	<span class="s0">blob() {</span>
		<span class="s0">let ct = </span><span class="s3">this</span><span class="s0">.headers &amp;&amp; </span><span class="s3">this</span><span class="s0">.headers.get(</span><span class="s1">'content-type'</span><span class="s0">) || </span><span class="s1">''</span><span class="s0">;</span>
		<span class="s3">return </span><span class="s0">consumeBody.call(</span><span class="s3">this</span><span class="s0">).then(</span><span class="s3">function </span><span class="s0">(buf) {</span>
			<span class="s3">return </span><span class="s0">Object.assign(</span>
			<span class="s2">// Prevent copying</span>
			<span class="s3">new </span><span class="s0">Blob([], {</span>
				<span class="s0">type: ct.toLowerCase()</span>
			<span class="s0">}), {</span>
				<span class="s0">[BUFFER]: buf</span>
			<span class="s0">});</span>
		<span class="s0">});</span>
	<span class="s0">},</span>

	<span class="s2">/** 
  * Decode response as json 
  * 
  * @return  Promise 
  */</span>
	<span class="s0">json() {</span>
		<span class="s3">var </span><span class="s0">_this2 = </span><span class="s3">this</span><span class="s0">;</span>

		<span class="s3">return </span><span class="s0">consumeBody.call(</span><span class="s3">this</span><span class="s0">).then(</span><span class="s3">function </span><span class="s0">(buffer) {</span>
			<span class="s3">try </span><span class="s0">{</span>
				<span class="s3">return </span><span class="s0">JSON.parse(buffer.toString());</span>
			<span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
				<span class="s3">return </span><span class="s0">Body.Promise.reject(</span><span class="s3">new </span><span class="s0">FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, </span><span class="s1">'invalid-json'</span><span class="s0">));</span>
			<span class="s0">}</span>
		<span class="s0">});</span>
	<span class="s0">},</span>

	<span class="s2">/** 
  * Decode response as text 
  * 
  * @return  Promise 
  */</span>
	<span class="s0">text() {</span>
		<span class="s3">return </span><span class="s0">consumeBody.call(</span><span class="s3">this</span><span class="s0">).then(</span><span class="s3">function </span><span class="s0">(buffer) {</span>
			<span class="s3">return </span><span class="s0">buffer.toString();</span>
		<span class="s0">});</span>
	<span class="s0">},</span>

	<span class="s2">/** 
  * Decode response as buffer (non-spec api) 
  * 
  * @return  Promise 
  */</span>
	<span class="s0">buffer() {</span>
		<span class="s3">return </span><span class="s0">consumeBody.call(</span><span class="s3">this</span><span class="s0">);</span>
	<span class="s0">},</span>

	<span class="s2">/** 
  * Decode response as text, while automatically detecting the encoding and 
  * trying to decode to UTF-8 (non-spec api) 
  * 
  * @return  Promise 
  */</span>
	<span class="s0">textConverted() {</span>
		<span class="s3">var </span><span class="s0">_this3 = </span><span class="s3">this</span><span class="s0">;</span>

		<span class="s3">return </span><span class="s0">consumeBody.call(</span><span class="s3">this</span><span class="s0">).then(</span><span class="s3">function </span><span class="s0">(buffer) {</span>
			<span class="s3">return </span><span class="s0">convertBody(buffer, _this3.headers);</span>
		<span class="s0">});</span>
	<span class="s0">}</span>
<span class="s0">};</span>

<span class="s2">// In browsers, all properties are enumerable.</span>
<span class="s0">Object.defineProperties(Body.prototype, {</span>
	<span class="s0">body: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">bodyUsed: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">arrayBuffer: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">blob: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">json: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">text: { enumerable: </span><span class="s3">true </span><span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">Body.mixIn = </span><span class="s3">function </span><span class="s0">(proto) {</span>
	<span class="s3">for </span><span class="s0">(const name of Object.getOwnPropertyNames(Body.prototype)) {</span>
		<span class="s2">// istanbul ignore else: future proof</span>
		<span class="s3">if </span><span class="s0">(!(name </span><span class="s3">in </span><span class="s0">proto)) {</span>
			<span class="s0">const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);</span>
			<span class="s0">Object.defineProperty(proto, name, desc);</span>
		<span class="s0">}</span>
	<span class="s0">}</span>
<span class="s0">};</span>

<span class="s2">/** 
 * Consume and convert an entire Body to a Buffer. 
 * 
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body 
 * 
 * @return  Promise 
 */</span>
<span class="s3">function </span><span class="s0">consumeBody() {</span>
	<span class="s3">var </span><span class="s0">_this4 = </span><span class="s3">this</span><span class="s0">;</span>

	<span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">[INTERNALS].disturbed) {</span>
		<span class="s3">return </span><span class="s0">Body.Promise.reject(</span><span class="s3">new </span><span class="s0">TypeError(`body used already </span><span class="s3">for</span><span class="s0">: ${</span><span class="s3">this</span><span class="s0">.url}`));</span>
	<span class="s0">}</span>

	<span class="s3">this</span><span class="s0">[INTERNALS].disturbed = </span><span class="s3">true</span><span class="s0">;</span>

	<span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">[INTERNALS].error) {</span>
		<span class="s3">return </span><span class="s0">Body.Promise.reject(</span><span class="s3">this</span><span class="s0">[INTERNALS].error);</span>
	<span class="s0">}</span>

	<span class="s0">let body = </span><span class="s3">this</span><span class="s0">.body;</span>

	<span class="s2">// body is null</span>
	<span class="s3">if </span><span class="s0">(body === </span><span class="s3">null</span><span class="s0">) {</span>
		<span class="s3">return </span><span class="s0">Body.Promise.resolve(Buffer.alloc(</span><span class="s4">0</span><span class="s0">));</span>
	<span class="s0">}</span>

	<span class="s2">// body is blob</span>
	<span class="s3">if </span><span class="s0">(isBlob(body)) {</span>
		<span class="s0">body = body.stream();</span>
	<span class="s0">}</span>

	<span class="s2">// body is buffer</span>
	<span class="s3">if </span><span class="s0">(Buffer.isBuffer(body)) {</span>
		<span class="s3">return </span><span class="s0">Body.Promise.resolve(body);</span>
	<span class="s0">}</span>

	<span class="s2">// istanbul ignore if: should never happen</span>
	<span class="s3">if </span><span class="s0">(!(body </span><span class="s3">instanceof </span><span class="s0">Stream)) {</span>
		<span class="s3">return </span><span class="s0">Body.Promise.resolve(Buffer.alloc(</span><span class="s4">0</span><span class="s0">));</span>
	<span class="s0">}</span>

	<span class="s2">// body is stream</span>
	<span class="s2">// get ready to actually consume the body</span>
	<span class="s0">let accum = [];</span>
	<span class="s0">let accumBytes = </span><span class="s4">0</span><span class="s0">;</span>
	<span class="s0">let abort = </span><span class="s3">false</span><span class="s0">;</span>

	<span class="s3">return new </span><span class="s0">Body.Promise(</span><span class="s3">function </span><span class="s0">(resolve, reject) {</span>
		<span class="s0">let resTimeout;</span>

		<span class="s2">// allow timeout on slow response body</span>
		<span class="s3">if </span><span class="s0">(_this4.timeout) {</span>
			<span class="s0">resTimeout = setTimeout(</span><span class="s3">function </span><span class="s0">() {</span>
				<span class="s0">abort = </span><span class="s3">true</span><span class="s0">;</span>
				<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`Response timeout </span><span class="s3">while </span><span class="s0">trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, </span><span class="s1">'body-timeout'</span><span class="s0">));</span>
			<span class="s0">}, _this4.timeout);</span>
		<span class="s0">}</span>

		<span class="s2">// handle stream errors</span>
		<span class="s0">body.on(</span><span class="s1">'error'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(err) {</span>
			<span class="s3">if </span><span class="s0">(err.name === </span><span class="s1">'AbortError'</span><span class="s0">) {</span>
				<span class="s2">// if the request was aborted, reject with this Error</span>
				<span class="s0">abort = </span><span class="s3">true</span><span class="s0">;</span>
				<span class="s0">reject(err);</span>
			<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
				<span class="s2">// other errors, such as incorrect content-encoding</span>
				<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`Invalid response body </span><span class="s3">while </span><span class="s0">trying to fetch ${_this4.url}: ${err.message}`, </span><span class="s1">'system'</span><span class="s0">, err));</span>
			<span class="s0">}</span>
		<span class="s0">});</span>

		<span class="s0">body.on(</span><span class="s1">'data'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(chunk) {</span>
			<span class="s3">if </span><span class="s0">(abort || chunk === </span><span class="s3">null</span><span class="s0">) {</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s3">if </span><span class="s0">(_this4.size &amp;&amp; accumBytes + chunk.length &gt; _this4.size) {</span>
				<span class="s0">abort = </span><span class="s3">true</span><span class="s0">;</span>
				<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, </span><span class="s1">'max-size'</span><span class="s0">));</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s0">accumBytes += chunk.length;</span>
			<span class="s0">accum.push(chunk);</span>
		<span class="s0">});</span>

		<span class="s0">body.on(</span><span class="s1">'end'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">() {</span>
			<span class="s3">if </span><span class="s0">(abort) {</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s0">clearTimeout(resTimeout);</span>

			<span class="s3">try </span><span class="s0">{</span>
				<span class="s0">resolve(Buffer.concat(accum, accumBytes));</span>
			<span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
				<span class="s2">// handle streams that have accumulated too much data (issue #414)</span>
				<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`Could not create Buffer from response body </span><span class="s3">for </span><span class="s0">${_this4.url}: ${err.message}`, </span><span class="s1">'system'</span><span class="s0">, err));</span>
			<span class="s0">}</span>
		<span class="s0">});</span>
	<span class="s0">});</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Detect buffer encoding and convert to target encoding 
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding 
 * 
 * @param   Buffer  buffer    Incoming buffer 
 * @param   String  encoding  Target encoding 
 * @return  String 
 */</span>
<span class="s3">function </span><span class="s0">convertBody(buffer, headers) {</span>
	<span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">convert !== </span><span class="s1">'function'</span><span class="s0">) {</span>
		<span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'The package `encoding` must be installed to use the textConverted() function'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s0">const ct = headers.get(</span><span class="s1">'content-type'</span><span class="s0">);</span>
	<span class="s0">let charset = </span><span class="s1">'utf-8'</span><span class="s0">;</span>
	<span class="s0">let res, str;</span>

	<span class="s2">// header</span>
	<span class="s3">if </span><span class="s0">(ct) {</span>
		<span class="s0">res = /charset=([^;]*)/i.exec(ct);</span>
	<span class="s0">}</span>

	<span class="s2">// no charset in content type, peek at response body for at most 1024 bytes</span>
	<span class="s0">str = buffer.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1024</span><span class="s0">).toString();</span>

	<span class="s2">// html5</span>
	<span class="s3">if </span><span class="s0">(!res &amp;&amp; str) {</span>
		<span class="s0">res = /&lt;meta.+?charset=([</span><span class="s1">'&quot;])(.+?)</span><span class="s5">\1</span><span class="s1">/i.exec(str);</span>
	<span class="s0">}</span>

	<span class="s2">// html4</span>
	<span class="s3">if </span><span class="s0">(!res &amp;&amp; str) {</span>
		<span class="s0">res = /&lt;meta[\s]+?http-equiv=([</span><span class="s1">'&quot;])content-type</span><span class="s5">\1</span><span class="s1">[</span><span class="s6">\s</span><span class="s1">]+?content=(['&quot;])(.+?)</span><span class="s5">\2</span><span class="s1">/i.exec(str);</span>
		<span class="s3">if </span><span class="s0">(!res) {</span>
			<span class="s0">res = /&lt;meta[\s]+?content=([</span><span class="s1">'&quot;])(.+?)</span><span class="s5">\1</span><span class="s1">[</span><span class="s6">\s</span><span class="s1">]+?http-equiv=(['&quot;])content-type</span><span class="s5">\3</span><span class="s1">/i.exec(str);</span>
			<span class="s3">if </span><span class="s0">(res) {</span>
				<span class="s0">res.pop(); </span><span class="s2">// drop last quote</span>
			<span class="s0">}</span>
		<span class="s0">}</span>

		<span class="s3">if </span><span class="s0">(res) {</span>
			<span class="s0">res = /charset=(.*)/i.exec(res.pop());</span>
		<span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s2">// xml</span>
	<span class="s3">if </span><span class="s0">(!res &amp;&amp; str) {</span>
		<span class="s0">res = /&lt;\?xml.+?encoding=([</span><span class="s1">'&quot;])(.+?)</span><span class="s5">\1</span><span class="s1">/i.exec(str);</span>
	<span class="s0">}</span>

	<span class="s2">// found charset</span>
	<span class="s3">if </span><span class="s0">(res) {</span>
		<span class="s0">charset = res.pop();</span>

		<span class="s2">// prevent decode issues when sites use incorrect encoding</span>
		<span class="s2">// ref: https://hsivonen.fi/encoding-menu/</span>
		<span class="s3">if </span><span class="s0">(charset === </span><span class="s1">'gb2312' </span><span class="s0">|| charset === </span><span class="s1">'gbk'</span><span class="s0">) {</span>
			<span class="s0">charset = </span><span class="s1">'gb18030'</span><span class="s0">;</span>
		<span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s2">// turn raw buffers into a single utf-8 buffer</span>
	<span class="s3">return </span><span class="s0">convert(buffer, </span><span class="s1">'UTF-8'</span><span class="s0">, charset).toString();</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Detect a URLSearchParams object 
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143 
 * 
 * @param   Object  obj     Object to detect by type or brand 
 * @return  String 
 */</span>
<span class="s3">function </span><span class="s0">isURLSearchParams(obj) {</span>
	<span class="s2">// Duck-typing as a necessary condition.</span>
	<span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">obj !== </span><span class="s1">'object' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">obj.append !== </span><span class="s1">'function' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">obj.</span><span class="s3">delete </span><span class="s0">!== </span><span class="s1">'function' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">obj.get !== </span><span class="s1">'function' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">obj.getAll !== </span><span class="s1">'function' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">obj.has !== </span><span class="s1">'function' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">obj.set !== </span><span class="s1">'function'</span><span class="s0">) {</span>
		<span class="s3">return false</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s2">// Brand-checking and more duck-typing as optional condition.</span>
	<span class="s3">return </span><span class="s0">obj.constructor.name === </span><span class="s1">'URLSearchParams' </span><span class="s0">|| Object.prototype.toString.call(obj) === </span><span class="s1">'[object URLSearchParams]' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">obj.sort === </span><span class="s1">'function'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from) 
 * @param  {*} obj 
 * @return {boolean} 
 */</span>
<span class="s3">function </span><span class="s0">isBlob(obj) {</span>
	<span class="s3">return typeof </span><span class="s0">obj === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; </span><span class="s3">typeof </span><span class="s0">obj.arrayBuffer === </span><span class="s1">'function' </span><span class="s0">&amp;&amp; </span><span class="s3">typeof </span><span class="s0">obj.type === </span><span class="s1">'string' </span><span class="s0">&amp;&amp; </span><span class="s3">typeof </span><span class="s0">obj.stream === </span><span class="s1">'function' </span><span class="s0">&amp;&amp; </span><span class="s3">typeof </span><span class="s0">obj.constructor === </span><span class="s1">'function' </span><span class="s0">&amp;&amp; </span><span class="s3">typeof </span><span class="s0">obj.constructor.name === </span><span class="s1">'string' </span><span class="s0">&amp;&amp; /^(Blob|File)$/.test(obj.constructor.name) &amp;&amp; /^(Blob|File)$/.test(obj[Symbol.toStringTag]);</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Clone body given Res/Req instance 
 * 
 * @param   Mixed  instance  Response or Request instance 
 * @return  Mixed 
 */</span>
<span class="s3">function </span><span class="s0">clone(instance) {</span>
	<span class="s0">let p1, p2;</span>
	<span class="s0">let body = instance.body;</span>

	<span class="s2">// don't allow cloning a used body</span>
	<span class="s3">if </span><span class="s0">(instance.bodyUsed) {</span>
		<span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'cannot clone body after it is used'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">// check that body is a stream and not form-data object</span>
	<span class="s2">// note: we can't clone the form-data object without having it as a dependency</span>
	<span class="s3">if </span><span class="s0">(body </span><span class="s3">instanceof </span><span class="s0">Stream &amp;&amp; </span><span class="s3">typeof </span><span class="s0">body.getBoundary !== </span><span class="s1">'function'</span><span class="s0">) {</span>
		<span class="s2">// tee instance body</span>
		<span class="s0">p1 = </span><span class="s3">new </span><span class="s0">PassThrough();</span>
		<span class="s0">p2 = </span><span class="s3">new </span><span class="s0">PassThrough();</span>
		<span class="s0">body.pipe(p1);</span>
		<span class="s0">body.pipe(p2);</span>
		<span class="s2">// set instance body to teed body and return the other teed body</span>
		<span class="s0">instance[INTERNALS].body = p1;</span>
		<span class="s0">body = p2;</span>
	<span class="s0">}</span>

	<span class="s3">return </span><span class="s0">body;</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Performs the operation &quot;extract a `Content-Type` value from |object|&quot; as 
 * specified in the specification: 
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract 
 * 
 * This function assumes that instance.body is present. 
 * 
 * @param   Mixed  instance  Any options.body input 
 */</span>
<span class="s3">function </span><span class="s0">extractContentType(body) {</span>
	<span class="s3">if </span><span class="s0">(body === </span><span class="s3">null</span><span class="s0">) {</span>
		<span class="s2">// body is null</span>
		<span class="s3">return null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">body === </span><span class="s1">'string'</span><span class="s0">) {</span>
		<span class="s2">// body is string</span>
		<span class="s3">return </span><span class="s1">'text/plain;charset=UTF-8'</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(isURLSearchParams(body)) {</span>
		<span class="s2">// body is a URLSearchParams</span>
		<span class="s3">return </span><span class="s1">'application/x-www-form-urlencoded;charset=UTF-8'</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(isBlob(body)) {</span>
		<span class="s2">// body is blob</span>
		<span class="s3">return </span><span class="s0">body.type || </span><span class="s3">null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(Buffer.isBuffer(body)) {</span>
		<span class="s2">// body is buffer</span>
		<span class="s3">return null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(Object.prototype.toString.call(body) === </span><span class="s1">'[object ArrayBuffer]'</span><span class="s0">) {</span>
		<span class="s2">// body is ArrayBuffer</span>
		<span class="s3">return null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(ArrayBuffer.isView(body)) {</span>
		<span class="s2">// body is ArrayBufferView</span>
		<span class="s3">return null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">body.getBoundary === </span><span class="s1">'function'</span><span class="s0">) {</span>
		<span class="s2">// detect form data input from form-data module</span>
		<span class="s3">return </span><span class="s0">`multipart/form-data;boundary=${body.getBoundary()}`;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(body </span><span class="s3">instanceof </span><span class="s0">Stream) {</span>
		<span class="s2">// body is stream</span>
		<span class="s2">// can't really do much about this</span>
		<span class="s3">return null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
		<span class="s2">// Body constructor defaults other things to string</span>
		<span class="s3">return </span><span class="s1">'text/plain;charset=UTF-8'</span><span class="s0">;</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">/** 
 * The Fetch Standard treats this as if &quot;total bytes&quot; is a property on the body. 
 * For us, we have to explicitly get it with a function. 
 * 
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes 
 * 
 * @param   Body    instance   Instance of Body 
 * @return  Number?            Number of bytes, or null if not possible 
 */</span>
<span class="s3">function </span><span class="s0">getTotalBytes(instance) {</span>
	<span class="s0">const body = instance.body;</span>


	<span class="s3">if </span><span class="s0">(body === </span><span class="s3">null</span><span class="s0">) {</span>
		<span class="s2">// body is null</span>
		<span class="s3">return </span><span class="s4">0</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(isBlob(body)) {</span>
		<span class="s3">return </span><span class="s0">body.size;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(Buffer.isBuffer(body)) {</span>
		<span class="s2">// body is buffer</span>
		<span class="s3">return </span><span class="s0">body.length;</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(body &amp;&amp; </span><span class="s3">typeof </span><span class="s0">body.getLengthSync === </span><span class="s1">'function'</span><span class="s0">) {</span>
		<span class="s2">// detect form data input from form-data module</span>
		<span class="s3">if </span><span class="s0">(body._lengthRetrievers &amp;&amp; body._lengthRetrievers.length == </span><span class="s4">0 </span><span class="s0">|| </span><span class="s2">// 1.x</span>
		<span class="s0">body.hasKnownLength &amp;&amp; body.hasKnownLength()) {</span>
			<span class="s2">// 2.x</span>
			<span class="s3">return </span><span class="s0">body.getLengthSync();</span>
		<span class="s0">}</span>
		<span class="s3">return null</span><span class="s0">;</span>
	<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
		<span class="s2">// body is stream</span>
		<span class="s3">return null</span><span class="s0">;</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object. 
 * 
 * @param   Body    instance   Instance of Body 
 * @return  Void 
 */</span>
<span class="s3">function </span><span class="s0">writeToStream(dest, instance) {</span>
	<span class="s0">const body = instance.body;</span>


	<span class="s3">if </span><span class="s0">(body === </span><span class="s3">null</span><span class="s0">) {</span>
		<span class="s2">// body is null</span>
		<span class="s0">dest.end();</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(isBlob(body)) {</span>
		<span class="s0">body.stream().pipe(dest);</span>
	<span class="s0">} </span><span class="s3">else if </span><span class="s0">(Buffer.isBuffer(body)) {</span>
		<span class="s2">// body is buffer</span>
		<span class="s0">dest.write(body);</span>
		<span class="s0">dest.end();</span>
	<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
		<span class="s2">// body is stream</span>
		<span class="s0">body.pipe(dest);</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">// expose Promise</span>
<span class="s0">Body.Promise = global.Promise;</span>

<span class="s2">/** 
 * headers.js 
 * 
 * Headers class offers convenient helpers 
 */</span>

<span class="s0">const invalidTokenRegex = /[^\^_`a-zA-Z\-</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">!#$%&amp;</span><span class="s1">'*+.|~]/;</span>
<span class="s0">const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;</span>

<span class="s3">function </span><span class="s0">validateName(name) {</span>
	<span class="s0">name = `${name}`;</span>
	<span class="s3">if </span><span class="s0">(invalidTokenRegex.test(name) || name === </span><span class="s1">''</span><span class="s0">) {</span>
		<span class="s3">throw new </span><span class="s0">TypeError(`${name} is not a legal HTTP header name`);</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">function </span><span class="s0">validateValue(value) {</span>
	<span class="s0">value = `${value}`;</span>
	<span class="s3">if </span><span class="s0">(invalidHeaderCharRegex.test(value)) {</span>
		<span class="s3">throw new </span><span class="s0">TypeError(`${value} is not a legal HTTP header value`);</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Find the key in the map object given a header name. 
 * 
 * Returns undefined if not found. 
 * 
 * @param   String  name  Header name 
 * @return  String|Undefined 
 */</span>
<span class="s3">function </span><span class="s0">find(map, name) {</span>
	<span class="s0">name = name.toLowerCase();</span>
	<span class="s3">for </span><span class="s0">(const key </span><span class="s3">in </span><span class="s0">map) {</span>
		<span class="s3">if </span><span class="s0">(key.toLowerCase() === name) {</span>
			<span class="s3">return </span><span class="s0">key;</span>
		<span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s3">return </span><span class="s0">undefined;</span>
<span class="s0">}</span>

<span class="s0">const MAP = Symbol(</span><span class="s1">'map'</span><span class="s0">);</span>
<span class="s0">class Headers {</span>
	<span class="s2">/** 
  * Headers class 
  * 
  * @param   Object  headers  Response headers 
  * @return  Void 
  */</span>
	<span class="s0">constructor() {</span>
		<span class="s0">let init = arguments.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">0</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">0</span><span class="s0">] : undefined;</span>

		<span class="s3">this</span><span class="s0">[MAP] = Object.create(</span><span class="s3">null</span><span class="s0">);</span>

		<span class="s3">if </span><span class="s0">(init </span><span class="s3">instanceof </span><span class="s0">Headers) {</span>
			<span class="s0">const rawHeaders = init.raw();</span>
			<span class="s0">const headerNames = Object.keys(rawHeaders);</span>

			<span class="s3">for </span><span class="s0">(const headerName of headerNames) {</span>
				<span class="s3">for </span><span class="s0">(const value of rawHeaders[headerName]) {</span>
					<span class="s3">this</span><span class="s0">.append(headerName, value);</span>
				<span class="s0">}</span>
			<span class="s0">}</span>

			<span class="s3">return</span><span class="s0">;</span>
		<span class="s0">}</span>

		<span class="s2">// We don't worry about converting prop to ByteString here as append()</span>
		<span class="s2">// will handle it.</span>
		<span class="s3">if </span><span class="s0">(init == </span><span class="s3">null</span><span class="s0">) ; </span><span class="s3">else if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">init === </span><span class="s1">'object'</span><span class="s0">) {</span>
			<span class="s0">const method = init[Symbol.iterator];</span>
			<span class="s3">if </span><span class="s0">(method != </span><span class="s3">null</span><span class="s0">) {</span>
				<span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">method !== </span><span class="s1">'function'</span><span class="s0">) {</span>
					<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Header pairs must be iterable'</span><span class="s0">);</span>
				<span class="s0">}</span>

				<span class="s2">// sequence&lt;sequence&lt;ByteString&gt;&gt;</span>
				<span class="s2">// Note: per spec we have to first exhaust the lists then process them</span>
				<span class="s0">const pairs = [];</span>
				<span class="s3">for </span><span class="s0">(const pair of init) {</span>
					<span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">pair !== </span><span class="s1">'object' </span><span class="s0">|| </span><span class="s3">typeof </span><span class="s0">pair[Symbol.iterator] !== </span><span class="s1">'function'</span><span class="s0">) {</span>
						<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Each header pair must be iterable'</span><span class="s0">);</span>
					<span class="s0">}</span>
					<span class="s0">pairs.push(Array.from(pair));</span>
				<span class="s0">}</span>

				<span class="s3">for </span><span class="s0">(const pair of pairs) {</span>
					<span class="s3">if </span><span class="s0">(pair.length !== </span><span class="s4">2</span><span class="s0">) {</span>
						<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Each header pair must be a name/value tuple'</span><span class="s0">);</span>
					<span class="s0">}</span>
					<span class="s3">this</span><span class="s0">.append(pair[</span><span class="s4">0</span><span class="s0">], pair[</span><span class="s4">1</span><span class="s0">]);</span>
				<span class="s0">}</span>
			<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
				<span class="s2">// record&lt;ByteString, ByteString&gt;</span>
				<span class="s3">for </span><span class="s0">(const key of Object.keys(init)) {</span>
					<span class="s0">const value = init[key];</span>
					<span class="s3">this</span><span class="s0">.append(key, value);</span>
				<span class="s0">}</span>
			<span class="s0">}</span>
		<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
			<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Provided initializer must be an object'</span><span class="s0">);</span>
		<span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Return combined header value given name 
  * 
  * @param   String  name  Header name 
  * @return  Mixed 
  */</span>
	<span class="s0">get(name) {</span>
		<span class="s0">name = `${name}`;</span>
		<span class="s0">validateName(name);</span>
		<span class="s0">const key = find(</span><span class="s3">this</span><span class="s0">[MAP], name);</span>
		<span class="s3">if </span><span class="s0">(key === undefined) {</span>
			<span class="s3">return null</span><span class="s0">;</span>
		<span class="s0">}</span>

		<span class="s3">return this</span><span class="s0">[MAP][key].join(</span><span class="s1">', '</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Iterate over all headers 
  * 
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg) 
  * @param   Boolean   thisArg   `this` context for callback function 
  * @return  Void 
  */</span>
	<span class="s0">forEach(callback) {</span>
		<span class="s0">let thisArg = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : undefined;</span>

		<span class="s0">let pairs = getHeaders(</span><span class="s3">this</span><span class="s0">);</span>
		<span class="s0">let i = </span><span class="s4">0</span><span class="s0">;</span>
		<span class="s3">while </span><span class="s0">(i &lt; pairs.length) {</span>
			<span class="s3">var </span><span class="s0">_pairs$i = pairs[i];</span>
			<span class="s0">const name = _pairs$i[</span><span class="s4">0</span><span class="s0">],</span>
			      <span class="s0">value = _pairs$i[</span><span class="s4">1</span><span class="s0">];</span>

			<span class="s0">callback.call(thisArg, value, name, </span><span class="s3">this</span><span class="s0">);</span>
			<span class="s0">pairs = getHeaders(</span><span class="s3">this</span><span class="s0">);</span>
			<span class="s0">i++;</span>
		<span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Overwrite header values given name 
  * 
  * @param   String  name   Header name 
  * @param   String  value  Header value 
  * @return  Void 
  */</span>
	<span class="s0">set(name, value) {</span>
		<span class="s0">name = `${name}`;</span>
		<span class="s0">value = `${value}`;</span>
		<span class="s0">validateName(name);</span>
		<span class="s0">validateValue(value);</span>
		<span class="s0">const key = find(</span><span class="s3">this</span><span class="s0">[MAP], name);</span>
		<span class="s3">this</span><span class="s0">[MAP][key !== undefined ? key : name] = [value];</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Append a value onto existing header 
  * 
  * @param   String  name   Header name 
  * @param   String  value  Header value 
  * @return  Void 
  */</span>
	<span class="s0">append(name, value) {</span>
		<span class="s0">name = `${name}`;</span>
		<span class="s0">value = `${value}`;</span>
		<span class="s0">validateName(name);</span>
		<span class="s0">validateValue(value);</span>
		<span class="s0">const key = find(</span><span class="s3">this</span><span class="s0">[MAP], name);</span>
		<span class="s3">if </span><span class="s0">(key !== undefined) {</span>
			<span class="s3">this</span><span class="s0">[MAP][key].push(value);</span>
		<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
			<span class="s3">this</span><span class="s0">[MAP][name] = [value];</span>
		<span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Check for header name existence 
  * 
  * @param   String   name  Header name 
  * @return  Boolean 
  */</span>
	<span class="s0">has(name) {</span>
		<span class="s0">name = `${name}`;</span>
		<span class="s0">validateName(name);</span>
		<span class="s3">return </span><span class="s0">find(</span><span class="s3">this</span><span class="s0">[MAP], name) !== undefined;</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Delete all header values given name 
  * 
  * @param   String  name  Header name 
  * @return  Void 
  */</span>
	<span class="s3">delete</span><span class="s0">(name) {</span>
		<span class="s0">name = `${name}`;</span>
		<span class="s0">validateName(name);</span>
		<span class="s0">const key = find(</span><span class="s3">this</span><span class="s0">[MAP], name);</span>
		<span class="s3">if </span><span class="s0">(key !== undefined) {</span>
			<span class="s3">delete this</span><span class="s0">[MAP][key];</span>
		<span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Return raw headers (non-spec api) 
  * 
  * @return  Object 
  */</span>
	<span class="s0">raw() {</span>
		<span class="s3">return this</span><span class="s0">[MAP];</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Get an iterator on keys. 
  * 
  * @return  Iterator 
  */</span>
	<span class="s0">keys() {</span>
		<span class="s3">return </span><span class="s0">createHeadersIterator(</span><span class="s3">this</span><span class="s0">, </span><span class="s1">'key'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Get an iterator on values. 
  * 
  * @return  Iterator 
  */</span>
	<span class="s0">values() {</span>
		<span class="s3">return </span><span class="s0">createHeadersIterator(</span><span class="s3">this</span><span class="s0">, </span><span class="s1">'value'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Get an iterator on entries. 
  * 
  * This is the default iterator of the Headers object. 
  * 
  * @return  Iterator 
  */</span>
	<span class="s0">[Symbol.iterator]() {</span>
		<span class="s3">return </span><span class="s0">createHeadersIterator(</span><span class="s3">this</span><span class="s0">, </span><span class="s1">'key+value'</span><span class="s0">);</span>
	<span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">Headers.prototype.entries = Headers.prototype[Symbol.iterator];</span>

<span class="s0">Object.defineProperty(Headers.prototype, Symbol.toStringTag, {</span>
	<span class="s0">value: </span><span class="s1">'Headers'</span><span class="s0">,</span>
	<span class="s0">writable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">enumerable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">configurable: </span><span class="s3">true</span>
<span class="s0">});</span>

<span class="s0">Object.defineProperties(Headers.prototype, {</span>
	<span class="s0">get: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">forEach: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">set: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">append: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">has: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s3">delete</span><span class="s0">: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">keys: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">values: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">entries: { enumerable: </span><span class="s3">true </span><span class="s0">}</span>
<span class="s0">});</span>

<span class="s3">function </span><span class="s0">getHeaders(headers) {</span>
	<span class="s0">let kind = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : </span><span class="s1">'key+value'</span><span class="s0">;</span>

	<span class="s0">const keys = Object.keys(headers[MAP]).sort();</span>
	<span class="s3">return </span><span class="s0">keys.map(kind === </span><span class="s1">'key' </span><span class="s0">? </span><span class="s3">function </span><span class="s0">(k) {</span>
		<span class="s3">return </span><span class="s0">k.toLowerCase();</span>
	<span class="s0">} : kind === </span><span class="s1">'value' </span><span class="s0">? </span><span class="s3">function </span><span class="s0">(k) {</span>
		<span class="s3">return </span><span class="s0">headers[MAP][k].join(</span><span class="s1">', '</span><span class="s0">);</span>
	<span class="s0">} : </span><span class="s3">function </span><span class="s0">(k) {</span>
		<span class="s3">return </span><span class="s0">[k.toLowerCase(), headers[MAP][k].join(</span><span class="s1">', '</span><span class="s0">)];</span>
	<span class="s0">});</span>
<span class="s0">}</span>

<span class="s0">const INTERNAL = Symbol(</span><span class="s1">'internal'</span><span class="s0">);</span>

<span class="s3">function </span><span class="s0">createHeadersIterator(target, kind) {</span>
	<span class="s0">const iterator = Object.create(HeadersIteratorPrototype);</span>
	<span class="s0">iterator[INTERNAL] = {</span>
		<span class="s0">target,</span>
		<span class="s0">kind,</span>
		<span class="s0">index: </span><span class="s4">0</span>
	<span class="s0">};</span>
	<span class="s3">return </span><span class="s0">iterator;</span>
<span class="s0">}</span>

<span class="s0">const HeadersIteratorPrototype = Object.setPrototypeOf({</span>
	<span class="s0">next() {</span>
		<span class="s2">// istanbul ignore if</span>
		<span class="s3">if </span><span class="s0">(!</span><span class="s3">this </span><span class="s0">|| Object.getPrototypeOf(</span><span class="s3">this</span><span class="s0">) !== HeadersIteratorPrototype) {</span>
			<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Value of `this` is not a HeadersIterator'</span><span class="s0">);</span>
		<span class="s0">}</span>

		<span class="s3">var </span><span class="s0">_INTERNAL = </span><span class="s3">this</span><span class="s0">[INTERNAL];</span>
		<span class="s0">const target = _INTERNAL.target,</span>
		      <span class="s0">kind = _INTERNAL.kind,</span>
		      <span class="s0">index = _INTERNAL.index;</span>

		<span class="s0">const values = getHeaders(target, kind);</span>
		<span class="s0">const len = values.length;</span>
		<span class="s3">if </span><span class="s0">(index &gt;= len) {</span>
			<span class="s3">return </span><span class="s0">{</span>
				<span class="s0">value: undefined,</span>
				<span class="s0">done: </span><span class="s3">true</span>
			<span class="s0">};</span>
		<span class="s0">}</span>

		<span class="s3">this</span><span class="s0">[INTERNAL].index = index + </span><span class="s4">1</span><span class="s0">;</span>

		<span class="s3">return </span><span class="s0">{</span>
			<span class="s0">value: values[index],</span>
			<span class="s0">done: </span><span class="s3">false</span>
		<span class="s0">};</span>
	<span class="s0">}</span>
<span class="s0">}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));</span>

<span class="s0">Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {</span>
	<span class="s0">value: </span><span class="s1">'HeadersIterator'</span><span class="s0">,</span>
	<span class="s0">writable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">enumerable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">configurable: </span><span class="s3">true</span>
<span class="s0">});</span>

<span class="s2">/** 
 * Export the Headers object in a form that Node.js can consume. 
 * 
 * @param   Headers  headers 
 * @return  Object 
 */</span>
<span class="s3">function </span><span class="s0">exportNodeCompatibleHeaders(headers) {</span>
	<span class="s0">const obj = Object.assign({ __proto__: </span><span class="s3">null </span><span class="s0">}, headers[MAP]);</span>

	<span class="s2">// http.request() only supports string as Host header. This hack makes</span>
	<span class="s2">// specifying custom Host header possible.</span>
	<span class="s0">const hostHeaderKey = find(headers[MAP], </span><span class="s1">'Host'</span><span class="s0">);</span>
	<span class="s3">if </span><span class="s0">(hostHeaderKey !== undefined) {</span>
		<span class="s0">obj[hostHeaderKey] = obj[hostHeaderKey][</span><span class="s4">0</span><span class="s0">];</span>
	<span class="s0">}</span>

	<span class="s3">return </span><span class="s0">obj;</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Create a Headers object from an object of headers, ignoring those that do 
 * not conform to HTTP grammar productions. 
 * 
 * @param   Object  obj  Object of headers 
 * @return  Headers 
 */</span>
<span class="s3">function </span><span class="s0">createHeadersLenient(obj) {</span>
	<span class="s0">const headers = </span><span class="s3">new </span><span class="s0">Headers();</span>
	<span class="s3">for </span><span class="s0">(const name of Object.keys(obj)) {</span>
		<span class="s3">if </span><span class="s0">(invalidTokenRegex.test(name)) {</span>
			<span class="s3">continue</span><span class="s0">;</span>
		<span class="s0">}</span>
		<span class="s3">if </span><span class="s0">(Array.isArray(obj[name])) {</span>
			<span class="s3">for </span><span class="s0">(const val of obj[name]) {</span>
				<span class="s3">if </span><span class="s0">(invalidHeaderCharRegex.test(val)) {</span>
					<span class="s3">continue</span><span class="s0">;</span>
				<span class="s0">}</span>
				<span class="s3">if </span><span class="s0">(headers[MAP][name] === undefined) {</span>
					<span class="s0">headers[MAP][name] = [val];</span>
				<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
					<span class="s0">headers[MAP][name].push(val);</span>
				<span class="s0">}</span>
			<span class="s0">}</span>
		<span class="s0">} </span><span class="s3">else if </span><span class="s0">(!invalidHeaderCharRegex.test(obj[name])) {</span>
			<span class="s0">headers[MAP][name] = [obj[name]];</span>
		<span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s3">return </span><span class="s0">headers;</span>
<span class="s0">}</span>

<span class="s0">const INTERNALS$1 = Symbol(</span><span class="s1">'Response internals'</span><span class="s0">);</span>

<span class="s2">// fix an issue where &quot;STATUS_CODES&quot; aren't a named export for node &lt;10</span>
<span class="s0">const STATUS_CODES = http.STATUS_CODES;</span>

<span class="s2">/** 
 * Response class 
 * 
 * @param   Stream  body  Readable stream 
 * @param   Object  opts  Response options 
 * @return  Void 
 */</span>
<span class="s0">class Response {</span>
	<span class="s0">constructor() {</span>
		<span class="s0">let body = arguments.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">0</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">0</span><span class="s0">] : </span><span class="s3">null</span><span class="s0">;</span>
		<span class="s0">let opts = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : {};</span>

		<span class="s0">Body.call(</span><span class="s3">this</span><span class="s0">, body, opts);</span>

		<span class="s0">const status = opts.status || </span><span class="s4">200</span><span class="s0">;</span>
		<span class="s0">const headers = </span><span class="s3">new </span><span class="s0">Headers(opts.headers);</span>

		<span class="s3">if </span><span class="s0">(body != </span><span class="s3">null </span><span class="s0">&amp;&amp; !headers.has(</span><span class="s1">'Content-Type'</span><span class="s0">)) {</span>
			<span class="s0">const contentType = extractContentType(body);</span>
			<span class="s3">if </span><span class="s0">(contentType) {</span>
				<span class="s0">headers.append(</span><span class="s1">'Content-Type'</span><span class="s0">, contentType);</span>
			<span class="s0">}</span>
		<span class="s0">}</span>

		<span class="s3">this</span><span class="s0">[INTERNALS$1] = {</span>
			<span class="s0">url: opts.url,</span>
			<span class="s0">status,</span>
			<span class="s0">statusText: opts.statusText || STATUS_CODES[status],</span>
			<span class="s0">headers,</span>
			<span class="s0">counter: opts.counter</span>
		<span class="s0">};</span>
	<span class="s0">}</span>

	<span class="s0">get url() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$1].url || </span><span class="s1">''</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s0">get status() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$1].status;</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Convenience property representing if the request ended normally 
  */</span>
	<span class="s0">get ok() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$1].status &gt;= </span><span class="s4">200 </span><span class="s0">&amp;&amp; </span><span class="s3">this</span><span class="s0">[INTERNALS$1].status &lt; </span><span class="s4">300</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s0">get redirected() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$1].counter &gt; </span><span class="s4">0</span><span class="s0">;</span>
	<span class="s0">}</span>

	<span class="s0">get statusText() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$1].statusText;</span>
	<span class="s0">}</span>

	<span class="s0">get headers() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$1].headers;</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Clone this response 
  * 
  * @return  Response 
  */</span>
	<span class="s0">clone() {</span>
		<span class="s3">return new </span><span class="s0">Response(clone(</span><span class="s3">this</span><span class="s0">), {</span>
			<span class="s0">url: </span><span class="s3">this</span><span class="s0">.url,</span>
			<span class="s0">status: </span><span class="s3">this</span><span class="s0">.status,</span>
			<span class="s0">statusText: </span><span class="s3">this</span><span class="s0">.statusText,</span>
			<span class="s0">headers: </span><span class="s3">this</span><span class="s0">.headers,</span>
			<span class="s0">ok: </span><span class="s3">this</span><span class="s0">.ok,</span>
			<span class="s0">redirected: </span><span class="s3">this</span><span class="s0">.redirected</span>
		<span class="s0">});</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">Body.mixIn(Response.prototype);</span>

<span class="s0">Object.defineProperties(Response.prototype, {</span>
	<span class="s0">url: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">status: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">ok: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">redirected: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">statusText: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">headers: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">clone: { enumerable: </span><span class="s3">true </span><span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">Object.defineProperty(Response.prototype, Symbol.toStringTag, {</span>
	<span class="s0">value: </span><span class="s1">'Response'</span><span class="s0">,</span>
	<span class="s0">writable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">enumerable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">configurable: </span><span class="s3">true</span>
<span class="s0">});</span>

<span class="s0">const INTERNALS$2 = Symbol(</span><span class="s1">'Request internals'</span><span class="s0">);</span>
<span class="s0">const URL = Url.URL || whatwgUrl.URL;</span>

<span class="s2">// fix an issue where &quot;format&quot;, &quot;parse&quot; aren't a named export for node &lt;10</span>
<span class="s0">const parse_url = Url.parse;</span>
<span class="s0">const format_url = Url.format;</span>

<span class="s2">/** 
 * Wrapper around `new URL` to handle arbitrary URLs 
 * 
 * @param  {string} urlStr 
 * @return {void} 
 */</span>
<span class="s3">function </span><span class="s0">parseURL(urlStr) {</span>
	<span class="s2">/* 
    Check whether the URL is absolute or not 
        Scheme: https://tools.ietf.org/html/rfc3986#section-3.1 
    Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3 
 */</span>
	<span class="s3">if </span><span class="s0">(/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {</span>
		<span class="s0">urlStr = </span><span class="s3">new </span><span class="s0">URL(urlStr).toString();</span>
	<span class="s0">}</span>

	<span class="s2">// Fallback to old implementation for arbitrary URLs</span>
	<span class="s3">return </span><span class="s0">parse_url(urlStr);</span>
<span class="s0">}</span>

<span class="s0">const streamDestructionSupported = </span><span class="s1">'destroy' </span><span class="s3">in </span><span class="s0">Stream.Readable.prototype;</span>

<span class="s2">/** 
 * Check if a value is an instance of Request. 
 * 
 * @param   Mixed   input 
 * @return  Boolean 
 */</span>
<span class="s3">function </span><span class="s0">isRequest(input) {</span>
	<span class="s3">return typeof </span><span class="s0">input === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; </span><span class="s3">typeof </span><span class="s0">input[INTERNALS$2] === </span><span class="s1">'object'</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">function </span><span class="s0">isAbortSignal(signal) {</span>
	<span class="s0">const proto = signal &amp;&amp; </span><span class="s3">typeof </span><span class="s0">signal === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; Object.getPrototypeOf(signal);</span>
	<span class="s3">return </span><span class="s0">!!(proto &amp;&amp; proto.constructor.name === </span><span class="s1">'AbortSignal'</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Request class 
 * 
 * @param   Mixed   input  Url or Request instance 
 * @param   Object  init   Custom options 
 * @return  Void 
 */</span>
<span class="s0">class Request {</span>
	<span class="s0">constructor(input) {</span>
		<span class="s0">let init = arguments.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s0">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s0">] : {};</span>

		<span class="s0">let parsedURL;</span>

		<span class="s2">// normalize input</span>
		<span class="s3">if </span><span class="s0">(!isRequest(input)) {</span>
			<span class="s3">if </span><span class="s0">(input &amp;&amp; input.href) {</span>
				<span class="s2">// in order to support Node.js' Url objects; though WHATWG's URL objects</span>
				<span class="s2">// will fall into this branch also (since their `toString()` will return</span>
				<span class="s2">// `href` property anyway)</span>
				<span class="s0">parsedURL = parseURL(input.href);</span>
			<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
				<span class="s2">// coerce input to a string before attempting to parse</span>
				<span class="s0">parsedURL = parseURL(`${input}`);</span>
			<span class="s0">}</span>
			<span class="s0">input = {};</span>
		<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
			<span class="s0">parsedURL = parseURL(input.url);</span>
		<span class="s0">}</span>

		<span class="s0">let method = init.method || input.method || </span><span class="s1">'GET'</span><span class="s0">;</span>
		<span class="s0">method = method.toUpperCase();</span>

		<span class="s3">if </span><span class="s0">((init.body != </span><span class="s3">null </span><span class="s0">|| isRequest(input) &amp;&amp; input.body !== </span><span class="s3">null</span><span class="s0">) &amp;&amp; (method === </span><span class="s1">'GET' </span><span class="s0">|| method === </span><span class="s1">'HEAD'</span><span class="s0">)) {</span>
			<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Request with GET/HEAD method cannot have body'</span><span class="s0">);</span>
		<span class="s0">}</span>

		<span class="s0">let inputBody = init.body != </span><span class="s3">null </span><span class="s0">? init.body : isRequest(input) &amp;&amp; input.body !== </span><span class="s3">null </span><span class="s0">? clone(input) : </span><span class="s3">null</span><span class="s0">;</span>

		<span class="s0">Body.call(</span><span class="s3">this</span><span class="s0">, inputBody, {</span>
			<span class="s0">timeout: init.timeout || input.timeout || </span><span class="s4">0</span><span class="s0">,</span>
			<span class="s0">size: init.size || input.size || </span><span class="s4">0</span>
		<span class="s0">});</span>

		<span class="s0">const headers = </span><span class="s3">new </span><span class="s0">Headers(init.headers || input.headers || {});</span>

		<span class="s3">if </span><span class="s0">(inputBody != </span><span class="s3">null </span><span class="s0">&amp;&amp; !headers.has(</span><span class="s1">'Content-Type'</span><span class="s0">)) {</span>
			<span class="s0">const contentType = extractContentType(inputBody);</span>
			<span class="s3">if </span><span class="s0">(contentType) {</span>
				<span class="s0">headers.append(</span><span class="s1">'Content-Type'</span><span class="s0">, contentType);</span>
			<span class="s0">}</span>
		<span class="s0">}</span>

		<span class="s0">let signal = isRequest(input) ? input.signal : </span><span class="s3">null</span><span class="s0">;</span>
		<span class="s3">if </span><span class="s0">(</span><span class="s1">'signal' </span><span class="s3">in </span><span class="s0">init) signal = init.signal;</span>

		<span class="s3">if </span><span class="s0">(signal != </span><span class="s3">null </span><span class="s0">&amp;&amp; !isAbortSignal(signal)) {</span>
			<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Expected signal to be an instanceof AbortSignal'</span><span class="s0">);</span>
		<span class="s0">}</span>

		<span class="s3">this</span><span class="s0">[INTERNALS$2] = {</span>
			<span class="s0">method,</span>
			<span class="s0">redirect: init.redirect || input.redirect || </span><span class="s1">'follow'</span><span class="s0">,</span>
			<span class="s0">headers,</span>
			<span class="s0">parsedURL,</span>
			<span class="s0">signal</span>
		<span class="s0">};</span>

		<span class="s2">// node-fetch-only options</span>
		<span class="s3">this</span><span class="s0">.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : </span><span class="s4">20</span><span class="s0">;</span>
		<span class="s3">this</span><span class="s0">.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : </span><span class="s3">true</span><span class="s0">;</span>
		<span class="s3">this</span><span class="s0">.counter = init.counter || input.counter || </span><span class="s4">0</span><span class="s0">;</span>
		<span class="s3">this</span><span class="s0">.agent = init.agent || input.agent;</span>
	<span class="s0">}</span>

	<span class="s0">get method() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$2].method;</span>
	<span class="s0">}</span>

	<span class="s0">get url() {</span>
		<span class="s3">return </span><span class="s0">format_url(</span><span class="s3">this</span><span class="s0">[INTERNALS$2].parsedURL);</span>
	<span class="s0">}</span>

	<span class="s0">get headers() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$2].headers;</span>
	<span class="s0">}</span>

	<span class="s0">get redirect() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$2].redirect;</span>
	<span class="s0">}</span>

	<span class="s0">get signal() {</span>
		<span class="s3">return this</span><span class="s0">[INTERNALS$2].signal;</span>
	<span class="s0">}</span>

	<span class="s2">/** 
  * Clone this request 
  * 
  * @return  Request 
  */</span>
	<span class="s0">clone() {</span>
		<span class="s3">return new </span><span class="s0">Request(</span><span class="s3">this</span><span class="s0">);</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">Body.mixIn(Request.prototype);</span>

<span class="s0">Object.defineProperty(Request.prototype, Symbol.toStringTag, {</span>
	<span class="s0">value: </span><span class="s1">'Request'</span><span class="s0">,</span>
	<span class="s0">writable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">enumerable: </span><span class="s3">false</span><span class="s0">,</span>
	<span class="s0">configurable: </span><span class="s3">true</span>
<span class="s0">});</span>

<span class="s0">Object.defineProperties(Request.prototype, {</span>
	<span class="s0">method: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">url: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">headers: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">redirect: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">clone: { enumerable: </span><span class="s3">true </span><span class="s0">},</span>
	<span class="s0">signal: { enumerable: </span><span class="s3">true </span><span class="s0">}</span>
<span class="s0">});</span>

<span class="s2">/** 
 * Convert a Request to Node.js http request options. 
 * 
 * @param   Request  A Request instance 
 * @return  Object   The options object to be passed to http.request 
 */</span>
<span class="s3">function </span><span class="s0">getNodeRequestOptions(request) {</span>
	<span class="s0">const parsedURL = request[INTERNALS$2].parsedURL;</span>
	<span class="s0">const headers = </span><span class="s3">new </span><span class="s0">Headers(request[INTERNALS$2].headers);</span>

	<span class="s2">// fetch step 1.3</span>
	<span class="s3">if </span><span class="s0">(!headers.has(</span><span class="s1">'Accept'</span><span class="s0">)) {</span>
		<span class="s0">headers.set(</span><span class="s1">'Accept'</span><span class="s0">, </span><span class="s1">'*/*'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">// Basic fetch</span>
	<span class="s3">if </span><span class="s0">(!parsedURL.protocol || !parsedURL.hostname) {</span>
		<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Only absolute URLs are supported'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s3">if </span><span class="s0">(!/^https?:$/.test(parsedURL.protocol)) {</span>
		<span class="s3">throw new </span><span class="s0">TypeError(</span><span class="s1">'Only HTTP(S) protocols are supported'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s3">if </span><span class="s0">(request.signal &amp;&amp; request.body </span><span class="s3">instanceof </span><span class="s0">Stream.Readable &amp;&amp; !streamDestructionSupported) {</span>
		<span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'Cancellation of streamed requests with AbortSignal is not supported in node &lt; 8'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">// HTTP-network-or-cache fetch steps 2.4-2.7</span>
	<span class="s0">let contentLengthValue = </span><span class="s3">null</span><span class="s0">;</span>
	<span class="s3">if </span><span class="s0">(request.body == </span><span class="s3">null </span><span class="s0">&amp;&amp; /^(POST|PUT)$/i.test(request.method)) {</span>
		<span class="s0">contentLengthValue = </span><span class="s1">'0'</span><span class="s0">;</span>
	<span class="s0">}</span>
	<span class="s3">if </span><span class="s0">(request.body != </span><span class="s3">null</span><span class="s0">) {</span>
		<span class="s0">const totalBytes = getTotalBytes(request);</span>
		<span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">totalBytes === </span><span class="s1">'number'</span><span class="s0">) {</span>
			<span class="s0">contentLengthValue = String(totalBytes);</span>
		<span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s3">if </span><span class="s0">(contentLengthValue) {</span>
		<span class="s0">headers.set(</span><span class="s1">'Content-Length'</span><span class="s0">, contentLengthValue);</span>
	<span class="s0">}</span>

	<span class="s2">// HTTP-network-or-cache fetch step 2.11</span>
	<span class="s3">if </span><span class="s0">(!headers.has(</span><span class="s1">'User-Agent'</span><span class="s0">)) {</span>
		<span class="s0">headers.set(</span><span class="s1">'User-Agent'</span><span class="s0">, </span><span class="s1">'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">// HTTP-network-or-cache fetch step 2.15</span>
	<span class="s3">if </span><span class="s0">(request.compress &amp;&amp; !headers.has(</span><span class="s1">'Accept-Encoding'</span><span class="s0">)) {</span>
		<span class="s0">headers.set(</span><span class="s1">'Accept-Encoding'</span><span class="s0">, </span><span class="s1">'gzip,deflate'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s0">let agent = request.agent;</span>
	<span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">agent === </span><span class="s1">'function'</span><span class="s0">) {</span>
		<span class="s0">agent = agent(parsedURL);</span>
	<span class="s0">}</span>

	<span class="s3">if </span><span class="s0">(!headers.has(</span><span class="s1">'Connection'</span><span class="s0">) &amp;&amp; !agent) {</span>
		<span class="s0">headers.set(</span><span class="s1">'Connection'</span><span class="s0">, </span><span class="s1">'close'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s2">// HTTP-network fetch step 4.2</span>
	<span class="s2">// chunked encoding is handled by Node.js</span>

	<span class="s3">return </span><span class="s0">Object.assign({}, parsedURL, {</span>
		<span class="s0">method: request.method,</span>
		<span class="s0">headers: exportNodeCompatibleHeaders(headers),</span>
		<span class="s0">agent</span>
	<span class="s0">});</span>
<span class="s0">}</span>

<span class="s2">/** 
 * abort-error.js 
 * 
 * AbortError interface for cancelled requests 
 */</span>

<span class="s2">/** 
 * Create AbortError instance 
 * 
 * @param   String      message      Error message for human 
 * @return  AbortError 
 */</span>
<span class="s3">function </span><span class="s0">AbortError(message) {</span>
  <span class="s0">Error.call(</span><span class="s3">this</span><span class="s0">, message);</span>

  <span class="s3">this</span><span class="s0">.type = </span><span class="s1">'aborted'</span><span class="s0">;</span>
  <span class="s3">this</span><span class="s0">.message = message;</span>

  <span class="s2">// hide custom error implementation details from end-users</span>
  <span class="s0">Error.captureStackTrace(</span><span class="s3">this</span><span class="s0">, </span><span class="s3">this</span><span class="s0">.constructor);</span>
<span class="s0">}</span>

<span class="s0">AbortError.prototype = Object.create(Error.prototype);</span>
<span class="s0">AbortError.prototype.constructor = AbortError;</span>
<span class="s0">AbortError.prototype.name = </span><span class="s1">'AbortError'</span><span class="s0">;</span>

<span class="s0">const URL$1 = Url.URL || whatwgUrl.URL;</span>

<span class="s2">// fix an issue where &quot;PassThrough&quot;, &quot;resolve&quot; aren't a named export for node &lt;10</span>
<span class="s0">const PassThrough$1 = Stream.PassThrough;</span>

<span class="s0">const isDomainOrSubdomain = </span><span class="s3">function </span><span class="s0">isDomainOrSubdomain(destination, original) {</span>
	<span class="s0">const orig = </span><span class="s3">new </span><span class="s0">URL$1(original).hostname;</span>
	<span class="s0">const dest = </span><span class="s3">new </span><span class="s0">URL$1(destination).hostname;</span>

	<span class="s3">return </span><span class="s0">orig === dest || orig[orig.length - dest.length - </span><span class="s4">1</span><span class="s0">] === </span><span class="s1">'.' </span><span class="s0">&amp;&amp; orig.endsWith(dest);</span>
<span class="s0">};</span>

<span class="s2">/** 
 * isSameProtocol reports whether the two provided URLs use the same protocol. 
 * 
 * Both domains must already be in canonical form. 
 * @param {string|URL} original 
 * @param {string|URL} destination 
 */</span>
<span class="s0">const isSameProtocol = </span><span class="s3">function </span><span class="s0">isSameProtocol(destination, original) {</span>
	<span class="s0">const orig = </span><span class="s3">new </span><span class="s0">URL$1(original).protocol;</span>
	<span class="s0">const dest = </span><span class="s3">new </span><span class="s0">URL$1(destination).protocol;</span>

	<span class="s3">return </span><span class="s0">orig === dest;</span>
<span class="s0">};</span>

<span class="s2">/** 
 * Fetch function 
 * 
 * @param   Mixed    url   Absolute url or Request instance 
 * @param   Object   opts  Fetch options 
 * @return  Promise 
 */</span>
<span class="s3">function </span><span class="s0">fetch(url, opts) {</span>

	<span class="s2">// allow custom promise</span>
	<span class="s3">if </span><span class="s0">(!fetch.Promise) {</span>
		<span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'native promise missing, set fetch.Promise to your favorite alternative'</span><span class="s0">);</span>
	<span class="s0">}</span>

	<span class="s0">Body.Promise = fetch.Promise;</span>

	<span class="s2">// wrap http.request into fetch</span>
	<span class="s3">return new </span><span class="s0">fetch.Promise(</span><span class="s3">function </span><span class="s0">(resolve, reject) {</span>
		<span class="s2">// build request object</span>
		<span class="s0">const request = </span><span class="s3">new </span><span class="s0">Request(url, opts);</span>
		<span class="s0">const options = getNodeRequestOptions(request);</span>

		<span class="s0">const send = (options.protocol === </span><span class="s1">'https:' </span><span class="s0">? https : http).request;</span>
		<span class="s0">const signal = request.signal;</span>

		<span class="s0">let response = </span><span class="s3">null</span><span class="s0">;</span>

		<span class="s0">const abort = </span><span class="s3">function </span><span class="s0">abort() {</span>
			<span class="s0">let error = </span><span class="s3">new </span><span class="s0">AbortError(</span><span class="s1">'The user aborted a request.'</span><span class="s0">);</span>
			<span class="s0">reject(error);</span>
			<span class="s3">if </span><span class="s0">(request.body &amp;&amp; request.body </span><span class="s3">instanceof </span><span class="s0">Stream.Readable) {</span>
				<span class="s0">destroyStream(request.body, error);</span>
			<span class="s0">}</span>
			<span class="s3">if </span><span class="s0">(!response || !response.body) </span><span class="s3">return</span><span class="s0">;</span>
			<span class="s0">response.body.emit(</span><span class="s1">'error'</span><span class="s0">, error);</span>
		<span class="s0">};</span>

		<span class="s3">if </span><span class="s0">(signal &amp;&amp; signal.aborted) {</span>
			<span class="s0">abort();</span>
			<span class="s3">return</span><span class="s0">;</span>
		<span class="s0">}</span>

		<span class="s0">const abortAndFinalize = </span><span class="s3">function </span><span class="s0">abortAndFinalize() {</span>
			<span class="s0">abort();</span>
			<span class="s0">finalize();</span>
		<span class="s0">};</span>

		<span class="s2">// send request</span>
		<span class="s0">const req = send(options);</span>
		<span class="s0">let reqTimeout;</span>

		<span class="s3">if </span><span class="s0">(signal) {</span>
			<span class="s0">signal.addEventListener(</span><span class="s1">'abort'</span><span class="s0">, abortAndFinalize);</span>
		<span class="s0">}</span>

		<span class="s3">function </span><span class="s0">finalize() {</span>
			<span class="s0">req.abort();</span>
			<span class="s3">if </span><span class="s0">(signal) signal.removeEventListener(</span><span class="s1">'abort'</span><span class="s0">, abortAndFinalize);</span>
			<span class="s0">clearTimeout(reqTimeout);</span>
		<span class="s0">}</span>

		<span class="s3">if </span><span class="s0">(request.timeout) {</span>
			<span class="s0">req.once(</span><span class="s1">'socket'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(socket) {</span>
				<span class="s0">reqTimeout = setTimeout(</span><span class="s3">function </span><span class="s0">() {</span>
					<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`network timeout at: ${request.url}`, </span><span class="s1">'request-timeout'</span><span class="s0">));</span>
					<span class="s0">finalize();</span>
				<span class="s0">}, request.timeout);</span>
			<span class="s0">});</span>
		<span class="s0">}</span>

		<span class="s0">req.on(</span><span class="s1">'error'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(err) {</span>
			<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`request to ${request.url} failed, reason: ${err.message}`, </span><span class="s1">'system'</span><span class="s0">, err));</span>

			<span class="s3">if </span><span class="s0">(response &amp;&amp; response.body) {</span>
				<span class="s0">destroyStream(response.body, err);</span>
			<span class="s0">}</span>

			<span class="s0">finalize();</span>
		<span class="s0">});</span>

		<span class="s0">fixResponseChunkedTransferBadEnding(req, </span><span class="s3">function </span><span class="s0">(err) {</span>
			<span class="s3">if </span><span class="s0">(signal &amp;&amp; signal.aborted) {</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s3">if </span><span class="s0">(response &amp;&amp; response.body) {</span>
				<span class="s0">destroyStream(response.body, err);</span>
			<span class="s0">}</span>
		<span class="s0">});</span>

		<span class="s2">/* c8 ignore next 18 */</span>
		<span class="s3">if </span><span class="s0">(parseInt(process.version.substring(</span><span class="s4">1</span><span class="s0">)) &lt; </span><span class="s4">14</span><span class="s0">) {</span>
			<span class="s2">// Before Node.js 14, pipeline() does not fully support async iterators and does not always</span>
			<span class="s2">// properly handle when the socket close/end events are out of order.</span>
			<span class="s0">req.on(</span><span class="s1">'socket'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(s) {</span>
				<span class="s0">s.addListener(</span><span class="s1">'close'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(hadError) {</span>
					<span class="s2">// if a data listener is still present we didn't end cleanly</span>
					<span class="s0">const hasDataListener = s.listenerCount(</span><span class="s1">'data'</span><span class="s0">) &gt; </span><span class="s4">0</span><span class="s0">;</span>

					<span class="s2">// if end happened before close but the socket didn't emit an error, do it now</span>
					<span class="s3">if </span><span class="s0">(response &amp;&amp; hasDataListener &amp;&amp; !hadError &amp;&amp; !(signal &amp;&amp; signal.aborted)) {</span>
						<span class="s0">const err = </span><span class="s3">new </span><span class="s0">Error(</span><span class="s1">'Premature close'</span><span class="s0">);</span>
						<span class="s0">err.code = </span><span class="s1">'ERR_STREAM_PREMATURE_CLOSE'</span><span class="s0">;</span>
						<span class="s0">response.body.emit(</span><span class="s1">'error'</span><span class="s0">, err);</span>
					<span class="s0">}</span>
				<span class="s0">});</span>
			<span class="s0">});</span>
		<span class="s0">}</span>

		<span class="s0">req.on(</span><span class="s1">'response'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(res) {</span>
			<span class="s0">clearTimeout(reqTimeout);</span>

			<span class="s0">const headers = createHeadersLenient(res.headers);</span>

			<span class="s2">// HTTP fetch step 5</span>
			<span class="s3">if </span><span class="s0">(fetch.isRedirect(res.statusCode)) {</span>
				<span class="s2">// HTTP fetch step 5.2</span>
				<span class="s0">const location = headers.get(</span><span class="s1">'Location'</span><span class="s0">);</span>

				<span class="s2">// HTTP fetch step 5.3</span>
				<span class="s0">let locationURL = </span><span class="s3">null</span><span class="s0">;</span>
				<span class="s3">try </span><span class="s0">{</span>
					<span class="s0">locationURL = location === </span><span class="s3">null </span><span class="s0">? </span><span class="s3">null </span><span class="s0">: </span><span class="s3">new </span><span class="s0">URL$1(location, request.url).toString();</span>
				<span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
					<span class="s2">// error here can only be invalid URL in Location: header</span>
					<span class="s2">// do not throw when options.redirect == manual</span>
					<span class="s2">// let the user extract the errorneous redirect URL</span>
					<span class="s3">if </span><span class="s0">(request.redirect !== </span><span class="s1">'manual'</span><span class="s0">) {</span>
						<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`uri requested responds </span><span class="s3">with </span><span class="s0">an invalid redirect URL: ${location}`, </span><span class="s1">'invalid-redirect'</span><span class="s0">));</span>
						<span class="s0">finalize();</span>
						<span class="s3">return</span><span class="s0">;</span>
					<span class="s0">}</span>
				<span class="s0">}</span>

				<span class="s2">// HTTP fetch step 5.5</span>
				<span class="s3">switch </span><span class="s0">(request.redirect) {</span>
					<span class="s3">case </span><span class="s1">'error'</span><span class="s0">:</span>
						<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`uri requested responds </span><span class="s3">with </span><span class="s0">a redirect, redirect mode is set to error: ${request.url}`, </span><span class="s1">'no-redirect'</span><span class="s0">));</span>
						<span class="s0">finalize();</span>
						<span class="s3">return</span><span class="s0">;</span>
					<span class="s3">case </span><span class="s1">'manual'</span><span class="s0">:</span>
						<span class="s2">// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.</span>
						<span class="s3">if </span><span class="s0">(locationURL !== </span><span class="s3">null</span><span class="s0">) {</span>
							<span class="s2">// handle corrupted header</span>
							<span class="s3">try </span><span class="s0">{</span>
								<span class="s0">headers.set(</span><span class="s1">'Location'</span><span class="s0">, locationURL);</span>
							<span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
								<span class="s2">// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request</span>
								<span class="s0">reject(err);</span>
							<span class="s0">}</span>
						<span class="s0">}</span>
						<span class="s3">break</span><span class="s0">;</span>
					<span class="s3">case </span><span class="s1">'follow'</span><span class="s0">:</span>
						<span class="s2">// HTTP-redirect fetch step 2</span>
						<span class="s3">if </span><span class="s0">(locationURL === </span><span class="s3">null</span><span class="s0">) {</span>
							<span class="s3">break</span><span class="s0">;</span>
						<span class="s0">}</span>

						<span class="s2">// HTTP-redirect fetch step 5</span>
						<span class="s3">if </span><span class="s0">(request.counter &gt;= request.follow) {</span>
							<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(`maximum redirect reached at: ${request.url}`, </span><span class="s1">'max-redirect'</span><span class="s0">));</span>
							<span class="s0">finalize();</span>
							<span class="s3">return</span><span class="s0">;</span>
						<span class="s0">}</span>

						<span class="s2">// HTTP-redirect fetch step 6 (counter increment)</span>
						<span class="s2">// Create a new Request object.</span>
						<span class="s0">const requestOpts = {</span>
							<span class="s0">headers: </span><span class="s3">new </span><span class="s0">Headers(request.headers),</span>
							<span class="s0">follow: request.follow,</span>
							<span class="s0">counter: request.counter + </span><span class="s4">1</span><span class="s0">,</span>
							<span class="s0">agent: request.agent,</span>
							<span class="s0">compress: request.compress,</span>
							<span class="s0">method: request.method,</span>
							<span class="s0">body: request.body,</span>
							<span class="s0">signal: request.signal,</span>
							<span class="s0">timeout: request.timeout,</span>
							<span class="s0">size: request.size</span>
						<span class="s0">};</span>

						<span class="s3">if </span><span class="s0">(!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {</span>
							<span class="s3">for </span><span class="s0">(const name of [</span><span class="s1">'authorization'</span><span class="s0">, </span><span class="s1">'www-authenticate'</span><span class="s0">, </span><span class="s1">'cookie'</span><span class="s0">, </span><span class="s1">'cookie2'</span><span class="s0">]) {</span>
								<span class="s0">requestOpts.headers.</span><span class="s3">delete</span><span class="s0">(name);</span>
							<span class="s0">}</span>
						<span class="s0">}</span>

						<span class="s2">// HTTP-redirect fetch step 9</span>
						<span class="s3">if </span><span class="s0">(res.statusCode !== </span><span class="s4">303 </span><span class="s0">&amp;&amp; request.body &amp;&amp; getTotalBytes(request) === </span><span class="s3">null</span><span class="s0">) {</span>
							<span class="s0">reject(</span><span class="s3">new </span><span class="s0">FetchError(</span><span class="s1">'Cannot follow redirect with body being a readable stream'</span><span class="s0">, </span><span class="s1">'unsupported-redirect'</span><span class="s0">));</span>
							<span class="s0">finalize();</span>
							<span class="s3">return</span><span class="s0">;</span>
						<span class="s0">}</span>

						<span class="s2">// HTTP-redirect fetch step 11</span>
						<span class="s3">if </span><span class="s0">(res.statusCode === </span><span class="s4">303 </span><span class="s0">|| (res.statusCode === </span><span class="s4">301 </span><span class="s0">|| res.statusCode === </span><span class="s4">302</span><span class="s0">) &amp;&amp; request.method === </span><span class="s1">'POST'</span><span class="s0">) {</span>
							<span class="s0">requestOpts.method = </span><span class="s1">'GET'</span><span class="s0">;</span>
							<span class="s0">requestOpts.body = undefined;</span>
							<span class="s0">requestOpts.headers.</span><span class="s3">delete</span><span class="s0">(</span><span class="s1">'content-length'</span><span class="s0">);</span>
						<span class="s0">}</span>

						<span class="s2">// HTTP-redirect fetch step 15</span>
						<span class="s0">resolve(fetch(</span><span class="s3">new </span><span class="s0">Request(locationURL, requestOpts)));</span>
						<span class="s0">finalize();</span>
						<span class="s3">return</span><span class="s0">;</span>
				<span class="s0">}</span>
			<span class="s0">}</span>

			<span class="s2">// prepare response</span>
			<span class="s0">res.once(</span><span class="s1">'end'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">() {</span>
				<span class="s3">if </span><span class="s0">(signal) signal.removeEventListener(</span><span class="s1">'abort'</span><span class="s0">, abortAndFinalize);</span>
			<span class="s0">});</span>
			<span class="s0">let body = res.pipe(</span><span class="s3">new </span><span class="s0">PassThrough$1());</span>

			<span class="s0">const response_options = {</span>
				<span class="s0">url: request.url,</span>
				<span class="s0">status: res.statusCode,</span>
				<span class="s0">statusText: res.statusMessage,</span>
				<span class="s0">headers: headers,</span>
				<span class="s0">size: request.size,</span>
				<span class="s0">timeout: request.timeout,</span>
				<span class="s0">counter: request.counter</span>
			<span class="s0">};</span>

			<span class="s2">// HTTP-network fetch step 12.1.1.3</span>
			<span class="s0">const codings = headers.get(</span><span class="s1">'Content-Encoding'</span><span class="s0">);</span>

			<span class="s2">// HTTP-network fetch step 12.1.1.4: handle content codings</span>

			<span class="s2">// in following scenarios we ignore compression support</span>
			<span class="s2">// 1. compression support is disabled</span>
			<span class="s2">// 2. HEAD request</span>
			<span class="s2">// 3. no Content-Encoding header</span>
			<span class="s2">// 4. no content response (204)</span>
			<span class="s2">// 5. content not modified response (304)</span>
			<span class="s3">if </span><span class="s0">(!request.compress || request.method === </span><span class="s1">'HEAD' </span><span class="s0">|| codings === </span><span class="s3">null </span><span class="s0">|| res.statusCode === </span><span class="s4">204 </span><span class="s0">|| res.statusCode === </span><span class="s4">304</span><span class="s0">) {</span>
				<span class="s0">response = </span><span class="s3">new </span><span class="s0">Response(body, response_options);</span>
				<span class="s0">resolve(response);</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s2">// For Node v6+</span>
			<span class="s2">// Be less strict when decoding compressed responses, since sometimes</span>
			<span class="s2">// servers send slightly invalid responses that are still accepted</span>
			<span class="s2">// by common browsers.</span>
			<span class="s2">// Always using Z_SYNC_FLUSH is what cURL does.</span>
			<span class="s0">const zlibOptions = {</span>
				<span class="s0">flush: zlib.Z_SYNC_FLUSH,</span>
				<span class="s0">finishFlush: zlib.Z_SYNC_FLUSH</span>
			<span class="s0">};</span>

			<span class="s2">// for gzip</span>
			<span class="s3">if </span><span class="s0">(codings == </span><span class="s1">'gzip' </span><span class="s0">|| codings == </span><span class="s1">'x-gzip'</span><span class="s0">) {</span>
				<span class="s0">body = body.pipe(zlib.createGunzip(zlibOptions));</span>
				<span class="s0">response = </span><span class="s3">new </span><span class="s0">Response(body, response_options);</span>
				<span class="s0">resolve(response);</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s2">// for deflate</span>
			<span class="s3">if </span><span class="s0">(codings == </span><span class="s1">'deflate' </span><span class="s0">|| codings == </span><span class="s1">'x-deflate'</span><span class="s0">) {</span>
				<span class="s2">// handle the infamous raw deflate response from old servers</span>
				<span class="s2">// a hack for old IIS and Apache servers</span>
				<span class="s0">const raw = res.pipe(</span><span class="s3">new </span><span class="s0">PassThrough$1());</span>
				<span class="s0">raw.once(</span><span class="s1">'data'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(chunk) {</span>
					<span class="s2">// see http://stackoverflow.com/questions/37519828</span>
					<span class="s3">if </span><span class="s0">((chunk[</span><span class="s4">0</span><span class="s0">] &amp; </span><span class="s4">0</span><span class="s0">x0F) === </span><span class="s4">0</span><span class="s0">x08) {</span>
						<span class="s0">body = body.pipe(zlib.createInflate());</span>
					<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
						<span class="s0">body = body.pipe(zlib.createInflateRaw());</span>
					<span class="s0">}</span>
					<span class="s0">response = </span><span class="s3">new </span><span class="s0">Response(body, response_options);</span>
					<span class="s0">resolve(response);</span>
				<span class="s0">});</span>
				<span class="s0">raw.on(</span><span class="s1">'end'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">() {</span>
					<span class="s2">// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.</span>
					<span class="s3">if </span><span class="s0">(!response) {</span>
						<span class="s0">response = </span><span class="s3">new </span><span class="s0">Response(body, response_options);</span>
						<span class="s0">resolve(response);</span>
					<span class="s0">}</span>
				<span class="s0">});</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s2">// for br</span>
			<span class="s3">if </span><span class="s0">(codings == </span><span class="s1">'br' </span><span class="s0">&amp;&amp; </span><span class="s3">typeof </span><span class="s0">zlib.createBrotliDecompress === </span><span class="s1">'function'</span><span class="s0">) {</span>
				<span class="s0">body = body.pipe(zlib.createBrotliDecompress());</span>
				<span class="s0">response = </span><span class="s3">new </span><span class="s0">Response(body, response_options);</span>
				<span class="s0">resolve(response);</span>
				<span class="s3">return</span><span class="s0">;</span>
			<span class="s0">}</span>

			<span class="s2">// otherwise, use response as-is</span>
			<span class="s0">response = </span><span class="s3">new </span><span class="s0">Response(body, response_options);</span>
			<span class="s0">resolve(response);</span>
		<span class="s0">});</span>

		<span class="s0">writeToStream(req, request);</span>
	<span class="s0">});</span>
<span class="s0">}</span>
<span class="s3">function </span><span class="s0">fixResponseChunkedTransferBadEnding(request, errorCallback) {</span>
	<span class="s0">let socket;</span>

	<span class="s0">request.on(</span><span class="s1">'socket'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(s) {</span>
		<span class="s0">socket = s;</span>
	<span class="s0">});</span>

	<span class="s0">request.on(</span><span class="s1">'response'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(response) {</span>
		<span class="s0">const headers = response.headers;</span>

		<span class="s3">if </span><span class="s0">(headers[</span><span class="s1">'transfer-encoding'</span><span class="s0">] === </span><span class="s1">'chunked' </span><span class="s0">&amp;&amp; !headers[</span><span class="s1">'content-length'</span><span class="s0">]) {</span>
			<span class="s0">response.once(</span><span class="s1">'close'</span><span class="s0">, </span><span class="s3">function </span><span class="s0">(hadError) {</span>
				<span class="s2">// tests for socket presence, as in some situations the</span>
				<span class="s2">// the 'socket' event is not triggered for the request</span>
				<span class="s2">// (happens in deno), avoids `TypeError`</span>
				<span class="s2">// if a data listener is still present we didn't end cleanly</span>
				<span class="s0">const hasDataListener = socket &amp;&amp; socket.listenerCount(</span><span class="s1">'data'</span><span class="s0">) &gt; </span><span class="s4">0</span><span class="s0">;</span>

				<span class="s3">if </span><span class="s0">(hasDataListener &amp;&amp; !hadError) {</span>
					<span class="s0">const err = </span><span class="s3">new </span><span class="s0">Error(</span><span class="s1">'Premature close'</span><span class="s0">);</span>
					<span class="s0">err.code = </span><span class="s1">'ERR_STREAM_PREMATURE_CLOSE'</span><span class="s0">;</span>
					<span class="s0">errorCallback(err);</span>
				<span class="s0">}</span>
			<span class="s0">});</span>
		<span class="s0">}</span>
	<span class="s0">});</span>
<span class="s0">}</span>

<span class="s3">function </span><span class="s0">destroyStream(stream, err) {</span>
	<span class="s3">if </span><span class="s0">(stream.destroy) {</span>
		<span class="s0">stream.destroy(err);</span>
	<span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
		<span class="s2">// node &lt; 8</span>
		<span class="s0">stream.emit(</span><span class="s1">'error'</span><span class="s0">, err);</span>
		<span class="s0">stream.end();</span>
	<span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Redirect code matching 
 * 
 * @param   Number   code  Status code 
 * @return  Boolean 
 */</span>
<span class="s0">fetch.isRedirect = </span><span class="s3">function </span><span class="s0">(code) {</span>
	<span class="s3">return </span><span class="s0">code === </span><span class="s4">301 </span><span class="s0">|| code === </span><span class="s4">302 </span><span class="s0">|| code === </span><span class="s4">303 </span><span class="s0">|| code === </span><span class="s4">307 </span><span class="s0">|| code === </span><span class="s4">308</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s2">// expose Promise</span>
<span class="s0">fetch.Promise = global.Promise;</span>

<span class="s0">export </span><span class="s3">default </span><span class="s0">fetch;</span>
<span class="s0">export { Headers, Request, Response, FetchError };</span>
</pre>
</body>
</html>
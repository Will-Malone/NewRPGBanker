<html>
<head>
<title>source-map.debug.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-map.debug.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">webpackUniversalModuleDefinition(root, factory) {</span>
	<span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module === </span><span class="s2">'object'</span><span class="s0">)</span>
		<span class="s0">module.exports = factory();</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd)</span>
		<span class="s0">define([], factory);</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object'</span><span class="s0">)</span>
		<span class="s0">exports[</span><span class="s2">&quot;sourceMap&quot;</span><span class="s0">] = factory();</span>
	<span class="s1">else</span>
		<span class="s0">root[</span><span class="s2">&quot;sourceMap&quot;</span><span class="s0">] = factory();</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
<span class="s1">return </span><span class="s3">/******/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(modules) { </span><span class="s3">// webpackBootstrap</span>
<span class="s3">/******/ 	// The module cache</span>
<span class="s3">/******/ 	</span><span class="s1">var </span><span class="s0">installedModules = {};</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 	// The require function</span>
<span class="s3">/******/ 	</span><span class="s1">function </span><span class="s0">__webpack_require__(moduleId) {</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 		// Check if module is in cache</span>
<span class="s3">/******/ 		</span><span class="s1">if</span><span class="s0">(installedModules[moduleId])</span>
<span class="s3">/******/ 			</span><span class="s1">return </span><span class="s0">installedModules[moduleId].exports;</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 		// Create a new module (and put it into the cache)</span>
<span class="s3">/******/ 		</span><span class="s1">var </span><span class="s0">module = installedModules[moduleId] = {</span>
<span class="s3">/******/ 			</span><span class="s0">exports: {},</span>
<span class="s3">/******/ 			</span><span class="s0">id: moduleId,</span>
<span class="s3">/******/ 			</span><span class="s0">loaded: </span><span class="s1">false</span>
<span class="s3">/******/ 		</span><span class="s0">};</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 		// Execute the module function</span>
<span class="s3">/******/ 		</span><span class="s0">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 		// Flag the module as loaded</span>
<span class="s3">/******/ 		</span><span class="s0">module.loaded = </span><span class="s1">true</span><span class="s0">;</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 		// Return the exports of the module</span>
<span class="s3">/******/ 		</span><span class="s1">return </span><span class="s0">module.exports;</span>
<span class="s3">/******/ 	</span><span class="s0">}</span>
<span class="s3">/******/</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 	// expose the modules object (__webpack_modules__)</span>
<span class="s3">/******/ 	</span><span class="s0">__webpack_require__.m = modules;</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 	// expose the module cache</span>
<span class="s3">/******/ 	</span><span class="s0">__webpack_require__.c = installedModules;</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 	// __webpack_public_path__</span>
<span class="s3">/******/ 	</span><span class="s0">__webpack_require__.p = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
<span class="s3">/******/</span>
<span class="s3">/******/ 	// Load entry module and return exports</span>
<span class="s3">/******/ 	</span><span class="s1">return </span><span class="s0">__webpack_require__(</span><span class="s4">0</span><span class="s0">);</span>
<span class="s3">/******/ </span><span class="s0">})</span>
<span class="s3">/************************************************************************/</span>
<span class="s3">/******/ </span><span class="s0">([</span>
<span class="s3">/* 0 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

	<span class="s3">/* 
     * Copyright 2009-2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE.txt or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	<span class="s0">exports.SourceMapGenerator = __webpack_require__(</span><span class="s4">1</span><span class="s0">).SourceMapGenerator;</span>
	<span class="s0">exports.SourceMapConsumer = __webpack_require__(</span><span class="s4">7</span><span class="s0">).SourceMapConsumer;</span>
	<span class="s0">exports.SourceNode = __webpack_require__(</span><span class="s4">10</span><span class="s0">).SourceNode;</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 1 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">base64VLQ = __webpack_require__(</span><span class="s4">2</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s4">4</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s0">ArraySet = __webpack_require__(</span><span class="s4">5</span><span class="s0">).ArraySet;</span>
	<span class="s1">var </span><span class="s0">MappingList = __webpack_require__(</span><span class="s4">6</span><span class="s0">).MappingList;</span>
	
	<span class="s3">/** 
     * An instance of the SourceMapGenerator represents a source map which is 
     * being built incrementally. You may pass an object with the following 
     * properties: 
     * 
     *   - file: The filename of the generated source. 
     *   - sourceRoot: A root for all relative URLs in this source map. 
     */</span>
	<span class="s1">function </span><span class="s0">SourceMapGenerator(aArgs) {</span>
	  <span class="s1">if </span><span class="s0">(!aArgs) {</span>
	    <span class="s0">aArgs = {};</span>
	  <span class="s0">}</span>
	  <span class="s1">this</span><span class="s0">._file = util.getArg(aArgs, </span><span class="s2">'file'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">._sourceRoot = util.getArg(aArgs, </span><span class="s2">'sourceRoot'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">._skipValidation = util.getArg(aArgs, </span><span class="s2">'skipValidation'</span><span class="s0">, </span><span class="s1">false</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">._sources = </span><span class="s1">new </span><span class="s0">ArraySet();</span>
	  <span class="s1">this</span><span class="s0">._names = </span><span class="s1">new </span><span class="s0">ArraySet();</span>
	  <span class="s1">this</span><span class="s0">._mappings = </span><span class="s1">new </span><span class="s0">MappingList();</span>
	  <span class="s1">this</span><span class="s0">._sourcesContents = </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s0">SourceMapGenerator.prototype._version = </span><span class="s4">3</span><span class="s0">;</span>
	
	<span class="s3">/** 
     * Creates a new SourceMapGenerator based on a SourceMapConsumer 
     * 
     * @param aSourceMapConsumer The SourceMap. 
     */</span>
	<span class="s0">SourceMapGenerator.fromSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {</span>
	    <span class="s1">var </span><span class="s0">sourceRoot = aSourceMapConsumer.sourceRoot;</span>
	    <span class="s1">var </span><span class="s0">generator = </span><span class="s1">new </span><span class="s0">SourceMapGenerator({</span>
	      <span class="s0">file: aSourceMapConsumer.file,</span>
	      <span class="s0">sourceRoot: sourceRoot</span>
	    <span class="s0">});</span>
	    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">var </span><span class="s0">newMapping = {</span>
	        <span class="s0">generated: {</span>
	          <span class="s0">line: mapping.generatedLine,</span>
	          <span class="s0">column: mapping.generatedColumn</span>
	        <span class="s0">}</span>
	      <span class="s0">};</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.source != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">newMapping.source = mapping.source;</span>
	        <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">newMapping.source = util.relative(sourceRoot, newMapping.source);</span>
	        <span class="s0">}</span>
	
	        <span class="s0">newMapping.original = {</span>
	          <span class="s0">line: mapping.originalLine,</span>
	          <span class="s0">column: mapping.originalColumn</span>
	        <span class="s0">};</span>
	
	        <span class="s1">if </span><span class="s0">(mapping.name != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">newMapping.name = mapping.name;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s0">generator.addMapping(newMapping);</span>
	    <span class="s0">});</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile);</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">generator.setSourceContent(sourceFile, content);</span>
	      <span class="s0">}</span>
	    <span class="s0">});</span>
	    <span class="s1">return </span><span class="s0">generator;</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Add a single mapping from original source line and column to the generated 
     * source's line and column for this source map being created. The mapping 
     * object should have the following properties: 
     * 
     *   - generated: An object with the generated line and column positions. 
     *   - original: An object with the original line and column positions. 
     *   - source: The original source file (relative to the sourceRoot). 
     *   - name: An optional original token name for this mapping. 
     */</span>
	<span class="s0">SourceMapGenerator.prototype.addMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_addMapping(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">generated = util.getArg(aArgs, </span><span class="s2">'generated'</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s0">original = util.getArg(aArgs, </span><span class="s2">'original'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s0">source = util.getArg(aArgs, </span><span class="s2">'source'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s0">name = util.getArg(aArgs, </span><span class="s2">'name'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._skipValidation) {</span>
	      <span class="s1">this</span><span class="s0">._validateMapping(generated, original, source, name);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(source != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">source = String(source);</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sources.has(source)) {</span>
	        <span class="s1">this</span><span class="s0">._sources.add(source);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(name != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">name = String(name);</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._names.has(name)) {</span>
	        <span class="s1">this</span><span class="s0">._names.add(name);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">this</span><span class="s0">._mappings.add({</span>
	      <span class="s0">generatedLine: generated.line,</span>
	      <span class="s0">generatedColumn: generated.column,</span>
	      <span class="s0">originalLine: original != </span><span class="s1">null </span><span class="s0">&amp;&amp; original.line,</span>
	      <span class="s0">originalColumn: original != </span><span class="s1">null </span><span class="s0">&amp;&amp; original.column,</span>
	      <span class="s0">source: source,</span>
	      <span class="s0">name: name</span>
	    <span class="s0">});</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Set the source content for a source file. 
     */</span>
	<span class="s0">SourceMapGenerator.prototype.setSourceContent =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {</span>
	    <span class="s1">var </span><span class="s0">source = aSourceFile;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">source = util.relative(</span><span class="s1">this</span><span class="s0">._sourceRoot, source);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(aSourceContent != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s3">// Add the source content to the _sourcesContents map.</span>
	      <span class="s3">// Create a new _sourcesContents map if the property is null.</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	        <span class="s1">this</span><span class="s0">._sourcesContents = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
	      <span class="s0">}</span>
	      <span class="s1">this</span><span class="s0">._sourcesContents[util.toSetString(source)] = aSourceContent;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	      <span class="s3">// Remove the source file from the _sourcesContents map.</span>
	      <span class="s3">// If the _sourcesContents map is empty, set the property to null.</span>
	      <span class="s1">delete this</span><span class="s0">._sourcesContents[util.toSetString(source)];</span>
	      <span class="s1">if </span><span class="s0">(Object.keys(</span><span class="s1">this</span><span class="s0">._sourcesContents).length === </span><span class="s4">0</span><span class="s0">) {</span>
	        <span class="s1">this</span><span class="s0">._sourcesContents = </span><span class="s1">null</span><span class="s0">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Applies the mappings of a sub-source-map for a specific source file to the 
     * source map being generated. Each mapping to the supplied source file is 
     * rewritten using the supplied source map. Note: The resolution for the 
     * resulting mappings is the minimium of this map and the supplied map. 
     * 
     * @param aSourceMapConsumer The source map to be applied. 
     * @param aSourceFile Optional. The filename of the source file. 
     *        If omitted, SourceMapConsumer's file property will be used. 
     * @param aSourceMapPath Optional. The dirname of the path to the source map 
     *        to be applied. If relative, it is relative to the SourceMapConsumer. 
     *        This parameter is needed when the two source maps aren't in the same 
     *        directory, and the source map to be applied contains relative source 
     *        paths. If so, those relative source paths need to be rewritten 
     *        relative to the SourceMapGenerator. 
     */</span>
	<span class="s0">SourceMapGenerator.prototype.applySourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {</span>
	    <span class="s1">var </span><span class="s0">sourceFile = aSourceFile;</span>
	    <span class="s3">// If aSourceFile is omitted, we will use the file property of the SourceMap</span>
	    <span class="s1">if </span><span class="s0">(aSourceFile == </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(aSourceMapConsumer.file == </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s0">Error(</span>
	          <span class="s2">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' </span><span class="s0">+</span>
	          <span class="s2">'or the source map</span><span class="s5">\'</span><span class="s2">s &quot;file&quot; property. Both were omitted.'</span>
	        <span class="s0">);</span>
	      <span class="s0">}</span>
	      <span class="s0">sourceFile = aSourceMapConsumer.file;</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s0">sourceRoot = </span><span class="s1">this</span><span class="s0">._sourceRoot;</span>
	    <span class="s3">// Make &quot;sourceFile&quot; relative if an absolute Url is passed.</span>
	    <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">sourceFile = util.relative(sourceRoot, sourceFile);</span>
	    <span class="s0">}</span>
	    <span class="s3">// Applying the SourceMap can add and remove items from the sources and</span>
	    <span class="s3">// the names array.</span>
	    <span class="s1">var </span><span class="s0">newSources = </span><span class="s1">new </span><span class="s0">ArraySet();</span>
	    <span class="s1">var </span><span class="s0">newNames = </span><span class="s1">new </span><span class="s0">ArraySet();</span>
	
	    <span class="s3">// Find mappings for the &quot;sourceFile&quot;</span>
	    <span class="s1">this</span><span class="s0">._mappings.unsortedForEach(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">if </span><span class="s0">(mapping.source === sourceFile &amp;&amp; mapping.originalLine != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s3">// Check if it can be mapped by the source map, then update the mapping.</span>
	        <span class="s1">var </span><span class="s0">original = aSourceMapConsumer.originalPositionFor({</span>
	          <span class="s0">line: mapping.originalLine,</span>
	          <span class="s0">column: mapping.originalColumn</span>
	        <span class="s0">});</span>
	        <span class="s1">if </span><span class="s0">(original.source != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s3">// Copy mapping</span>
	          <span class="s0">mapping.source = original.source;</span>
	          <span class="s1">if </span><span class="s0">(aSourceMapPath != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.source = util.join(aSourceMapPath, mapping.source)</span>
	          <span class="s0">}</span>
	          <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.source = util.relative(sourceRoot, mapping.source);</span>
	          <span class="s0">}</span>
	          <span class="s0">mapping.originalLine = original.line;</span>
	          <span class="s0">mapping.originalColumn = original.column;</span>
	          <span class="s1">if </span><span class="s0">(original.name != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.name = original.name;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s0">source = mapping.source;</span>
	      <span class="s1">if </span><span class="s0">(source != </span><span class="s1">null </span><span class="s0">&amp;&amp; !newSources.has(source)) {</span>
	        <span class="s0">newSources.add(source);</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s0">name = mapping.name;</span>
	      <span class="s1">if </span><span class="s0">(name != </span><span class="s1">null </span><span class="s0">&amp;&amp; !newNames.has(name)) {</span>
	        <span class="s0">newNames.add(name);</span>
	      <span class="s0">}</span>
	
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	    <span class="s1">this</span><span class="s0">._sources = newSources;</span>
	    <span class="s1">this</span><span class="s0">._names = newNames;</span>
	
	    <span class="s3">// Copy sourcesContents of applied map.</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile);</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(aSourceMapPath != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.join(aSourceMapPath, sourceFile);</span>
	        <span class="s0">}</span>
	        <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.relative(sourceRoot, sourceFile);</span>
	        <span class="s0">}</span>
	        <span class="s1">this</span><span class="s0">.setSourceContent(sourceFile, content);</span>
	      <span class="s0">}</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * A mapping can have one of the three levels of data: 
     * 
     *   1. Just the generated position. 
     *   2. The Generated position, original position, and original source. 
     *   3. Generated and original position, original source, as well as a name 
     *      token. 
     * 
     * To maintain consistency, we validate that any new mapping being added falls 
     * in to one of these categories. 
     */</span>
	<span class="s0">SourceMapGenerator.prototype._validateMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,</span>
	                                              <span class="s0">aName) {</span>
	    <span class="s3">// When aOriginal is truthy but has empty values for .line and .column,</span>
	    <span class="s3">// it is most likely a programmer error. In this case we throw a very</span>
	    <span class="s3">// specific error message to try to guide them the right way.</span>
	    <span class="s3">// For example: https://github.com/Polymer/polymer-bundler/pull/519</span>
	    <span class="s1">if </span><span class="s0">(aOriginal &amp;&amp; </span><span class="s1">typeof </span><span class="s0">aOriginal.line !== </span><span class="s2">'number' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">aOriginal.column !== </span><span class="s2">'number'</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s0">Error(</span>
	            <span class="s2">'original.line and original.column are not numbers -- you probably meant to omit ' </span><span class="s0">+</span>
	            <span class="s2">'the original mapping entirely and only map the generated position. If so, pass ' </span><span class="s0">+</span>
	            <span class="s2">'null for the original mapping instead of an object with empty or null values.'</span>
	        <span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s2">'line' </span><span class="s1">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s2">'column' </span><span class="s1">in </span><span class="s0">aGenerated</span>
	        <span class="s0">&amp;&amp; aGenerated.line &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s4">0</span>
	        <span class="s0">&amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {</span>
	      <span class="s3">// Case 1.</span>
	      <span class="s1">return</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s2">'line' </span><span class="s1">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s2">'column' </span><span class="s1">in </span><span class="s0">aGenerated</span>
	             <span class="s0">&amp;&amp; aOriginal &amp;&amp; </span><span class="s2">'line' </span><span class="s1">in </span><span class="s0">aOriginal &amp;&amp; </span><span class="s2">'column' </span><span class="s1">in </span><span class="s0">aOriginal</span>
	             <span class="s0">&amp;&amp; aGenerated.line &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s4">0</span>
	             <span class="s0">&amp;&amp; aOriginal.line &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; aOriginal.column &gt;= </span><span class="s4">0</span>
	             <span class="s0">&amp;&amp; aSource) {</span>
	      <span class="s3">// Cases 2 and 3.</span>
	      <span class="s1">return</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Invalid mapping: ' </span><span class="s0">+ JSON.stringify({</span>
	        <span class="s0">generated: aGenerated,</span>
	        <span class="s0">source: aSource,</span>
	        <span class="s0">original: aOriginal,</span>
	        <span class="s0">name: aName</span>
	      <span class="s0">}));</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Serialize the accumulated mappings in to the stream of base 64 VLQs 
     * specified by the source map format. 
     */</span>
	<span class="s0">SourceMapGenerator.prototype._serializeMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_serializeMappings() {</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedColumn = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedLine = </span><span class="s4">1</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalColumn = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalLine = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousName = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousSource = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">result = </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">next;</span>
	    <span class="s1">var </span><span class="s0">mapping;</span>
	    <span class="s1">var </span><span class="s0">nameIdx;</span>
	    <span class="s1">var </span><span class="s0">sourceIdx;</span>
	
	    <span class="s1">var </span><span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._mappings.toArray();</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = mappings.length; i &lt; len; i++) {</span>
	      <span class="s0">mapping = mappings[i];</span>
	      <span class="s0">next = </span><span class="s2">''</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.generatedLine !== previousGeneratedLine) {</span>
	        <span class="s0">previousGeneratedColumn = </span><span class="s4">0</span><span class="s0">;</span>
	        <span class="s1">while </span><span class="s0">(mapping.generatedLine !== previousGeneratedLine) {</span>
	          <span class="s0">next += </span><span class="s2">';'</span><span class="s0">;</span>
	          <span class="s0">previousGeneratedLine++;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) {</span>
	          <span class="s1">if </span><span class="s0">(!util.compareByGeneratedPositionsInflated(mapping, mappings[i - </span><span class="s4">1</span><span class="s0">])) {</span>
	            <span class="s1">continue</span><span class="s0">;</span>
	          <span class="s0">}</span>
	          <span class="s0">next += </span><span class="s2">','</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s0">next += base64VLQ.encode(mapping.generatedColumn</span>
	                                 <span class="s0">- previousGeneratedColumn);</span>
	      <span class="s0">previousGeneratedColumn = mapping.generatedColumn;</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.source != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">sourceIdx = </span><span class="s1">this</span><span class="s0">._sources.indexOf(mapping.source);</span>
	        <span class="s0">next += base64VLQ.encode(sourceIdx - previousSource);</span>
	        <span class="s0">previousSource = sourceIdx;</span>
	
	        <span class="s3">// lines are stored 0-based in SourceMap spec version 3</span>
	        <span class="s0">next += base64VLQ.encode(mapping.originalLine - </span><span class="s4">1</span>
	                                   <span class="s0">- previousOriginalLine);</span>
	        <span class="s0">previousOriginalLine = mapping.originalLine - </span><span class="s4">1</span><span class="s0">;</span>
	
	        <span class="s0">next += base64VLQ.encode(mapping.originalColumn</span>
	                                   <span class="s0">- previousOriginalColumn);</span>
	        <span class="s0">previousOriginalColumn = mapping.originalColumn;</span>
	
	        <span class="s1">if </span><span class="s0">(mapping.name != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">nameIdx = </span><span class="s1">this</span><span class="s0">._names.indexOf(mapping.name);</span>
	          <span class="s0">next += base64VLQ.encode(nameIdx - previousName);</span>
	          <span class="s0">previousName = nameIdx;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s0">result += next;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">result;</span>
	  <span class="s0">};</span>
	
	<span class="s0">SourceMapGenerator.prototype._generateSourcesContent =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {</span>
	    <span class="s1">return </span><span class="s0">aSources.map(</span><span class="s1">function </span><span class="s0">(source) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	        <span class="s1">return null</span><span class="s0">;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(aSourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">source = util.relative(aSourceRoot, source);</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s0">key = util.toSetString(source);</span>
	      <span class="s1">return </span><span class="s0">Object.prototype.hasOwnProperty.call(</span><span class="s1">this</span><span class="s0">._sourcesContents, key)</span>
	        <span class="s0">? </span><span class="s1">this</span><span class="s0">._sourcesContents[key]</span>
	        <span class="s0">: </span><span class="s1">null</span><span class="s0">;</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Externalize the source map. 
     */</span>
	<span class="s0">SourceMapGenerator.prototype.toJSON =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_toJSON() {</span>
	    <span class="s1">var </span><span class="s0">map = {</span>
	      <span class="s0">version: </span><span class="s1">this</span><span class="s0">._version,</span>
	      <span class="s0">sources: </span><span class="s1">this</span><span class="s0">._sources.toArray(),</span>
	      <span class="s0">names: </span><span class="s1">this</span><span class="s0">._names.toArray(),</span>
	      <span class="s0">mappings: </span><span class="s1">this</span><span class="s0">._serializeMappings()</span>
	    <span class="s0">};</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._file != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">map.file = </span><span class="s1">this</span><span class="s0">._file;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">map.sourceRoot = </span><span class="s1">this</span><span class="s0">._sourceRoot;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	      <span class="s0">map.sourcesContent = </span><span class="s1">this</span><span class="s0">._generateSourcesContent(map.sources, map.sourceRoot);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">map;</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Render the source map being generated to a string. 
     */</span>
	<span class="s0">SourceMapGenerator.prototype.toString =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_toString() {</span>
	    <span class="s1">return </span><span class="s0">JSON.stringify(</span><span class="s1">this</span><span class="s0">.toJSON());</span>
	  <span class="s0">};</span>
	
	<span class="s0">exports.SourceMapGenerator = SourceMapGenerator;</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 2 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     * 
     * Based on the Base 64 VLQ implementation in Closure Compiler: 
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java 
     * 
     * Copyright 2011 The Closure Compiler Authors. All rights reserved. 
     * Redistribution and use in source and binary forms, with or without 
     * modification, are permitted provided that the following conditions are 
     * met: 
     * 
     *  * Redistributions of source code must retain the above copyright 
     *    notice, this list of conditions and the following disclaimer. 
     *  * Redistributions in binary form must reproduce the above 
     *    copyright notice, this list of conditions and the following 
     *    disclaimer in the documentation and/or other materials provided 
     *    with the distribution. 
     *  * Neither the name of Google Inc. nor the names of its 
     *    contributors may be used to endorse or promote products derived 
     *    from this software without specific prior written permission. 
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
     */</span>
	
	<span class="s1">var </span><span class="s0">base64 = __webpack_require__(</span><span class="s4">3</span><span class="s0">);</span>
	
	<span class="s3">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span>
	<span class="s3">// length quantities we use in the source map spec, the first bit is the sign,</span>
	<span class="s3">// the next four bits are the actual value, and the 6th bit is the</span>
	<span class="s3">// continuation bit. The continuation bit tells us whether there are more</span>
	<span class="s3">// digits in this value following this digit.</span>
	<span class="s3">//</span>
	<span class="s3">//   Continuation</span>
	<span class="s3">//   |    Sign</span>
	<span class="s3">//   |    |</span>
	<span class="s3">//   V    V</span>
	<span class="s3">//   101011</span>
	
	<span class="s1">var </span><span class="s0">VLQ_BASE_SHIFT = </span><span class="s4">5</span><span class="s0">;</span>
	
	<span class="s3">// binary: 100000</span>
	<span class="s1">var </span><span class="s0">VLQ_BASE = </span><span class="s4">1 </span><span class="s0">&lt;&lt; VLQ_BASE_SHIFT;</span>
	
	<span class="s3">// binary: 011111</span>
	<span class="s1">var </span><span class="s0">VLQ_BASE_MASK = VLQ_BASE - </span><span class="s4">1</span><span class="s0">;</span>
	
	<span class="s3">// binary: 100000</span>
	<span class="s1">var </span><span class="s0">VLQ_CONTINUATION_BIT = VLQ_BASE;</span>
	
	<span class="s3">/** 
     * Converts from a two-complement value to a value where the sign bit is 
     * placed in the least significant bit.  For example, as decimals: 
     *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary) 
     *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary) 
     */</span>
	<span class="s1">function </span><span class="s0">toVLQSigned(aValue) {</span>
	  <span class="s1">return </span><span class="s0">aValue &lt; </span><span class="s4">0</span>
	    <span class="s0">? ((-aValue) &lt;&lt; </span><span class="s4">1</span><span class="s0">) + </span><span class="s4">1</span>
	    <span class="s0">: (aValue &lt;&lt; </span><span class="s4">1</span><span class="s0">) + </span><span class="s4">0</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Converts to a two-complement value from a value where the sign bit is 
     * placed in the least significant bit.  For example, as decimals: 
     *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1 
     *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2 
     */</span>
	<span class="s1">function </span><span class="s0">fromVLQSigned(aValue) {</span>
	  <span class="s1">var </span><span class="s0">isNegative = (aValue &amp; </span><span class="s4">1</span><span class="s0">) === </span><span class="s4">1</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">shifted = aValue &gt;&gt; </span><span class="s4">1</span><span class="s0">;</span>
	  <span class="s1">return </span><span class="s0">isNegative</span>
	    <span class="s0">? -shifted</span>
	    <span class="s0">: shifted;</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Returns the base 64 VLQ encoded value. 
     */</span>
	<span class="s0">exports.encode = </span><span class="s1">function </span><span class="s0">base64VLQ_encode(aValue) {</span>
	  <span class="s1">var </span><span class="s0">encoded = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">digit;</span>
	
	  <span class="s1">var </span><span class="s0">vlq = toVLQSigned(aValue);</span>
	
	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s0">digit = vlq &amp; VLQ_BASE_MASK;</span>
	    <span class="s0">vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT;</span>
	    <span class="s1">if </span><span class="s0">(vlq &gt; </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s3">// There are still more digits in this value, so we must make sure the</span>
	      <span class="s3">// continuation bit is marked.</span>
	      <span class="s0">digit |= VLQ_CONTINUATION_BIT;</span>
	    <span class="s0">}</span>
	    <span class="s0">encoded += base64.encode(digit);</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(vlq &gt; </span><span class="s4">0</span><span class="s0">);</span>
	
	  <span class="s1">return </span><span class="s0">encoded;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Decodes the next base 64 VLQ value from the given string and returns the 
     * value and the rest of the string via the out parameter. 
     */</span>
	<span class="s0">exports.decode = </span><span class="s1">function </span><span class="s0">base64VLQ_decode(aStr, aIndex, aOutParam) {</span>
	  <span class="s1">var </span><span class="s0">strLen = aStr.length;</span>
	  <span class="s1">var </span><span class="s0">result = </span><span class="s4">0</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">shift = </span><span class="s4">0</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">continuation, digit;</span>
	
	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s1">if </span><span class="s0">(aIndex &gt;= strLen) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Expected more digits in base 64 VLQ value.&quot;</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s0">digit = base64.decode(aStr.charCodeAt(aIndex++));</span>
	    <span class="s1">if </span><span class="s0">(digit === -</span><span class="s4">1</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Invalid base64 digit: &quot; </span><span class="s0">+ aStr.charAt(aIndex - </span><span class="s4">1</span><span class="s0">));</span>
	    <span class="s0">}</span>
	
	    <span class="s0">continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);</span>
	    <span class="s0">digit &amp;= VLQ_BASE_MASK;</span>
	    <span class="s0">result = result + (digit &lt;&lt; shift);</span>
	    <span class="s0">shift += VLQ_BASE_SHIFT;</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(continuation);</span>
	
	  <span class="s0">aOutParam.value = fromVLQSigned(result);</span>
	  <span class="s0">aOutParam.rest = aIndex;</span>
	<span class="s0">};</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 3 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">intToCharMap = </span><span class="s2">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s0">.split(</span><span class="s2">''</span><span class="s0">);</span>
	
	<span class="s3">/** 
     * Encode an integer in the range of 0 to 63 to a single base 64 digit. 
     */</span>
	<span class="s0">exports.encode = </span><span class="s1">function </span><span class="s0">(number) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s4">0 </span><span class="s0">&lt;= number &amp;&amp; number &lt; intToCharMap.length) {</span>
	    <span class="s1">return </span><span class="s0">intToCharMap[number];</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">&quot;Must be between 0 and 63: &quot; </span><span class="s0">+ number);</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Decode a single base 64 character code digit to an integer. Returns -1 on 
     * failure. 
     */</span>
	<span class="s0">exports.decode = </span><span class="s1">function </span><span class="s0">(charCode) {</span>
	  <span class="s1">var </span><span class="s0">bigA = </span><span class="s4">65</span><span class="s0">;     </span><span class="s3">// 'A'</span>
	  <span class="s1">var </span><span class="s0">bigZ = </span><span class="s4">90</span><span class="s0">;     </span><span class="s3">// 'Z'</span>
	
	  <span class="s1">var </span><span class="s0">littleA = </span><span class="s4">97</span><span class="s0">;  </span><span class="s3">// 'a'</span>
	  <span class="s1">var </span><span class="s0">littleZ = </span><span class="s4">122</span><span class="s0">; </span><span class="s3">// 'z'</span>
	
	  <span class="s1">var </span><span class="s0">zero = </span><span class="s4">48</span><span class="s0">;     </span><span class="s3">// '0'</span>
	  <span class="s1">var </span><span class="s0">nine = </span><span class="s4">57</span><span class="s0">;     </span><span class="s3">// '9'</span>
	
	  <span class="s1">var </span><span class="s0">plus = </span><span class="s4">43</span><span class="s0">;     </span><span class="s3">// '+'</span>
	  <span class="s1">var </span><span class="s0">slash = </span><span class="s4">47</span><span class="s0">;    </span><span class="s3">// '/'</span>
	
	  <span class="s1">var </span><span class="s0">littleOffset = </span><span class="s4">26</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">numberOffset = </span><span class="s4">52</span><span class="s0">;</span>
	
	  <span class="s3">// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</span>
	  <span class="s1">if </span><span class="s0">(bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - bigA);</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// 26 - 51: abcdefghijklmnopqrstuvwxyz</span>
	  <span class="s1">if </span><span class="s0">(littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - littleA + littleOffset);</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// 52 - 61: 0123456789</span>
	  <span class="s1">if </span><span class="s0">(zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - zero + numberOffset);</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// 62: +</span>
	  <span class="s1">if </span><span class="s0">(charCode == plus) {</span>
	    <span class="s1">return </span><span class="s4">62</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// 63: /</span>
	  <span class="s1">if </span><span class="s0">(charCode == slash) {</span>
	    <span class="s1">return </span><span class="s4">63</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// Invalid base64 digit.</span>
	  <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
	<span class="s0">};</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 4 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s3">/** 
     * This is a helper function for getting values from parameter/options 
     * objects. 
     * 
     * @param args The object we are extracting values from 
     * @param name The name of the property we are getting. 
     * @param defaultValue An optional value to return if the property is missing 
     * from the object. If this is not specified and the property is missing, an 
     * error will be thrown. 
     */</span>
	<span class="s1">function </span><span class="s0">getArg(aArgs, aName, aDefaultValue) {</span>
	  <span class="s1">if </span><span class="s0">(aName </span><span class="s1">in </span><span class="s0">aArgs) {</span>
	    <span class="s1">return </span><span class="s0">aArgs[aName];</span>
	  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(arguments.length === </span><span class="s4">3</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">aDefaultValue;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'&quot;' </span><span class="s0">+ aName + </span><span class="s2">'&quot; is a required argument.'</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">exports.getArg = getArg;</span>
	
	<span class="s1">var </span><span class="s0">urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;</span>
	<span class="s1">var </span><span class="s0">dataUrlRegexp = /^data:.+\,.+$/;</span>
	
	<span class="s1">function </span><span class="s0">urlParse(aUrl) {</span>
	  <span class="s1">var </span><span class="s0">match = aUrl.match(urlRegexp);</span>
	  <span class="s1">if </span><span class="s0">(!match) {</span>
	    <span class="s1">return null</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">{</span>
	    <span class="s0">scheme: match[</span><span class="s4">1</span><span class="s0">],</span>
	    <span class="s0">auth: match[</span><span class="s4">2</span><span class="s0">],</span>
	    <span class="s0">host: match[</span><span class="s4">3</span><span class="s0">],</span>
	    <span class="s0">port: match[</span><span class="s4">4</span><span class="s0">],</span>
	    <span class="s0">path: match[</span><span class="s4">5</span><span class="s0">]</span>
	  <span class="s0">};</span>
	<span class="s0">}</span>
	<span class="s0">exports.urlParse = urlParse;</span>
	
	<span class="s1">function </span><span class="s0">urlGenerate(aParsedUrl) {</span>
	  <span class="s1">var </span><span class="s0">url = </span><span class="s2">''</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.scheme) {</span>
	    <span class="s0">url += aParsedUrl.scheme + </span><span class="s2">':'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s0">url += </span><span class="s2">'//'</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.auth) {</span>
	    <span class="s0">url += aParsedUrl.auth + </span><span class="s2">'@'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.host) {</span>
	    <span class="s0">url += aParsedUrl.host;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.port) {</span>
	    <span class="s0">url += </span><span class="s2">&quot;:&quot; </span><span class="s0">+ aParsedUrl.port</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.path) {</span>
	    <span class="s0">url += aParsedUrl.path;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">url;</span>
	<span class="s0">}</span>
	<span class="s0">exports.urlGenerate = urlGenerate;</span>
	
	<span class="s3">/** 
     * Normalizes a path, or the path portion of a URL: 
     * 
     * - Replaces consecutive slashes with one slash. 
     * - Removes unnecessary '.' parts. 
     * - Removes unnecessary '&lt;dir&gt;/..' parts. 
     * 
     * Based on code in the Node.js 'path' core module. 
     * 
     * @param aPath The path or url to normalize. 
     */</span>
	<span class="s1">function </span><span class="s0">normalize(aPath) {</span>
	  <span class="s1">var </span><span class="s0">path = aPath;</span>
	  <span class="s1">var </span><span class="s0">url = urlParse(aPath);</span>
	  <span class="s1">if </span><span class="s0">(url) {</span>
	    <span class="s1">if </span><span class="s0">(!url.path) {</span>
	      <span class="s1">return </span><span class="s0">aPath;</span>
	    <span class="s0">}</span>
	    <span class="s0">path = url.path;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s0">isAbsolute = exports.isAbsolute(path);</span>
	
	  <span class="s1">var </span><span class="s0">parts = path.split(/\/+/);</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">part, up = </span><span class="s4">0</span><span class="s0">, i = parts.length - </span><span class="s4">1</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; i--) {</span>
	    <span class="s0">part = parts[i];</span>
	    <span class="s1">if </span><span class="s0">(part === </span><span class="s2">'.'</span><span class="s0">) {</span>
	      <span class="s0">parts.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(part === </span><span class="s2">'..'</span><span class="s0">) {</span>
	      <span class="s0">up++;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(up &gt; </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(part === </span><span class="s2">''</span><span class="s0">) {</span>
	        <span class="s3">// The first part is blank if the path is absolute. Trying to go</span>
	        <span class="s3">// above the root is a no-op. Therefore we can remove all '..' parts</span>
	        <span class="s3">// directly after the root.</span>
	        <span class="s0">parts.splice(i + </span><span class="s4">1</span><span class="s0">, up);</span>
	        <span class="s0">up = </span><span class="s4">0</span><span class="s0">;</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">parts.splice(i, </span><span class="s4">2</span><span class="s0">);</span>
	        <span class="s0">up--;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s0">path = parts.join(</span><span class="s2">'/'</span><span class="s0">);</span>
	
	  <span class="s1">if </span><span class="s0">(path === </span><span class="s2">''</span><span class="s0">) {</span>
	    <span class="s0">path = isAbsolute ? </span><span class="s2">'/' </span><span class="s0">: </span><span class="s2">'.'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(url) {</span>
	    <span class="s0">url.path = path;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(url);</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">path;</span>
	<span class="s0">}</span>
	<span class="s0">exports.normalize = normalize;</span>
	
	<span class="s3">/** 
     * Joins two paths/URLs. 
     * 
     * @param aRoot The root path or URL. 
     * @param aPath The path or URL to be joined with the root. 
     * 
     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a 
     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended 
     *   first. 
     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion 
     *   is updated with the result and aRoot is returned. Otherwise the result 
     *   is returned. 
     *   - If aPath is absolute, the result is aPath. 
     *   - Otherwise the two paths are joined with a slash. 
     * - Joining for example 'http://' and 'www.example.com' is also supported. 
     */</span>
	<span class="s1">function </span><span class="s0">join(aRoot, aPath) {</span>
	  <span class="s1">if </span><span class="s0">(aRoot === </span><span class="s2">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aRoot = </span><span class="s2">&quot;.&quot;</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aPath === </span><span class="s2">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aPath = </span><span class="s2">&quot;.&quot;</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s0">aPathUrl = urlParse(aPath);</span>
	  <span class="s1">var </span><span class="s0">aRootUrl = urlParse(aRoot);</span>
	  <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	    <span class="s0">aRoot = aRootUrl.path || </span><span class="s2">'/'</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// `join(foo, '//www.example.org')`</span>
	  <span class="s1">if </span><span class="s0">(aPathUrl &amp;&amp; !aPathUrl.scheme) {</span>
	    <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	      <span class="s0">aPathUrl.scheme = aRootUrl.scheme;</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aPathUrl);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(aPathUrl || aPath.match(dataUrlRegexp)) {</span>
	    <span class="s1">return </span><span class="s0">aPath;</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// `join('http://', 'www.example.com')`</span>
	  <span class="s1">if </span><span class="s0">(aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {</span>
	    <span class="s0">aRootUrl.host = aPath;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aRootUrl);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">joined = aPath.charAt(</span><span class="s4">0</span><span class="s0">) === </span><span class="s2">'/'</span>
	    <span class="s0">? aPath</span>
	    <span class="s0">: normalize(aRoot.replace(/\/+$/, </span><span class="s2">''</span><span class="s0">) + </span><span class="s2">'/' </span><span class="s0">+ aPath);</span>
	
	  <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	    <span class="s0">aRootUrl.path = joined;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aRootUrl);</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">joined;</span>
	<span class="s0">}</span>
	<span class="s0">exports.join = join;</span>
	
	<span class="s0">exports.isAbsolute = </span><span class="s1">function </span><span class="s0">(aPath) {</span>
	  <span class="s1">return </span><span class="s0">aPath.charAt(</span><span class="s4">0</span><span class="s0">) === </span><span class="s2">'/' </span><span class="s0">|| !!aPath.match(urlRegexp);</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Make a path relative to a URL or another path. 
     * 
     * @param aRoot The root path or URL. 
     * @param aPath The path or URL to be made relative to aRoot. 
     */</span>
	<span class="s1">function </span><span class="s0">relative(aRoot, aPath) {</span>
	  <span class="s1">if </span><span class="s0">(aRoot === </span><span class="s2">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aRoot = </span><span class="s2">&quot;.&quot;</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">aRoot = aRoot.replace(/\/$/, </span><span class="s2">''</span><span class="s0">);</span>
	
	  <span class="s3">// It is possible for the path to be above the root. In this case, simply</span>
	  <span class="s3">// checking whether the root is a prefix of the path won't work. Instead, we</span>
	  <span class="s3">// need to remove components from the root one by one, until either we find</span>
	  <span class="s3">// a prefix that fits, or we run out of components to remove.</span>
	  <span class="s1">var </span><span class="s0">level = </span><span class="s4">0</span><span class="s0">;</span>
	  <span class="s1">while </span><span class="s0">(aPath.indexOf(aRoot + </span><span class="s2">'/'</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s0">index = aRoot.lastIndexOf(</span><span class="s2">&quot;/&quot;</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">aPath;</span>
	    <span class="s0">}</span>
	
	    <span class="s3">// If the only part of the root that is left is the scheme (i.e. http://,</span>
	    <span class="s3">// file:///, etc.), one or more slashes (/), or simply nothing at all, we</span>
	    <span class="s3">// have exhausted all components, so the path is not relative to the root.</span>
	    <span class="s0">aRoot = aRoot.slice(</span><span class="s4">0</span><span class="s0">, index);</span>
	    <span class="s1">if </span><span class="s0">(aRoot.match(/^([^\/]+:\/)?\</span><span class="s3">/*$/)) { 
          return aPath; 
        } 
     
        ++level; 
      } 
     
      // Make sure we add a &quot;../&quot; for each component we removed from the root. 
      return Array(level + 1).join(&quot;../&quot;) + aPath.substr(aRoot.length + 1); 
    } 
    exports.relative = relative; 
     
    var supportsNullProto = (function () { 
      var obj = Object.create(null); 
      return !('__proto__' in obj); 
    }()); 
     
    function identity (s) { 
      return s; 
    } 
     
    /** 
     * Because behavior goes wacky when you set `__proto__` on objects, we 
     * have to prefix all the strings in our set with an arbitrary character. 
     * 
     * See https://github.com/mozilla/source-map/pull/31 and 
     * https://github.com/mozilla/source-map/issues/30 
     * 
     * @param String aStr 
     */</span>
	<span class="s1">function </span><span class="s0">toSetString(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(isProtoString(aStr)) {</span>
	    <span class="s1">return </span><span class="s2">'$' </span><span class="s0">+ aStr;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">aStr;</span>
	<span class="s0">}</span>
	<span class="s0">exports.toSetString = supportsNullProto ? identity : toSetString;</span>
	
	<span class="s1">function </span><span class="s0">fromSetString(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(isProtoString(aStr)) {</span>
	    <span class="s1">return </span><span class="s0">aStr.slice(</span><span class="s4">1</span><span class="s0">);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">aStr;</span>
	<span class="s0">}</span>
	<span class="s0">exports.fromSetString = supportsNullProto ? identity : fromSetString;</span>
	
	<span class="s1">function </span><span class="s0">isProtoString(s) {</span>
	  <span class="s1">if </span><span class="s0">(!s) {</span>
	    <span class="s1">return false</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">length = s.length;</span>
	
	  <span class="s1">if </span><span class="s0">(length &lt; </span><span class="s4">9 </span><span class="s3">/* &quot;__proto__&quot;.length */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(s.charCodeAt(length - </span><span class="s4">1</span><span class="s0">) !== </span><span class="s4">95  </span><span class="s3">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">2</span><span class="s0">) !== </span><span class="s4">95  </span><span class="s3">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">3</span><span class="s0">) !== </span><span class="s4">111 </span><span class="s3">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">4</span><span class="s0">) !== </span><span class="s4">116 </span><span class="s3">/* 't' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">5</span><span class="s0">) !== </span><span class="s4">111 </span><span class="s3">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">6</span><span class="s0">) !== </span><span class="s4">114 </span><span class="s3">/* 'r' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">7</span><span class="s0">) !== </span><span class="s4">112 </span><span class="s3">/* 'p' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">8</span><span class="s0">) !== </span><span class="s4">95  </span><span class="s3">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s4">9</span><span class="s0">) !== </span><span class="s4">95  </span><span class="s3">/* '_' */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = length - </span><span class="s4">10</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; i--) {</span>
	    <span class="s1">if </span><span class="s0">(s.charCodeAt(i) !== </span><span class="s4">36 </span><span class="s3">/* '$' */</span><span class="s0">) {</span>
	      <span class="s1">return false</span><span class="s0">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return true</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Comparator between two mappings where the original positions are compared. 
     * 
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two 
     * mappings with the same original source/line/column, but different generated 
     * line and column the same. Useful when searching for a mapping with a 
     * stubbed out mapping. 
     */</span>
	<span class="s1">function </span><span class="s0">compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {</span>
	  <span class="s1">var </span><span class="s0">cmp = mappingA.source - mappingB.source;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0 </span><span class="s0">|| onlyCompareOriginal) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">mappingA.name - mappingB.name;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByOriginalPositions = compareByOriginalPositions;</span>
	
	<span class="s3">/** 
     * Comparator between two mappings with deflated source and name indices where 
     * the generated positions are compared. 
     * 
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two 
     * mappings with the same generated line and column, but different 
     * source/name/original line and column the same. Useful when searching for a 
     * mapping with a stubbed out mapping. 
     */</span>
	<span class="s1">function </span><span class="s0">compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {</span>
	  <span class="s1">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0 </span><span class="s0">|| onlyCompareGenerated) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.source - mappingB.source;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">mappingA.name - mappingB.name;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;</span>
	
	<span class="s1">function </span><span class="s0">strcmp(aStr1, aStr2) {</span>
	  <span class="s1">if </span><span class="s0">(aStr1 === aStr2) {</span>
	    <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(aStr1 &gt; aStr2) {</span>
	    <span class="s1">return </span><span class="s4">1</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Comparator between two mappings with inflated source and name strings where 
     * the generated positions are compared. 
     */</span>
	<span class="s1">function </span><span class="s0">compareByGeneratedPositionsInflated(mappingA, mappingB) {</span>
	  <span class="s1">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = strcmp(mappingA.source, mappingB.source);</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">strcmp(mappingA.name, mappingB.name);</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 5 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s4">4</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s0">has = Object.prototype.hasOwnProperty;</span>
	<span class="s1">var </span><span class="s0">hasNativeMap = </span><span class="s1">typeof </span><span class="s0">Map !== </span><span class="s2">&quot;undefined&quot;</span><span class="s0">;</span>
	
	<span class="s3">/** 
     * A data structure which is a combination of an array and a set. Adding a new 
     * member is O(1), testing for membership is O(1), and finding the index of an 
     * element is O(1). Removing elements from the set is not supported. Only 
     * strings are supported for membership. 
     */</span>
	<span class="s1">function </span><span class="s0">ArraySet() {</span>
	  <span class="s1">this</span><span class="s0">._array = [];</span>
	  <span class="s1">this</span><span class="s0">._set = hasNativeMap ? </span><span class="s1">new </span><span class="s0">Map() : Object.create(</span><span class="s1">null</span><span class="s0">);</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Static method for creating ArraySet instances from an existing array. 
     */</span>
	<span class="s0">ArraySet.fromArray = </span><span class="s1">function </span><span class="s0">ArraySet_fromArray(aArray, aAllowDuplicates) {</span>
	  <span class="s1">var </span><span class="s0">set = </span><span class="s1">new </span><span class="s0">ArraySet();</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = aArray.length; i &lt; len; i++) {</span>
	    <span class="s0">set.add(aArray[i], aAllowDuplicates);</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">set;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Return how many unique items are in this ArraySet. If duplicates have been 
     * added, than those do not count towards the size. 
     * 
     * @returns Number 
     */</span>
	<span class="s0">ArraySet.prototype.size = </span><span class="s1">function </span><span class="s0">ArraySet_size() {</span>
	  <span class="s1">return </span><span class="s0">hasNativeMap ? </span><span class="s1">this</span><span class="s0">._set.size : Object.getOwnPropertyNames(</span><span class="s1">this</span><span class="s0">._set).length;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Add the given string to this set. 
     * 
     * @param String aStr 
     */</span>
	<span class="s0">ArraySet.prototype.add = </span><span class="s1">function </span><span class="s0">ArraySet_add(aStr, aAllowDuplicates) {</span>
	  <span class="s1">var </span><span class="s0">sStr = hasNativeMap ? aStr : util.toSetString(aStr);</span>
	  <span class="s1">var </span><span class="s0">isDuplicate = hasNativeMap ? </span><span class="s1">this</span><span class="s0">.has(aStr) : has.call(</span><span class="s1">this</span><span class="s0">._set, sStr);</span>
	  <span class="s1">var </span><span class="s0">idx = </span><span class="s1">this</span><span class="s0">._array.length;</span>
	  <span class="s1">if </span><span class="s0">(!isDuplicate || aAllowDuplicates) {</span>
	    <span class="s1">this</span><span class="s0">._array.push(aStr);</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(!isDuplicate) {</span>
	    <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	      <span class="s1">this</span><span class="s0">._set.set(aStr, idx);</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">this</span><span class="s0">._set[sStr] = idx;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Is the given string a member of this set? 
     * 
     * @param String aStr 
     */</span>
	<span class="s0">ArraySet.prototype.has = </span><span class="s1">function </span><span class="s0">ArraySet_has(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	    <span class="s1">return this</span><span class="s0">._set.has(aStr);</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s0">sStr = util.toSetString(aStr);</span>
	    <span class="s1">return </span><span class="s0">has.call(</span><span class="s1">this</span><span class="s0">._set, sStr);</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * What is the index of the given string in the array? 
     * 
     * @param String aStr 
     */</span>
	<span class="s0">ArraySet.prototype.indexOf = </span><span class="s1">function </span><span class="s0">ArraySet_indexOf(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	    <span class="s1">var </span><span class="s0">idx = </span><span class="s1">this</span><span class="s0">._set.get(aStr);</span>
	    <span class="s1">if </span><span class="s0">(idx &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s0">idx;</span>
	    <span class="s0">}</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s0">sStr = util.toSetString(aStr);</span>
	    <span class="s1">if </span><span class="s0">(has.call(</span><span class="s1">this</span><span class="s0">._set, sStr)) {</span>
	      <span class="s1">return this</span><span class="s0">._set[sStr];</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'&quot;' </span><span class="s0">+ aStr + </span><span class="s2">'&quot; is not in the set.'</span><span class="s0">);</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * What is the element at the given index? 
     * 
     * @param Number aIdx 
     */</span>
	<span class="s0">ArraySet.prototype.at = </span><span class="s1">function </span><span class="s0">ArraySet_at(aIdx) {</span>
	  <span class="s1">if </span><span class="s0">(aIdx &gt;= </span><span class="s4">0 </span><span class="s0">&amp;&amp; aIdx &lt; </span><span class="s1">this</span><span class="s0">._array.length) {</span>
	    <span class="s1">return this</span><span class="s0">._array[aIdx];</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'No element indexed by ' </span><span class="s0">+ aIdx);</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the array representation of this set (which has the proper indices 
     * indicated by indexOf). Note that this is a copy of the internal array used 
     * for storing the members so that no one can mess with internal state. 
     */</span>
	<span class="s0">ArraySet.prototype.toArray = </span><span class="s1">function </span><span class="s0">ArraySet_toArray() {</span>
	  <span class="s1">return this</span><span class="s0">._array.slice();</span>
	<span class="s0">};</span>
	
	<span class="s0">exports.ArraySet = ArraySet;</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 6 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2014 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s4">4</span><span class="s0">);</span>
	
	<span class="s3">/** 
     * Determine whether mappingB is after mappingA with respect to generated 
     * position. 
     */</span>
	<span class="s1">function </span><span class="s0">generatedPositionAfter(mappingA, mappingB) {</span>
	  <span class="s3">// Optimized for most common case</span>
	  <span class="s1">var </span><span class="s0">lineA = mappingA.generatedLine;</span>
	  <span class="s1">var </span><span class="s0">lineB = mappingB.generatedLine;</span>
	  <span class="s1">var </span><span class="s0">columnA = mappingA.generatedColumn;</span>
	  <span class="s1">var </span><span class="s0">columnB = mappingB.generatedColumn;</span>
	  <span class="s1">return </span><span class="s0">lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA ||</span>
	         <span class="s0">util.compareByGeneratedPositionsInflated(mappingA, mappingB) &lt;= </span><span class="s4">0</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * A data structure to provide a sorted view of accumulated mappings in a 
     * performance conscious manner. It trades a neglibable overhead in general 
     * case for a large speedup in case of mappings being added in order. 
     */</span>
	<span class="s1">function </span><span class="s0">MappingList() {</span>
	  <span class="s1">this</span><span class="s0">._array = [];</span>
	  <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">true</span><span class="s0">;</span>
	  <span class="s3">// Serves as infimum</span>
	  <span class="s1">this</span><span class="s0">._last = {generatedLine: -</span><span class="s4">1</span><span class="s0">, generatedColumn: </span><span class="s4">0</span><span class="s0">};</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Iterate through internal items. This method takes the same arguments that 
     * `Array.prototype.forEach` takes. 
     * 
     * NOTE: The order of the mappings is NOT guaranteed. 
     */</span>
	<span class="s0">MappingList.prototype.unsortedForEach =</span>
	  <span class="s1">function </span><span class="s0">MappingList_forEach(aCallback, aThisArg) {</span>
	    <span class="s1">this</span><span class="s0">._array.forEach(aCallback, aThisArg);</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Add the given source mapping. 
     * 
     * @param Object aMapping 
     */</span>
	<span class="s0">MappingList.prototype.add = </span><span class="s1">function </span><span class="s0">MappingList_add(aMapping) {</span>
	  <span class="s1">if </span><span class="s0">(generatedPositionAfter(</span><span class="s1">this</span><span class="s0">._last, aMapping)) {</span>
	    <span class="s1">this</span><span class="s0">._last = aMapping;</span>
	    <span class="s1">this</span><span class="s0">._array.push(aMapping);</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">false</span><span class="s0">;</span>
	    <span class="s1">this</span><span class="s0">._array.push(aMapping);</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the flat, sorted array of mappings. The mappings are sorted by 
     * generated position. 
     * 
     * WARNING: This method returns internal data without copying, for 
     * performance. The return value must NOT be mutated, and should be treated as 
     * an immutable borrow. If you want to take ownership, you must make your own 
     * copy. 
     */</span>
	<span class="s0">MappingList.prototype.toArray = </span><span class="s1">function </span><span class="s0">MappingList_toArray() {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sorted) {</span>
	    <span class="s1">this</span><span class="s0">._array.sort(util.compareByGeneratedPositionsInflated);</span>
	    <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">true</span><span class="s0">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">._array;</span>
	<span class="s0">};</span>
	
	<span class="s0">exports.MappingList = MappingList;</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 7 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s4">4</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s0">binarySearch = __webpack_require__(</span><span class="s4">8</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s0">ArraySet = __webpack_require__(</span><span class="s4">5</span><span class="s0">).ArraySet;</span>
	<span class="s1">var </span><span class="s0">base64VLQ = __webpack_require__(</span><span class="s4">2</span><span class="s0">);</span>
	<span class="s1">var </span><span class="s0">quickSort = __webpack_require__(</span><span class="s4">9</span><span class="s0">).quickSort;</span>
	
	<span class="s1">function </span><span class="s0">SourceMapConsumer(aSourceMap) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s2">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}</span><span class="s2">'/, ''));</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">sourceMap.sections != </span><span class="s1">null</span>
	    <span class="s0">? </span><span class="s1">new </span><span class="s0">IndexedSourceMapConsumer(sourceMap)</span>
	    <span class="s0">: </span><span class="s1">new </span><span class="s0">BasicSourceMapConsumer(sourceMap);</span>
	<span class="s0">}</span>
	
	<span class="s0">SourceMapConsumer.fromSourceMap = </span><span class="s1">function</span><span class="s0">(aSourceMap) {</span>
	  <span class="s1">return </span><span class="s0">BasicSourceMapConsumer.fromSourceMap(aSourceMap);</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * The version of the source mapping spec that we are consuming. 
     */</span>
	<span class="s0">SourceMapConsumer.prototype._version = </span><span class="s4">3</span><span class="s0">;</span>
	
	<span class="s3">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span>
	<span class="s3">// parsed mapping coordinates from the source map's &quot;mappings&quot; attribute. They</span>
	<span class="s3">// are lazily instantiated, accessed via the `_generatedMappings` and</span>
	<span class="s3">// `_originalMappings` getters respectively, and we only parse the mappings</span>
	<span class="s3">// and create these arrays once queried for a source location. We jump through</span>
	<span class="s3">// these hoops because there can be many thousands of mappings, and parsing</span>
	<span class="s3">// them is expensive, so we only want to do it if we must.</span>
	<span class="s3">//</span>
	<span class="s3">// Each object in the arrays is of the form:</span>
	<span class="s3">//</span>
	<span class="s3">//     {</span>
	<span class="s3">//       generatedLine: The line number in the generated code,</span>
	<span class="s3">//       generatedColumn: The column number in the generated code,</span>
	<span class="s3">//       source: The path to the original source file that generated this</span>
	<span class="s3">//               chunk of code,</span>
	<span class="s3">//       originalLine: The line number in the original source that</span>
	<span class="s3">//                     corresponds to this chunk of generated code,</span>
	<span class="s3">//       originalColumn: The column number in the original source that</span>
	<span class="s3">//                       corresponds to this chunk of generated code,</span>
	<span class="s3">//       name: The name of the original symbol which generated this chunk of</span>
	<span class="s3">//             code.</span>
	<span class="s3">//     }</span>
	<span class="s3">//</span>
	<span class="s3">// All properties except for `generatedLine` and `generatedColumn` can be</span>
	<span class="s3">// `null`.</span>
	<span class="s3">//</span>
	<span class="s3">// `_generatedMappings` is ordered by the generated positions.</span>
	<span class="s3">//</span>
	<span class="s3">// `_originalMappings` is ordered by the original positions.</span>
	
	<span class="s0">SourceMapConsumer.prototype.__generatedMappings = </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s0">Object.defineProperty(SourceMapConsumer.prototype, </span><span class="s2">'_generatedMappings'</span><span class="s0">, {</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.__generatedMappings) {</span>
	      <span class="s1">this</span><span class="s0">._parseMappings(</span><span class="s1">this</span><span class="s0">._mappings, </span><span class="s1">this</span><span class="s0">.sourceRoot);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return this</span><span class="s0">.__generatedMappings;</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s0">SourceMapConsumer.prototype.__originalMappings = </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s0">Object.defineProperty(SourceMapConsumer.prototype, </span><span class="s2">'_originalMappings'</span><span class="s0">, {</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.__originalMappings) {</span>
	      <span class="s1">this</span><span class="s0">._parseMappings(</span><span class="s1">this</span><span class="s0">._mappings, </span><span class="s1">this</span><span class="s0">.sourceRoot);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return this</span><span class="s0">.__originalMappings;</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s0">SourceMapConsumer.prototype._charIsMappingSeparator =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_charIsMappingSeparator(aStr, index) {</span>
	    <span class="s1">var </span><span class="s0">c = aStr.charAt(index);</span>
	    <span class="s1">return </span><span class="s0">c === </span><span class="s2">&quot;;&quot; </span><span class="s0">|| c === </span><span class="s2">&quot;,&quot;</span><span class="s0">;</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Parse the mappings in a string in to a data structure which we can easily 
     * query (the ordered arrays in the `this.__generatedMappings` and 
     * `this.__originalMappings` properties). 
     */</span>
	<span class="s0">SourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Subclasses must implement _parseMappings&quot;</span><span class="s0">);</span>
	  <span class="s0">};</span>
	
	<span class="s0">SourceMapConsumer.GENERATED_ORDER = </span><span class="s4">1</span><span class="s0">;</span>
	<span class="s0">SourceMapConsumer.ORIGINAL_ORDER = </span><span class="s4">2</span><span class="s0">;</span>
	
	<span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND = </span><span class="s4">1</span><span class="s0">;</span>
	<span class="s0">SourceMapConsumer.LEAST_UPPER_BOUND = </span><span class="s4">2</span><span class="s0">;</span>
	
	<span class="s3">/** 
     * Iterate over each mapping between an original source/line/column and a 
     * generated line/column in this source map. 
     * 
     * @param Function aCallback 
     *        The function that is called with each mapping. 
     * @param Object aContext 
     *        Optional. If specified, this object will be the value of `this` every 
     *        time that `aCallback` is called. 
     * @param aOrder 
     *        Either `SourceMapConsumer.GENERATED_ORDER` or 
     *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to 
     *        iterate over the mappings sorted by the generated file's line/column 
     *        order or the original's source/line/column order, respectively. Defaults to 
     *        `SourceMapConsumer.GENERATED_ORDER`. 
     */</span>
	<span class="s0">SourceMapConsumer.prototype.eachMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {</span>
	    <span class="s1">var </span><span class="s0">context = aContext || </span><span class="s1">null</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">order = aOrder || SourceMapConsumer.GENERATED_ORDER;</span>
	
	    <span class="s1">var </span><span class="s0">mappings;</span>
	    <span class="s1">switch </span><span class="s0">(order) {</span>
	    <span class="s1">case </span><span class="s0">SourceMapConsumer.GENERATED_ORDER:</span>
	      <span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._generatedMappings;</span>
	      <span class="s1">break</span><span class="s0">;</span>
	    <span class="s1">case </span><span class="s0">SourceMapConsumer.ORIGINAL_ORDER:</span>
	      <span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._originalMappings;</span>
	      <span class="s1">break</span><span class="s0">;</span>
	    <span class="s1">default</span><span class="s0">:</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Unknown order of iteration.&quot;</span><span class="s0">);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">sourceRoot = </span><span class="s1">this</span><span class="s0">.sourceRoot;</span>
	    <span class="s0">mappings.map(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">var </span><span class="s0">source = mapping.source === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">._sources.at(mapping.source);</span>
	      <span class="s1">if </span><span class="s0">(source != </span><span class="s1">null </span><span class="s0">&amp;&amp; sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">source = util.join(sourceRoot, source);</span>
	      <span class="s0">}</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">source: source,</span>
	        <span class="s0">generatedLine: mapping.generatedLine,</span>
	        <span class="s0">generatedColumn: mapping.generatedColumn,</span>
	        <span class="s0">originalLine: mapping.originalLine,</span>
	        <span class="s0">originalColumn: mapping.originalColumn,</span>
	        <span class="s0">name: mapping.name === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">._names.at(mapping.name)</span>
	      <span class="s0">};</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">).forEach(aCallback, context);</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns all generated line and column information for the original source, 
     * line, and column provided. If no column is provided, returns all mappings 
     * corresponding to a either the line we are searching for or the next 
     * closest line that has any mappings. Otherwise, returns all mappings 
     * corresponding to the given line and either the column we are searching for 
     * or the next closest column that has any offsets. 
     * 
     * The only argument is an object with the following properties: 
     * 
     *   - source: The filename of the original source. 
     *   - line: The line number in the original source. 
     *   - column: Optional. the column number in the original source. 
     * 
     * and an array of objects is returned, each with the following properties: 
     * 
     *   - line: The line number in the generated source, or null. 
     *   - column: The column number in the generated source, or null. 
     */</span>
	<span class="s0">SourceMapConsumer.prototype.allGeneratedPositionsFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_allGeneratedPositionsFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">line = util.getArg(aArgs, </span><span class="s2">'line'</span><span class="s0">);</span>
	
	    <span class="s3">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span>
	    <span class="s3">// returns the index of the closest mapping less than the needle. By</span>
	    <span class="s3">// setting needle.originalColumn to 0, we thus find the last mapping for</span>
	    <span class="s3">// the given line, provided such a mapping exists.</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">source: util.getArg(aArgs, </span><span class="s2">'source'</span><span class="s0">),</span>
	      <span class="s0">originalLine: line,</span>
	      <span class="s0">originalColumn: util.getArg(aArgs, </span><span class="s2">'column'</span><span class="s0">, </span><span class="s4">0</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">needle.source = util.relative(</span><span class="s1">this</span><span class="s0">.sourceRoot, needle.source);</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sources.has(needle.source)) {</span>
	      <span class="s1">return </span><span class="s0">[];</span>
	    <span class="s0">}</span>
	    <span class="s0">needle.source = </span><span class="s1">this</span><span class="s0">._sources.indexOf(needle.source);</span>
	
	    <span class="s1">var </span><span class="s0">mappings = [];</span>
	
	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(needle,</span>
	                                  <span class="s1">this</span><span class="s0">._originalMappings,</span>
	                                  <span class="s2">&quot;originalLine&quot;</span><span class="s0">,</span>
	                                  <span class="s2">&quot;originalColumn&quot;</span><span class="s0">,</span>
	                                  <span class="s0">util.compareByOriginalPositions,</span>
	                                  <span class="s0">binarySearch.LEAST_UPPER_BOUND);</span>
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[index];</span>
	
	      <span class="s1">if </span><span class="s0">(aArgs.column === undefined) {</span>
	        <span class="s1">var </span><span class="s0">originalLine = mapping.originalLine;</span>
	
	        <span class="s3">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s3">// a mapping for a different line than the one we found. Since</span>
	        <span class="s3">// mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s3">// the line we found.</span>
	        <span class="s1">while </span><span class="s0">(mapping &amp;&amp; mapping.originalLine === originalLine) {</span>
	          <span class="s0">mappings.push({</span>
	            <span class="s0">line: util.getArg(mapping, </span><span class="s2">'generatedLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s0">column: util.getArg(mapping, </span><span class="s2">'generatedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s0">lastColumn: util.getArg(mapping, </span><span class="s2">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">});</span>
	
	          <span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[++index];</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s0">originalColumn = mapping.originalColumn;</span>
	
	        <span class="s3">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s3">// a mapping for a different line than the one we were searching for.</span>
	        <span class="s3">// Since mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s3">// the line we are searching for.</span>
	        <span class="s1">while </span><span class="s0">(mapping &amp;&amp;</span>
	               <span class="s0">mapping.originalLine === line &amp;&amp;</span>
	               <span class="s0">mapping.originalColumn == originalColumn) {</span>
	          <span class="s0">mappings.push({</span>
	            <span class="s0">line: util.getArg(mapping, </span><span class="s2">'generatedLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s0">column: util.getArg(mapping, </span><span class="s2">'generatedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	            <span class="s0">lastColumn: util.getArg(mapping, </span><span class="s2">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">});</span>
	
	          <span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[++index];</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">mappings;</span>
	  <span class="s0">};</span>
	
	<span class="s0">exports.SourceMapConsumer = SourceMapConsumer;</span>
	
	<span class="s3">/** 
     * A BasicSourceMapConsumer instance represents a parsed source map which we can 
     * query for information about the original file positions by giving it a file 
     * position in the generated source. 
     * 
     * The only parameter is the raw source map (either as a JSON string, or 
     * already parsed to an object). According to the spec, source maps have the 
     * following attributes: 
     * 
     *   - version: Which version of the source map spec this map is following. 
     *   - sources: An array of URLs to the original source files. 
     *   - names: An array of identifiers which can be referrenced by individual mappings. 
     *   - sourceRoot: Optional. The URL root from which all sources are relative. 
     *   - sourcesContent: Optional. An array of contents of the original source files. 
     *   - mappings: A string of base64 VLQs which contain the actual mappings. 
     *   - file: Optional. The generated file this source map is associated with. 
     * 
     * Here is an example source map, taken from the source map spec[0]: 
     * 
     *     { 
     *       version : 3, 
     *       file: &quot;out.js&quot;, 
     *       sourceRoot : &quot;&quot;, 
     *       sources: [&quot;foo.js&quot;, &quot;bar.js&quot;], 
     *       names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;], 
     *       mappings: &quot;AA,AB;;ABCDE;&quot; 
     *     } 
     * 
     * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1# 
     */</span>
	<span class="s1">function </span><span class="s0">BasicSourceMapConsumer(aSourceMap) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s2">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}</span><span class="s2">'/, ''));</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">version = util.getArg(sourceMap, </span><span class="s2">'version'</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s0">sources = util.getArg(sourceMap, </span><span class="s2">'sources'</span><span class="s0">);</span>
	  <span class="s3">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span>
	  <span class="s3">// requires the array) to play nice here.</span>
	  <span class="s1">var </span><span class="s0">names = util.getArg(sourceMap, </span><span class="s2">'names'</span><span class="s0">, []);</span>
	  <span class="s1">var </span><span class="s0">sourceRoot = util.getArg(sourceMap, </span><span class="s2">'sourceRoot'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s0">sourcesContent = util.getArg(sourceMap, </span><span class="s2">'sourcesContent'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s0">mappings = util.getArg(sourceMap, </span><span class="s2">'mappings'</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s0">file = util.getArg(sourceMap, </span><span class="s2">'file'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	
	  <span class="s3">// Once again, Sass deviates from the spec and supplies the version as a</span>
	  <span class="s3">// string rather than a number, so we use loose equality checking here.</span>
	  <span class="s1">if </span><span class="s0">(version != </span><span class="s1">this</span><span class="s0">._version) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Unsupported version: ' </span><span class="s0">+ version);</span>
	  <span class="s0">}</span>
	
	  <span class="s0">sources = sources</span>
	    <span class="s0">.map(String)</span>
	    <span class="s3">// Some source maps produce relative source paths like &quot;./foo.js&quot; instead of</span>
	    <span class="s3">// &quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.</span>
	    <span class="s3">// See bugzil.la/1090768.</span>
	    <span class="s0">.map(util.normalize)</span>
	    <span class="s3">// Always ensure that absolute sources are internally stored relative to</span>
	    <span class="s3">// the source root, if the source root is absolute. Not doing this would</span>
	    <span class="s3">// be particularly problematic when the source root is a prefix of the</span>
	    <span class="s3">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span>
	    <span class="s0">.map(</span><span class="s1">function </span><span class="s0">(source) {</span>
	      <span class="s1">return </span><span class="s0">sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)</span>
	        <span class="s0">? util.relative(sourceRoot, source)</span>
	        <span class="s0">: source;</span>
	    <span class="s0">});</span>
	
	  <span class="s3">// Pass `true` below to allow duplicate names and sources. While source maps</span>
	  <span class="s3">// are intended to be compressed and deduplicated, the TypeScript compiler</span>
	  <span class="s3">// sometimes generates source maps with duplicates in them. See Github issue</span>
	  <span class="s3">// #72 and bugzil.la/889492.</span>
	  <span class="s1">this</span><span class="s0">._names = ArraySet.fromArray(names.map(String), </span><span class="s1">true</span><span class="s0">);</span>
	  <span class="s1">this</span><span class="s0">._sources = ArraySet.fromArray(sources, </span><span class="s1">true</span><span class="s0">);</span>
	
	  <span class="s1">this</span><span class="s0">.sourceRoot = sourceRoot;</span>
	  <span class="s1">this</span><span class="s0">.sourcesContent = sourcesContent;</span>
	  <span class="s1">this</span><span class="s0">._mappings = mappings;</span>
	  <span class="s1">this</span><span class="s0">.file = file;</span>
	<span class="s0">}</span>
	
	<span class="s0">BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span>
	<span class="s0">BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;</span>
	
	<span class="s3">/** 
     * Create a BasicSourceMapConsumer from a SourceMapGenerator. 
     * 
     * @param SourceMapGenerator aSourceMap 
     *        The source map that will be consumed. 
     * @returns BasicSourceMapConsumer 
     */</span>
	<span class="s0">BasicSourceMapConsumer.fromSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_fromSourceMap(aSourceMap) {</span>
	    <span class="s1">var </span><span class="s0">smc = Object.create(BasicSourceMapConsumer.prototype);</span>
	
	    <span class="s1">var </span><span class="s0">names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), </span><span class="s1">true</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s0">sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), </span><span class="s1">true</span><span class="s0">);</span>
	    <span class="s0">smc.sourceRoot = aSourceMap._sourceRoot;</span>
	    <span class="s0">smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),</span>
	                                                            <span class="s0">smc.sourceRoot);</span>
	    <span class="s0">smc.file = aSourceMap._file;</span>
	
	    <span class="s3">// Because we are modifying the entries (by converting string sources and</span>
	    <span class="s3">// names to indices into the sources and names ArraySets), we have to make</span>
	    <span class="s3">// a copy of the entry or else bad things happen. Shared mutable state</span>
	    <span class="s3">// strikes again! See github issue #191.</span>
	
	    <span class="s1">var </span><span class="s0">generatedMappings = aSourceMap._mappings.toArray().slice();</span>
	    <span class="s1">var </span><span class="s0">destGeneratedMappings = smc.__generatedMappings = [];</span>
	    <span class="s1">var </span><span class="s0">destOriginalMappings = smc.__originalMappings = [];</span>
	
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, length = generatedMappings.length; i &lt; length; i++) {</span>
	      <span class="s1">var </span><span class="s0">srcMapping = generatedMappings[i];</span>
	      <span class="s1">var </span><span class="s0">destMapping = </span><span class="s1">new </span><span class="s0">Mapping;</span>
	      <span class="s0">destMapping.generatedLine = srcMapping.generatedLine;</span>
	      <span class="s0">destMapping.generatedColumn = srcMapping.generatedColumn;</span>
	
	      <span class="s1">if </span><span class="s0">(srcMapping.source) {</span>
	        <span class="s0">destMapping.source = sources.indexOf(srcMapping.source);</span>
	        <span class="s0">destMapping.originalLine = srcMapping.originalLine;</span>
	        <span class="s0">destMapping.originalColumn = srcMapping.originalColumn;</span>
	
	        <span class="s1">if </span><span class="s0">(srcMapping.name) {</span>
	          <span class="s0">destMapping.name = names.indexOf(srcMapping.name);</span>
	        <span class="s0">}</span>
	
	        <span class="s0">destOriginalMappings.push(destMapping);</span>
	      <span class="s0">}</span>
	
	      <span class="s0">destGeneratedMappings.push(destMapping);</span>
	    <span class="s0">}</span>
	
	    <span class="s0">quickSort(smc.__originalMappings, util.compareByOriginalPositions);</span>
	
	    <span class="s1">return </span><span class="s0">smc;</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * The version of the source mapping spec that we are consuming. 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype._version = </span><span class="s4">3</span><span class="s0">;</span>
	
	<span class="s3">/** 
     * The list of original sources. 
     */</span>
	<span class="s0">Object.defineProperty(BasicSourceMapConsumer.prototype, </span><span class="s2">'sources'</span><span class="s0">, {</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">return this</span><span class="s0">._sources.toArray().map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	      <span class="s1">return this</span><span class="s0">.sourceRoot != </span><span class="s1">null </span><span class="s0">? util.join(</span><span class="s1">this</span><span class="s0">.sourceRoot, s) : s;</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s3">/** 
     * Provide the JIT with a nice shape / hidden class. 
     */</span>
	<span class="s1">function </span><span class="s0">Mapping() {</span>
	  <span class="s1">this</span><span class="s0">.generatedLine = </span><span class="s4">0</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.generatedColumn = </span><span class="s4">0</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.source = </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.originalLine = </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.originalColumn = </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.name = </span><span class="s1">null</span><span class="s0">;</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Parse the mappings in a string in to a data structure which we can easily 
     * query (the ordered arrays in the `this.__generatedMappings` and 
     * `this.__originalMappings` properties). 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span>
	    <span class="s1">var </span><span class="s0">generatedLine = </span><span class="s4">1</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedColumn = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalLine = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalColumn = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousSource = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">previousName = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">length = aStr.length;</span>
	    <span class="s1">var </span><span class="s0">index = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">cachedSegments = {};</span>
	    <span class="s1">var </span><span class="s0">temp = {};</span>
	    <span class="s1">var </span><span class="s0">originalMappings = [];</span>
	    <span class="s1">var </span><span class="s0">generatedMappings = [];</span>
	    <span class="s1">var </span><span class="s0">mapping, str, segment, end, value;</span>
	
	    <span class="s1">while </span><span class="s0">(index &lt; length) {</span>
	      <span class="s1">if </span><span class="s0">(aStr.charAt(index) === </span><span class="s2">';'</span><span class="s0">) {</span>
	        <span class="s0">generatedLine++;</span>
	        <span class="s0">index++;</span>
	        <span class="s0">previousGeneratedColumn = </span><span class="s4">0</span><span class="s0">;</span>
	      <span class="s0">}</span>
	      <span class="s1">else if </span><span class="s0">(aStr.charAt(index) === </span><span class="s2">','</span><span class="s0">) {</span>
	        <span class="s0">index++;</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">mapping = </span><span class="s1">new </span><span class="s0">Mapping();</span>
	        <span class="s0">mapping.generatedLine = generatedLine;</span>
	
	        <span class="s3">// Because each offset is encoded relative to the previous one,</span>
	        <span class="s3">// many segments often have the same encoding. We can exploit this</span>
	        <span class="s3">// fact by caching the parsed variable length fields of each segment,</span>
	        <span class="s3">// allowing us to avoid a second parse if we encounter the same</span>
	        <span class="s3">// segment again.</span>
	        <span class="s1">for </span><span class="s0">(end = index; end &lt; length; end++) {</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._charIsMappingSeparator(aStr, end)) {</span>
	            <span class="s1">break</span><span class="s0">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	        <span class="s0">str = aStr.slice(index, end);</span>
	
	        <span class="s0">segment = cachedSegments[str];</span>
	        <span class="s1">if </span><span class="s0">(segment) {</span>
	          <span class="s0">index += str.length;</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s0">segment = [];</span>
	          <span class="s1">while </span><span class="s0">(index &lt; end) {</span>
	            <span class="s0">base64VLQ.decode(aStr, index, temp);</span>
	            <span class="s0">value = temp.value;</span>
	            <span class="s0">index = temp.rest;</span>
	            <span class="s0">segment.push(value);</span>
	          <span class="s0">}</span>
	
	          <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s4">2</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Found a source, but no line and column'</span><span class="s0">);</span>
	          <span class="s0">}</span>
	
	          <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s4">3</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Found a source and line, but no column'</span><span class="s0">);</span>
	          <span class="s0">}</span>
	
	          <span class="s0">cachedSegments[str] = segment;</span>
	        <span class="s0">}</span>
	
	        <span class="s3">// Generated column.</span>
	        <span class="s0">mapping.generatedColumn = previousGeneratedColumn + segment[</span><span class="s4">0</span><span class="s0">];</span>
	        <span class="s0">previousGeneratedColumn = mapping.generatedColumn;</span>
	
	        <span class="s1">if </span><span class="s0">(segment.length &gt; </span><span class="s4">1</span><span class="s0">) {</span>
	          <span class="s3">// Original source.</span>
	          <span class="s0">mapping.source = previousSource + segment[</span><span class="s4">1</span><span class="s0">];</span>
	          <span class="s0">previousSource += segment[</span><span class="s4">1</span><span class="s0">];</span>
	
	          <span class="s3">// Original line.</span>
	          <span class="s0">mapping.originalLine = previousOriginalLine + segment[</span><span class="s4">2</span><span class="s0">];</span>
	          <span class="s0">previousOriginalLine = mapping.originalLine;</span>
	          <span class="s3">// Lines are stored 0-based</span>
	          <span class="s0">mapping.originalLine += </span><span class="s4">1</span><span class="s0">;</span>
	
	          <span class="s3">// Original column.</span>
	          <span class="s0">mapping.originalColumn = previousOriginalColumn + segment[</span><span class="s4">3</span><span class="s0">];</span>
	          <span class="s0">previousOriginalColumn = mapping.originalColumn;</span>
	
	          <span class="s1">if </span><span class="s0">(segment.length &gt; </span><span class="s4">4</span><span class="s0">) {</span>
	            <span class="s3">// Original name.</span>
	            <span class="s0">mapping.name = previousName + segment[</span><span class="s4">4</span><span class="s0">];</span>
	            <span class="s0">previousName += segment[</span><span class="s4">4</span><span class="s0">];</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	
	        <span class="s0">generatedMappings.push(mapping);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">mapping.originalLine === </span><span class="s2">'number'</span><span class="s0">) {</span>
	          <span class="s0">originalMappings.push(mapping);</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s0">quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);</span>
	    <span class="s1">this</span><span class="s0">.__generatedMappings = generatedMappings;</span>
	
	    <span class="s0">quickSort(originalMappings, util.compareByOriginalPositions);</span>
	    <span class="s1">this</span><span class="s0">.__originalMappings = originalMappings;</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that 
     * we are searching for in the given &quot;haystack&quot; of mappings. 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype._findMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,</span>
	                                         <span class="s0">aColumnName, aComparator, aBias) {</span>
	    <span class="s3">// To return the position we are searching for, we must first find the</span>
	    <span class="s3">// mapping for the given position and then return the opposite position it</span>
	    <span class="s3">// points to. Because the mappings are sorted, we can use binary search to</span>
	    <span class="s3">// find the best mapping.</span>
	
	    <span class="s1">if </span><span class="s0">(aNeedle[aLineName] &lt;= </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Line must be greater than or equal to 1, got '</span>
	                          <span class="s0">+ aNeedle[aLineName]);</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(aNeedle[aColumnName] &lt; </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s2">'Column must be greater than or equal to 0, got '</span>
	                          <span class="s0">+ aNeedle[aColumnName]);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">binarySearch.search(aNeedle, aMappings, aComparator, aBias);</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Compute the last column for each generated mapping. The last column is 
     * inclusive. 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype.computeColumnSpans =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_computeColumnSpans() {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">index = </span><span class="s4">0</span><span class="s0">; index &lt; </span><span class="s1">this</span><span class="s0">._generatedMappings.length; ++index) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index];</span>
	
	      <span class="s3">// Mappings do not contain a field for the last generated columnt. We</span>
	      <span class="s3">// can come up with an optimistic estimate, however, by assuming that</span>
	      <span class="s3">// mappings are contiguous (i.e. given two consecutive mappings, the</span>
	      <span class="s3">// first mapping ends where the second one starts).</span>
	      <span class="s1">if </span><span class="s0">(index + </span><span class="s4">1 </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">._generatedMappings.length) {</span>
	        <span class="s1">var </span><span class="s0">nextMapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index + </span><span class="s4">1</span><span class="s0">];</span>
	
	        <span class="s1">if </span><span class="s0">(mapping.generatedLine === nextMapping.generatedLine) {</span>
	          <span class="s0">mapping.lastGeneratedColumn = nextMapping.generatedColumn - </span><span class="s4">1</span><span class="s0">;</span>
	          <span class="s1">continue</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s3">// The last mapping for each line spans the entire line.</span>
	      <span class="s0">mapping.lastGeneratedColumn = Infinity;</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the original source, line, and column information for the generated 
     * source's line and column positions provided. The only argument is an object 
     * with the following properties: 
     * 
     *   - line: The line number in the generated source. 
     *   - column: The column number in the generated source. 
     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or 
     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the 
     *     closest element that is smaller than or greater than the one we are 
     *     searching for, respectively, if the exact element cannot be found. 
     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'. 
     * 
     * and an object is returned with the following properties: 
     * 
     *   - source: The original source file, or null. 
     *   - line: The line number in the original source, or null. 
     *   - column: The column number in the original source, or null. 
     *   - name: The original identifier, or null. 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype.originalPositionFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_originalPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">generatedLine: util.getArg(aArgs, </span><span class="s2">'line'</span><span class="s0">),</span>
	      <span class="s0">generatedColumn: util.getArg(aArgs, </span><span class="s2">'column'</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(</span>
	      <span class="s0">needle,</span>
	      <span class="s1">this</span><span class="s0">._generatedMappings,</span>
	      <span class="s2">&quot;generatedLine&quot;</span><span class="s0">,</span>
	      <span class="s2">&quot;generatedColumn&quot;</span><span class="s0">,</span>
	      <span class="s0">util.compareByGeneratedPositionsDeflated,</span>
	      <span class="s0">util.getArg(aArgs, </span><span class="s2">'bias'</span><span class="s0">, SourceMapConsumer.GREATEST_LOWER_BOUND)</span>
	    <span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index];</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.generatedLine === needle.generatedLine) {</span>
	        <span class="s1">var </span><span class="s0">source = util.getArg(mapping, </span><span class="s2">'source'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(source !== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">source = </span><span class="s1">this</span><span class="s0">._sources.at(source);</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">source = util.join(</span><span class="s1">this</span><span class="s0">.sourceRoot, source);</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	        <span class="s1">var </span><span class="s0">name = util.getArg(mapping, </span><span class="s2">'name'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
	        <span class="s1">if </span><span class="s0">(name !== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">name = </span><span class="s1">this</span><span class="s0">._names.at(name);</span>
	        <span class="s0">}</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s0">source: source,</span>
	          <span class="s0">line: util.getArg(mapping, </span><span class="s2">'originalLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s0">column: util.getArg(mapping, </span><span class="s2">'originalColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s0">name: name</span>
	        <span class="s0">};</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">source: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s0">column: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s0">name: </span><span class="s1">null</span>
	    <span class="s0">};</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Return true if we have the source content for every source in the source 
     * map, false otherwise. 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype.hasContentsOfAllSources =</span>
	  <span class="s1">function </span><span class="s0">BasicSourceMapConsumer_hasContentsOfAllSources() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.sourcesContent) {</span>
	      <span class="s1">return false</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">return this</span><span class="s0">.sourcesContent.length &gt;= </span><span class="s1">this</span><span class="s0">._sources.size() &amp;&amp;</span>
	      <span class="s0">!</span><span class="s1">this</span><span class="s0">.sourcesContent.some(</span><span class="s1">function </span><span class="s0">(sc) { </span><span class="s1">return </span><span class="s0">sc == </span><span class="s1">null</span><span class="s0">; });</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the original source content. The only argument is the url of the 
     * original source file. Returns null if no original source content is 
     * available. 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype.sourceContentFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.sourcesContent) {</span>
	      <span class="s1">return null</span><span class="s0">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">aSource = util.relative(</span><span class="s1">this</span><span class="s0">.sourceRoot, aSource);</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sources.has(aSource)) {</span>
	      <span class="s1">return this</span><span class="s0">.sourcesContent[</span><span class="s1">this</span><span class="s0">._sources.indexOf(aSource)];</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">url;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; (url = util.urlParse(</span><span class="s1">this</span><span class="s0">.sourceRoot))) {</span>
	      <span class="s3">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span>
	      <span class="s3">// many users. We can help them out when they expect file:// URIs to</span>
	      <span class="s3">// behave like it would if they were running a local HTTP server. See</span>
	      <span class="s3">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span>
	      <span class="s1">var </span><span class="s0">fileUriAbsPath = aSource.replace(/^file:\/\</span><span class="s3">//, &quot;&quot;);</span>
	      <span class="s1">if </span><span class="s0">(url.scheme == </span><span class="s2">&quot;file&quot;</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">._sources.has(fileUriAbsPath)) {</span>
	        <span class="s1">return this</span><span class="s0">.sourcesContent[</span><span class="s1">this</span><span class="s0">._sources.indexOf(fileUriAbsPath)]</span>
	      <span class="s0">}</span>
	
	      <span class="s1">if </span><span class="s0">((!url.path || url.path == </span><span class="s2">&quot;/&quot;</span><span class="s0">)</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">._sources.has(</span><span class="s2">&quot;/&quot; </span><span class="s0">+ aSource)) {</span>
	        <span class="s1">return this</span><span class="s0">.sourcesContent[</span><span class="s1">this</span><span class="s0">._sources.indexOf(</span><span class="s2">&quot;/&quot; </span><span class="s0">+ aSource)];</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s3">// This function is used recursively from</span>
	    <span class="s3">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span>
	    <span class="s3">// don't want to throw if we can't find the source - we just want to</span>
	    <span class="s3">// return null, so we provide a flag to exit gracefully.</span>
	    <span class="s1">if </span><span class="s0">(nullOnMissing) {</span>
	      <span class="s1">return null</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'&quot;' </span><span class="s0">+ aSource + </span><span class="s2">'&quot; is not in the SourceMap.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the generated line and column information for the original source, 
     * line, and column positions provided. The only argument is an object with 
     * the following properties: 
     * 
     *   - source: The filename of the original source. 
     *   - line: The line number in the original source. 
     *   - column: The column number in the original source. 
     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or 
     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the 
     *     closest element that is smaller than or greater than the one we are 
     *     searching for, respectively, if the exact element cannot be found. 
     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'. 
     * 
     * and an object is returned with the following properties: 
     * 
     *   - line: The line number in the generated source, or null. 
     *   - column: The column number in the generated source, or null. 
     */</span>
	<span class="s0">BasicSourceMapConsumer.prototype.generatedPositionFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_generatedPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">source = util.getArg(aArgs, </span><span class="s2">'source'</span><span class="s0">);</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">source = util.relative(</span><span class="s1">this</span><span class="s0">.sourceRoot, source);</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sources.has(source)) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">line: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s0">column: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s0">lastColumn: </span><span class="s1">null</span>
	      <span class="s0">};</span>
	    <span class="s0">}</span>
	    <span class="s0">source = </span><span class="s1">this</span><span class="s0">._sources.indexOf(source);</span>
	
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">source: source,</span>
	      <span class="s0">originalLine: util.getArg(aArgs, </span><span class="s2">'line'</span><span class="s0">),</span>
	      <span class="s0">originalColumn: util.getArg(aArgs, </span><span class="s2">'column'</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(</span>
	      <span class="s0">needle,</span>
	      <span class="s1">this</span><span class="s0">._originalMappings,</span>
	      <span class="s2">&quot;originalLine&quot;</span><span class="s0">,</span>
	      <span class="s2">&quot;originalColumn&quot;</span><span class="s0">,</span>
	      <span class="s0">util.compareByOriginalPositions,</span>
	      <span class="s0">util.getArg(aArgs, </span><span class="s2">'bias'</span><span class="s0">, SourceMapConsumer.GREATEST_LOWER_BOUND)</span>
	    <span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[index];</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.source === needle.source) {</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s0">line: util.getArg(mapping, </span><span class="s2">'generatedLine'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s0">column: util.getArg(mapping, </span><span class="s2">'generatedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">),</span>
	          <span class="s0">lastColumn: util.getArg(mapping, </span><span class="s2">'lastGeneratedColumn'</span><span class="s0">, </span><span class="s1">null</span><span class="s0">)</span>
	        <span class="s0">};</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s0">column: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s0">lastColumn: </span><span class="s1">null</span>
	    <span class="s0">};</span>
	  <span class="s0">};</span>
	
	<span class="s0">exports.BasicSourceMapConsumer = BasicSourceMapConsumer;</span>
	
	<span class="s3">/** 
     * An IndexedSourceMapConsumer instance represents a parsed source map which 
     * we can query for information. It differs from BasicSourceMapConsumer in 
     * that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as 
     * input. 
     * 
     * The only parameter is a raw source map (either as a JSON string, or already 
     * parsed to an object). According to the spec for indexed source maps, they 
     * have the following attributes: 
     * 
     *   - version: Which version of the source map spec this map is following. 
     *   - file: Optional. The generated file this source map is associated with. 
     *   - sections: A list of section definitions. 
     * 
     * Each value under the &quot;sections&quot; field has two fields: 
     *   - offset: The offset into the original specified at which this section 
     *       begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot; 
     *       field. 
     *   - map: A source map definition. This source map could also be indexed, 
     *       but doesn't have to be. 
     * 
     * Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field 
     * specifying a URL to retrieve a source map from, but that's currently 
     * unsupported. 
     * 
     * Here's an example source map, taken from the source map spec[0], but 
     * modified to omit a section which uses the &quot;url&quot; field. 
     * 
     *  { 
     *    version : 3, 
     *    file: &quot;app.js&quot;, 
     *    sections: [{ 
     *      offset: {line:100, column:10}, 
     *      map: { 
     *        version : 3, 
     *        file: &quot;section.js&quot;, 
     *        sources: [&quot;foo.js&quot;, &quot;bar.js&quot;], 
     *        names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;], 
     *        mappings: &quot;AAAA,E;;ABCDE;&quot; 
     *      } 
     *    }], 
     *  } 
     * 
     * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt 
     */</span>
	<span class="s1">function </span><span class="s0">IndexedSourceMapConsumer(aSourceMap) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s2">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}</span><span class="s2">'/, ''));</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">version = util.getArg(sourceMap, </span><span class="s2">'version'</span><span class="s0">);</span>
	  <span class="s1">var </span><span class="s0">sections = util.getArg(sourceMap, </span><span class="s2">'sections'</span><span class="s0">);</span>
	
	  <span class="s1">if </span><span class="s0">(version != </span><span class="s1">this</span><span class="s0">._version) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Unsupported version: ' </span><span class="s0">+ version);</span>
	  <span class="s0">}</span>
	
	  <span class="s1">this</span><span class="s0">._sources = </span><span class="s1">new </span><span class="s0">ArraySet();</span>
	  <span class="s1">this</span><span class="s0">._names = </span><span class="s1">new </span><span class="s0">ArraySet();</span>
	
	  <span class="s1">var </span><span class="s0">lastOffset = {</span>
	    <span class="s0">line: -</span><span class="s4">1</span><span class="s0">,</span>
	    <span class="s0">column: </span><span class="s4">0</span>
	  <span class="s0">};</span>
	  <span class="s1">this</span><span class="s0">._sections = sections.map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	    <span class="s1">if </span><span class="s0">(s.url) {</span>
	      <span class="s3">// The url field will require support for asynchronicity.</span>
	      <span class="s3">// See https://github.com/mozilla/source-map/issues/16</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Support for url field in sections not implemented.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s0">offset = util.getArg(s, </span><span class="s2">'offset'</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s0">offsetLine = util.getArg(offset, </span><span class="s2">'line'</span><span class="s0">);</span>
	    <span class="s1">var </span><span class="s0">offsetColumn = util.getArg(offset, </span><span class="s2">'column'</span><span class="s0">);</span>
	
	    <span class="s1">if </span><span class="s0">(offsetLine &lt; lastOffset.line ||</span>
	        <span class="s0">(offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'Section offsets must be ordered and non-overlapping.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	    <span class="s0">lastOffset = offset;</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">generatedOffset: {</span>
	        <span class="s3">// The offset fields are 0-based, but we use 1-based indices when</span>
	        <span class="s3">// encoding/decoding from VLQ.</span>
	        <span class="s0">generatedLine: offsetLine + </span><span class="s4">1</span><span class="s0">,</span>
	        <span class="s0">generatedColumn: offsetColumn + </span><span class="s4">1</span>
	      <span class="s0">},</span>
	      <span class="s0">consumer: </span><span class="s1">new </span><span class="s0">SourceMapConsumer(util.getArg(s, </span><span class="s2">'map'</span><span class="s0">))</span>
	    <span class="s0">}</span>
	  <span class="s0">});</span>
	<span class="s0">}</span>
	
	<span class="s0">IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;</span>
	
	<span class="s3">/** 
     * The version of the source mapping spec that we are consuming. 
     */</span>
	<span class="s0">IndexedSourceMapConsumer.prototype._version = </span><span class="s4">3</span><span class="s0">;</span>
	
	<span class="s3">/** 
     * The list of original sources. 
     */</span>
	<span class="s0">Object.defineProperty(IndexedSourceMapConsumer.prototype, </span><span class="s2">'sources'</span><span class="s0">, {</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">var </span><span class="s0">sources = [];</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">._sections.length; i++) {</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; </span><span class="s1">this</span><span class="s0">._sections[i].consumer.sources.length; j++) {</span>
	        <span class="s0">sources.push(</span><span class="s1">this</span><span class="s0">._sections[i].consumer.sources[j]);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s0">sources;</span>
	  <span class="s0">}</span>
	<span class="s0">});</span>
	
	<span class="s3">/** 
     * Returns the original source, line, and column information for the generated 
     * source's line and column positions provided. The only argument is an object 
     * with the following properties: 
     * 
     *   - line: The line number in the generated source. 
     *   - column: The column number in the generated source. 
     * 
     * and an object is returned with the following properties: 
     * 
     *   - source: The original source file, or null. 
     *   - line: The line number in the original source, or null. 
     *   - column: The column number in the original source, or null. 
     *   - name: The original identifier, or null. 
     */</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.originalPositionFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_originalPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">generatedLine: util.getArg(aArgs, </span><span class="s2">'line'</span><span class="s0">),</span>
	      <span class="s0">generatedColumn: util.getArg(aArgs, </span><span class="s2">'column'</span><span class="s0">)</span>
	    <span class="s0">};</span>
	
	    <span class="s3">// Find the section containing the generated position we're trying to map</span>
	    <span class="s3">// to an original position.</span>
	    <span class="s1">var </span><span class="s0">sectionIndex = binarySearch.search(needle, </span><span class="s1">this</span><span class="s0">._sections,</span>
	      <span class="s1">function</span><span class="s0">(needle, section) {</span>
	        <span class="s1">var </span><span class="s0">cmp = needle.generatedLine - section.generatedOffset.generatedLine;</span>
	        <span class="s1">if </span><span class="s0">(cmp) {</span>
	          <span class="s1">return </span><span class="s0">cmp;</span>
	        <span class="s0">}</span>
	
	        <span class="s1">return </span><span class="s0">(needle.generatedColumn -</span>
	                <span class="s0">section.generatedOffset.generatedColumn);</span>
	      <span class="s0">});</span>
	    <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[sectionIndex];</span>
	
	    <span class="s1">if </span><span class="s0">(!section) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">source: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s0">line: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s0">column: </span><span class="s1">null</span><span class="s0">,</span>
	        <span class="s0">name: </span><span class="s1">null</span>
	      <span class="s0">};</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">section.consumer.originalPositionFor({</span>
	      <span class="s0">line: needle.generatedLine -</span>
	        <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s4">1</span><span class="s0">),</span>
	      <span class="s0">column: needle.generatedColumn -</span>
	        <span class="s0">(section.generatedOffset.generatedLine === needle.generatedLine</span>
	         <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s4">1</span>
	         <span class="s0">: </span><span class="s4">0</span><span class="s0">),</span>
	      <span class="s0">bias: aArgs.bias</span>
	    <span class="s0">});</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Return true if we have the source content for every source in the source 
     * map, false otherwise. 
     */</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_hasContentsOfAllSources() {</span>
	    <span class="s1">return this</span><span class="s0">._sections.every(</span><span class="s1">function </span><span class="s0">(s) {</span>
	      <span class="s1">return </span><span class="s0">s.consumer.hasContentsOfAllSources();</span>
	    <span class="s0">});</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the original source content. The only argument is the url of the 
     * original source file. Returns null if no original source content is 
     * available. 
     */</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.sourceContentFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">._sections.length; i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i];</span>
	
	      <span class="s1">var </span><span class="s0">content = section.consumer.sourceContentFor(aSource, </span><span class="s1">true</span><span class="s0">);</span>
	      <span class="s1">if </span><span class="s0">(content) {</span>
	        <span class="s1">return </span><span class="s0">content;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(nullOnMissing) {</span>
	      <span class="s1">return null</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">'&quot;' </span><span class="s0">+ aSource + </span><span class="s2">'&quot; is not in the SourceMap.'</span><span class="s0">);</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the generated line and column information for the original source, 
     * line, and column positions provided. The only argument is an object with 
     * the following properties: 
     * 
     *   - source: The filename of the original source. 
     *   - line: The line number in the original source. 
     *   - column: The column number in the original source. 
     * 
     * and an object is returned with the following properties: 
     * 
     *   - line: The line number in the generated source, or null. 
     *   - column: The column number in the generated source, or null. 
     */</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.generatedPositionFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_generatedPositionFor(aArgs) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">._sections.length; i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i];</span>
	
	      <span class="s3">// Only consider this section if the requested source is in the list of</span>
	      <span class="s3">// sources of the consumer.</span>
	      <span class="s1">if </span><span class="s0">(section.consumer.sources.indexOf(util.getArg(aArgs, </span><span class="s2">'source'</span><span class="s0">)) === -</span><span class="s4">1</span><span class="s0">) {</span>
	        <span class="s1">continue</span><span class="s0">;</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s0">generatedPosition = section.consumer.generatedPositionFor(aArgs);</span>
	      <span class="s1">if </span><span class="s0">(generatedPosition) {</span>
	        <span class="s1">var </span><span class="s0">ret = {</span>
	          <span class="s0">line: generatedPosition.line +</span>
	            <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s4">1</span><span class="s0">),</span>
	          <span class="s0">column: generatedPosition.column +</span>
	            <span class="s0">(section.generatedOffset.generatedLine === generatedPosition.line</span>
	             <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s4">1</span>
	             <span class="s0">: </span><span class="s4">0</span><span class="s0">)</span>
	        <span class="s0">};</span>
	        <span class="s1">return </span><span class="s0">ret;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s0">,</span>
	      <span class="s0">column: </span><span class="s1">null</span>
	    <span class="s0">};</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Parse the mappings in a string in to a data structure which we can easily 
     * query (the ordered arrays in the `this.__generatedMappings` and 
     * `this.__originalMappings` properties). 
     */</span>
	<span class="s0">IndexedSourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {</span>
	    <span class="s1">this</span><span class="s0">.__generatedMappings = [];</span>
	    <span class="s1">this</span><span class="s0">.__originalMappings = [];</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">._sections.length; i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i];</span>
	      <span class="s1">var </span><span class="s0">sectionMappings = section.consumer._generatedMappings;</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; sectionMappings.length; j++) {</span>
	        <span class="s1">var </span><span class="s0">mapping = sectionMappings[j];</span>
	
	        <span class="s1">var </span><span class="s0">source = section.consumer._sources.at(mapping.source);</span>
	        <span class="s1">if </span><span class="s0">(section.consumer.sourceRoot !== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">source = util.join(section.consumer.sourceRoot, source);</span>
	        <span class="s0">}</span>
	        <span class="s1">this</span><span class="s0">._sources.add(source);</span>
	        <span class="s0">source = </span><span class="s1">this</span><span class="s0">._sources.indexOf(source);</span>
	
	        <span class="s1">var </span><span class="s0">name = section.consumer._names.at(mapping.name);</span>
	        <span class="s1">this</span><span class="s0">._names.add(name);</span>
	        <span class="s0">name = </span><span class="s1">this</span><span class="s0">._names.indexOf(name);</span>
	
	        <span class="s3">// The mappings coming from the consumer for the section have</span>
	        <span class="s3">// generated positions relative to the start of the section, so we</span>
	        <span class="s3">// need to offset them to be relative to the start of the concatenated</span>
	        <span class="s3">// generated file.</span>
	        <span class="s1">var </span><span class="s0">adjustedMapping = {</span>
	          <span class="s0">source: source,</span>
	          <span class="s0">generatedLine: mapping.generatedLine +</span>
	            <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s4">1</span><span class="s0">),</span>
	          <span class="s0">generatedColumn: mapping.generatedColumn +</span>
	            <span class="s0">(section.generatedOffset.generatedLine === mapping.generatedLine</span>
	            <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s4">1</span>
	            <span class="s0">: </span><span class="s4">0</span><span class="s0">),</span>
	          <span class="s0">originalLine: mapping.originalLine,</span>
	          <span class="s0">originalColumn: mapping.originalColumn,</span>
	          <span class="s0">name: name</span>
	        <span class="s0">};</span>
	
	        <span class="s1">this</span><span class="s0">.__generatedMappings.push(adjustedMapping);</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">adjustedMapping.originalLine === </span><span class="s2">'number'</span><span class="s0">) {</span>
	          <span class="s1">this</span><span class="s0">.__originalMappings.push(adjustedMapping);</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s0">quickSort(</span><span class="s1">this</span><span class="s0">.__generatedMappings, util.compareByGeneratedPositionsDeflated);</span>
	    <span class="s0">quickSort(</span><span class="s1">this</span><span class="s0">.__originalMappings, util.compareByOriginalPositions);</span>
	  <span class="s0">};</span>
	
	<span class="s0">exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 8 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s0">exports.GREATEST_LOWER_BOUND = </span><span class="s4">1</span><span class="s0">;</span>
	<span class="s0">exports.LEAST_UPPER_BOUND = </span><span class="s4">2</span><span class="s0">;</span>
	
	<span class="s3">/** 
     * Recursive implementation of binary search. 
     * 
     * @param aLow Indices here and lower do not contain the needle. 
     * @param aHigh Indices here and higher do not contain the needle. 
     * @param aNeedle The element being searched for. 
     * @param aHaystack The non-empty array being searched. 
     * @param aCompare Function which takes two elements and returns -1, 0, or 1. 
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or 
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the 
     *     closest element that is smaller than or greater than the one we are 
     *     searching for, respectively, if the exact element cannot be found. 
     */</span>
	<span class="s1">function </span><span class="s0">recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {</span>
	  <span class="s3">// This function terminates when one of the following is true:</span>
	  <span class="s3">//</span>
	  <span class="s3">//   1. We find the exact element we are looking for.</span>
	  <span class="s3">//</span>
	  <span class="s3">//   2. We did not find the exact element, but we can return the index of</span>
	  <span class="s3">//      the next-closest element.</span>
	  <span class="s3">//</span>
	  <span class="s3">//   3. We did not find the exact element, and there is no next-closest</span>
	  <span class="s3">//      element than the one we are searching for, so we return -1.</span>
	  <span class="s1">var </span><span class="s0">mid = Math.floor((aHigh - aLow) / </span><span class="s4">2</span><span class="s0">) + aLow;</span>
	  <span class="s1">var </span><span class="s0">cmp = aCompare(aNeedle, aHaystack[mid], </span><span class="s1">true</span><span class="s0">);</span>
	  <span class="s1">if </span><span class="s0">(cmp === </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s3">// Found the element we are looking for.</span>
	    <span class="s1">return </span><span class="s0">mid;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(cmp &gt; </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s3">// Our needle is greater than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(aHigh - mid &gt; </span><span class="s4">1</span><span class="s0">) {</span>
	      <span class="s3">// The element is in the upper half.</span>
	      <span class="s1">return </span><span class="s0">recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);</span>
	    <span class="s0">}</span>
	
	    <span class="s3">// The exact needle element was not found in this haystack. Determine if</span>
	    <span class="s3">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
	      <span class="s1">return </span><span class="s0">aHigh &lt; aHaystack.length ? aHigh : -</span><span class="s4">1</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s0">mid;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s3">// Our needle is less than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(mid - aLow &gt; </span><span class="s4">1</span><span class="s0">) {</span>
	      <span class="s3">// The element is in the lower half.</span>
	      <span class="s1">return </span><span class="s0">recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);</span>
	    <span class="s0">}</span>
	
	    <span class="s3">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
	      <span class="s1">return </span><span class="s0">mid;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s0">aLow &lt; </span><span class="s4">0 </span><span class="s0">? -</span><span class="s4">1 </span><span class="s0">: aLow;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * This is an implementation of binary search which will always try and return 
     * the index of the closest element if there is no exact hit. This is because 
     * mappings between original and generated line/col pairs are single points, 
     * and there is an implicit region between each of them, so a miss just means 
     * that you aren't on the very start of a region. 
     * 
     * @param aNeedle The element you are looking for. 
     * @param aHaystack The array that is being searched. 
     * @param aCompare A function which takes the needle and an element in the 
     *     array and returns -1, 0, or 1 depending on whether the needle is less 
     *     than, equal to, or greater than the element, respectively. 
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or 
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the 
     *     closest element that is smaller than or greater than the one we are 
     *     searching for, respectively, if the exact element cannot be found. 
     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'. 
     */</span>
	<span class="s0">exports.search = </span><span class="s1">function </span><span class="s0">search(aNeedle, aHaystack, aCompare, aBias) {</span>
	  <span class="s1">if </span><span class="s0">(aHaystack.length === </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">index = recursiveSearch(-</span><span class="s4">1</span><span class="s0">, aHaystack.length, aNeedle, aHaystack,</span>
	                              <span class="s0">aCompare, aBias || exports.GREATEST_LOWER_BOUND);</span>
	  <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
	  <span class="s0">}</span>
	
	  <span class="s3">// We have found either the exact element, or the next-closest element than</span>
	  <span class="s3">// the one we are searching for. However, there may be more than one such</span>
	  <span class="s3">// element. Make sure we always return the smallest of these.</span>
	  <span class="s1">while </span><span class="s0">(index - </span><span class="s4">1 </span><span class="s0">&gt;= </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(aCompare(aHaystack[index], aHaystack[index - </span><span class="s4">1</span><span class="s0">], </span><span class="s1">true</span><span class="s0">) !== </span><span class="s4">0</span><span class="s0">) {</span>
	      <span class="s1">break</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s0">--index;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">index;</span>
	<span class="s0">};</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 9 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s3">// It turns out that some (most?) JavaScript engines don't self-host</span>
	<span class="s3">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span>
	<span class="s3">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span>
	<span class="s3">// custom comparator function, calling back and forth between the VM's C++ and</span>
	<span class="s3">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span>
	<span class="s3">// worse generated code for the comparator function than would be optimal. In</span>
	<span class="s3">// fact, when sorting with a comparator, these costs outweigh the benefits of</span>
	<span class="s3">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span>
	<span class="s3">// a ~3500ms mean speed-up in `bench/bench.html`.</span>
	
	<span class="s3">/** 
     * Swap the elements indexed by `x` and `y` in the array `ary`. 
     * 
     * @param {Array} ary 
     *        The array. 
     * @param {Number} x 
     *        The index of the first item. 
     * @param {Number} y 
     *        The index of the second item. 
     */</span>
	<span class="s1">function </span><span class="s0">swap(ary, x, y) {</span>
	  <span class="s1">var </span><span class="s0">temp = ary[x];</span>
	  <span class="s0">ary[x] = ary[y];</span>
	  <span class="s0">ary[y] = temp;</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Returns a random integer within the range `low .. high` inclusive. 
     * 
     * @param {Number} low 
     *        The lower bound on the range. 
     * @param {Number} high 
     *        The upper bound on the range. 
     */</span>
	<span class="s1">function </span><span class="s0">randomIntInRange(low, high) {</span>
	  <span class="s1">return </span><span class="s0">Math.round(low + (Math.random() * (high - low)));</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * The Quick Sort algorithm. 
     * 
     * @param {Array} ary 
     *        An array to sort. 
     * @param {function} comparator 
     *        Function to use to compare two items. 
     * @param {Number} p 
     *        Start index of the array 
     * @param {Number} r 
     *        End index of the array 
     */</span>
	<span class="s1">function </span><span class="s0">doQuickSort(ary, comparator, p, r) {</span>
	  <span class="s3">// If our lower bound is less than our upper bound, we (1) partition the</span>
	  <span class="s3">// array into two pieces and (2) recurse on each half. If it is not, this is</span>
	  <span class="s3">// the empty array and our base case.</span>
	
	  <span class="s1">if </span><span class="s0">(p &lt; r) {</span>
	    <span class="s3">// (1) Partitioning.</span>
	    <span class="s3">//</span>
	    <span class="s3">// The partitioning chooses a pivot between `p` and `r` and moves all</span>
	    <span class="s3">// elements that are less than or equal to the pivot to the before it, and</span>
	    <span class="s3">// all the elements that are greater than it after it. The effect is that</span>
	    <span class="s3">// once partition is done, the pivot is in the exact place it will be when</span>
	    <span class="s3">// the array is put in sorted order, and it will not need to be moved</span>
	    <span class="s3">// again. This runs in O(n) time.</span>
	
	    <span class="s3">// Always choose a random pivot so that an input array which is reverse</span>
	    <span class="s3">// sorted does not cause O(n^2) running time.</span>
	    <span class="s1">var </span><span class="s0">pivotIndex = randomIntInRange(p, r);</span>
	    <span class="s1">var </span><span class="s0">i = p - </span><span class="s4">1</span><span class="s0">;</span>
	
	    <span class="s0">swap(ary, pivotIndex, r);</span>
	    <span class="s1">var </span><span class="s0">pivot = ary[r];</span>
	
	    <span class="s3">// Immediately after `j` is incremented in this loop, the following hold</span>
	    <span class="s3">// true:</span>
	    <span class="s3">//</span>
	    <span class="s3">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span>
	    <span class="s3">//</span>
	    <span class="s3">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = p; j &lt; r; j++) {</span>
	      <span class="s1">if </span><span class="s0">(comparator(ary[j], pivot) &lt;= </span><span class="s4">0</span><span class="s0">) {</span>
	        <span class="s0">i += </span><span class="s4">1</span><span class="s0">;</span>
	        <span class="s0">swap(ary, i, j);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s0">swap(ary, i + </span><span class="s4">1</span><span class="s0">, j);</span>
	    <span class="s1">var </span><span class="s0">q = i + </span><span class="s4">1</span><span class="s0">;</span>
	
	    <span class="s3">// (2) Recurse on each half.</span>
	
	    <span class="s0">doQuickSort(ary, comparator, p, q - </span><span class="s4">1</span><span class="s0">);</span>
	    <span class="s0">doQuickSort(ary, comparator, q + </span><span class="s4">1</span><span class="s0">, r);</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Sort the given array in-place with the given comparator function. 
     * 
     * @param {Array} ary 
     *        An array to sort. 
     * @param {function} comparator 
     *        Function to use to compare two items. 
     */</span>
	<span class="s0">exports.quickSort = </span><span class="s1">function </span><span class="s0">(ary, comparator) {</span>
	  <span class="s0">doQuickSort(ary, comparator, </span><span class="s4">0</span><span class="s0">, ary.length - </span><span class="s4">1</span><span class="s0">);</span>
	<span class="s0">};</span>


<span class="s3">/***/ </span><span class="s0">}),</span>
<span class="s3">/* 10 */</span>
<span class="s3">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module, exports, __webpack_require__) {</span>

	<span class="s3">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s3">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">SourceMapGenerator = __webpack_require__(</span><span class="s4">1</span><span class="s0">).SourceMapGenerator;</span>
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s4">4</span><span class="s0">);</span>
	
	<span class="s3">// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other</span>
	<span class="s3">// operating systems these days (capturing the result).</span>
	<span class="s1">var </span><span class="s0">REGEX_NEWLINE = /(\r?\n)/;</span>
	
	<span class="s3">// Newline character code for charCodeAt() comparisons</span>
	<span class="s1">var </span><span class="s0">NEWLINE_CODE = </span><span class="s4">10</span><span class="s0">;</span>
	
	<span class="s3">// Private symbol for identifying `SourceNode`s when multiple versions of</span>
	<span class="s3">// the source-map library are loaded. This MUST NOT CHANGE across</span>
	<span class="s3">// versions!</span>
	<span class="s1">var </span><span class="s0">isSourceNode = </span><span class="s2">&quot;$$$isSourceNode$$$&quot;</span><span class="s0">;</span>
	
	<span class="s3">/** 
     * SourceNodes provide a way to abstract over interpolating/concatenating 
     * snippets of generated JavaScript source code while maintaining the line and 
     * column information associated with the original source code. 
     * 
     * @param aLine The original line number. 
     * @param aColumn The original column number. 
     * @param aSource The original source's filename. 
     * @param aChunks Optional. An array of strings which are snippets of 
     *        generated JS, or other SourceNodes. 
     * @param aName The original identifier. 
     */</span>
	<span class="s1">function </span><span class="s0">SourceNode(aLine, aColumn, aSource, aChunks, aName) {</span>
	  <span class="s1">this</span><span class="s0">.children = [];</span>
	  <span class="s1">this</span><span class="s0">.sourceContents = {};</span>
	  <span class="s1">this</span><span class="s0">.line = aLine == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aLine;</span>
	  <span class="s1">this</span><span class="s0">.column = aColumn == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aColumn;</span>
	  <span class="s1">this</span><span class="s0">.source = aSource == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aSource;</span>
	  <span class="s1">this</span><span class="s0">.name = aName == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aName;</span>
	  <span class="s1">this</span><span class="s0">[isSourceNode] = </span><span class="s1">true</span><span class="s0">;</span>
	  <span class="s1">if </span><span class="s0">(aChunks != </span><span class="s1">null</span><span class="s0">) </span><span class="s1">this</span><span class="s0">.add(aChunks);</span>
	<span class="s0">}</span>
	
	<span class="s3">/** 
     * Creates a SourceNode from generated code and a SourceMapConsumer. 
     * 
     * @param aGeneratedCode The generated code 
     * @param aSourceMapConsumer The SourceMap for the generated code 
     * @param aRelativePath Optional. The path that relative sources in the 
     *        SourceMapConsumer should be relative to. 
     */</span>
	<span class="s0">SourceNode.fromStringWithSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {</span>
	    <span class="s3">// The SourceNode we want to fill with the generated code</span>
	    <span class="s3">// and the SourceMap</span>
	    <span class="s1">var </span><span class="s0">node = </span><span class="s1">new </span><span class="s0">SourceNode();</span>
	
	    <span class="s3">// All even indices of this array are one line of the generated code,</span>
	    <span class="s3">// while all odd indices are the newlines between two adjacent lines</span>
	    <span class="s3">// (since `REGEX_NEWLINE` captures its match).</span>
	    <span class="s3">// Processed fragments are accessed by calling `shiftNextLine`.</span>
	    <span class="s1">var </span><span class="s0">remainingLines = aGeneratedCode.split(REGEX_NEWLINE);</span>
	    <span class="s1">var </span><span class="s0">remainingLinesIndex = </span><span class="s4">0</span><span class="s0">;</span>
	    <span class="s1">var </span><span class="s0">shiftNextLine = </span><span class="s1">function</span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s0">lineContents = getNextLine();</span>
	      <span class="s3">// The last line of a file might not have a newline.</span>
	      <span class="s1">var </span><span class="s0">newLine = getNextLine() || </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	      <span class="s1">return </span><span class="s0">lineContents + newLine;</span>
	
	      <span class="s1">function </span><span class="s0">getNextLine() {</span>
	        <span class="s1">return </span><span class="s0">remainingLinesIndex &lt; remainingLines.length ?</span>
	            <span class="s0">remainingLines[remainingLinesIndex++] : undefined;</span>
	      <span class="s0">}</span>
	    <span class="s0">};</span>
	
	    <span class="s3">// We need to remember the position of &quot;remainingLines&quot;</span>
	    <span class="s1">var </span><span class="s0">lastGeneratedLine = </span><span class="s4">1</span><span class="s0">, lastGeneratedColumn = </span><span class="s4">0</span><span class="s0">;</span>
	
	    <span class="s3">// The generate SourceNodes we need a code range.</span>
	    <span class="s3">// To extract it current and last mapping is used.</span>
	    <span class="s3">// Here we store the last mapping.</span>
	    <span class="s1">var </span><span class="s0">lastMapping = </span><span class="s1">null</span><span class="s0">;</span>
	
	    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">if </span><span class="s0">(lastMapping !== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s3">// We add the code from &quot;lastMapping&quot; to &quot;mapping&quot;:</span>
	        <span class="s3">// First check if there is a new line in between.</span>
	        <span class="s1">if </span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine) {</span>
	          <span class="s3">// Associate first line with &quot;lastMapping&quot;</span>
	          <span class="s0">addMappingWithCode(lastMapping, shiftNextLine());</span>
	          <span class="s0">lastGeneratedLine++;</span>
	          <span class="s0">lastGeneratedColumn = </span><span class="s4">0</span><span class="s0">;</span>
	          <span class="s3">// The remaining code is added without mapping</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s3">// There is no new line in between.</span>
	          <span class="s3">// Associate the code between &quot;lastGeneratedColumn&quot; and</span>
	          <span class="s3">// &quot;mapping.generatedColumn&quot; with &quot;lastMapping&quot;</span>
	          <span class="s1">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex];</span>
	          <span class="s1">var </span><span class="s0">code = nextLine.substr(</span><span class="s4">0</span><span class="s0">, mapping.generatedColumn -</span>
	                                        <span class="s0">lastGeneratedColumn);</span>
	          <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -</span>
	                                              <span class="s0">lastGeneratedColumn);</span>
	          <span class="s0">lastGeneratedColumn = mapping.generatedColumn;</span>
	          <span class="s0">addMappingWithCode(lastMapping, code);</span>
	          <span class="s3">// No more remaining code, continue</span>
	          <span class="s0">lastMapping = mapping;</span>
	          <span class="s1">return</span><span class="s0">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s3">// We add the generated code until the first mapping</span>
	      <span class="s3">// to the SourceNode without any mapping.</span>
	      <span class="s3">// Each line is added as separate string.</span>
	      <span class="s1">while </span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine) {</span>
	        <span class="s0">node.add(shiftNextLine());</span>
	        <span class="s0">lastGeneratedLine++;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(lastGeneratedColumn &lt; mapping.generatedColumn) {</span>
	        <span class="s1">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex];</span>
	        <span class="s0">node.add(nextLine.substr(</span><span class="s4">0</span><span class="s0">, mapping.generatedColumn));</span>
	        <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);</span>
	        <span class="s0">lastGeneratedColumn = mapping.generatedColumn;</span>
	      <span class="s0">}</span>
	      <span class="s0">lastMapping = mapping;</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	    <span class="s3">// We have processed all mappings.</span>
	    <span class="s1">if </span><span class="s0">(remainingLinesIndex &lt; remainingLines.length) {</span>
	      <span class="s1">if </span><span class="s0">(lastMapping) {</span>
	        <span class="s3">// Associate the remaining code in the current line with &quot;lastMapping&quot;</span>
	        <span class="s0">addMappingWithCode(lastMapping, shiftNextLine());</span>
	      <span class="s0">}</span>
	      <span class="s3">// and add the remaining lines without any mapping</span>
	      <span class="s0">node.add(remainingLines.splice(remainingLinesIndex).join(</span><span class="s2">&quot;&quot;</span><span class="s0">));</span>
	    <span class="s0">}</span>
	
	    <span class="s3">// Copy sourcesContent into SourceNode</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile);</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(aRelativePath != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.join(aRelativePath, sourceFile);</span>
	        <span class="s0">}</span>
	        <span class="s0">node.setSourceContent(sourceFile, content);</span>
	      <span class="s0">}</span>
	    <span class="s0">});</span>
	
	    <span class="s1">return </span><span class="s0">node;</span>
	
	    <span class="s1">function </span><span class="s0">addMappingWithCode(mapping, code) {</span>
	      <span class="s1">if </span><span class="s0">(mapping === </span><span class="s1">null </span><span class="s0">|| mapping.source === undefined) {</span>
	        <span class="s0">node.add(code);</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s0">source = aRelativePath</span>
	          <span class="s0">? util.join(aRelativePath, mapping.source)</span>
	          <span class="s0">: mapping.source;</span>
	        <span class="s0">node.add(</span><span class="s1">new </span><span class="s0">SourceNode(mapping.originalLine,</span>
	                                <span class="s0">mapping.originalColumn,</span>
	                                <span class="s0">source,</span>
	                                <span class="s0">code,</span>
	                                <span class="s0">mapping.name));</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Add a chunk of generated JS to this source node. 
     * 
     * @param aChunk A string snippet of generated JS code, another instance of 
     *        SourceNode, or an array where each member is one of those things. 
     */</span>
	<span class="s0">SourceNode.prototype.add = </span><span class="s1">function </span><span class="s0">SourceNode_add(aChunk) {</span>
	  <span class="s1">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
	    <span class="s0">aChunk.forEach(</span><span class="s1">function </span><span class="s0">(chunk) {</span>
	      <span class="s1">this</span><span class="s0">.add(chunk);</span>
	    <span class="s0">}, </span><span class="s1">this</span><span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s1">typeof </span><span class="s0">aChunk === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(aChunk) {</span>
	      <span class="s1">this</span><span class="s0">.children.push(aChunk);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">TypeError(</span>
	      <span class="s2">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk</span>
	    <span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Add a chunk of generated JS to the beginning of this source node. 
     * 
     * @param aChunk A string snippet of generated JS code, another instance of 
     *        SourceNode, or an array where each member is one of those things. 
     */</span>
	<span class="s0">SourceNode.prototype.prepend = </span><span class="s1">function </span><span class="s0">SourceNode_prepend(aChunk) {</span>
	  <span class="s1">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = aChunk.length-1; i &gt;= </span><span class="s4">0</span><span class="s0">; i--) {</span>
	      <span class="s1">this</span><span class="s0">.prepend(aChunk[i]);</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s1">typeof </span><span class="s0">aChunk === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.children.unshift(aChunk);</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">TypeError(</span>
	      <span class="s2">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk</span>
	    <span class="s0">);</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Walk over the tree of JS snippets in this node and its children. The 
     * walking function is called once for each snippet of JS and is passed that 
     * snippet and the its original associated source's line/column location. 
     * 
     * @param aFn The traversal function. 
     */</span>
	<span class="s0">SourceNode.prototype.walk = </span><span class="s1">function </span><span class="s0">SourceNode_walk(aFn) {</span>
	  <span class="s1">var </span><span class="s0">chunk;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = </span><span class="s1">this</span><span class="s0">.children.length; i &lt; len; i++) {</span>
	    <span class="s0">chunk = </span><span class="s1">this</span><span class="s0">.children[i];</span>
	    <span class="s1">if </span><span class="s0">(chunk[isSourceNode]) {</span>
	      <span class="s0">chunk.walk(aFn);</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">if </span><span class="s0">(chunk !== </span><span class="s2">''</span><span class="s0">) {</span>
	        <span class="s0">aFn(chunk, { source: </span><span class="s1">this</span><span class="s0">.source,</span>
	                     <span class="s0">line: </span><span class="s1">this</span><span class="s0">.line,</span>
	                     <span class="s0">column: </span><span class="s1">this</span><span class="s0">.column,</span>
	                     <span class="s0">name: </span><span class="s1">this</span><span class="s0">.name });</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between 
     * each of `this.children`. 
     * 
     * @param aSep The separator. 
     */</span>
	<span class="s0">SourceNode.prototype.join = </span><span class="s1">function </span><span class="s0">SourceNode_join(aSep) {</span>
	  <span class="s1">var </span><span class="s0">newChildren;</span>
	  <span class="s1">var </span><span class="s0">i;</span>
	  <span class="s1">var </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">.children.length;</span>
	  <span class="s1">if </span><span class="s0">(len &gt; </span><span class="s4">0</span><span class="s0">) {</span>
	    <span class="s0">newChildren = [];</span>
	    <span class="s1">for </span><span class="s0">(i = </span><span class="s4">0</span><span class="s0">; i &lt; len-1; i++) {</span>
	      <span class="s0">newChildren.push(</span><span class="s1">this</span><span class="s0">.children[i]);</span>
	      <span class="s0">newChildren.push(aSep);</span>
	    <span class="s0">}</span>
	    <span class="s0">newChildren.push(</span><span class="s1">this</span><span class="s0">.children[i]);</span>
	    <span class="s1">this</span><span class="s0">.children = newChildren;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Call String.prototype.replace on the very right-most source snippet. Useful 
     * for trimming whitespace from the end of a source node, etc. 
     * 
     * @param aPattern The pattern to replace. 
     * @param aReplacement The thing to replace the pattern with. 
     */</span>
	<span class="s0">SourceNode.prototype.replaceRight = </span><span class="s1">function </span><span class="s0">SourceNode_replaceRight(aPattern, aReplacement) {</span>
	  <span class="s1">var </span><span class="s0">lastChild = </span><span class="s1">this</span><span class="s0">.children[</span><span class="s1">this</span><span class="s0">.children.length - </span><span class="s4">1</span><span class="s0">];</span>
	  <span class="s1">if </span><span class="s0">(lastChild[isSourceNode]) {</span>
	    <span class="s0">lastChild.replaceRight(aPattern, aReplacement);</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">lastChild === </span><span class="s2">'string'</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.children[</span><span class="s1">this</span><span class="s0">.children.length - </span><span class="s4">1</span><span class="s0">] = lastChild.replace(aPattern, aReplacement);</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">.children.push(</span><span class="s2">''</span><span class="s0">.replace(aPattern, aReplacement));</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Set the source content for a source file. This will be added to the SourceMapGenerator 
     * in the sourcesContent field. 
     * 
     * @param aSourceFile The filename of the source file 
     * @param aSourceContent The content of the source file 
     */</span>
	<span class="s0">SourceNode.prototype.setSourceContent =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_setSourceContent(aSourceFile, aSourceContent) {</span>
	    <span class="s1">this</span><span class="s0">.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Walk over the tree of SourceNodes. The walking function is called for each 
     * source file content and is passed the filename and source content. 
     * 
     * @param aFn The traversal function. 
     */</span>
	<span class="s0">SourceNode.prototype.walkSourceContents =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_walkSourceContents(aFn) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = </span><span class="s1">this</span><span class="s0">.children.length; i &lt; len; i++) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.children[i][isSourceNode]) {</span>
	        <span class="s1">this</span><span class="s0">.children[i].walkSourceContents(aFn);</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">sources = Object.keys(</span><span class="s1">this</span><span class="s0">.sourceContents);</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = sources.length; i &lt; len; i++) {</span>
	      <span class="s0">aFn(util.fromSetString(sources[i]), </span><span class="s1">this</span><span class="s0">.sourceContents[sources[i]]);</span>
	    <span class="s0">}</span>
	  <span class="s0">};</span>
	
	<span class="s3">/** 
     * Return the string representation of this source node. Walks over the tree 
     * and concatenates all the various snippets together to one string. 
     */</span>
	<span class="s0">SourceNode.prototype.toString = </span><span class="s1">function </span><span class="s0">SourceNode_toString() {</span>
	  <span class="s1">var </span><span class="s0">str = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">function </span><span class="s0">(chunk) {</span>
	    <span class="s0">str += chunk;</span>
	  <span class="s0">});</span>
	  <span class="s1">return </span><span class="s0">str;</span>
	<span class="s0">};</span>
	
	<span class="s3">/** 
     * Returns the string representation of this source node along with a source 
     * map. 
     */</span>
	<span class="s0">SourceNode.prototype.toStringWithSourceMap = </span><span class="s1">function </span><span class="s0">SourceNode_toStringWithSourceMap(aArgs) {</span>
	  <span class="s1">var </span><span class="s0">generated = {</span>
	    <span class="s0">code: </span><span class="s2">&quot;&quot;</span><span class="s0">,</span>
	    <span class="s0">line: </span><span class="s4">1</span><span class="s0">,</span>
	    <span class="s0">column: </span><span class="s4">0</span>
	  <span class="s0">};</span>
	  <span class="s1">var </span><span class="s0">map = </span><span class="s1">new </span><span class="s0">SourceMapGenerator(aArgs);</span>
	  <span class="s1">var </span><span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalLine = </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalColumn = </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalName = </span><span class="s1">null</span><span class="s0">;</span>
	  <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">function </span><span class="s0">(chunk, original) {</span>
	    <span class="s0">generated.code += chunk;</span>
	    <span class="s1">if </span><span class="s0">(original.source !== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; original.line !== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; original.column !== </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if</span><span class="s0">(lastOriginalSource !== original.source</span>
	         <span class="s0">|| lastOriginalLine !== original.line</span>
	         <span class="s0">|| lastOriginalColumn !== original.column</span>
	         <span class="s0">|| lastOriginalName !== original.name) {</span>
	        <span class="s0">map.addMapping({</span>
	          <span class="s0">source: original.source,</span>
	          <span class="s0">original: {</span>
	            <span class="s0">line: original.line,</span>
	            <span class="s0">column: original.column</span>
	          <span class="s0">},</span>
	          <span class="s0">generated: {</span>
	            <span class="s0">line: generated.line,</span>
	            <span class="s0">column: generated.column</span>
	          <span class="s0">},</span>
	          <span class="s0">name: original.name</span>
	        <span class="s0">});</span>
	      <span class="s0">}</span>
	      <span class="s0">lastOriginalSource = original.source;</span>
	      <span class="s0">lastOriginalLine = original.line;</span>
	      <span class="s0">lastOriginalColumn = original.column;</span>
	      <span class="s0">lastOriginalName = original.name;</span>
	      <span class="s0">sourceMappingActive = </span><span class="s1">true</span><span class="s0">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sourceMappingActive) {</span>
	      <span class="s0">map.addMapping({</span>
	        <span class="s0">generated: {</span>
	          <span class="s0">line: generated.line,</span>
	          <span class="s0">column: generated.column</span>
	        <span class="s0">}</span>
	      <span class="s0">});</span>
	      <span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s0">;</span>
	      <span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s0">;</span>
	    <span class="s0">}</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">idx = </span><span class="s4">0</span><span class="s0">, length = chunk.length; idx &lt; length; idx++) {</span>
	      <span class="s1">if </span><span class="s0">(chunk.charCodeAt(idx) === NEWLINE_CODE) {</span>
	        <span class="s0">generated.line++;</span>
	        <span class="s0">generated.column = </span><span class="s4">0</span><span class="s0">;</span>
	        <span class="s3">// Mappings end at eol</span>
	        <span class="s1">if </span><span class="s0">(idx + </span><span class="s4">1 </span><span class="s0">=== length) {</span>
	          <span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s0">;</span>
	          <span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s0">;</span>
	        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sourceMappingActive) {</span>
	          <span class="s0">map.addMapping({</span>
	            <span class="s0">source: original.source,</span>
	            <span class="s0">original: {</span>
	              <span class="s0">line: original.line,</span>
	              <span class="s0">column: original.column</span>
	            <span class="s0">},</span>
	            <span class="s0">generated: {</span>
	              <span class="s0">line: generated.line,</span>
	              <span class="s0">column: generated.column</span>
	            <span class="s0">},</span>
	            <span class="s0">name: original.name</span>
	          <span class="s0">});</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">generated.column++;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">});</span>
	  <span class="s1">this</span><span class="s0">.walkSourceContents(</span><span class="s1">function </span><span class="s0">(sourceFile, sourceContent) {</span>
	    <span class="s0">map.setSourceContent(sourceFile, sourceContent);</span>
	  <span class="s0">});</span>
	
	  <span class="s1">return </span><span class="s0">{ code: generated.code, map: map };</span>
	<span class="s0">};</span>
	
	<span class="s0">exports.SourceNode = SourceNode;</span>


<span class="s3">/***/ </span><span class="s0">})</span>
<span class="s3">/******/ </span><span class="s0">])</span>
<span class="s0">});</span>
<span class="s0">;</span>
<span class="s3">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBlNDczOGZjNzJhN2IyMzAzOTg4OSIsIndlYnBhY2s6Ly8vLi9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9hcnJheS1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL21hcHBpbmctbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc291cmNlLW5vZGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL1pBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRDtBQUMzRCxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7Ozs7Ozs7QUMzSUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCLGlCQUFnQjs7QUFFaEIsb0JBQW1CO0FBQ25CLHFCQUFvQjs7QUFFcEIsaUJBQWdCO0FBQ2hCLGlCQUFnQjs7QUFFaEIsaUJBQWdCO0FBQ2hCLGtCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsRUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoYUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hIQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlFQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHdDQUF3QztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLG1CQUFtQixFQUFFO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixNQUFNO0FBQ25DO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNEO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwyQkFBMkI7QUFDOUMsc0JBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBLHNCQUFxQiw0QkFBNEI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDempDQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzlHQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQSxZQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQSxZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pIQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFlBQVc7QUFDWDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7O0FBRUgsV0FBVTtBQUNWOztBQUVBIiwiZmlsZSI6InNvdXJjZS1tYXAuZGVidWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJzb3VyY2VNYXBcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wic291cmNlTWFwXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGU0NzM4ZmM3MmE3YjIzMDM5ODg5IiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAvLyBXaGVuIGFPcmlnaW5hbCBpcyB0cnV0aHkgYnV0IGhhcyBlbXB0eSB2YWx1ZXMgZm9yIC5saW5lIGFuZCAuY29sdW1uLFxuICAgIC8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuICAgIC8vIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgdG8gdHJ5IHRvIGd1aWRlIHRoZW0gdGhlIHJpZ2h0IHdheS5cbiAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci1idW5kbGVyL3B1bGwvNTE5XG4gICAgaWYgKGFPcmlnaW5hbCAmJiB0eXBlb2YgYU9yaWdpbmFsLmxpbmUgIT09ICdudW1iZXInICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCAnICtcbiAgICAgICAgICAgICd0aGUgb3JpZ2luYWwgbWFwcGluZyBlbnRpcmVseSBhbmQgb25seSBtYXAgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi4gSWYgc28sIHBhc3MgJyArXG4gICAgICAgICAgICAnbnVsbCBmb3IgdGhlIG9yaWdpbmFsIG1hcHBpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBlbXB0eSBvciBudWxsIHZhbHVlcy4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvYmFzZTY0LXZscS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvYmFzZTY0LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gIH1cbn1cbmV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG52YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgISFhUGF0aC5tYXRjaCh1cmxSZWdleHApO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzTmF0aXZlTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gaGFzTmF0aXZlTWFwID8gbmV3IE1hcCgpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcClcbiAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCk7XG59XG5cblNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwKSB7XG4gIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCk7XG59XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMobmVlZGxlLnNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihuZWVkbGUuc291cmNlKTtcblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKSB7XG4gICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgIH0sIHRoaXMpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhhU291cmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgfVxuXG4gICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG5leHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAqIGlucHV0LlxuICpcbiAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSlcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICB9KTtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgIDogMCksXG4gICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlcy5pbmRleE9mKHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgOiAwKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc291cmNlLW1hcC1jb25zdW1lci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvYmluYXJ5LXNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvcXVpY2stc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgYWNjZXNzZWQgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gZ2V0TmV4dExpbmUoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF07XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zcGxpY2UocmVtYWluaW5nTGluZXNJbmRleCkuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc291cmNlLW5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=</span></pre>
</body>
</html>
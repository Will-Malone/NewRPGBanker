<html>
<head>
<title>ast-spec.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #a9b7c6;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ast-spec.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/********************************************** 
 *      DO NOT MODIFY THIS FILE MANUALLY      * 
 *                                            * 
 *  THIS FILE HAS BEEN COPIED FROM ast-spec.  * 
 * ANY CHANGES WILL BE LOST ON THE NEXT BUILD * 
 *                                            * 
 *   MAKE CHANGES TO ast-spec AND THEN RUN    * 
 *                 yarn build                 * 
 **********************************************/</span>
<span class="s2">import </span><span class="s1">{ </span><span class="s3">SyntaxKind </span><span class="s1">} </span><span class="s2">from </span><span class="s4">'typescript'</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">Accessibility </span><span class="s2">= </span><span class="s4">'private' </span><span class="s2">| </span><span class="s4">'protected' </span><span class="s2">| </span><span class="s4">'public'</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">AccessorProperty </span><span class="s2">= </span><span class="s3">AccessorPropertyComputedName </span><span class="s2">| </span><span class="s3">AccessorPropertyNonComputedName</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">AccessorPropertyComputedName </span><span class="s2">extends </span><span class="s3">PropertyDefinitionComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">AccessorProperty</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">AccessorPropertyNonComputedName </span><span class="s2">extends </span><span class="s3">PropertyDefinitionNonComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">AccessorProperty</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ArrayExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ArrayExpression</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* an element will be `null` in the case of a sparse array: `[1, ,3]` 
     */</span>
    <span class="s1">elements</span><span class="s2">: </span><span class="s1">(</span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">SpreadElement </span><span class="s2">| </span><span class="s3">null</span><span class="s1">)[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ArrayPattern </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ArrayPattern</span><span class="s1">;</span>
    <span class="s1">elements</span><span class="s2">: </span><span class="s1">(</span><span class="s3">DestructuringPattern </span><span class="s2">| </span><span class="s3">null</span><span class="s1">)[];</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ArrowFunctionExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ArrowFunctionExpression</span><span class="s1">;</span>
    <span class="s1">generator</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s3">Parameter</span><span class="s1">[];</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">BlockStatement </span><span class="s2">| </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">async</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">returnType</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">AssignmentExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">AssignmentExpression</span><span class="s1">;</span>
    <span class="s1">operator</span><span class="s2">: </span><span class="s3">ValueOf</span><span class="s1">&lt;</span><span class="s3">AssignmentOperatorToText</span><span class="s1">&gt;;</span>
    <span class="s1">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">AssignmentOperatorToText </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'+='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'-='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'*='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskAsteriskEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'**='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SlashEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'/='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PercentEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'%='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanLessThanEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&lt;&lt;='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&gt;&gt;='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanGreaterThanEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&gt;&gt;&gt;='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&amp;='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'|='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarBarEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'||='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandAmpersandEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&amp;&amp;='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionQuestionEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'??='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaretEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'^='</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">AssignmentPattern </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">AssignmentPattern</span><span class="s1">;</span>
    <span class="s1">left</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">;</span>
    <span class="s1">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare enum </span><span class="s3">AST_NODE_TYPES </span><span class="s1">{</span>
    <span class="s3">AccessorProperty </span><span class="s2">= </span><span class="s4">&quot;AccessorProperty&quot;</span><span class="s1">,</span>
    <span class="s3">ArrayExpression </span><span class="s2">= </span><span class="s4">&quot;ArrayExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ArrayPattern </span><span class="s2">= </span><span class="s4">&quot;ArrayPattern&quot;</span><span class="s1">,</span>
    <span class="s3">ArrowFunctionExpression </span><span class="s2">= </span><span class="s4">&quot;ArrowFunctionExpression&quot;</span><span class="s1">,</span>
    <span class="s3">AssignmentExpression </span><span class="s2">= </span><span class="s4">&quot;AssignmentExpression&quot;</span><span class="s1">,</span>
    <span class="s3">AssignmentPattern </span><span class="s2">= </span><span class="s4">&quot;AssignmentPattern&quot;</span><span class="s1">,</span>
    <span class="s3">AwaitExpression </span><span class="s2">= </span><span class="s4">&quot;AwaitExpression&quot;</span><span class="s1">,</span>
    <span class="s3">BinaryExpression </span><span class="s2">= </span><span class="s4">&quot;BinaryExpression&quot;</span><span class="s1">,</span>
    <span class="s3">BlockStatement </span><span class="s2">= </span><span class="s4">&quot;BlockStatement&quot;</span><span class="s1">,</span>
    <span class="s3">BreakStatement </span><span class="s2">= </span><span class="s4">&quot;BreakStatement&quot;</span><span class="s1">,</span>
    <span class="s3">CallExpression </span><span class="s2">= </span><span class="s4">&quot;CallExpression&quot;</span><span class="s1">,</span>
    <span class="s3">CatchClause </span><span class="s2">= </span><span class="s4">&quot;CatchClause&quot;</span><span class="s1">,</span>
    <span class="s3">ChainExpression </span><span class="s2">= </span><span class="s4">&quot;ChainExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ClassBody </span><span class="s2">= </span><span class="s4">&quot;ClassBody&quot;</span><span class="s1">,</span>
    <span class="s3">ClassDeclaration </span><span class="s2">= </span><span class="s4">&quot;ClassDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">ClassExpression </span><span class="s2">= </span><span class="s4">&quot;ClassExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ConditionalExpression </span><span class="s2">= </span><span class="s4">&quot;ConditionalExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ContinueStatement </span><span class="s2">= </span><span class="s4">&quot;ContinueStatement&quot;</span><span class="s1">,</span>
    <span class="s3">DebuggerStatement </span><span class="s2">= </span><span class="s4">&quot;DebuggerStatement&quot;</span><span class="s1">,</span>
    <span class="s3">Decorator </span><span class="s2">= </span><span class="s4">&quot;Decorator&quot;</span><span class="s1">,</span>
    <span class="s3">DoWhileStatement </span><span class="s2">= </span><span class="s4">&quot;DoWhileStatement&quot;</span><span class="s1">,</span>
    <span class="s3">EmptyStatement </span><span class="s2">= </span><span class="s4">&quot;EmptyStatement&quot;</span><span class="s1">,</span>
    <span class="s3">ExportAllDeclaration </span><span class="s2">= </span><span class="s4">&quot;ExportAllDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">ExportDefaultDeclaration </span><span class="s2">= </span><span class="s4">&quot;ExportDefaultDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">ExportNamedDeclaration </span><span class="s2">= </span><span class="s4">&quot;ExportNamedDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">ExportSpecifier </span><span class="s2">= </span><span class="s4">&quot;ExportSpecifier&quot;</span><span class="s1">,</span>
    <span class="s3">ExpressionStatement </span><span class="s2">= </span><span class="s4">&quot;ExpressionStatement&quot;</span><span class="s1">,</span>
    <span class="s3">ForInStatement </span><span class="s2">= </span><span class="s4">&quot;ForInStatement&quot;</span><span class="s1">,</span>
    <span class="s3">ForOfStatement </span><span class="s2">= </span><span class="s4">&quot;ForOfStatement&quot;</span><span class="s1">,</span>
    <span class="s3">ForStatement </span><span class="s2">= </span><span class="s4">&quot;ForStatement&quot;</span><span class="s1">,</span>
    <span class="s3">FunctionDeclaration </span><span class="s2">= </span><span class="s4">&quot;FunctionDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">FunctionExpression </span><span class="s2">= </span><span class="s4">&quot;FunctionExpression&quot;</span><span class="s1">,</span>
    <span class="s3">Identifier </span><span class="s2">= </span><span class="s4">&quot;Identifier&quot;</span><span class="s1">,</span>
    <span class="s3">IfStatement </span><span class="s2">= </span><span class="s4">&quot;IfStatement&quot;</span><span class="s1">,</span>
    <span class="s3">ImportAttribute </span><span class="s2">= </span><span class="s4">&quot;ImportAttribute&quot;</span><span class="s1">,</span>
    <span class="s3">ImportDeclaration </span><span class="s2">= </span><span class="s4">&quot;ImportDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">ImportDefaultSpecifier </span><span class="s2">= </span><span class="s4">&quot;ImportDefaultSpecifier&quot;</span><span class="s1">,</span>
    <span class="s3">ImportExpression </span><span class="s2">= </span><span class="s4">&quot;ImportExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ImportNamespaceSpecifier </span><span class="s2">= </span><span class="s4">&quot;ImportNamespaceSpecifier&quot;</span><span class="s1">,</span>
    <span class="s3">ImportSpecifier </span><span class="s2">= </span><span class="s4">&quot;ImportSpecifier&quot;</span><span class="s1">,</span>
    <span class="s3">JSXAttribute </span><span class="s2">= </span><span class="s4">&quot;JSXAttribute&quot;</span><span class="s1">,</span>
    <span class="s3">JSXClosingElement </span><span class="s2">= </span><span class="s4">&quot;JSXClosingElement&quot;</span><span class="s1">,</span>
    <span class="s3">JSXClosingFragment </span><span class="s2">= </span><span class="s4">&quot;JSXClosingFragment&quot;</span><span class="s1">,</span>
    <span class="s3">JSXElement </span><span class="s2">= </span><span class="s4">&quot;JSXElement&quot;</span><span class="s1">,</span>
    <span class="s3">JSXEmptyExpression </span><span class="s2">= </span><span class="s4">&quot;JSXEmptyExpression&quot;</span><span class="s1">,</span>
    <span class="s3">JSXExpressionContainer </span><span class="s2">= </span><span class="s4">&quot;JSXExpressionContainer&quot;</span><span class="s1">,</span>
    <span class="s3">JSXFragment </span><span class="s2">= </span><span class="s4">&quot;JSXFragment&quot;</span><span class="s1">,</span>
    <span class="s3">JSXIdentifier </span><span class="s2">= </span><span class="s4">&quot;JSXIdentifier&quot;</span><span class="s1">,</span>
    <span class="s3">JSXMemberExpression </span><span class="s2">= </span><span class="s4">&quot;JSXMemberExpression&quot;</span><span class="s1">,</span>
    <span class="s3">JSXNamespacedName </span><span class="s2">= </span><span class="s4">&quot;JSXNamespacedName&quot;</span><span class="s1">,</span>
    <span class="s3">JSXOpeningElement </span><span class="s2">= </span><span class="s4">&quot;JSXOpeningElement&quot;</span><span class="s1">,</span>
    <span class="s3">JSXOpeningFragment </span><span class="s2">= </span><span class="s4">&quot;JSXOpeningFragment&quot;</span><span class="s1">,</span>
    <span class="s3">JSXSpreadAttribute </span><span class="s2">= </span><span class="s4">&quot;JSXSpreadAttribute&quot;</span><span class="s1">,</span>
    <span class="s3">JSXSpreadChild </span><span class="s2">= </span><span class="s4">&quot;JSXSpreadChild&quot;</span><span class="s1">,</span>
    <span class="s3">JSXText </span><span class="s2">= </span><span class="s4">&quot;JSXText&quot;</span><span class="s1">,</span>
    <span class="s3">LabeledStatement </span><span class="s2">= </span><span class="s4">&quot;LabeledStatement&quot;</span><span class="s1">,</span>
    <span class="s3">Literal </span><span class="s2">= </span><span class="s4">&quot;Literal&quot;</span><span class="s1">,</span>
    <span class="s3">LogicalExpression </span><span class="s2">= </span><span class="s4">&quot;LogicalExpression&quot;</span><span class="s1">,</span>
    <span class="s3">MemberExpression </span><span class="s2">= </span><span class="s4">&quot;MemberExpression&quot;</span><span class="s1">,</span>
    <span class="s3">MetaProperty </span><span class="s2">= </span><span class="s4">&quot;MetaProperty&quot;</span><span class="s1">,</span>
    <span class="s3">MethodDefinition </span><span class="s2">= </span><span class="s4">&quot;MethodDefinition&quot;</span><span class="s1">,</span>
    <span class="s3">NewExpression </span><span class="s2">= </span><span class="s4">&quot;NewExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ObjectExpression </span><span class="s2">= </span><span class="s4">&quot;ObjectExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ObjectPattern </span><span class="s2">= </span><span class="s4">&quot;ObjectPattern&quot;</span><span class="s1">,</span>
    <span class="s3">PrivateIdentifier </span><span class="s2">= </span><span class="s4">&quot;PrivateIdentifier&quot;</span><span class="s1">,</span>
    <span class="s3">Program </span><span class="s2">= </span><span class="s4">&quot;Program&quot;</span><span class="s1">,</span>
    <span class="s3">Property </span><span class="s2">= </span><span class="s4">&quot;Property&quot;</span><span class="s1">,</span>
    <span class="s3">PropertyDefinition </span><span class="s2">= </span><span class="s4">&quot;PropertyDefinition&quot;</span><span class="s1">,</span>
    <span class="s3">RestElement </span><span class="s2">= </span><span class="s4">&quot;RestElement&quot;</span><span class="s1">,</span>
    <span class="s3">ReturnStatement </span><span class="s2">= </span><span class="s4">&quot;ReturnStatement&quot;</span><span class="s1">,</span>
    <span class="s3">SequenceExpression </span><span class="s2">= </span><span class="s4">&quot;SequenceExpression&quot;</span><span class="s1">,</span>
    <span class="s3">SpreadElement </span><span class="s2">= </span><span class="s4">&quot;SpreadElement&quot;</span><span class="s1">,</span>
    <span class="s3">StaticBlock </span><span class="s2">= </span><span class="s4">&quot;StaticBlock&quot;</span><span class="s1">,</span>
    <span class="s3">Super </span><span class="s2">= </span><span class="s4">&quot;Super&quot;</span><span class="s1">,</span>
    <span class="s3">SwitchCase </span><span class="s2">= </span><span class="s4">&quot;SwitchCase&quot;</span><span class="s1">,</span>
    <span class="s3">SwitchStatement </span><span class="s2">= </span><span class="s4">&quot;SwitchStatement&quot;</span><span class="s1">,</span>
    <span class="s3">TaggedTemplateExpression </span><span class="s2">= </span><span class="s4">&quot;TaggedTemplateExpression&quot;</span><span class="s1">,</span>
    <span class="s3">TemplateElement </span><span class="s2">= </span><span class="s4">&quot;TemplateElement&quot;</span><span class="s1">,</span>
    <span class="s3">TemplateLiteral </span><span class="s2">= </span><span class="s4">&quot;TemplateLiteral&quot;</span><span class="s1">,</span>
    <span class="s3">ThisExpression </span><span class="s2">= </span><span class="s4">&quot;ThisExpression&quot;</span><span class="s1">,</span>
    <span class="s3">ThrowStatement </span><span class="s2">= </span><span class="s4">&quot;ThrowStatement&quot;</span><span class="s1">,</span>
    <span class="s3">TryStatement </span><span class="s2">= </span><span class="s4">&quot;TryStatement&quot;</span><span class="s1">,</span>
    <span class="s3">UnaryExpression </span><span class="s2">= </span><span class="s4">&quot;UnaryExpression&quot;</span><span class="s1">,</span>
    <span class="s3">UpdateExpression </span><span class="s2">= </span><span class="s4">&quot;UpdateExpression&quot;</span><span class="s1">,</span>
    <span class="s3">VariableDeclaration </span><span class="s2">= </span><span class="s4">&quot;VariableDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">VariableDeclarator </span><span class="s2">= </span><span class="s4">&quot;VariableDeclarator&quot;</span><span class="s1">,</span>
    <span class="s3">WhileStatement </span><span class="s2">= </span><span class="s4">&quot;WhileStatement&quot;</span><span class="s1">,</span>
    <span class="s3">WithStatement </span><span class="s2">= </span><span class="s4">&quot;WithStatement&quot;</span><span class="s1">,</span>
    <span class="s3">YieldExpression </span><span class="s2">= </span><span class="s4">&quot;YieldExpression&quot;</span><span class="s1">,</span>
    <span class="s0">/**</span>
     <span class="s0">* TS-prefixed nodes 
     */</span>
    <span class="s3">TSAbstractAccessorProperty </span><span class="s2">= </span><span class="s4">&quot;TSAbstractAccessorProperty&quot;</span><span class="s1">,</span>
    <span class="s3">TSAbstractKeyword </span><span class="s2">= </span><span class="s4">&quot;TSAbstractKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSAbstractMethodDefinition </span><span class="s2">= </span><span class="s4">&quot;TSAbstractMethodDefinition&quot;</span><span class="s1">,</span>
    <span class="s3">TSAbstractPropertyDefinition </span><span class="s2">= </span><span class="s4">&quot;TSAbstractPropertyDefinition&quot;</span><span class="s1">,</span>
    <span class="s3">TSAnyKeyword </span><span class="s2">= </span><span class="s4">&quot;TSAnyKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSArrayType </span><span class="s2">= </span><span class="s4">&quot;TSArrayType&quot;</span><span class="s1">,</span>
    <span class="s3">TSAsExpression </span><span class="s2">= </span><span class="s4">&quot;TSAsExpression&quot;</span><span class="s1">,</span>
    <span class="s3">TSAsyncKeyword </span><span class="s2">= </span><span class="s4">&quot;TSAsyncKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSBigIntKeyword </span><span class="s2">= </span><span class="s4">&quot;TSBigIntKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSBooleanKeyword </span><span class="s2">= </span><span class="s4">&quot;TSBooleanKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSCallSignatureDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSCallSignatureDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSClassImplements </span><span class="s2">= </span><span class="s4">&quot;TSClassImplements&quot;</span><span class="s1">,</span>
    <span class="s3">TSConditionalType </span><span class="s2">= </span><span class="s4">&quot;TSConditionalType&quot;</span><span class="s1">,</span>
    <span class="s3">TSConstructorType </span><span class="s2">= </span><span class="s4">&quot;TSConstructorType&quot;</span><span class="s1">,</span>
    <span class="s3">TSConstructSignatureDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSConstructSignatureDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSDeclareFunction </span><span class="s2">= </span><span class="s4">&quot;TSDeclareFunction&quot;</span><span class="s1">,</span>
    <span class="s3">TSDeclareKeyword </span><span class="s2">= </span><span class="s4">&quot;TSDeclareKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSEmptyBodyFunctionExpression </span><span class="s2">= </span><span class="s4">&quot;TSEmptyBodyFunctionExpression&quot;</span><span class="s1">,</span>
    <span class="s3">TSEnumDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSEnumDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSEnumMember </span><span class="s2">= </span><span class="s4">&quot;TSEnumMember&quot;</span><span class="s1">,</span>
    <span class="s3">TSExportAssignment </span><span class="s2">= </span><span class="s4">&quot;TSExportAssignment&quot;</span><span class="s1">,</span>
    <span class="s3">TSExportKeyword </span><span class="s2">= </span><span class="s4">&quot;TSExportKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSExternalModuleReference </span><span class="s2">= </span><span class="s4">&quot;TSExternalModuleReference&quot;</span><span class="s1">,</span>
    <span class="s3">TSFunctionType </span><span class="s2">= </span><span class="s4">&quot;TSFunctionType&quot;</span><span class="s1">,</span>
    <span class="s3">TSInstantiationExpression </span><span class="s2">= </span><span class="s4">&quot;TSInstantiationExpression&quot;</span><span class="s1">,</span>
    <span class="s3">TSImportEqualsDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSImportEqualsDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSImportType </span><span class="s2">= </span><span class="s4">&quot;TSImportType&quot;</span><span class="s1">,</span>
    <span class="s3">TSIndexedAccessType </span><span class="s2">= </span><span class="s4">&quot;TSIndexedAccessType&quot;</span><span class="s1">,</span>
    <span class="s3">TSIndexSignature </span><span class="s2">= </span><span class="s4">&quot;TSIndexSignature&quot;</span><span class="s1">,</span>
    <span class="s3">TSInferType </span><span class="s2">= </span><span class="s4">&quot;TSInferType&quot;</span><span class="s1">,</span>
    <span class="s3">TSInterfaceBody </span><span class="s2">= </span><span class="s4">&quot;TSInterfaceBody&quot;</span><span class="s1">,</span>
    <span class="s3">TSInterfaceDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSInterfaceDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSInterfaceHeritage </span><span class="s2">= </span><span class="s4">&quot;TSInterfaceHeritage&quot;</span><span class="s1">,</span>
    <span class="s3">TSIntersectionType </span><span class="s2">= </span><span class="s4">&quot;TSIntersectionType&quot;</span><span class="s1">,</span>
    <span class="s3">TSIntrinsicKeyword </span><span class="s2">= </span><span class="s4">&quot;TSIntrinsicKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSLiteralType </span><span class="s2">= </span><span class="s4">&quot;TSLiteralType&quot;</span><span class="s1">,</span>
    <span class="s3">TSMappedType </span><span class="s2">= </span><span class="s4">&quot;TSMappedType&quot;</span><span class="s1">,</span>
    <span class="s3">TSMethodSignature </span><span class="s2">= </span><span class="s4">&quot;TSMethodSignature&quot;</span><span class="s1">,</span>
    <span class="s3">TSModuleBlock </span><span class="s2">= </span><span class="s4">&quot;TSModuleBlock&quot;</span><span class="s1">,</span>
    <span class="s3">TSModuleDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSModuleDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSNamedTupleMember </span><span class="s2">= </span><span class="s4">&quot;TSNamedTupleMember&quot;</span><span class="s1">,</span>
    <span class="s3">TSNamespaceExportDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSNamespaceExportDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSNeverKeyword </span><span class="s2">= </span><span class="s4">&quot;TSNeverKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSNonNullExpression </span><span class="s2">= </span><span class="s4">&quot;TSNonNullExpression&quot;</span><span class="s1">,</span>
    <span class="s3">TSNullKeyword </span><span class="s2">= </span><span class="s4">&quot;TSNullKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSNumberKeyword </span><span class="s2">= </span><span class="s4">&quot;TSNumberKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSObjectKeyword </span><span class="s2">= </span><span class="s4">&quot;TSObjectKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSOptionalType </span><span class="s2">= </span><span class="s4">&quot;TSOptionalType&quot;</span><span class="s1">,</span>
    <span class="s3">TSParameterProperty </span><span class="s2">= </span><span class="s4">&quot;TSParameterProperty&quot;</span><span class="s1">,</span>
    <span class="s3">TSPrivateKeyword </span><span class="s2">= </span><span class="s4">&quot;TSPrivateKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSPropertySignature </span><span class="s2">= </span><span class="s4">&quot;TSPropertySignature&quot;</span><span class="s1">,</span>
    <span class="s3">TSProtectedKeyword </span><span class="s2">= </span><span class="s4">&quot;TSProtectedKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSPublicKeyword </span><span class="s2">= </span><span class="s4">&quot;TSPublicKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSQualifiedName </span><span class="s2">= </span><span class="s4">&quot;TSQualifiedName&quot;</span><span class="s1">,</span>
    <span class="s3">TSReadonlyKeyword </span><span class="s2">= </span><span class="s4">&quot;TSReadonlyKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSRestType </span><span class="s2">= </span><span class="s4">&quot;TSRestType&quot;</span><span class="s1">,</span>
    <span class="s3">TSSatisfiesExpression </span><span class="s2">= </span><span class="s4">&quot;TSSatisfiesExpression&quot;</span><span class="s1">,</span>
    <span class="s3">TSStaticKeyword </span><span class="s2">= </span><span class="s4">&quot;TSStaticKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSStringKeyword </span><span class="s2">= </span><span class="s4">&quot;TSStringKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSSymbolKeyword </span><span class="s2">= </span><span class="s4">&quot;TSSymbolKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSTemplateLiteralType </span><span class="s2">= </span><span class="s4">&quot;TSTemplateLiteralType&quot;</span><span class="s1">,</span>
    <span class="s3">TSThisType </span><span class="s2">= </span><span class="s4">&quot;TSThisType&quot;</span><span class="s1">,</span>
    <span class="s3">TSTupleType </span><span class="s2">= </span><span class="s4">&quot;TSTupleType&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeAliasDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSTypeAliasDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeAnnotation </span><span class="s2">= </span><span class="s4">&quot;TSTypeAnnotation&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeAssertion </span><span class="s2">= </span><span class="s4">&quot;TSTypeAssertion&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeLiteral </span><span class="s2">= </span><span class="s4">&quot;TSTypeLiteral&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeOperator </span><span class="s2">= </span><span class="s4">&quot;TSTypeOperator&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeParameter </span><span class="s2">= </span><span class="s4">&quot;TSTypeParameter&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeParameterDeclaration </span><span class="s2">= </span><span class="s4">&quot;TSTypeParameterDeclaration&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeParameterInstantiation </span><span class="s2">= </span><span class="s4">&quot;TSTypeParameterInstantiation&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypePredicate </span><span class="s2">= </span><span class="s4">&quot;TSTypePredicate&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeQuery </span><span class="s2">= </span><span class="s4">&quot;TSTypeQuery&quot;</span><span class="s1">,</span>
    <span class="s3">TSTypeReference </span><span class="s2">= </span><span class="s4">&quot;TSTypeReference&quot;</span><span class="s1">,</span>
    <span class="s3">TSUndefinedKeyword </span><span class="s2">= </span><span class="s4">&quot;TSUndefinedKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSUnionType </span><span class="s2">= </span><span class="s4">&quot;TSUnionType&quot;</span><span class="s1">,</span>
    <span class="s3">TSUnknownKeyword </span><span class="s2">= </span><span class="s4">&quot;TSUnknownKeyword&quot;</span><span class="s1">,</span>
    <span class="s3">TSVoidKeyword </span><span class="s2">= </span><span class="s4">&quot;TSVoidKeyword&quot;</span>
<span class="s1">}</span>
<span class="s2">export declare enum </span><span class="s3">AST_TOKEN_TYPES </span><span class="s1">{</span>
    <span class="s3">Boolean </span><span class="s2">= </span><span class="s4">&quot;Boolean&quot;</span><span class="s1">,</span>
    <span class="s3">Identifier </span><span class="s2">= </span><span class="s4">&quot;Identifier&quot;</span><span class="s1">,</span>
    <span class="s3">JSXIdentifier </span><span class="s2">= </span><span class="s4">&quot;JSXIdentifier&quot;</span><span class="s1">,</span>
    <span class="s3">JSXText </span><span class="s2">= </span><span class="s4">&quot;JSXText&quot;</span><span class="s1">,</span>
    <span class="s3">Keyword </span><span class="s2">= </span><span class="s4">&quot;Keyword&quot;</span><span class="s1">,</span>
    <span class="s3">Null </span><span class="s2">= </span><span class="s4">&quot;Null&quot;</span><span class="s1">,</span>
    <span class="s3">Numeric </span><span class="s2">= </span><span class="s4">&quot;Numeric&quot;</span><span class="s1">,</span>
    <span class="s3">Punctuator </span><span class="s2">= </span><span class="s4">&quot;Punctuator&quot;</span><span class="s1">,</span>
    <span class="s3">RegularExpression </span><span class="s2">= </span><span class="s4">&quot;RegularExpression&quot;</span><span class="s1">,</span>
    <span class="s3">String </span><span class="s2">= </span><span class="s4">&quot;String&quot;</span><span class="s1">,</span>
    <span class="s3">Template </span><span class="s2">= </span><span class="s4">&quot;Template&quot;</span><span class="s1">,</span>
    <span class="s3">Block </span><span class="s2">= </span><span class="s4">&quot;Block&quot;</span><span class="s1">,</span>
    <span class="s3">Line </span><span class="s2">= </span><span class="s4">&quot;Line&quot;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">AwaitExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">AwaitExpression</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">BaseNode </span><span class="s2">extends </span><span class="s3">NodeOrTokenData </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">BaseToken </span><span class="s2">extends </span><span class="s3">NodeOrTokenData </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">BigIntLiteral </span><span class="s2">extends </span><span class="s3">LiteralBase </span><span class="s1">{</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">bigint </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">bigint</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">BinaryExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">BinaryExpression</span><span class="s1">;</span>
    <span class="s1">operator</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">left</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s1">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">BindingName </span><span class="s2">= </span><span class="s3">BindingPattern </span><span class="s2">| </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">BindingPattern </span><span class="s2">= </span><span class="s3">ArrayPattern </span><span class="s2">| </span><span class="s3">ObjectPattern</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">BlockComment </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Block</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">BlockStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">BlockStatement</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">BooleanLiteral </span><span class="s2">extends </span><span class="s3">LiteralBase </span><span class="s1">{</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">raw</span><span class="s2">: </span><span class="s4">'false' </span><span class="s2">| </span><span class="s4">'true'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">BooleanToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">BreakStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">BreakStatement</span><span class="s1">;</span>
    <span class="s1">label</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">CallExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">CallExpression</span><span class="s1">;</span>
    <span class="s1">callee</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
    <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CallExpressionArgument</span><span class="s1">[];</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">CallExpressionArgument </span><span class="s2">= </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">SpreadElement</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">CatchClause </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">CatchClause</span><span class="s1">;</span>
    <span class="s1">param</span><span class="s2">: </span><span class="s3">BindingName </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">BlockStatement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ChainElement </span><span class="s2">= </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">MemberExpression </span><span class="s2">| </span><span class="s3">TSNonNullExpression</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ChainExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ChainExpression</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">ChainElement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">ClassBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the class is an abstract class. 
     * ``` 
     * abstract class Foo {...} 
     * ``` 
     * This is always `undefined` for `ClassExpression`. 
     */</span>
    <span class="s1">abstract</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The class body. 
     */</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">ClassBody</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the class has been `declare`d: 
     * ``` 
     * declare class Foo {...} 
     * ``` 
     * This is always `undefined` for `ClassExpression`. 
     */</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The decorators declared for the class. 
     * This is `undefined` if there are no decorators. 
     * ``` 
     * </span><span class="s2">@deco</span>
     <span class="s0">* class Foo {...} 
     * ``` 
     * This is always `undefined` for `ClassExpression`. 
     */</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The class's name. 
     * - For a `ClassExpression` this may be `null` if the name is omitted. 
     * - For a `ClassDeclaration` this may be `null` if and only if the parent is 
     *   an `ExportDefaultDeclaration`. 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The implemented interfaces for the class. 
     * This is `undefined` if there are no implemented interfaces. 
     */</span>
    <span class="s1">implements</span><span class="s2">?: </span><span class="s3">TSClassImplements</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The super class this class extends. 
     */</span>
    <span class="s1">superClass</span><span class="s2">: </span><span class="s3">LeftHandSideExpression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters passed to the superClass. 
     * This is `undefined` if there are no generic type parameters passed. 
     */</span>
    <span class="s1">superTypeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters declared for the class. 
     * This is `undefined` if there are no generic type parameters declared. 
     */</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ClassBody </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ClassBody</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">ClassElement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ClassDeclaration </span><span class="s2">= </span><span class="s3">ClassDeclarationWithName </span><span class="s2">| </span><span class="s3">ClassDeclarationWithOptionalName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">ClassDeclarationBase </span><span class="s2">extends </span><span class="s3">ClassBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ClassDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ClassDeclarationWithName </span><span class="s2">extends </span><span class="s3">ClassDeclarationBase </span><span class="s1">{</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ClassDeclarationWithOptionalName </span><span class="s2">extends </span><span class="s3">ClassDeclarationBase </span><span class="s1">{</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ClassElement </span><span class="s2">= </span><span class="s3">AccessorProperty </span><span class="s2">| </span><span class="s3">MethodDefinition </span><span class="s2">| </span><span class="s3">PropertyDefinition </span><span class="s2">| </span><span class="s3">StaticBlock </span><span class="s2">| </span><span class="s3">TSAbstractAccessorProperty </span><span class="s2">| </span><span class="s3">TSAbstractMethodDefinition </span><span class="s2">| </span><span class="s3">TSAbstractPropertyDefinition </span><span class="s2">| </span><span class="s3">TSIndexSignature</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ClassExpression </span><span class="s2">extends </span><span class="s3">ClassBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ClassExpression</span><span class="s1">;</span>
    <span class="s1">abstract</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">ClassMethodDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s3">MethodDefinitionBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">ClassPropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">ClassPropertyDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s3">PropertyDefinitionBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">ClassPropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ClassPropertyNameNonComputed </span><span class="s2">= </span><span class="s3">PrivateIdentifier </span><span class="s2">| </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">Comment </span><span class="s2">= </span><span class="s3">BlockComment </span><span class="s2">| </span><span class="s3">LineComment</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ConditionalExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ConditionalExpression</span><span class="s1">;</span>
    <span class="s1">test</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">consequent</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">alternate</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ContinueStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ContinueStatement</span><span class="s1">;</span>
    <span class="s1">label</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">DebuggerStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">DebuggerStatement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">DeclarationStatement </span><span class="s2">= </span><span class="s3">ClassDeclaration </span><span class="s2">| </span><span class="s3">ClassExpression </span><span class="s2">| </span><span class="s3">ExportAllDeclaration </span><span class="s2">| </span><span class="s3">ExportDefaultDeclaration </span><span class="s2">| </span><span class="s3">ExportNamedDeclaration </span><span class="s2">| </span><span class="s3">FunctionDeclaration </span><span class="s2">| </span><span class="s3">TSDeclareFunction </span><span class="s2">| </span><span class="s3">TSEnumDeclaration </span><span class="s2">| </span><span class="s3">TSImportEqualsDeclaration </span><span class="s2">| </span><span class="s3">TSInterfaceDeclaration </span><span class="s2">| </span><span class="s3">TSModuleDeclaration </span><span class="s2">| </span><span class="s3">TSNamespaceExportDeclaration </span><span class="s2">| </span><span class="s3">TSTypeAliasDeclaration</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">Decorator </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">Decorator</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">DefaultExportDeclarations </span><span class="s2">= </span><span class="s3">ClassDeclarationWithOptionalName </span><span class="s2">| </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">FunctionDeclarationWithName </span><span class="s2">| </span><span class="s3">FunctionDeclarationWithOptionalName </span><span class="s2">| </span><span class="s3">TSDeclareFunction </span><span class="s2">| </span><span class="s3">TSEnumDeclaration </span><span class="s2">| </span><span class="s3">TSInterfaceDeclaration </span><span class="s2">| </span><span class="s3">TSModuleDeclaration </span><span class="s2">| </span><span class="s3">TSTypeAliasDeclaration </span><span class="s2">| </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">DestructuringPattern </span><span class="s2">= </span><span class="s3">ArrayPattern </span><span class="s2">| </span><span class="s3">AssignmentPattern </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">MemberExpression </span><span class="s2">| </span><span class="s3">ObjectPattern </span><span class="s2">| </span><span class="s3">RestElement</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">DoWhileStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">DoWhileStatement</span><span class="s1">;</span>
    <span class="s1">test</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">EmptyStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">EmptyStatement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">EntityName </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ThisExpression </span><span class="s2">| </span><span class="s3">TSQualifiedName</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ExportAllDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ExportAllDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The assertions declared for the export. 
     * ``` 
     * export * from 'mod' assert { type: 'json' }; 
     * ``` 
     */</span>
    <span class="s1">assertions</span><span class="s2">: </span><span class="s3">ImportAttribute</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The name for the exported items. `null` if no name is assigned. 
     */</span>
    <span class="s1">exported</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the export. 
     */</span>
    <span class="s1">exportKind</span><span class="s2">: </span><span class="s3">ExportKind</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The source module being exported from. 
     */</span>
    <span class="s1">source</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare type </span><span class="s3">ExportAndImportKind </span><span class="s2">= </span><span class="s4">'type' </span><span class="s2">| </span><span class="s4">'value'</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">ExportDeclaration </span><span class="s2">= </span><span class="s3">DefaultExportDeclarations </span><span class="s2">| </span><span class="s3">NamedExportDeclarations</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ExportDefaultDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ExportDefaultDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The declaration being exported. 
     */</span>
    <span class="s1">declaration</span><span class="s2">: </span><span class="s3">DefaultExportDeclarations</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the export. 
     */</span>
    <span class="s1">exportKind</span><span class="s2">: </span><span class="s3">ExportKind</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare type </span><span class="s3">ExportKind </span><span class="s2">= </span><span class="s3">ExportAndImportKind</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">ExportNamedDeclaration </span><span class="s2">= </span><span class="s3">ExportNamedDeclarationWithoutSourceWithMultiple </span><span class="s2">| </span><span class="s3">ExportNamedDeclarationWithoutSourceWithSingle </span><span class="s2">| </span><span class="s3">ExportNamedDeclarationWithSource</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">ExportNamedDeclarationBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ExportNamedDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The assertions declared for the export. 
     * ``` 
     * export { foo } from 'mod' assert { type: 'json' }; 
     * ``` 
     * This will be an empty array if `source` is `null` 
     */</span>
    <span class="s1">assertions</span><span class="s2">: </span><span class="s3">ImportAttribute</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The exported declaration. 
     * ``` 
     * export const x = 1; 
     * ``` 
     * This will be `null` if `source` is not `null`, or if there are `specifiers` 
     */</span>
    <span class="s1">declaration</span><span class="s2">: </span><span class="s3">NamedExportDeclarations </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the export. 
     */</span>
    <span class="s1">exportKind</span><span class="s2">: </span><span class="s3">ExportKind</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The source module being exported from. 
     */</span>
    <span class="s1">source</span><span class="s2">: </span><span class="s3">StringLiteral </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The specifiers being exported. 
     * ``` 
     * export { a, b }; 
     * ``` 
     * This will be an empty array if `declaration` is not `null` 
     */</span>
    <span class="s1">specifiers</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ExportNamedDeclarationWithoutSourceWithMultiple </span><span class="s2">extends </span><span class="s3">ExportNamedDeclarationBase </span><span class="s1">{</span>
    <span class="s1">assertions</span><span class="s2">: </span><span class="s3">ImportAttribute</span><span class="s1">[];</span>
    <span class="s1">declaration</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">source</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">specifiers</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ExportNamedDeclarationWithoutSourceWithSingle </span><span class="s2">extends </span><span class="s3">ExportNamedDeclarationBase </span><span class="s1">{</span>
    <span class="s1">assertions</span><span class="s2">: </span><span class="s3">ImportAttribute</span><span class="s1">[];</span>
    <span class="s1">declaration</span><span class="s2">: </span><span class="s3">NamedExportDeclarations</span><span class="s1">;</span>
    <span class="s1">source</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">specifiers</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ExportNamedDeclarationWithSource </span><span class="s2">extends </span><span class="s3">ExportNamedDeclarationBase </span><span class="s1">{</span>
    <span class="s1">assertions</span><span class="s2">: </span><span class="s3">ImportAttribute</span><span class="s1">[];</span>
    <span class="s1">declaration</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">source</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s1">specifiers</span><span class="s2">: </span><span class="s3">ExportSpecifier</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ExportSpecifier </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ExportSpecifier</span><span class="s1">;</span>
    <span class="s1">local</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">exported</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">exportKind</span><span class="s2">: </span><span class="s3">ExportKind</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">Expression </span><span class="s2">= </span><span class="s3">ArrayExpression </span><span class="s2">| </span><span class="s3">ArrayPattern </span><span class="s2">| </span><span class="s3">ArrowFunctionExpression </span><span class="s2">| </span><span class="s3">AssignmentExpression </span><span class="s2">| </span><span class="s3">AwaitExpression </span><span class="s2">| </span><span class="s3">BinaryExpression </span><span class="s2">| </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">ChainExpression </span><span class="s2">| </span><span class="s3">ClassExpression </span><span class="s2">| </span><span class="s3">ConditionalExpression </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ImportExpression </span><span class="s2">| </span><span class="s3">JSXElement </span><span class="s2">| </span><span class="s3">JSXFragment </span><span class="s2">| </span><span class="s3">LiteralExpression </span><span class="s2">| </span><span class="s3">LogicalExpression </span><span class="s2">| </span><span class="s3">MemberExpression </span><span class="s2">| </span><span class="s3">MetaProperty </span><span class="s2">| </span><span class="s3">NewExpression </span><span class="s2">| </span><span class="s3">ObjectExpression </span><span class="s2">| </span><span class="s3">ObjectPattern </span><span class="s2">| </span><span class="s3">SequenceExpression </span><span class="s2">| </span><span class="s3">Super </span><span class="s2">| </span><span class="s3">TaggedTemplateExpression </span><span class="s2">| </span><span class="s3">TemplateLiteral </span><span class="s2">| </span><span class="s3">ThisExpression </span><span class="s2">| </span><span class="s3">TSAsExpression </span><span class="s2">| </span><span class="s3">TSInstantiationExpression </span><span class="s2">| </span><span class="s3">TSNonNullExpression </span><span class="s2">| </span><span class="s3">TSSatisfiesExpression </span><span class="s2">| </span><span class="s3">TSTypeAssertion </span><span class="s2">| </span><span class="s3">UnaryExpression </span><span class="s2">| </span><span class="s3">UpdateExpression </span><span class="s2">| </span><span class="s3">YieldExpression</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ExpressionStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ExpressionStatement</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">directive</span><span class="s2">?: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ForInitialiser </span><span class="s2">= </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ForInStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ForInStatement</span><span class="s1">;</span>
    <span class="s1">left</span><span class="s2">: </span><span class="s3">ForInitialiser</span><span class="s1">;</span>
    <span class="s1">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ForOfStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ForOfStatement</span><span class="s1">;</span>
    <span class="s1">left</span><span class="s2">: </span><span class="s3">ForInitialiser</span><span class="s1">;</span>
    <span class="s1">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
    <span class="s1">await</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ForStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ForStatement</span><span class="s1">;</span>
    <span class="s1">init</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">ForInitialiser </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">test</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">update</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">FunctionBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the function is async: 
     * ``` 
     * async function foo(...) {...} 
     * const x = async function (...) {...} 
     * const x = async (...) =&gt; {...} 
     * ``` 
     */</span>
    <span class="s1">async</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of the function. 
     * - For an `ArrowFunctionExpression` this may be an `Expression` or `BlockStatement`. 
     * - For a `FunctionDeclaration` or `FunctionExpression` this is always a `BlockStatement. 
     * - For a `TSDeclareFunction` this is always `undefined`. 
     * - For a `TSEmptyBodyFunctionExpression` this is always `null`. 
     */</span>
    <span class="s1">body</span><span class="s2">?: </span><span class="s3">BlockStatement </span><span class="s2">| </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This is only `true` if and only if the node is a `TSDeclareFunction` and it has `declare`: 
     * ``` 
     * declare function foo(...) {...} 
     * ``` 
     */</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* This is only ever `true` if and only the node is an `ArrowFunctionExpression` and the body 
     * is an expression: 
     * ``` 
     * (() =&gt; 1) 
     * ``` 
     */</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the function is a generator function: 
     * ``` 
     * function *foo(...) {...} 
     * const x = function *(...) {...} 
     * ``` 
     * This is always `false` for arrow functions as they cannot be generators. 
     */</span>
    <span class="s1">generator</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The function's name. 
     * - For an `ArrowFunctionExpression` this is always `null`. 
     * - For a `FunctionExpression` this may be `null` if the name is omitted. 
     * - For a `FunctionDeclaration` or `TSDeclareFunction` this may be `null` if 
     *   and only if the parent is an `ExportDefaultDeclaration`. 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The list of parameters declared for the function. 
     */</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s3">Parameter</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The return type annotation for the function. 
     * This is `undefined` if there is no return type declared. 
     */</span>
    <span class="s1">returnType</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameter declaration for the function. 
     * This is `undefined` if there are no generic type parameters declared. 
     */</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">FunctionDeclaration </span><span class="s2">= </span><span class="s3">FunctionDeclarationWithName </span><span class="s2">| </span><span class="s3">FunctionDeclarationWithOptionalName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">FunctionDeclarationBase </span><span class="s2">extends </span><span class="s3">FunctionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">FunctionDeclaration</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">BlockStatement</span><span class="s1">;</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">FunctionDeclarationWithName </span><span class="s2">extends </span><span class="s3">FunctionDeclarationBase </span><span class="s1">{</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">FunctionDeclarationWithOptionalName </span><span class="s2">extends </span><span class="s3">FunctionDeclarationBase </span><span class="s1">{</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">FunctionExpression </span><span class="s2">extends </span><span class="s3">FunctionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">FunctionExpression</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">BlockStatement</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">FunctionLike </span><span class="s2">= </span><span class="s3">ArrowFunctionExpression </span><span class="s2">| </span><span class="s3">FunctionDeclaration </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">TSDeclareFunction </span><span class="s2">| </span><span class="s3">TSEmptyBodyFunctionExpression</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">Identifier </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">IdentifierToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">IfStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">IfStatement</span><span class="s1">;</span>
    <span class="s1">test</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">consequent</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
    <span class="s1">alternate</span><span class="s2">: </span><span class="s3">Statement </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ImportAttribute </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ImportAttribute</span><span class="s1">;</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">Literal</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">Literal</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ImportClause </span><span class="s2">= </span><span class="s3">ImportDefaultSpecifier </span><span class="s2">| </span><span class="s3">ImportNamespaceSpecifier </span><span class="s2">| </span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ImportDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ImportDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The assertions declared for the export. 
     * ``` 
     * import * from 'mod' assert { type: 'json' }; 
     * ``` 
     */</span>
    <span class="s1">assertions</span><span class="s2">: </span><span class="s3">ImportAttribute</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The kind of the import. 
     */</span>
    <span class="s1">importKind</span><span class="s2">: </span><span class="s3">ImportKind</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The source module being imported from. 
     */</span>
    <span class="s1">source</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The specifiers being imported. 
     * If this is an empty array then either there are no specifiers: 
     * ``` 
     * import {} from 'mod'; 
     * ``` 
     * Or it is a side-effect import: 
     * ``` 
     * import 'mod'; 
     * ``` 
     */</span>
    <span class="s1">specifiers</span><span class="s2">: </span><span class="s3">ImportClause</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ImportDefaultSpecifier </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ImportDefaultSpecifier</span><span class="s1">;</span>
    <span class="s1">local</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ImportExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ImportExpression</span><span class="s1">;</span>
    <span class="s1">source</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">attributes</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare type </span><span class="s3">ImportKind </span><span class="s2">= </span><span class="s3">ExportAndImportKind</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ImportNamespaceSpecifier </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ImportNamespaceSpecifier</span><span class="s1">;</span>
    <span class="s1">local</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ImportSpecifier </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ImportSpecifier</span><span class="s1">;</span>
    <span class="s1">local</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">imported</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">importKind</span><span class="s2">: </span><span class="s3">ImportKind</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">IterationStatement </span><span class="s2">= </span><span class="s3">DoWhileStatement </span><span class="s2">| </span><span class="s3">ForInStatement </span><span class="s2">| </span><span class="s3">ForOfStatement </span><span class="s2">| </span><span class="s3">ForStatement </span><span class="s2">| </span><span class="s3">WhileStatement</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">JSXAttribute </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXAttribute</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">JSXIdentifier </span><span class="s2">| </span><span class="s3">JSXNamespacedName</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">JSXExpression </span><span class="s2">| </span><span class="s3">Literal </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">JSXChild </span><span class="s2">= </span><span class="s3">JSXElement </span><span class="s2">| </span><span class="s3">JSXExpression </span><span class="s2">| </span><span class="s3">JSXFragment </span><span class="s2">| </span><span class="s3">JSXText</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">JSXClosingElement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXClosingElement</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">JSXTagNameExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXClosingFragment </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXClosingFragment</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXElement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXElement</span><span class="s1">;</span>
    <span class="s1">openingElement</span><span class="s2">: </span><span class="s3">JSXOpeningElement</span><span class="s1">;</span>
    <span class="s1">closingElement</span><span class="s2">: </span><span class="s3">JSXClosingElement </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">children</span><span class="s2">: </span><span class="s3">JSXChild</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXEmptyExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXEmptyExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">JSXExpression </span><span class="s2">= </span><span class="s3">JSXExpressionContainer </span><span class="s2">| </span><span class="s3">JSXSpreadChild</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">JSXExpressionContainer </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXExpressionContainer</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">JSXEmptyExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXFragment </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXFragment</span><span class="s1">;</span>
    <span class="s1">openingFragment</span><span class="s2">: </span><span class="s3">JSXOpeningFragment</span><span class="s1">;</span>
    <span class="s1">closingFragment</span><span class="s2">: </span><span class="s3">JSXClosingFragment</span><span class="s1">;</span>
    <span class="s1">children</span><span class="s2">: </span><span class="s3">JSXChild</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXIdentifier </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXIdentifier</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXIdentifierToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">JSXIdentifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXMemberExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXMemberExpression</span><span class="s1">;</span>
    <span class="s1">object</span><span class="s2">: </span><span class="s3">JSXTagNameExpression</span><span class="s1">;</span>
    <span class="s1">property</span><span class="s2">: </span><span class="s3">JSXIdentifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXNamespacedName </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXNamespacedName</span><span class="s1">;</span>
    <span class="s1">namespace</span><span class="s2">: </span><span class="s3">JSXIdentifier</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">JSXIdentifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXOpeningElement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXOpeningElement</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
    <span class="s1">selfClosing</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">JSXTagNameExpression</span><span class="s1">;</span>
    <span class="s1">attributes</span><span class="s2">: </span><span class="s1">(</span><span class="s3">JSXAttribute </span><span class="s2">| </span><span class="s3">JSXSpreadAttribute</span><span class="s1">)[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXOpeningFragment </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXOpeningFragment</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXSpreadAttribute </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXSpreadAttribute</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXSpreadChild </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXSpreadChild</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">JSXEmptyExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">JSXTagNameExpression </span><span class="s2">= </span><span class="s3">JSXIdentifier </span><span class="s2">| </span><span class="s3">JSXMemberExpression </span><span class="s2">| </span><span class="s3">JSXNamespacedName</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">JSXText </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">JSXText</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">raw</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">JSXTextToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">JSXText</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">KeywordToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Keyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">LabeledStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">LabeledStatement</span><span class="s1">;</span>
    <span class="s1">label</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">LeftHandSideExpression </span><span class="s2">= </span><span class="s3">ArrayExpression </span><span class="s2">| </span><span class="s3">ArrayPattern </span><span class="s2">| </span><span class="s3">ArrowFunctionExpression </span><span class="s2">| </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">ClassExpression </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSXElement </span><span class="s2">| </span><span class="s3">JSXFragment </span><span class="s2">| </span><span class="s3">LiteralExpression </span><span class="s2">| </span><span class="s3">MemberExpression </span><span class="s2">| </span><span class="s3">MetaProperty </span><span class="s2">| </span><span class="s3">ObjectExpression </span><span class="s2">| </span><span class="s3">ObjectPattern </span><span class="s2">| </span><span class="s3">SequenceExpression </span><span class="s2">| </span><span class="s3">Super </span><span class="s2">| </span><span class="s3">TaggedTemplateExpression </span><span class="s2">| </span><span class="s3">ThisExpression </span><span class="s2">| </span><span class="s3">TSAsExpression </span><span class="s2">| </span><span class="s3">TSNonNullExpression </span><span class="s2">| </span><span class="s3">TSTypeAssertion</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">LineComment </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Line</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">Literal </span><span class="s2">= </span><span class="s3">BigIntLiteral </span><span class="s2">| </span><span class="s3">BooleanLiteral </span><span class="s2">| </span><span class="s3">NullLiteral </span><span class="s2">| </span><span class="s3">NumberLiteral </span><span class="s2">| </span><span class="s3">RegExpLiteral </span><span class="s2">| </span><span class="s3">StringLiteral</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">LiteralBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">Literal</span><span class="s1">;</span>
    <span class="s1">raw</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">RegExp </span><span class="s2">| </span><span class="s3">bigint </span><span class="s2">| </span><span class="s3">boolean </span><span class="s2">| </span><span class="s3">number </span><span class="s2">| </span><span class="s3">string </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">LiteralExpression </span><span class="s2">= </span><span class="s3">Literal </span><span class="s2">| </span><span class="s3">TemplateLiteral</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">LogicalExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">LogicalExpression</span><span class="s1">;</span>
    <span class="s1">operator</span><span class="s2">: </span><span class="s4">'??' </span><span class="s2">| </span><span class="s4">'&amp;&amp;' </span><span class="s2">| </span><span class="s4">'||'</span><span class="s1">;</span>
    <span class="s1">left</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">right</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">MemberExpression </span><span class="s2">= </span><span class="s3">MemberExpressionComputedName </span><span class="s2">| </span><span class="s3">MemberExpressionNonComputedName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">MemberExpressionBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">object</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">property</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">MemberExpressionComputedName </span><span class="s2">extends </span><span class="s3">MemberExpressionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">MemberExpression</span><span class="s1">;</span>
    <span class="s1">property</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">MemberExpressionNonComputedName </span><span class="s2">extends </span><span class="s3">MemberExpressionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">MemberExpression</span><span class="s1">;</span>
    <span class="s1">property</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">MetaProperty </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">MetaProperty</span><span class="s1">;</span>
    <span class="s1">meta</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">property</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">MethodDefinition </span><span class="s2">= </span><span class="s3">MethodDefinitionComputedName </span><span class="s2">| </span><span class="s3">MethodDefinitionNonComputedName</span><span class="s1">;</span>
<span class="s0">/** this should not be directly used - instead use MethodDefinitionComputedNameBase or MethodDefinitionNonComputedNameBase */</span>
<span class="s2">declare interface </span><span class="s3">MethodDefinitionBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">TSEmptyBodyFunctionExpression</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'constructor' </span><span class="s2">| </span><span class="s4">'get' </span><span class="s2">| </span><span class="s4">'method' </span><span class="s2">| </span><span class="s4">'set'</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
    <span class="s1">accessibility</span><span class="s2">?: </span><span class="s3">Accessibility</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">override</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">MethodDefinitionComputedName </span><span class="s2">extends </span><span class="s3">MethodDefinitionComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">MethodDefinition</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">MethodDefinitionComputedNameBase </span><span class="s2">extends </span><span class="s3">MethodDefinitionBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">MethodDefinitionNonComputedName </span><span class="s2">extends </span><span class="s3">ClassMethodDefinitionNonComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">MethodDefinition</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">MethodDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s3">MethodDefinitionBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">Modifier </span><span class="s2">= </span><span class="s3">TSAbstractKeyword </span><span class="s2">| </span><span class="s3">TSAsyncKeyword </span><span class="s2">| </span><span class="s3">TSPrivateKeyword </span><span class="s2">| </span><span class="s3">TSProtectedKeyword </span><span class="s2">| </span><span class="s3">TSPublicKeyword </span><span class="s2">| </span><span class="s3">TSReadonlyKeyword </span><span class="s2">| </span><span class="s3">TSStaticKeyword</span><span class="s1">;</span>
<span class="s2">declare type </span><span class="s3">ModuleBody_TODOFixThis </span><span class="s2">= </span><span class="s3">TSModuleBlock </span><span class="s2">| </span><span class="s3">TSModuleDeclaration</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">NamedExportDeclarations </span><span class="s2">= </span><span class="s3">ClassDeclarationWithName </span><span class="s2">| </span><span class="s3">ClassDeclarationWithOptionalName </span><span class="s2">| </span><span class="s3">FunctionDeclarationWithName </span><span class="s2">| </span><span class="s3">FunctionDeclarationWithOptionalName </span><span class="s2">| </span><span class="s3">TSDeclareFunction </span><span class="s2">| </span><span class="s3">TSEnumDeclaration </span><span class="s2">| </span><span class="s3">TSInterfaceDeclaration </span><span class="s2">| </span><span class="s3">TSModuleDeclaration </span><span class="s2">| </span><span class="s3">TSTypeAliasDeclaration </span><span class="s2">| </span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">NewExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">NewExpression</span><span class="s1">;</span>
    <span class="s1">callee</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
    <span class="s1">arguments</span><span class="s2">: </span><span class="s3">CallExpressionArgument</span><span class="s1">[];</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">Node </span><span class="s2">= </span><span class="s3">AccessorProperty </span><span class="s2">| </span><span class="s3">ArrayExpression </span><span class="s2">| </span><span class="s3">ArrayPattern </span><span class="s2">| </span><span class="s3">ArrowFunctionExpression </span><span class="s2">| </span><span class="s3">AssignmentExpression </span><span class="s2">| </span><span class="s3">AssignmentPattern </span><span class="s2">| </span><span class="s3">AwaitExpression </span><span class="s2">| </span><span class="s3">BinaryExpression </span><span class="s2">| </span><span class="s3">BlockStatement </span><span class="s2">| </span><span class="s3">BreakStatement </span><span class="s2">| </span><span class="s3">CallExpression </span><span class="s2">| </span><span class="s3">CatchClause </span><span class="s2">| </span><span class="s3">ChainExpression </span><span class="s2">| </span><span class="s3">ClassBody </span><span class="s2">| </span><span class="s3">ClassDeclaration </span><span class="s2">| </span><span class="s3">ClassExpression </span><span class="s2">| </span><span class="s3">ConditionalExpression </span><span class="s2">| </span><span class="s3">ContinueStatement </span><span class="s2">| </span><span class="s3">DebuggerStatement </span><span class="s2">| </span><span class="s3">Decorator </span><span class="s2">| </span><span class="s3">DoWhileStatement </span><span class="s2">| </span><span class="s3">EmptyStatement </span><span class="s2">| </span><span class="s3">ExportAllDeclaration </span><span class="s2">| </span><span class="s3">ExportDefaultDeclaration </span><span class="s2">| </span><span class="s3">ExportNamedDeclaration </span><span class="s2">| </span><span class="s3">ExportSpecifier </span><span class="s2">| </span><span class="s3">ExpressionStatement </span><span class="s2">| </span><span class="s3">ForInStatement </span><span class="s2">| </span><span class="s3">ForOfStatement </span><span class="s2">| </span><span class="s3">ForStatement </span><span class="s2">| </span><span class="s3">FunctionDeclaration </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">IfStatement </span><span class="s2">| </span><span class="s3">ImportAttribute </span><span class="s2">| </span><span class="s3">ImportDeclaration </span><span class="s2">| </span><span class="s3">ImportDefaultSpecifier </span><span class="s2">| </span><span class="s3">ImportExpression </span><span class="s2">| </span><span class="s3">ImportNamespaceSpecifier </span><span class="s2">| </span><span class="s3">ImportSpecifier </span><span class="s2">| </span><span class="s3">JSXAttribute </span><span class="s2">| </span><span class="s3">JSXClosingElement </span><span class="s2">| </span><span class="s3">JSXClosingFragment </span><span class="s2">| </span><span class="s3">JSXElement </span><span class="s2">| </span><span class="s3">JSXEmptyExpression </span><span class="s2">| </span><span class="s3">JSXExpressionContainer </span><span class="s2">| </span><span class="s3">JSXFragment </span><span class="s2">| </span><span class="s3">JSXIdentifier </span><span class="s2">| </span><span class="s3">JSXMemberExpression </span><span class="s2">| </span><span class="s3">JSXNamespacedName </span><span class="s2">| </span><span class="s3">JSXOpeningElement </span><span class="s2">| </span><span class="s3">JSXOpeningFragment </span><span class="s2">| </span><span class="s3">JSXSpreadAttribute </span><span class="s2">| </span><span class="s3">JSXSpreadChild </span><span class="s2">| </span><span class="s3">JSXText </span><span class="s2">| </span><span class="s3">LabeledStatement </span><span class="s2">| </span><span class="s3">Literal </span><span class="s2">| </span><span class="s3">LogicalExpression </span><span class="s2">| </span><span class="s3">MemberExpression </span><span class="s2">| </span><span class="s3">MetaProperty </span><span class="s2">| </span><span class="s3">MethodDefinition </span><span class="s2">| </span><span class="s3">NewExpression </span><span class="s2">| </span><span class="s3">ObjectExpression </span><span class="s2">| </span><span class="s3">ObjectPattern </span><span class="s2">| </span><span class="s3">PrivateIdentifier </span><span class="s2">| </span><span class="s3">Program </span><span class="s2">| </span><span class="s3">Property </span><span class="s2">| </span><span class="s3">PropertyDefinition </span><span class="s2">| </span><span class="s3">RestElement </span><span class="s2">| </span><span class="s3">ReturnStatement </span><span class="s2">| </span><span class="s3">SequenceExpression </span><span class="s2">| </span><span class="s3">SpreadElement </span><span class="s2">| </span><span class="s3">StaticBlock </span><span class="s2">| </span><span class="s3">Super </span><span class="s2">| </span><span class="s3">SwitchCase </span><span class="s2">| </span><span class="s3">SwitchStatement </span><span class="s2">| </span><span class="s3">TaggedTemplateExpression </span><span class="s2">| </span><span class="s3">TemplateElement </span><span class="s2">| </span><span class="s3">TemplateLiteral </span><span class="s2">| </span><span class="s3">ThisExpression </span><span class="s2">| </span><span class="s3">ThrowStatement </span><span class="s2">| </span><span class="s3">TryStatement </span><span class="s2">| </span><span class="s3">TSAbstractAccessorProperty </span><span class="s2">| </span><span class="s3">TSAbstractKeyword </span><span class="s2">| </span><span class="s3">TSAbstractMethodDefinition </span><span class="s2">| </span><span class="s3">TSAbstractPropertyDefinition </span><span class="s2">| </span><span class="s3">TSAnyKeyword </span><span class="s2">| </span><span class="s3">TSArrayType </span><span class="s2">| </span><span class="s3">TSAsExpression </span><span class="s2">| </span><span class="s3">TSAsyncKeyword </span><span class="s2">| </span><span class="s3">TSBigIntKeyword </span><span class="s2">| </span><span class="s3">TSBooleanKeyword </span><span class="s2">| </span><span class="s3">TSCallSignatureDeclaration </span><span class="s2">| </span><span class="s3">TSClassImplements </span><span class="s2">| </span><span class="s3">TSConditionalType </span><span class="s2">| </span><span class="s3">TSConstructorType </span><span class="s2">| </span><span class="s3">TSConstructSignatureDeclaration </span><span class="s2">| </span><span class="s3">TSDeclareFunction </span><span class="s2">| </span><span class="s3">TSDeclareKeyword </span><span class="s2">| </span><span class="s3">TSEmptyBodyFunctionExpression </span><span class="s2">| </span><span class="s3">TSEnumDeclaration </span><span class="s2">| </span><span class="s3">TSEnumMember </span><span class="s2">| </span><span class="s3">TSExportAssignment </span><span class="s2">| </span><span class="s3">TSExportKeyword </span><span class="s2">| </span><span class="s3">TSExternalModuleReference </span><span class="s2">| </span><span class="s3">TSFunctionType </span><span class="s2">| </span><span class="s3">TSImportEqualsDeclaration </span><span class="s2">| </span><span class="s3">TSImportType </span><span class="s2">| </span><span class="s3">TSIndexedAccessType </span><span class="s2">| </span><span class="s3">TSIndexSignature </span><span class="s2">| </span><span class="s3">TSInferType </span><span class="s2">| </span><span class="s3">TSInstantiationExpression </span><span class="s2">| </span><span class="s3">TSInterfaceBody </span><span class="s2">| </span><span class="s3">TSInterfaceDeclaration </span><span class="s2">| </span><span class="s3">TSInterfaceHeritage </span><span class="s2">| </span><span class="s3">TSIntersectionType </span><span class="s2">| </span><span class="s3">TSIntrinsicKeyword </span><span class="s2">| </span><span class="s3">TSLiteralType </span><span class="s2">| </span><span class="s3">TSMappedType </span><span class="s2">| </span><span class="s3">TSMethodSignature </span><span class="s2">| </span><span class="s3">TSModuleBlock </span><span class="s2">| </span><span class="s3">TSModuleDeclaration </span><span class="s2">| </span><span class="s3">TSNamedTupleMember </span><span class="s2">| </span><span class="s3">TSNamespaceExportDeclaration </span><span class="s2">| </span><span class="s3">TSNeverKeyword </span><span class="s2">| </span><span class="s3">TSNonNullExpression </span><span class="s2">| </span><span class="s3">TSNullKeyword </span><span class="s2">| </span><span class="s3">TSNumberKeyword </span><span class="s2">| </span><span class="s3">TSObjectKeyword </span><span class="s2">| </span><span class="s3">TSOptionalType </span><span class="s2">| </span><span class="s3">TSParameterProperty </span><span class="s2">| </span><span class="s3">TSPrivateKeyword </span><span class="s2">| </span><span class="s3">TSPropertySignature </span><span class="s2">| </span><span class="s3">TSProtectedKeyword </span><span class="s2">| </span><span class="s3">TSPublicKeyword </span><span class="s2">| </span><span class="s3">TSQualifiedName </span><span class="s2">| </span><span class="s3">TSReadonlyKeyword </span><span class="s2">| </span><span class="s3">TSRestType </span><span class="s2">| </span><span class="s3">TSSatisfiesExpression </span><span class="s2">| </span><span class="s3">TSStaticKeyword </span><span class="s2">| </span><span class="s3">TSStringKeyword </span><span class="s2">| </span><span class="s3">TSSymbolKeyword </span><span class="s2">| </span><span class="s3">TSTemplateLiteralType </span><span class="s2">| </span><span class="s3">TSThisType </span><span class="s2">| </span><span class="s3">TSTupleType </span><span class="s2">| </span><span class="s3">TSTypeAliasDeclaration </span><span class="s2">| </span><span class="s3">TSTypeAnnotation </span><span class="s2">| </span><span class="s3">TSTypeAssertion </span><span class="s2">| </span><span class="s3">TSTypeLiteral </span><span class="s2">| </span><span class="s3">TSTypeOperator </span><span class="s2">| </span><span class="s3">TSTypeParameter </span><span class="s2">| </span><span class="s3">TSTypeParameterDeclaration </span><span class="s2">| </span><span class="s3">TSTypeParameterInstantiation </span><span class="s2">| </span><span class="s3">TSTypePredicate </span><span class="s2">| </span><span class="s3">TSTypeQuery </span><span class="s2">| </span><span class="s3">TSTypeReference </span><span class="s2">| </span><span class="s3">TSUndefinedKeyword </span><span class="s2">| </span><span class="s3">TSUnionType </span><span class="s2">| </span><span class="s3">TSUnknownKeyword </span><span class="s2">| </span><span class="s3">TSVoidKeyword </span><span class="s2">| </span><span class="s3">UnaryExpression </span><span class="s2">| </span><span class="s3">UpdateExpression </span><span class="s2">| </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">VariableDeclarator </span><span class="s2">| </span><span class="s3">WhileStatement </span><span class="s2">| </span><span class="s3">WithStatement </span><span class="s2">| </span><span class="s3">YieldExpression</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">NodeOrTokenData </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The source location information of the node. 
     * 
     * The loc property is defined as nullable by ESTree, but ESLint requires this property. 
     * 
     * </span><span class="s2">@see </span><span class="s3">{SourceLocation}</span>
     <span class="s0">*/</span>
    <span class="s1">loc</span><span class="s2">: </span><span class="s3">SourceLocation</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s3">{Range}</span>
     <span class="s0">*/</span>
    <span class="s1">range</span><span class="s2">: </span><span class="s3">Range</span><span class="s1">;</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">NullLiteral </span><span class="s2">extends </span><span class="s3">LiteralBase </span><span class="s1">{</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">raw</span><span class="s2">: </span><span class="s4">'null'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">NullToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">NumberLiteral </span><span class="s2">extends </span><span class="s3">LiteralBase </span><span class="s1">{</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">NumericToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Numeric</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ObjectExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ObjectExpression</span><span class="s1">;</span>
    <span class="s1">properties</span><span class="s2">: </span><span class="s3">ObjectLiteralElement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ObjectLiteralElement </span><span class="s2">= </span><span class="s3">Property </span><span class="s2">| </span><span class="s3">SpreadElement</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">ObjectLiteralElementLike </span><span class="s2">= </span><span class="s3">ObjectLiteralElement</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">ObjectPattern </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ObjectPattern</span><span class="s1">;</span>
    <span class="s1">properties</span><span class="s2">: </span><span class="s1">(</span><span class="s3">Property </span><span class="s2">| </span><span class="s3">RestElement</span><span class="s1">)[];</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">OptionalRangeAndLoc</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s3">Pick</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">, </span><span class="s3">Exclude</span><span class="s1">&lt;</span><span class="s2">keyof </span><span class="s3">T</span><span class="s1">, </span><span class="s4">'loc' </span><span class="s2">| </span><span class="s4">'range'</span><span class="s1">&gt;&gt; </span><span class="s2">&amp; </span><span class="s1">{</span>
    <span class="s1">range</span><span class="s2">?: </span><span class="s3">Range</span><span class="s1">;</span>
    <span class="s1">loc</span><span class="s2">?: </span><span class="s3">SourceLocation</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s2">export declare type </span><span class="s3">Parameter </span><span class="s2">= </span><span class="s3">ArrayPattern </span><span class="s2">| </span><span class="s3">AssignmentPattern </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">ObjectPattern </span><span class="s2">| </span><span class="s3">RestElement </span><span class="s2">| </span><span class="s3">TSParameterProperty</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">Position </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* Line number (1-indexed) 
     */</span>
    <span class="s1">line</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Column number on the line (0-indexed) 
     */</span>
    <span class="s1">column</span><span class="s2">: </span><span class="s3">number</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">PrimaryExpression </span><span class="s2">= </span><span class="s3">ArrayExpression </span><span class="s2">| </span><span class="s3">ArrayPattern </span><span class="s2">| </span><span class="s3">ClassExpression </span><span class="s2">| </span><span class="s3">FunctionExpression </span><span class="s2">| </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">JSXElement </span><span class="s2">| </span><span class="s3">JSXFragment </span><span class="s2">| </span><span class="s3">JSXOpeningElement </span><span class="s2">| </span><span class="s3">LiteralExpression </span><span class="s2">| </span><span class="s3">MetaProperty </span><span class="s2">| </span><span class="s3">ObjectExpression </span><span class="s2">| </span><span class="s3">ObjectPattern </span><span class="s2">| </span><span class="s3">Super </span><span class="s2">| </span><span class="s3">TemplateLiteral </span><span class="s2">| </span><span class="s3">ThisExpression </span><span class="s2">| </span><span class="s3">TSNullKeyword</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">PrivateIdentifier </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">PrivateIdentifier</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">Program </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">Program</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">ProgramStatement</span><span class="s1">[];</span>
    <span class="s1">sourceType</span><span class="s2">: </span><span class="s4">'module' </span><span class="s2">| </span><span class="s4">'script'</span><span class="s1">;</span>
    <span class="s1">comments</span><span class="s2">?: </span><span class="s3">Comment</span><span class="s1">[];</span>
    <span class="s1">tokens</span><span class="s2">?: </span><span class="s3">Token</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">ProgramStatement </span><span class="s2">= </span><span class="s3">ExportAllDeclaration </span><span class="s2">| </span><span class="s3">ExportDefaultDeclaration </span><span class="s2">| </span><span class="s3">ExportNamedDeclaration </span><span class="s2">| </span><span class="s3">ImportDeclaration </span><span class="s2">| </span><span class="s3">Statement </span><span class="s2">| </span><span class="s3">TSImportEqualsDeclaration </span><span class="s2">| </span><span class="s3">TSNamespaceExportDeclaration</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">Property </span><span class="s2">= </span><span class="s3">PropertyComputedName </span><span class="s2">| </span><span class="s3">PropertyNonComputedName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">PropertyBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">Property</span><span class="s1">;</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">AssignmentPattern </span><span class="s2">| </span><span class="s3">BindingName </span><span class="s2">| </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">TSEmptyBodyFunctionExpression</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">method</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">shorthand</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'get' </span><span class="s2">| </span><span class="s4">'init' </span><span class="s2">| </span><span class="s4">'set'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">PropertyComputedName </span><span class="s2">extends </span><span class="s3">PropertyBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">PropertyDefinition </span><span class="s2">= </span><span class="s3">PropertyDefinitionComputedName </span><span class="s2">| </span><span class="s3">PropertyDefinitionNonComputedName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">PropertyDefinitionBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">declare</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">readonly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
    <span class="s1">accessibility</span><span class="s2">?: </span><span class="s3">Accessibility</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">definite</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">override</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">PropertyDefinitionComputedName </span><span class="s2">extends </span><span class="s3">PropertyDefinitionComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">PropertyDefinition</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">PropertyDefinitionComputedNameBase </span><span class="s2">extends </span><span class="s3">PropertyDefinitionBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">PropertyDefinitionNonComputedName </span><span class="s2">extends </span><span class="s3">ClassPropertyDefinitionNonComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">PropertyDefinition</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">PropertyDefinitionNonComputedNameBase </span><span class="s2">extends </span><span class="s3">PropertyDefinitionBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">PropertyName </span><span class="s2">= </span><span class="s3">ClassPropertyNameNonComputed </span><span class="s2">| </span><span class="s3">PropertyNameComputed </span><span class="s2">| </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">PropertyNameComputed </span><span class="s2">= </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">PropertyNameNonComputed </span><span class="s2">= </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">NumberLiteral </span><span class="s2">| </span><span class="s3">StringLiteral</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">PropertyNonComputedName </span><span class="s2">extends </span><span class="s3">PropertyBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">PunctuatorToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Punctuator</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">ValueOf</span><span class="s1">&lt;</span><span class="s3">PunctuatorTokenToText</span><span class="s1">&gt;;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">PunctuatorTokenToText </span><span class="s2">extends </span><span class="s3">AssignmentOperatorToText </span><span class="s1">{</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenBraceToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'{'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseBraceToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'}'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenParenToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'('</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseParenToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">')'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">OpenBracketToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'['</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CloseBracketToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">']'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'.'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">DotDotDotToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'...'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SemicolonToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">';'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CommaToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">','</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionDotToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'?.'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&lt;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanSlashToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&lt;/'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&gt;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&lt;='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&gt;='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'=='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'!='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsEqualsEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'==='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationEqualsEqualsToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'!=='</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">EqualsGreaterThanToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'=&gt;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'+'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'-'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'*'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AsteriskAsteriskToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'**'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">SlashToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'/'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PercentToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'%'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">PlusPlusToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'++'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">MinusMinusToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'--'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">LessThanLessThanToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&lt;&lt;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&gt;&gt;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">GreaterThanGreaterThanGreaterThanToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&gt;&gt;&gt;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&amp;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'|'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">CaretToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'^'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ExclamationToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'!'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">TildeToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'~'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AmpersandAmpersandToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'&amp;&amp;'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BarBarToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'||'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'?'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">ColonToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">':'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">AtToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'@'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">QuestionQuestionToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'??'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">BacktickToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'`'</span><span class="s1">;</span>
    <span class="s1">[</span><span class="s3">SyntaxKind</span><span class="s1">.</span><span class="s3">HashToken</span><span class="s1">]</span><span class="s2">: </span><span class="s4">'#'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* An array of two numbers. 
 * Both numbers are a 0-based index which is the position in the array of source code characters. 
 * The first is the start position of the node, the second is the end position of the node. 
 */</span>
<span class="s2">export declare type </span><span class="s3">Range </span><span class="s2">= </span><span class="s1">[</span>
    <span class="s3">number</span><span class="s1">,</span>
    <span class="s3">number</span>
<span class="s1">];</span>
<span class="s2">export declare interface </span><span class="s3">RegExpLiteral </span><span class="s2">extends </span><span class="s3">LiteralBase </span><span class="s1">{</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">RegExp </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">regex</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">pattern</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">RegularExpressionToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">RegularExpression</span><span class="s1">;</span>
    <span class="s1">regex</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">pattern</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">RestElement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">RestElement</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">: </span><span class="s3">DestructuringPattern</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">?: </span><span class="s3">AssignmentPattern</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ReturnStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ReturnStatement</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">SequenceExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">SequenceExpression</span><span class="s1">;</span>
    <span class="s1">expressions</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">SourceLocation </span><span class="s1">{</span>
    <span class="s0">/**</span>
     <span class="s0">* The position of the first character of the parsed source region 
     */</span>
    <span class="s1">start</span><span class="s2">: </span><span class="s3">Position</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The position of the first character after the parsed source region 
     */</span>
    <span class="s1">end</span><span class="s2">: </span><span class="s3">Position</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">SpreadElement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">SpreadElement</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">Statement </span><span class="s2">= </span><span class="s3">BlockStatement </span><span class="s2">| </span><span class="s3">BreakStatement </span><span class="s2">| </span><span class="s3">ClassDeclarationWithName </span><span class="s2">| </span><span class="s3">ContinueStatement </span><span class="s2">| </span><span class="s3">DebuggerStatement </span><span class="s2">| </span><span class="s3">DoWhileStatement </span><span class="s2">| </span><span class="s3">ExportAllDeclaration </span><span class="s2">| </span><span class="s3">ExportDefaultDeclaration </span><span class="s2">| </span><span class="s3">ExportNamedDeclaration </span><span class="s2">| </span><span class="s3">ExpressionStatement </span><span class="s2">| </span><span class="s3">ForInStatement </span><span class="s2">| </span><span class="s3">ForOfStatement </span><span class="s2">| </span><span class="s3">ForStatement </span><span class="s2">| </span><span class="s3">FunctionDeclarationWithName </span><span class="s2">| </span><span class="s3">IfStatement </span><span class="s2">| </span><span class="s3">ImportDeclaration </span><span class="s2">| </span><span class="s3">LabeledStatement </span><span class="s2">| </span><span class="s3">ReturnStatement </span><span class="s2">| </span><span class="s3">SwitchStatement </span><span class="s2">| </span><span class="s3">ThrowStatement </span><span class="s2">| </span><span class="s3">TryStatement </span><span class="s2">| </span><span class="s3">TSDeclareFunction </span><span class="s2">| </span><span class="s3">TSEnumDeclaration </span><span class="s2">| </span><span class="s3">TSExportAssignment </span><span class="s2">| </span><span class="s3">TSImportEqualsDeclaration </span><span class="s2">| </span><span class="s3">TSInterfaceDeclaration </span><span class="s2">| </span><span class="s3">TSModuleDeclaration </span><span class="s2">| </span><span class="s3">TSNamespaceExportDeclaration </span><span class="s2">| </span><span class="s3">TSTypeAliasDeclaration </span><span class="s2">| </span><span class="s3">VariableDeclaration </span><span class="s2">| </span><span class="s3">WhileStatement </span><span class="s2">| </span><span class="s3">WithStatement</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">StaticBlock </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">StaticBlock</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">StringLiteral </span><span class="s2">extends </span><span class="s3">LiteralBase </span><span class="s1">{</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">StringToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">String</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">Super </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">Super</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">SwitchCase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">SwitchCase</span><span class="s1">;</span>
    <span class="s1">test</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">consequent</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">SwitchStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">SwitchStatement</span><span class="s1">;</span>
    <span class="s1">discriminant</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">cases</span><span class="s2">: </span><span class="s3">SwitchCase</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TaggedTemplateExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TaggedTemplateExpression</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
    <span class="s1">tag</span><span class="s2">: </span><span class="s3">LeftHandSideExpression</span><span class="s1">;</span>
    <span class="s1">quasi</span><span class="s2">: </span><span class="s3">TemplateLiteral</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TemplateElement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TemplateElement</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s1">{</span>
        <span class="s1">raw</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
        <span class="s1">cooked</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s1">tail</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TemplateLiteral </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TemplateLiteral</span><span class="s1">;</span>
    <span class="s1">quasis</span><span class="s2">: </span><span class="s3">TemplateElement</span><span class="s1">[];</span>
    <span class="s1">expressions</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TemplateToken </span><span class="s2">extends </span><span class="s3">BaseToken </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_TOKEN_TYPES</span><span class="s1">.</span><span class="s3">Template</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ThisExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ThisExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">ThrowStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">ThrowStatement</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">: </span><span class="s3">Statement </span><span class="s2">| </span><span class="s3">TSAsExpression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">Token </span><span class="s2">= </span><span class="s3">BooleanToken </span><span class="s2">| </span><span class="s3">Comment </span><span class="s2">| </span><span class="s3">IdentifierToken </span><span class="s2">| </span><span class="s3">JSXIdentifierToken </span><span class="s2">| </span><span class="s3">JSXTextToken </span><span class="s2">| </span><span class="s3">KeywordToken </span><span class="s2">| </span><span class="s3">NullToken </span><span class="s2">| </span><span class="s3">NumericToken </span><span class="s2">| </span><span class="s3">PunctuatorToken </span><span class="s2">| </span><span class="s3">RegularExpressionToken </span><span class="s2">| </span><span class="s3">StringToken </span><span class="s2">| </span><span class="s3">TemplateToken</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">TryStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TryStatement</span><span class="s1">;</span>
    <span class="s1">block</span><span class="s2">: </span><span class="s3">BlockStatement</span><span class="s1">;</span>
    <span class="s1">handler</span><span class="s2">: </span><span class="s3">CatchClause </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">finalizer</span><span class="s2">: </span><span class="s3">BlockStatement </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSAbstractAccessorProperty </span><span class="s2">= </span><span class="s3">TSAbstractAccessorPropertyComputedName </span><span class="s2">| </span><span class="s3">TSAbstractAccessorPropertyNonComputedName</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">TSAbstractAccessorPropertyComputedName </span><span class="s2">extends </span><span class="s3">PropertyDefinitionComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAbstractAccessorProperty</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSAbstractAccessorPropertyNonComputedName </span><span class="s2">extends </span><span class="s3">PropertyDefinitionNonComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAbstractAccessorProperty</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSAbstractKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAbstractKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSAbstractMethodDefinition </span><span class="s2">= </span><span class="s3">TSAbstractMethodDefinitionComputedName </span><span class="s2">| </span><span class="s3">TSAbstractMethodDefinitionNonComputedName</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">TSAbstractMethodDefinitionComputedName </span><span class="s2">extends </span><span class="s3">MethodDefinitionComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAbstractMethodDefinition</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSAbstractMethodDefinitionNonComputedName </span><span class="s2">extends </span><span class="s3">MethodDefinitionNonComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAbstractMethodDefinition</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSAbstractPropertyDefinition </span><span class="s2">= </span><span class="s3">TSAbstractPropertyDefinitionComputedName </span><span class="s2">| </span><span class="s3">TSAbstractPropertyDefinitionNonComputedName</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">TSAbstractPropertyDefinitionComputedName </span><span class="s2">extends </span><span class="s3">PropertyDefinitionComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAbstractPropertyDefinition</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSAbstractPropertyDefinitionNonComputedName </span><span class="s2">extends </span><span class="s3">PropertyDefinitionNonComputedNameBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAbstractPropertyDefinition</span><span class="s1">;</span>
    <span class="s1">value</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSAnyKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAnyKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSArrayType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSArrayType</span><span class="s1">;</span>
    <span class="s1">elementType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSAsExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAsExpression</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSAsyncKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSAsyncKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSBigIntKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSBigIntKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSBooleanKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSBooleanKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSCallSignatureDeclaration </span><span class="s2">extends </span><span class="s3">TSFunctionSignatureBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSCallSignatureDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSClassImplements </span><span class="s2">extends </span><span class="s3">TSHeritageBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSClassImplements</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSConditionalType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSConditionalType</span><span class="s1">;</span>
    <span class="s1">checkType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">extendsType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">trueType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">falseType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSConstructorType </span><span class="s2">extends </span><span class="s3">TSFunctionSignatureBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSConstructorType</span><span class="s1">;</span>
    <span class="s1">abstract</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSConstructSignatureDeclaration </span><span class="s2">extends </span><span class="s3">TSFunctionSignatureBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSConstructSignatureDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSDeclareFunction </span><span class="s2">extends </span><span class="s3">FunctionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSDeclareFunction</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">?: </span><span class="s3">BlockStatement</span><span class="s1">;</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSDeclareKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSDeclareKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSEmptyBodyFunctionExpression </span><span class="s2">extends </span><span class="s3">FunctionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSEmptyBodyFunctionExpression</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSEnumDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSEnumDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether this is a `const` enum. 
     * ``` 
     * const enum Foo {...} 
     * ``` 
     */</span>
    <span class="s1">const</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether this is a `declare`d enum. 
     * ``` 
     * declare enum Foo {...} 
     * ``` 
     */</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The enum name. 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The enum members. 
     */</span>
    <span class="s1">members</span><span class="s2">: </span><span class="s3">TSEnumMember</span><span class="s1">[];</span>
    <span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">Modifier</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSEnumMember </span><span class="s2">= </span><span class="s3">TSEnumMemberComputedName </span><span class="s2">| </span><span class="s3">TSEnumMemberNonComputedName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">TSEnumMemberBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSEnumMember</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">PropertyNameComputed </span><span class="s2">| </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* this should only really happen in semantically invalid code (errors 1164 and 2452) 
 * 
 * VALID: 
 * enum Foo { ['a'] } 
 * 
 * INVALID: 
 * const x = 'a'; 
 * enum Foo { [x] } 
 * enum Bar { ['a' + 'b'] } 
 */</span>
<span class="s2">export declare interface </span><span class="s3">TSEnumMemberComputedName </span><span class="s2">extends </span><span class="s3">TSEnumMemberBase </span><span class="s1">{</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">PropertyNameComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSEnumMemberNonComputedName </span><span class="s2">extends </span><span class="s3">TSEnumMemberBase </span><span class="s1">{</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">?: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSExportAssignment </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSExportAssignment</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSExportKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSExportKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSExternalModuleReference </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSExternalModuleReference</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">TSFunctionSignatureBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s3">Parameter</span><span class="s1">[];</span>
    <span class="s1">returnType</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSFunctionType </span><span class="s2">extends </span><span class="s3">TSFunctionSignatureBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSFunctionType</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">TSHeritageBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSImportEqualsDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSImportEqualsDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The locally imported name 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The value being aliased. 
     * ``` 
     * import F1 = A; 
     * import F2 = A.B.C; 
     * import F3 = require('mod'); 
     * ``` 
     */</span>
    <span class="s1">moduleReference</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">TSExternalModuleReference</span><span class="s1">;</span>
    <span class="s1">importKind</span><span class="s2">: </span><span class="s3">ImportKind</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether this is immediately exported 
     * ``` 
     * export import F = A; 
     * ``` 
     */</span>
    <span class="s1">isExport</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSImportType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSImportType</span><span class="s1">;</span>
    <span class="s1">isTypeOf</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">parameter</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">qualifier</span><span class="s2">: </span><span class="s3">EntityName </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">: </span><span class="s3">TSTypeParameterInstantiation </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSIndexedAccessType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSIndexedAccessType</span><span class="s1">;</span>
    <span class="s1">objectType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">indexType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSIndexSignature </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSIndexSignature</span><span class="s1">;</span>
    <span class="s1">parameters</span><span class="s2">: </span><span class="s3">Parameter</span><span class="s1">[];</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">readonly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">accessibility</span><span class="s2">?: </span><span class="s3">Accessibility</span><span class="s1">;</span>
    <span class="s1">export</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSInferType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSInferType</span><span class="s1">;</span>
    <span class="s1">typeParameter</span><span class="s2">: </span><span class="s3">TSTypeParameter</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSInstantiationExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSInstantiationExpression</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSInterfaceBody </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSInterfaceBody</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">TypeElement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSInterfaceDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSInterfaceDeclaration</span><span class="s1">;</span>
    <span class="s1">abstract</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of the interface 
     */</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">TSInterfaceBody</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the interface was `declare`d, `undefined` otherwise 
     */</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The types this interface `extends` 
     */</span>
    <span class="s1">extends</span><span class="s2">?: </span><span class="s3">TSInterfaceHeritage</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of this interface 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">implements</span><span class="s2">?: </span><span class="s3">TSInterfaceHeritage</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters declared for the interface. 
     * This is `undefined` if there are no generic type parameters declared. 
     */</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSInterfaceHeritage </span><span class="s2">extends </span><span class="s3">TSHeritageBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSInterfaceHeritage</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSIntersectionType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSIntersectionType</span><span class="s1">;</span>
    <span class="s1">types</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSIntrinsicKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSIntrinsicKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSLiteralType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSLiteralType</span><span class="s1">;</span>
    <span class="s1">literal</span><span class="s2">: </span><span class="s3">LiteralExpression </span><span class="s2">| </span><span class="s3">UnaryExpression </span><span class="s2">| </span><span class="s3">UpdateExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSMappedType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSMappedType</span><span class="s1">;</span>
    <span class="s1">typeParameter</span><span class="s2">: </span><span class="s3">TSTypeParameter</span><span class="s1">;</span>
    <span class="s1">readonly</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s4">'-' </span><span class="s2">| </span><span class="s4">'+'</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean </span><span class="s2">| </span><span class="s4">'-' </span><span class="s2">| </span><span class="s4">'+'</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">nameType</span><span class="s2">: </span><span class="s3">TypeNode </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSMethodSignature </span><span class="s2">= </span><span class="s3">TSMethodSignatureComputedName </span><span class="s2">| </span><span class="s3">TSMethodSignatureNonComputedName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">TSMethodSignatureBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSMethodSignature</span><span class="s1">;</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s3">Parameter</span><span class="s1">[];</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">returnType</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">readonly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">accessibility</span><span class="s2">?: </span><span class="s3">Accessibility</span><span class="s1">;</span>
    <span class="s1">export</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'get' </span><span class="s2">| </span><span class="s4">'method' </span><span class="s2">| </span><span class="s4">'set'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSMethodSignatureComputedName </span><span class="s2">extends </span><span class="s3">TSMethodSignatureBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSMethodSignatureNonComputedName </span><span class="s2">extends </span><span class="s3">TSMethodSignatureBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSModuleBlock </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSModuleBlock</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">ProgramStatement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSModuleDeclaration </span><span class="s2">= </span><span class="s3">TSModuleDeclarationGlobal </span><span class="s2">| </span><span class="s3">TSModuleDeclarationModule </span><span class="s2">| </span><span class="s3">TSModuleDeclarationNamespace</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">TSModuleDeclarationBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSModuleDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of the module 
     * ``` 
     * namespace A {} 
     * namespace A.B.C {} 
     * module 'a' {} 
     * ``` 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The body of the module. 
     * This can only be `undefined` for the code `declare module 'mod';` 
     * This will be a `TSModuleDeclaration` if the name is &quot;nested&quot; (`Foo.Bar`). 
     */</span>
    <span class="s1">body</span><span class="s2">?: </span><span class="s3">ModuleBody_TODOFixThis</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether this is a global declaration 
     * ``` 
     * declare global {} 
     * ``` 
     */</span>
    <span class="s1">global</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the module is `declare`d 
     * ``` 
     * declare namespace F {} 
     * ``` 
     */</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">modifiers</span><span class="s2">?: </span><span class="s3">Modifier</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* The keyword used to define this module declaration 
     * ``` 
     * namespace Foo {} 
     * ^^^^^^^^^ 
     * 
     * module 'foo' {} 
     * ^^^^^^ 
     * 
     * declare global {} 
     *         ^^^^^^ 
     * ``` 
     */</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s3">TSModuleDeclarationKind</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSModuleDeclarationGlobal </span><span class="s2">extends </span><span class="s3">TSModuleDeclarationBase </span><span class="s1">{</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'global'</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">TSModuleBlock</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">global</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSModuleDeclarationKind </span><span class="s2">= </span><span class="s4">'global' </span><span class="s2">| </span><span class="s4">'module' </span><span class="s2">| </span><span class="s4">'namespace'</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">TSModuleDeclarationModule </span><span class="s2">= </span><span class="s3">TSModuleDeclarationModuleWithIdentifierId </span><span class="s2">| </span><span class="s3">TSModuleDeclarationModuleWithStringId</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">TSModuleDeclarationModuleBase </span><span class="s2">extends </span><span class="s3">TSModuleDeclarationBase </span><span class="s1">{</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'module'</span><span class="s1">;</span>
    <span class="s1">global</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSModuleDeclarationModuleWithIdentifierId </span><span class="s2">extends </span><span class="s3">TSModuleDeclarationModuleBase </span><span class="s1">{</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'module'</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">ModuleBody_TODOFixThis</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSModuleDeclarationModuleWithStringId </span><span class="s2">= </span><span class="s3">TSModuleDeclarationModuleWithStringIdDeclared </span><span class="s2">| </span><span class="s3">TSModuleDeclarationModuleWithStringIdNotDeclared</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">TSModuleDeclarationModuleWithStringIdDeclared </span><span class="s2">extends </span><span class="s3">TSModuleDeclarationModuleBase </span><span class="s1">{</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'module'</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s1">declare</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">?: </span><span class="s3">TSModuleBlock</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSModuleDeclarationModuleWithStringIdNotDeclared </span><span class="s2">extends </span><span class="s3">TSModuleDeclarationModuleBase </span><span class="s1">{</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'module'</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">StringLiteral</span><span class="s1">;</span>
    <span class="s1">declare</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">TSModuleBlock</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSModuleDeclarationNamespace </span><span class="s2">extends </span><span class="s3">TSModuleDeclarationBase </span><span class="s1">{</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'namespace'</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">ModuleBody_TODOFixThis</span><span class="s1">;</span>
    <span class="s1">global</span><span class="s2">?: </span><span class="s3">undefined</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSNamedTupleMember </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSNamedTupleMember</span><span class="s1">;</span>
    <span class="s1">elementType</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">label</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSNamespaceExportDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSNamespaceExportDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name the global variable being exported to 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSNeverKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSNeverKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSNonNullExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSNonNullExpression</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSNullKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSNullKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSNumberKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSNumberKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSObjectKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSObjectKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSOptionalType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSOptionalType</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSParameterProperty </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSParameterProperty</span><span class="s1">;</span>
    <span class="s1">accessibility</span><span class="s2">?: </span><span class="s3">Accessibility</span><span class="s1">;</span>
    <span class="s1">readonly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">export</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">override</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">parameter</span><span class="s2">: </span><span class="s3">AssignmentPattern </span><span class="s2">| </span><span class="s3">BindingName </span><span class="s2">| </span><span class="s3">RestElement</span><span class="s1">;</span>
    <span class="s1">decorators</span><span class="s2">?: </span><span class="s3">Decorator</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSPrivateKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSPrivateKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSPropertySignature </span><span class="s2">= </span><span class="s3">TSPropertySignatureComputedName </span><span class="s2">| </span><span class="s3">TSPropertySignatureNonComputedName</span><span class="s1">;</span>
<span class="s2">declare interface </span><span class="s3">TSPropertySignatureBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSPropertySignature</span><span class="s1">;</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyName</span><span class="s1">;</span>
    <span class="s1">optional</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">initializer</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">readonly</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">static</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">export</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">accessibility</span><span class="s2">?: </span><span class="s3">Accessibility</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSPropertySignatureComputedName </span><span class="s2">extends </span><span class="s3">TSPropertySignatureBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSPropertySignatureNonComputedName </span><span class="s2">extends </span><span class="s3">TSPropertySignatureBase </span><span class="s1">{</span>
    <span class="s1">key</span><span class="s2">: </span><span class="s3">PropertyNameNonComputed</span><span class="s1">;</span>
    <span class="s1">computed</span><span class="s2">: </span><span class="s3">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSProtectedKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSProtectedKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSPublicKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSPublicKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSQualifiedName </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSQualifiedName</span><span class="s1">;</span>
    <span class="s1">left</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">;</span>
    <span class="s1">right</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSReadonlyKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSReadonlyKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSRestType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSRestType</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSSatisfiesExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSSatisfiesExpression</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSStaticKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSStaticKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSStringKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSStringKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSSymbolKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSSymbolKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTemplateLiteralType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTemplateLiteralType</span><span class="s1">;</span>
    <span class="s1">quasis</span><span class="s2">: </span><span class="s3">TemplateElement</span><span class="s1">[];</span>
    <span class="s1">types</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSThisType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSThisType</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTupleType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTupleType</span><span class="s1">;</span>
    <span class="s1">elementTypes</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeAliasDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeAliasDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the type was `declare`d. 
     * ``` 
     * declare type T = 1; 
     * ``` 
     */</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The name of the type. 
     */</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The &quot;value&quot; (type) of the declaration 
     */</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The generic type parameters declared for the type. 
     * This is `undefined` if there are no generic type parameters declared. 
     */</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeAnnotation </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeAnnotation</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeAssertion </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeAssertion</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">expression</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeLiteral </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeLiteral</span><span class="s1">;</span>
    <span class="s1">members</span><span class="s2">: </span><span class="s3">TypeElement</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeOperator </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeOperator</span><span class="s1">;</span>
    <span class="s1">operator</span><span class="s2">: </span><span class="s4">'keyof' </span><span class="s2">| </span><span class="s4">'readonly' </span><span class="s2">| </span><span class="s4">'unique'</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeParameter </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeParameter</span><span class="s1">;</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s3">Identifier</span><span class="s1">;</span>
    <span class="s1">constraint</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">default</span><span class="s2">?: </span><span class="s3">TypeNode</span><span class="s1">;</span>
    <span class="s1">in</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">out</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">const</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeParameterDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeParameterDeclaration</span><span class="s1">;</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s3">TSTypeParameter</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeParameterInstantiation </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
    <span class="s1">params</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypePredicate </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypePredicate</span><span class="s1">;</span>
    <span class="s1">asserts</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">parameterName</span><span class="s2">: </span><span class="s3">Identifier </span><span class="s2">| </span><span class="s3">TSThisType</span><span class="s1">;</span>
    <span class="s1">typeAnnotation</span><span class="s2">: </span><span class="s3">TSTypeAnnotation </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeQuery </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeQuery</span><span class="s1">;</span>
    <span class="s1">exprName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSTypeReference </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSTypeReference</span><span class="s1">;</span>
    <span class="s1">typeName</span><span class="s2">: </span><span class="s3">EntityName</span><span class="s1">;</span>
    <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s3">TSTypeParameterInstantiation</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TSUnaryExpression </span><span class="s2">= </span><span class="s3">AwaitExpression </span><span class="s2">| </span><span class="s3">LeftHandSideExpression </span><span class="s2">| </span><span class="s3">UnaryExpression </span><span class="s2">| </span><span class="s3">UpdateExpression</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">TSUndefinedKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSUndefinedKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSUnionType </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSUnionType</span><span class="s1">;</span>
    <span class="s1">types</span><span class="s2">: </span><span class="s3">TypeNode</span><span class="s1">[];</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSUnknownKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSUnknownKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">TSVoidKeyword </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">TSVoidKeyword</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare type </span><span class="s3">TypeElement </span><span class="s2">= </span><span class="s3">TSCallSignatureDeclaration </span><span class="s2">| </span><span class="s3">TSConstructSignatureDeclaration </span><span class="s2">| </span><span class="s3">TSIndexSignature </span><span class="s2">| </span><span class="s3">TSMethodSignature </span><span class="s2">| </span><span class="s3">TSPropertySignature</span><span class="s1">;</span>
<span class="s2">export declare type </span><span class="s3">TypeNode </span><span class="s2">= </span><span class="s3">TSAbstractKeyword </span><span class="s2">| </span><span class="s3">TSAnyKeyword </span><span class="s2">| </span><span class="s3">TSArrayType </span><span class="s2">| </span><span class="s3">TSAsyncKeyword </span><span class="s2">| </span><span class="s3">TSBigIntKeyword </span><span class="s2">| </span><span class="s3">TSBooleanKeyword </span><span class="s2">| </span><span class="s3">TSConditionalType </span><span class="s2">| </span><span class="s3">TSConstructorType </span><span class="s2">| </span><span class="s3">TSDeclareKeyword </span><span class="s2">| </span><span class="s3">TSExportKeyword </span><span class="s2">| </span><span class="s3">TSFunctionType </span><span class="s2">| </span><span class="s3">TSImportType </span><span class="s2">| </span><span class="s3">TSIndexedAccessType </span><span class="s2">| </span><span class="s3">TSInferType </span><span class="s2">| </span><span class="s3">TSIntersectionType </span><span class="s2">| </span><span class="s3">TSIntrinsicKeyword </span><span class="s2">| </span><span class="s3">TSLiteralType </span><span class="s2">| </span><span class="s3">TSMappedType </span><span class="s2">| </span><span class="s3">TSNamedTupleMember </span><span class="s2">| </span><span class="s3">TSNeverKeyword </span><span class="s2">| </span><span class="s3">TSNullKeyword </span><span class="s2">| </span><span class="s3">TSNumberKeyword </span><span class="s2">| </span><span class="s3">TSObjectKeyword </span><span class="s2">| </span><span class="s3">TSOptionalType </span><span class="s2">| </span><span class="s3">TSPrivateKeyword </span><span class="s2">| </span><span class="s3">TSProtectedKeyword </span><span class="s2">| </span><span class="s3">TSPublicKeyword </span><span class="s2">| </span><span class="s3">TSQualifiedName </span><span class="s2">| </span><span class="s3">TSReadonlyKeyword </span><span class="s2">| </span><span class="s3">TSRestType </span><span class="s2">| </span><span class="s3">TSStaticKeyword </span><span class="s2">| </span><span class="s3">TSStringKeyword </span><span class="s2">| </span><span class="s3">TSSymbolKeyword </span><span class="s2">| </span><span class="s3">TSTemplateLiteralType </span><span class="s2">| </span><span class="s3">TSThisType </span><span class="s2">| </span><span class="s3">TSTupleType </span><span class="s2">| </span><span class="s3">TSTypeLiteral </span><span class="s2">| </span><span class="s3">TSTypeOperator </span><span class="s2">| </span><span class="s3">TSTypePredicate </span><span class="s2">| </span><span class="s3">TSTypeQuery </span><span class="s2">| </span><span class="s3">TSTypeReference </span><span class="s2">| </span><span class="s3">TSUndefinedKeyword </span><span class="s2">| </span><span class="s3">TSUnionType </span><span class="s2">| </span><span class="s3">TSUnknownKeyword </span><span class="s2">| </span><span class="s3">TSVoidKeyword</span><span class="s1">;</span>
<span class="s2">export declare interface </span><span class="s3">UnaryExpression </span><span class="s2">extends </span><span class="s3">UnaryExpressionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">UnaryExpression</span><span class="s1">;</span>
    <span class="s1">operator</span><span class="s2">: </span><span class="s4">'-' </span><span class="s2">| </span><span class="s4">'!' </span><span class="s2">| </span><span class="s4">'+' </span><span class="s2">| </span><span class="s4">'~' </span><span class="s2">| </span><span class="s4">'delete' </span><span class="s2">| </span><span class="s4">'typeof' </span><span class="s2">| </span><span class="s4">'void'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare interface </span><span class="s3">UnaryExpressionBase </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">operator</span><span class="s2">: </span><span class="s3">string</span><span class="s1">;</span>
    <span class="s1">prefix</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">: </span><span class="s3">LeftHandSideExpression </span><span class="s2">| </span><span class="s3">Literal </span><span class="s2">| </span><span class="s3">UnaryExpression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">UpdateExpression </span><span class="s2">extends </span><span class="s3">UnaryExpressionBase </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">UpdateExpression</span><span class="s1">;</span>
    <span class="s1">operator</span><span class="s2">: </span><span class="s4">'--' </span><span class="s2">| </span><span class="s4">'++'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">declare type </span><span class="s3">ValueOf</span><span class="s1">&lt;</span><span class="s3">T</span><span class="s1">&gt; </span><span class="s2">= </span><span class="s3">T</span><span class="s1">[</span><span class="s2">keyof </span><span class="s3">T</span><span class="s1">];</span>
<span class="s2">export declare interface </span><span class="s3">VariableDeclaration </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">VariableDeclaration</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The variables declared by this declaration. 
     * Note that there may be 0 declarations (i.e. `const;`). 
     * ``` 
     * let x; 
     * let y, z; 
     * ``` 
     */</span>
    <span class="s1">declarations</span><span class="s2">: </span><span class="s3">VariableDeclarator</span><span class="s1">[];</span>
    <span class="s0">/**</span>
     <span class="s0">* Whether the declaration is `declare`d 
     * ``` 
     * declare const x = 1; 
     * ``` 
     */</span>
    <span class="s1">declare</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* The keyword used to declare the variable(s) 
     * ``` 
     * const x = 1; 
     * let y = 2; 
     * var z = 3; 
     * ``` 
     */</span>
    <span class="s1">kind</span><span class="s2">: </span><span class="s4">'const' </span><span class="s2">| </span><span class="s4">'let' </span><span class="s2">| </span><span class="s4">'var'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">VariableDeclarator </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">VariableDeclarator</span><span class="s1">;</span>
    <span class="s1">id</span><span class="s2">: </span><span class="s3">BindingName</span><span class="s1">;</span>
    <span class="s1">init</span><span class="s2">: </span><span class="s3">Expression </span><span class="s2">| </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s1">definite</span><span class="s2">?: </span><span class="s3">boolean</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">WhileStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">WhileStatement</span><span class="s1">;</span>
    <span class="s1">test</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">WithStatement </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">WithStatement</span><span class="s1">;</span>
    <span class="s1">object</span><span class="s2">: </span><span class="s3">Expression</span><span class="s1">;</span>
    <span class="s1">body</span><span class="s2">: </span><span class="s3">Statement</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export declare interface </span><span class="s3">YieldExpression </span><span class="s2">extends </span><span class="s3">BaseNode </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">: </span><span class="s3">AST_NODE_TYPES</span><span class="s1">.</span><span class="s3">YieldExpression</span><span class="s1">;</span>
    <span class="s1">delegate</span><span class="s2">: </span><span class="s3">boolean</span><span class="s1">;</span>
    <span class="s1">argument</span><span class="s2">?: </span><span class="s3">Expression</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">{};</span>
<span class="s0">//# sourceMappingURL=ast-spec.d.ts.map</span>
</pre>
</body>
</html>
<html>
<head>
<title>fake-timers-src.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fake-timers-src.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s1">const globalObject = require(</span><span class="s0">&quot;@sinonjs/commons&quot;</span><span class="s1">).global;</span>

<span class="s2">/** 
 * @typedef {object} IdleDeadline 
 * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout 
 * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period 
 */</span>

<span class="s2">/** 
 * Queues a function to be called during a browser's idle periods 
 * 
 * @callback RequestIdleCallback 
 * @param {function(IdleDeadline)} callback 
 * @param {{timeout: number}} options - an options object 
 * @returns {number} the id 
 */</span>

<span class="s2">/** 
 * @callback NextTick 
 * @param {VoidVarArgsFunc} callback - the callback to run 
 * @param {...*} arguments - optional arguments to call the callback with 
 * @returns {void} 
 */</span>

<span class="s2">/** 
 * @callback SetImmediate 
 * @param {VoidVarArgsFunc} callback - the callback to run 
 * @param {...*} arguments - optional arguments to call the callback with 
 * @returns {NodeImmediate} 
 */</span>

<span class="s2">/** 
 * @callback VoidVarArgsFunc 
 * @param {...*} callback - the callback to run 
 * @returns {void} 
 */</span>

<span class="s2">/** 
 * @typedef RequestAnimationFrame 
 * @property {function(number):void} requestAnimationFrame 
 * @returns {number} - the id 
 */</span>

<span class="s2">/** 
 * @typedef Performance 
 * @property {function(): number} now 
 */</span>

<span class="s2">/* eslint-disable jsdoc/require-property-description */</span>
<span class="s2">/** 
 * @typedef {object} Clock 
 * @property {number} now - the current time 
 * @property {Date} Date - the Date constructor 
 * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop 
 * @property {RequestIdleCallback} requestIdleCallback 
 * @property {function(number):void} cancelIdleCallback 
 * @property {setTimeout} setTimeout 
 * @property {clearTimeout} clearTimeout 
 * @property {NextTick} nextTick 
 * @property {queueMicrotask} queueMicrotask 
 * @property {setInterval} setInterval 
 * @property {clearInterval} clearInterval 
 * @property {SetImmediate} setImmediate 
 * @property {function(NodeImmediate):void} clearImmediate 
 * @property {function():number} countTimers 
 * @property {RequestAnimationFrame} requestAnimationFrame 
 * @property {function(number):void} cancelAnimationFrame 
 * @property {function():void} runMicrotasks 
 * @property {function(string | number): number} tick 
 * @property {function(string | number): Promise&lt;number&gt;} tickAsync 
 * @property {function(): number} next 
 * @property {function(): Promise&lt;number&gt;} nextAsync 
 * @property {function(): number} runAll 
 * @property {function(): number} runToFrame 
 * @property {function(): Promise&lt;number&gt;} runAllAsync 
 * @property {function(): number} runToLast 
 * @property {function(): Promise&lt;number&gt;} runToLastAsync 
 * @property {function(): void} reset 
 * @property {function(number | Date): void} setSystemTime 
 * @property {function(number): void} jump 
 * @property {Performance} performance 
 * @property {function(number[]): number[]} hrtime - process.hrtime (legacy) 
 * @property {function(): void} uninstall Uninstall the clock. 
 * @property {Function[]} methods - the methods that are faked 
 * @property {boolean} [shouldClearNativeTimers] inherited from config 
 */</span>
<span class="s2">/* eslint-enable jsdoc/require-property-description */</span>

<span class="s2">/** 
 * Configuration object for the `install` method. 
 * 
 * @typedef {object} Config 
 * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch) 
 * @property {string[]} [toFake] names of the methods that should be faked. 
 * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll() 
 * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false) 
 * @property {number} [advanceTimeDelta] increment mocked time every &lt;&lt;advanceTimeDelta&gt;&gt; ms (default: 20ms) 
 * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false) 
 */</span>

<span class="s2">/* eslint-disable jsdoc/require-property-description */</span>
<span class="s2">/** 
 * The internal structure to describe a scheduled fake timer 
 * 
 * @typedef {object} Timer 
 * @property {Function} func 
 * @property {*[]} args 
 * @property {number} delay 
 * @property {number} callAt 
 * @property {number} createdAt 
 * @property {boolean} immediate 
 * @property {number} id 
 * @property {Error} [error] 
 */</span>

<span class="s2">/** 
 * A Node timer 
 * 
 * @typedef {object} NodeImmediate 
 * @property {function(): boolean} hasRef 
 * @property {function(): NodeImmediate} ref 
 * @property {function(): NodeImmediate} unref 
 */</span>
<span class="s2">/* eslint-enable jsdoc/require-property-description */</span>

<span class="s2">/* eslint-disable complexity */</span>

<span class="s2">/** 
 * Mocks available features in the specified global namespace. 
 * 
 * @param {*} _global Namespace to mock (e.g. `window`) 
 * @returns {FakeTimers} 
 */</span>
<span class="s3">function </span><span class="s1">withGlobal(_global) {</span>
    <span class="s1">const userAgent = _global.navigator &amp;&amp; _global.navigator.userAgent;</span>
    <span class="s1">const isRunningInIE = userAgent &amp;&amp; userAgent.indexOf(</span><span class="s0">&quot;MSIE &quot;</span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">const maxTimeout = Math.pow(</span><span class="s4">2</span><span class="s1">, </span><span class="s4">31</span><span class="s1">) - </span><span class="s4">1</span><span class="s1">; </span><span class="s2">//see https://heycam.github.io/webidl/#abstract-opdef-converttoint</span>
    <span class="s1">const idCounterStart = </span><span class="s4">1</span><span class="s1">e12; </span><span class="s2">// arbitrarily large number to avoid collisions with native timer IDs</span>
    <span class="s1">const NOOP = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">undefined;</span>
    <span class="s1">};</span>
    <span class="s1">const NOOP_ARRAY = </span><span class="s3">function </span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">[];</span>
    <span class="s1">};</span>
    <span class="s1">const timeoutResult = _global.setTimeout(NOOP, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">const addTimerReturnsObject = </span><span class="s3">typeof </span><span class="s1">timeoutResult === </span><span class="s0">&quot;object&quot;</span><span class="s1">;</span>
    <span class="s1">const hrtimePresent =</span>
        <span class="s1">_global.process &amp;&amp; </span><span class="s3">typeof </span><span class="s1">_global.process.hrtime === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const hrtimeBigintPresent =</span>
        <span class="s1">hrtimePresent &amp;&amp; </span><span class="s3">typeof </span><span class="s1">_global.process.hrtime.bigint === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const nextTickPresent =</span>
        <span class="s1">_global.process &amp;&amp; </span><span class="s3">typeof </span><span class="s1">_global.process.nextTick === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const utilPromisify = _global.process &amp;&amp; require(</span><span class="s0">&quot;util&quot;</span><span class="s1">).promisify;</span>
    <span class="s1">const performancePresent =</span>
        <span class="s1">_global.performance &amp;&amp; </span><span class="s3">typeof </span><span class="s1">_global.performance.now === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const hasPerformancePrototype =</span>
        <span class="s1">_global.Performance &amp;&amp;</span>
        <span class="s1">(</span><span class="s3">typeof </span><span class="s1">_global.Performance).match(/^(</span><span class="s3">function</span><span class="s1">|object)$/);</span>
    <span class="s1">const hasPerformanceConstructorPrototype =</span>
        <span class="s1">_global.performance &amp;&amp;</span>
        <span class="s1">_global.performance.constructor &amp;&amp;</span>
        <span class="s1">_global.performance.constructor.prototype;</span>
    <span class="s1">const queueMicrotaskPresent = _global.hasOwnProperty(</span><span class="s0">&quot;queueMicrotask&quot;</span><span class="s1">);</span>
    <span class="s1">const requestAnimationFramePresent =</span>
        <span class="s1">_global.requestAnimationFrame &amp;&amp;</span>
        <span class="s3">typeof </span><span class="s1">_global.requestAnimationFrame === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const cancelAnimationFramePresent =</span>
        <span class="s1">_global.cancelAnimationFrame &amp;&amp;</span>
        <span class="s3">typeof </span><span class="s1">_global.cancelAnimationFrame === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const requestIdleCallbackPresent =</span>
        <span class="s1">_global.requestIdleCallback &amp;&amp;</span>
        <span class="s3">typeof </span><span class="s1">_global.requestIdleCallback === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const cancelIdleCallbackPresent =</span>
        <span class="s1">_global.cancelIdleCallback &amp;&amp;</span>
        <span class="s3">typeof </span><span class="s1">_global.cancelIdleCallback === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s1">const setImmediatePresent =</span>
        <span class="s1">_global.setImmediate &amp;&amp; </span><span class="s3">typeof </span><span class="s1">_global.setImmediate === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>

    <span class="s2">// Make properties writable in IE, as per</span>
    <span class="s2">// https://www.adequatelygood.com/Replacing-setTimeout-Globally.html</span>
    <span class="s2">/* eslint-disable no-self-assign */</span>
    <span class="s3">if </span><span class="s1">(isRunningInIE) {</span>
        <span class="s1">_global.setTimeout = _global.setTimeout;</span>
        <span class="s1">_global.clearTimeout = _global.clearTimeout;</span>
        <span class="s1">_global.setInterval = _global.setInterval;</span>
        <span class="s1">_global.clearInterval = _global.clearInterval;</span>
        <span class="s1">_global.Date = _global.Date;</span>
    <span class="s1">}</span>

    <span class="s2">// setImmediate is not a standard function</span>
    <span class="s2">// avoid adding the prop to the window object if not present</span>
    <span class="s3">if </span><span class="s1">(setImmediatePresent) {</span>
        <span class="s1">_global.setImmediate = _global.setImmediate;</span>
        <span class="s1">_global.clearImmediate = _global.clearImmediate;</span>
    <span class="s1">}</span>
    <span class="s2">/* eslint-enable no-self-assign */</span>

    <span class="s1">_global.clearTimeout(timeoutResult);</span>

    <span class="s1">const NativeDate = _global.Date;</span>
    <span class="s1">let uniqueTimerId = idCounterStart;</span>

    <span class="s2">/** 
     * @param {number} num 
     * @returns {boolean} 
     */</span>
    <span class="s3">function </span><span class="s1">isNumberFinite(num) {</span>
        <span class="s3">if </span><span class="s1">(Number.isFinite) {</span>
            <span class="s3">return </span><span class="s1">Number.isFinite(num);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">isFinite(num);</span>
    <span class="s1">}</span>

    <span class="s1">let isNearInfiniteLimit = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {number} i 
     */</span>
    <span class="s3">function </span><span class="s1">checkIsNearInfiniteLimit(clock, i) {</span>
        <span class="s3">if </span><span class="s1">(clock.loopLimit &amp;&amp; i === clock.loopLimit - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">isNearInfiniteLimit = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * 
     */</span>
    <span class="s3">function </span><span class="s1">resetIsNearInfiniteLimit() {</span>
        <span class="s1">isNearInfiniteLimit = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * Parse strings like &quot;01:10:00&quot; (meaning 1 hour, 10 minutes, 0 seconds) into 
     * number of milliseconds. This is used to support human-readable strings passed 
     * to clock.tick() 
     * 
     * @param {string} str 
     * @returns {number} 
     */</span>
    <span class="s3">function </span><span class="s1">parseTime(str) {</span>
        <span class="s3">if </span><span class="s1">(!str) {</span>
            <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">const strings = str.split(</span><span class="s0">&quot;:&quot;</span><span class="s1">);</span>
        <span class="s1">const l = strings.length;</span>
        <span class="s1">let i = l;</span>
        <span class="s1">let ms = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">let parsed;</span>

        <span class="s3">if </span><span class="s1">(l &gt; </span><span class="s4">3 </span><span class="s1">|| !/^(\d\d:){</span><span class="s4">0</span><span class="s1">,</span><span class="s4">2</span><span class="s1">}\d\d?$/.test(str)) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span>
                <span class="s0">&quot;tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">while </span><span class="s1">(i--) {</span>
            <span class="s1">parsed = parseInt(strings[i], </span><span class="s4">10</span><span class="s1">);</span>

            <span class="s3">if </span><span class="s1">(parsed &gt;= </span><span class="s4">60</span><span class="s1">) {</span>
                <span class="s3">throw new </span><span class="s1">Error(`Invalid time ${str}`);</span>
            <span class="s1">}</span>

            <span class="s1">ms += parsed * Math.pow(</span><span class="s4">60</span><span class="s1">, l - i - </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">ms * </span><span class="s4">1000</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * Get the decimal part of the millisecond value as nanoseconds 
     * 
     * @param {number} msFloat the number of milliseconds 
     * @returns {number} an integer number of nanoseconds in the range [0,1e6) 
     * 
     * Example: nanoRemainer(123.456789) -&gt; 456789 
     */</span>
    <span class="s3">function </span><span class="s1">nanoRemainder(msFloat) {</span>
        <span class="s1">const modulo = </span><span class="s4">1</span><span class="s1">e6;</span>
        <span class="s1">const remainder = (msFloat * </span><span class="s4">1</span><span class="s1">e6) % modulo;</span>
        <span class="s1">const positiveRemainder =</span>
            <span class="s1">remainder &lt; </span><span class="s4">0 </span><span class="s1">? remainder + modulo : remainder;</span>

        <span class="s3">return </span><span class="s1">Math.floor(positiveRemainder);</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * Used to grok the `now` parameter to createClock. 
     * 
     * @param {Date|number} epoch the system time 
     * @returns {number} 
     */</span>
    <span class="s3">function </span><span class="s1">getEpoch(epoch) {</span>
        <span class="s3">if </span><span class="s1">(!epoch) {</span>
            <span class="s3">return </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">epoch.getTime === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">epoch.getTime();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">epoch === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">epoch;</span>
        <span class="s1">}</span>
        <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;now should be milliseconds since UNIX epoch&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {number} from 
     * @param {number} to 
     * @param {Timer} timer 
     * @returns {boolean} 
     */</span>
    <span class="s3">function </span><span class="s1">inRange(from, to, timer) {</span>
        <span class="s3">return </span><span class="s1">timer &amp;&amp; timer.callAt &gt;= from &amp;&amp; timer.callAt &lt;= to;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {Timer} job 
     */</span>
    <span class="s3">function </span><span class="s1">getInfiniteLoopError(clock, job) {</span>
        <span class="s1">const infiniteLoopError = </span><span class="s3">new </span><span class="s1">Error(</span>
            <span class="s1">`Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`</span>
        <span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(!job.error) {</span>
            <span class="s3">return </span><span class="s1">infiniteLoopError;</span>
        <span class="s1">}</span>

        <span class="s2">// pattern never matched in Node</span>
        <span class="s1">const computedTargetPattern = /target\.*[&lt;|(|[].*?[&gt;|\]|)]\s*/;</span>
        <span class="s1">let clockMethodPattern = </span><span class="s3">new </span><span class="s1">RegExp(</span>
            <span class="s1">String(Object.keys(clock).join(</span><span class="s0">&quot;|&quot;</span><span class="s1">))</span>
        <span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(addTimerReturnsObject) {</span>
            <span class="s2">// node.js environment</span>
            <span class="s1">clockMethodPattern = </span><span class="s3">new </span><span class="s1">RegExp(</span>
                <span class="s1">`\\s+at (Object\\.)?(?:${Object.keys(clock).join(</span><span class="s0">&quot;|&quot;</span><span class="s1">)})\\s+`</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">let matchedLineIndex = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">job.error.stack.split(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">).some(</span><span class="s3">function </span><span class="s1">(line, i) {</span>
            <span class="s2">// If we've matched a computed target line (e.g. setTimeout) then we</span>
            <span class="s2">// don't need to look any further. Return true to stop iterating.</span>
            <span class="s1">const matchedComputedTarget = line.match(computedTargetPattern);</span>
            <span class="s2">/* istanbul ignore if */</span>
            <span class="s3">if </span><span class="s1">(matchedComputedTarget) {</span>
                <span class="s1">matchedLineIndex = i;</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">// If we've matched a clock method line, then there may still be</span>
            <span class="s2">// others further down the trace. Return false to keep iterating.</span>
            <span class="s1">const matchedClockMethod = line.match(clockMethodPattern);</span>
            <span class="s3">if </span><span class="s1">(matchedClockMethod) {</span>
                <span class="s1">matchedLineIndex = i;</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">// If we haven't matched anything on this line, but we matched</span>
            <span class="s2">// previously and set the matched line index, then we can stop.</span>
            <span class="s2">// If we haven't matched previously, then we should keep iterating.</span>
            <span class="s3">return </span><span class="s1">matchedLineIndex &gt;= </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">});</span>

        <span class="s1">const stack = `${infiniteLoopError}\n${job.type || </span><span class="s0">&quot;Microtask&quot;</span><span class="s1">} - ${</span>
            <span class="s1">job.func.name || </span><span class="s0">&quot;anonymous&quot;</span>
        <span class="s1">}\n${job.error.stack</span>
            <span class="s1">.split(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">)</span>
            <span class="s1">.slice(matchedLineIndex + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">.join(</span><span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">&quot;</span><span class="s1">)}`;</span>

        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">Object.defineProperty(infiniteLoopError, </span><span class="s0">&quot;stack&quot;</span><span class="s1">, {</span>
                <span class="s1">value: stack,</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
            <span class="s2">// noop</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">infiniteLoopError;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Date} target 
     * @param {Date} source 
     * @returns {Date} the target after modifications 
     */</span>
    <span class="s3">function </span><span class="s1">mirrorDateProperties(target, source) {</span>
        <span class="s1">let prop;</span>
        <span class="s3">for </span><span class="s1">(prop </span><span class="s3">in </span><span class="s1">source) {</span>
            <span class="s3">if </span><span class="s1">(source.hasOwnProperty(prop)) {</span>
                <span class="s1">target[prop] = source[prop];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">// set special now implementation</span>
        <span class="s3">if </span><span class="s1">(source.now) {</span>
            <span class="s1">target.now = </span><span class="s3">function </span><span class="s1">now() {</span>
                <span class="s3">return </span><span class="s1">target.clock.now;</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">delete </span><span class="s1">target.now;</span>
        <span class="s1">}</span>

        <span class="s2">// set special toSource implementation</span>
        <span class="s3">if </span><span class="s1">(source.toSource) {</span>
            <span class="s1">target.toSource = </span><span class="s3">function </span><span class="s1">toSource() {</span>
                <span class="s3">return </span><span class="s1">source.toSource();</span>
            <span class="s1">};</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">delete </span><span class="s1">target.toSource;</span>
        <span class="s1">}</span>

        <span class="s2">// set special toString implementation</span>
        <span class="s1">target.toString = </span><span class="s3">function </span><span class="s1">toString() {</span>
            <span class="s3">return </span><span class="s1">source.toString();</span>
        <span class="s1">};</span>

        <span class="s1">target.prototype = source.prototype;</span>
        <span class="s1">target.parse = source.parse;</span>
        <span class="s1">target.UTC = source.UTC;</span>
        <span class="s1">target.prototype.toUTCString = source.prototype.toUTCString;</span>
        <span class="s1">target.isFake = </span><span class="s3">true</span><span class="s1">;</span>

        <span class="s3">return </span><span class="s1">target;</span>
    <span class="s1">}</span>

    <span class="s2">//eslint-disable-next-line jsdoc/require-jsdoc</span>
    <span class="s3">function </span><span class="s1">createDate() {</span>
        <span class="s2">/** 
         * @param {number} year 
         * @param {number} month 
         * @param {number} date 
         * @param {number} hour 
         * @param {number} minute 
         * @param {number} second 
         * @param {number} ms 
         * @returns {Date} 
         */</span>
        <span class="s3">function </span><span class="s1">ClockDate(year, month, date, hour, minute, second, ms) {</span>
            <span class="s2">// the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.</span>
            <span class="s2">// This remains so in the 10th edition of 2019 as well.</span>
            <span class="s3">if </span><span class="s1">(!(</span><span class="s3">this instanceof </span><span class="s1">ClockDate)) {</span>
                <span class="s3">return new </span><span class="s1">NativeDate(ClockDate.clock.now).toString();</span>
            <span class="s1">}</span>

            <span class="s2">// if Date is called as a constructor with 'new' keyword</span>
            <span class="s2">// Defensive and verbose to avoid potential harm in passing</span>
            <span class="s2">// explicit undefined when user does not pass argument</span>
            <span class="s3">switch </span><span class="s1">(arguments.length) {</span>
                <span class="s3">case </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(ClockDate.clock.now);</span>
                <span class="s3">case </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(year);</span>
                <span class="s3">case </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(year, month);</span>
                <span class="s3">case </span><span class="s4">3</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(year, month, date);</span>
                <span class="s3">case </span><span class="s4">4</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(year, month, date, hour);</span>
                <span class="s3">case </span><span class="s4">5</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(year, month, date, hour, minute);</span>
                <span class="s3">case </span><span class="s4">6</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(</span>
                        <span class="s1">year,</span>
                        <span class="s1">month,</span>
                        <span class="s1">date,</span>
                        <span class="s1">hour,</span>
                        <span class="s1">minute,</span>
                        <span class="s1">second</span>
                    <span class="s1">);</span>
                <span class="s3">default</span><span class="s1">:</span>
                    <span class="s3">return new </span><span class="s1">NativeDate(</span>
                        <span class="s1">year,</span>
                        <span class="s1">month,</span>
                        <span class="s1">date,</span>
                        <span class="s1">hour,</span>
                        <span class="s1">minute,</span>
                        <span class="s1">second,</span>
                        <span class="s1">ms</span>
                    <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">mirrorDateProperties(ClockDate, NativeDate);</span>
    <span class="s1">}</span>

    <span class="s2">//eslint-disable-next-line jsdoc/require-jsdoc</span>
    <span class="s3">function </span><span class="s1">enqueueJob(clock, job) {</span>
        <span class="s2">// enqueues a microtick-deferred task - ecma262/#sec-enqueuejob</span>
        <span class="s3">if </span><span class="s1">(!clock.jobs) {</span>
            <span class="s1">clock.jobs = [];</span>
        <span class="s1">}</span>
        <span class="s1">clock.jobs.push(job);</span>
    <span class="s1">}</span>

    <span class="s2">//eslint-disable-next-line jsdoc/require-jsdoc</span>
    <span class="s3">function </span><span class="s1">runJobs(clock) {</span>
        <span class="s2">// runs all microtick-deferred tasks - ecma262/#sec-runjobs</span>
        <span class="s3">if </span><span class="s1">(!clock.jobs) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(let i = </span><span class="s4">0</span><span class="s1">; i &lt; clock.jobs.length; i++) {</span>
            <span class="s1">const job = clock.jobs[i];</span>
            <span class="s1">job.func.apply(</span><span class="s3">null</span><span class="s1">, job.args);</span>

            <span class="s1">checkIsNearInfiniteLimit(clock, i);</span>
            <span class="s3">if </span><span class="s1">(clock.loopLimit &amp;&amp; i &gt; clock.loopLimit) {</span>
                <span class="s3">throw </span><span class="s1">getInfiniteLoopError(clock, job);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">resetIsNearInfiniteLimit();</span>
        <span class="s1">clock.jobs = [];</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {Timer} timer 
     * @returns {number} id of the created timer 
     */</span>
    <span class="s3">function </span><span class="s1">addTimer(clock, timer) {</span>
        <span class="s3">if </span><span class="s1">(timer.func === undefined) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Callback must be provided to timer calls&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(addTimerReturnsObject) {</span>
            <span class="s2">// Node.js environment</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">timer.func !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
                <span class="s3">throw new </span><span class="s1">TypeError(</span>
                    <span class="s1">`[ERR_INVALID_CALLBACK]: Callback must be a </span><span class="s3">function</span><span class="s1">. Received ${</span>
                        <span class="s1">timer.func</span>
                    <span class="s1">} of type ${</span><span class="s3">typeof </span><span class="s1">timer.func}`</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(isNearInfiniteLimit) {</span>
            <span class="s1">timer.error = </span><span class="s3">new </span><span class="s1">Error();</span>
        <span class="s1">}</span>

        <span class="s1">timer.type = timer.immediate ? </span><span class="s0">&quot;Immediate&quot; </span><span class="s1">: </span><span class="s0">&quot;Timeout&quot;</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(timer.hasOwnProperty(</span><span class="s0">&quot;delay&quot;</span><span class="s1">)) {</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">timer.delay !== </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
                <span class="s1">timer.delay = parseInt(timer.delay, </span><span class="s4">10</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(!isNumberFinite(timer.delay)) {</span>
                <span class="s1">timer.delay = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">timer.delay = timer.delay &gt; maxTimeout ? </span><span class="s4">1 </span><span class="s1">: timer.delay;</span>
            <span class="s1">timer.delay = Math.max(</span><span class="s4">0</span><span class="s1">, timer.delay);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(timer.hasOwnProperty(</span><span class="s0">&quot;interval&quot;</span><span class="s1">)) {</span>
            <span class="s1">timer.type = </span><span class="s0">&quot;Interval&quot;</span><span class="s1">;</span>
            <span class="s1">timer.interval = timer.interval &gt; maxTimeout ? </span><span class="s4">1 </span><span class="s1">: timer.interval;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(timer.hasOwnProperty(</span><span class="s0">&quot;animation&quot;</span><span class="s1">)) {</span>
            <span class="s1">timer.type = </span><span class="s0">&quot;AnimationFrame&quot;</span><span class="s1">;</span>
            <span class="s1">timer.animation = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(timer.hasOwnProperty(</span><span class="s0">&quot;idleCallback&quot;</span><span class="s1">)) {</span>
            <span class="s1">timer.type = </span><span class="s0">&quot;IdleCallback&quot;</span><span class="s1">;</span>
            <span class="s1">timer.idleCallback = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!clock.timers) {</span>
            <span class="s1">clock.timers = {};</span>
        <span class="s1">}</span>

        <span class="s1">timer.id = uniqueTimerId++;</span>
        <span class="s1">timer.createdAt = clock.now;</span>
        <span class="s1">timer.callAt =</span>
            <span class="s1">clock.now + (parseInt(timer.delay) || (clock.duringTick ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">));</span>

        <span class="s1">clock.timers[timer.id] = timer;</span>

        <span class="s3">if </span><span class="s1">(addTimerReturnsObject) {</span>
            <span class="s1">const res = {</span>
                <span class="s1">refed: </span><span class="s3">true</span><span class="s1">,</span>
                <span class="s1">ref: </span><span class="s3">function </span><span class="s1">() {</span>
                    <span class="s3">this</span><span class="s1">.refed = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">res;</span>
                <span class="s1">},</span>
                <span class="s1">unref: </span><span class="s3">function </span><span class="s1">() {</span>
                    <span class="s3">this</span><span class="s1">.refed = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">res;</span>
                <span class="s1">},</span>
                <span class="s1">hasRef: </span><span class="s3">function </span><span class="s1">() {</span>
                    <span class="s3">return this</span><span class="s1">.refed;</span>
                <span class="s1">},</span>
                <span class="s1">refresh: </span><span class="s3">function </span><span class="s1">() {</span>
                    <span class="s1">timer.callAt =</span>
                        <span class="s1">clock.now +</span>
                        <span class="s1">(parseInt(timer.delay) || (clock.duringTick ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">));</span>

                    <span class="s2">// it _might_ have been removed, but if not the assignment is perfectly fine</span>
                    <span class="s1">clock.timers[timer.id] = timer;</span>

                    <span class="s3">return </span><span class="s1">res;</span>
                <span class="s1">},</span>
                <span class="s1">[Symbol.toPrimitive]: </span><span class="s3">function </span><span class="s1">() {</span>
                    <span class="s3">return </span><span class="s1">timer.id;</span>
                <span class="s1">},</span>
            <span class="s1">};</span>
            <span class="s3">return </span><span class="s1">res;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">timer.id;</span>
    <span class="s1">}</span>

    <span class="s2">/* eslint consistent-return: &quot;off&quot; */</span>
    <span class="s2">/** 
     * Timer comparitor 
     * 
     * @param {Timer} a 
     * @param {Timer} b 
     * @returns {number} 
     */</span>
    <span class="s3">function </span><span class="s1">compareTimers(a, b) {</span>
        <span class="s2">// Sort first by absolute timing</span>
        <span class="s3">if </span><span class="s1">(a.callAt &lt; b.callAt) {</span>
            <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(a.callAt &gt; b.callAt) {</span>
            <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">// Sort next by immediate, immediate timers take precedence</span>
        <span class="s3">if </span><span class="s1">(a.immediate &amp;&amp; !b.immediate) {</span>
            <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!a.immediate &amp;&amp; b.immediate) {</span>
            <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">// Sort next by creation time, earlier-created timers take precedence</span>
        <span class="s3">if </span><span class="s1">(a.createdAt &lt; b.createdAt) {</span>
            <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(a.createdAt &gt; b.createdAt) {</span>
            <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">// Sort next by id, lower-id timers take precedence</span>
        <span class="s3">if </span><span class="s1">(a.id &lt; b.id) {</span>
            <span class="s3">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(a.id &gt; b.id) {</span>
            <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">// As timer ids are unique, no fallback `0` is necessary</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {number} from 
     * @param {number} to 
     * @returns {Timer} 
     */</span>
    <span class="s3">function </span><span class="s1">firstTimerInRange(clock, from, to) {</span>
        <span class="s1">const timers = clock.timers;</span>
        <span class="s1">let timer = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">let id, isInRange;</span>

        <span class="s3">for </span><span class="s1">(id </span><span class="s3">in </span><span class="s1">timers) {</span>
            <span class="s3">if </span><span class="s1">(timers.hasOwnProperty(id)) {</span>
                <span class="s1">isInRange = inRange(from, to, timers[id]);</span>

                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">isInRange &amp;&amp;</span>
                    <span class="s1">(!timer || compareTimers(timer, timers[id]) === </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">) {</span>
                    <span class="s1">timer = timers[id];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">timer;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @returns {Timer} 
     */</span>
    <span class="s3">function </span><span class="s1">firstTimer(clock) {</span>
        <span class="s1">const timers = clock.timers;</span>
        <span class="s1">let timer = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">let id;</span>

        <span class="s3">for </span><span class="s1">(id </span><span class="s3">in </span><span class="s1">timers) {</span>
            <span class="s3">if </span><span class="s1">(timers.hasOwnProperty(id)) {</span>
                <span class="s3">if </span><span class="s1">(!timer || compareTimers(timer, timers[id]) === </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s1">timer = timers[id];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">timer;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @returns {Timer} 
     */</span>
    <span class="s3">function </span><span class="s1">lastTimer(clock) {</span>
        <span class="s1">const timers = clock.timers;</span>
        <span class="s1">let timer = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">let id;</span>

        <span class="s3">for </span><span class="s1">(id </span><span class="s3">in </span><span class="s1">timers) {</span>
            <span class="s3">if </span><span class="s1">(timers.hasOwnProperty(id)) {</span>
                <span class="s3">if </span><span class="s1">(!timer || compareTimers(timer, timers[id]) === -</span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s1">timer = timers[id];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">timer;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {Timer} timer 
     */</span>
    <span class="s3">function </span><span class="s1">callTimer(clock, timer) {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">timer.interval === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s1">clock.timers[timer.id].callAt += timer.interval;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s3">delete </span><span class="s1">clock.timers[timer.id];</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">timer.func === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">timer.func.apply(</span><span class="s3">null</span><span class="s1">, timer.args);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s2">/* eslint no-eval: &quot;off&quot; */</span>
            <span class="s1">const eval2 = eval;</span>
            <span class="s1">(</span><span class="s3">function </span><span class="s1">() {</span>
                <span class="s1">eval2(timer.func);</span>
            <span class="s1">})();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * Gets clear handler name for a given timer type 
     * 
     * @param {string} ttype 
     */</span>
    <span class="s3">function </span><span class="s1">getClearHandler(ttype) {</span>
        <span class="s3">if </span><span class="s1">(ttype === </span><span class="s0">&quot;IdleCallback&quot; </span><span class="s1">|| ttype === </span><span class="s0">&quot;AnimationFrame&quot;</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">`cancel${ttype}`;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">`clear${ttype}`;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * Gets schedule handler name for a given timer type 
     * 
     * @param {string} ttype 
     */</span>
    <span class="s3">function </span><span class="s1">getScheduleHandler(ttype) {</span>
        <span class="s3">if </span><span class="s1">(ttype === </span><span class="s0">&quot;IdleCallback&quot; </span><span class="s1">|| ttype === </span><span class="s0">&quot;AnimationFrame&quot;</span><span class="s1">) {</span>
            <span class="s3">return </span><span class="s1">`request${ttype}`;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">`set${ttype}`;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * Creates an anonymous function to warn only once 
     */</span>
    <span class="s3">function </span><span class="s1">createWarnOnce() {</span>
        <span class="s1">let calls = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">return function </span><span class="s1">(msg) {</span>
            <span class="s2">// eslint-disable-next-line</span>
            <span class="s1">!calls++ &amp;&amp; console.warn(msg);</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">const warnOnce = createWarnOnce();</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {number} timerId 
     * @param {string} ttype 
     */</span>
    <span class="s3">function </span><span class="s1">clearTimer(clock, timerId, ttype) {</span>
        <span class="s3">if </span><span class="s1">(!timerId) {</span>
            <span class="s2">// null appears to be allowed in most browsers, and appears to be</span>
            <span class="s2">// relied upon by some libraries, like Bootstrap carousel</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(!clock.timers) {</span>
            <span class="s1">clock.timers = {};</span>
        <span class="s1">}</span>

        <span class="s2">// in Node, the ID is stored as the primitive value for `Timeout` objects</span>
        <span class="s2">// for `Immediate` objects, no ID exists, so it gets coerced to NaN</span>
        <span class="s1">const id = Number(timerId);</span>

        <span class="s3">if </span><span class="s1">(Number.isNaN(id) || id &lt; idCounterStart) {</span>
            <span class="s1">const handlerName = getClearHandler(ttype);</span>

            <span class="s3">if </span><span class="s1">(clock.shouldClearNativeTimers === </span><span class="s3">true</span><span class="s1">) {</span>
                <span class="s1">const nativeHandler = clock[`_${handlerName}`];</span>
                <span class="s3">return typeof </span><span class="s1">nativeHandler === </span><span class="s0">&quot;function&quot;</span>
                    <span class="s1">? nativeHandler(timerId)</span>
                    <span class="s1">: undefined;</span>
            <span class="s1">}</span>
            <span class="s1">warnOnce(</span>
                <span class="s1">`FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by </span><span class="s3">this </span><span class="s1">library.` +</span>
                    <span class="s0">&quot;</span><span class="s5">\n</span><span class="s0">To automatically clean-up native timers, use `shouldClearNativeTimers`.&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(clock.timers.hasOwnProperty(id)) {</span>
            <span class="s2">// check that the ID matches a timer of the correct type</span>
            <span class="s1">const timer = clock.timers[id];</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">timer.type === ttype ||</span>
                <span class="s1">(timer.type === </span><span class="s0">&quot;Timeout&quot; </span><span class="s1">&amp;&amp; ttype === </span><span class="s0">&quot;Interval&quot;</span><span class="s1">) ||</span>
                <span class="s1">(timer.type === </span><span class="s0">&quot;Interval&quot; </span><span class="s1">&amp;&amp; ttype === </span><span class="s0">&quot;Timeout&quot;</span><span class="s1">)</span>
            <span class="s1">) {</span>
                <span class="s3">delete </span><span class="s1">clock.timers[id];</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">const clear = getClearHandler(ttype);</span>
                <span class="s1">const schedule = getScheduleHandler(timer.type);</span>
                <span class="s3">throw new </span><span class="s1">Error(</span>
                    <span class="s1">`Cannot clear timer: timer created </span><span class="s3">with </span><span class="s1">${schedule}() but cleared </span><span class="s3">with </span><span class="s1">${clear}()`</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {Config} config 
     * @returns {Timer[]} 
     */</span>
    <span class="s3">function </span><span class="s1">uninstall(clock, config) {</span>
        <span class="s1">let method, i, l;</span>
        <span class="s1">const installedHrTime = </span><span class="s0">&quot;_hrtime&quot;</span><span class="s1">;</span>
        <span class="s1">const installedNextTick = </span><span class="s0">&quot;_nextTick&quot;</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">, l = clock.methods.length; i &lt; l; i++) {</span>
            <span class="s1">method = clock.methods[i];</span>
            <span class="s3">if </span><span class="s1">(method === </span><span class="s0">&quot;hrtime&quot; </span><span class="s1">&amp;&amp; _global.process) {</span>
                <span class="s1">_global.process.hrtime = clock[installedHrTime];</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(method === </span><span class="s0">&quot;nextTick&quot; </span><span class="s1">&amp;&amp; _global.process) {</span>
                <span class="s1">_global.process.nextTick = clock[installedNextTick];</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(method === </span><span class="s0">&quot;performance&quot;</span><span class="s1">) {</span>
                <span class="s1">const originalPerfDescriptor = Object.getOwnPropertyDescriptor(</span>
                    <span class="s1">clock,</span>
                    <span class="s1">`_${method}`</span>
                <span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">originalPerfDescriptor &amp;&amp;</span>
                    <span class="s1">originalPerfDescriptor.get &amp;&amp;</span>
                    <span class="s1">!originalPerfDescriptor.set</span>
                <span class="s1">) {</span>
                    <span class="s1">Object.defineProperty(</span>
                        <span class="s1">_global,</span>
                        <span class="s1">method,</span>
                        <span class="s1">originalPerfDescriptor</span>
                    <span class="s1">);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(originalPerfDescriptor.configurable) {</span>
                    <span class="s1">_global[method] = clock[`_${method}`];</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">if </span><span class="s1">(_global[method] &amp;&amp; _global[method].hadOwnProperty) {</span>
                    <span class="s1">_global[method] = clock[`_${method}`];</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">try </span><span class="s1">{</span>
                        <span class="s3">delete </span><span class="s1">_global[method];</span>
                    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ignore) {</span>
                        <span class="s2">/* eslint no-empty: &quot;off&quot; */</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(config.shouldAdvanceTime === </span><span class="s3">true</span><span class="s1">) {</span>
            <span class="s1">_global.clearInterval(clock.attachedInterval);</span>
        <span class="s1">}</span>

        <span class="s2">// Prevent multiple executions which will completely remove these props</span>
        <span class="s1">clock.methods = [];</span>

        <span class="s2">// return pending timers, to enable checking what timers remained on uninstall</span>
        <span class="s3">if </span><span class="s1">(!clock.timers) {</span>
            <span class="s3">return </span><span class="s1">[];</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">Object.keys(clock.timers).map(</span><span class="s3">function </span><span class="s1">mapper(key) {</span>
            <span class="s3">return </span><span class="s1">clock.timers[key];</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {object} target the target containing the method to replace 
     * @param {string} method the keyname of the method on the target 
     * @param {Clock} clock 
     */</span>
    <span class="s3">function </span><span class="s1">hijackMethod(target, method, clock) {</span>
        <span class="s1">clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(</span>
            <span class="s1">target,</span>
            <span class="s1">method</span>
        <span class="s1">);</span>
        <span class="s1">clock[`_${method}`] = target[method];</span>

        <span class="s3">if </span><span class="s1">(method === </span><span class="s0">&quot;Date&quot;</span><span class="s1">) {</span>
            <span class="s1">const date = mirrorDateProperties(clock[method], target[method]);</span>
            <span class="s1">target[method] = date;</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(method === </span><span class="s0">&quot;performance&quot;</span><span class="s1">) {</span>
            <span class="s1">const originalPerfDescriptor = Object.getOwnPropertyDescriptor(</span>
                <span class="s1">target,</span>
                <span class="s1">method</span>
            <span class="s1">);</span>
            <span class="s2">// JSDOM has a read only performance field so we have to save/copy it differently</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">originalPerfDescriptor &amp;&amp;</span>
                <span class="s1">originalPerfDescriptor.get &amp;&amp;</span>
                <span class="s1">!originalPerfDescriptor.set</span>
            <span class="s1">) {</span>
                <span class="s1">Object.defineProperty(</span>
                    <span class="s1">clock,</span>
                    <span class="s1">`_${method}`,</span>
                    <span class="s1">originalPerfDescriptor</span>
                <span class="s1">);</span>

                <span class="s1">const perfDescriptor = Object.getOwnPropertyDescriptor(</span>
                    <span class="s1">clock,</span>
                    <span class="s1">method</span>
                <span class="s1">);</span>
                <span class="s1">Object.defineProperty(target, method, perfDescriptor);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">target[method] = clock[method];</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">target[method] = </span><span class="s3">function </span><span class="s1">() {</span>
                <span class="s3">return </span><span class="s1">clock[method].apply(clock, arguments);</span>
            <span class="s1">};</span>

            <span class="s1">Object.defineProperties(</span>
                <span class="s1">target[method],</span>
                <span class="s1">Object.getOwnPropertyDescriptors(clock[method])</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">target[method].clock = clock;</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @param {Clock} clock 
     * @param {number} advanceTimeDelta 
     */</span>
    <span class="s3">function </span><span class="s1">doIntervalTick(clock, advanceTimeDelta) {</span>
        <span class="s1">clock.tick(advanceTimeDelta);</span>
    <span class="s1">}</span>

    <span class="s2">/** 
     * @typedef {object} Timers 
     * @property {setTimeout} setTimeout 
     * @property {clearTimeout} clearTimeout 
     * @property {setInterval} setInterval 
     * @property {clearInterval} clearInterval 
     * @property {Date} Date 
     * @property {SetImmediate=} setImmediate 
     * @property {function(NodeImmediate): void=} clearImmediate 
     * @property {function(number[]):number[]=} hrtime 
     * @property {NextTick=} nextTick 
     * @property {Performance=} performance 
     * @property {RequestAnimationFrame=} requestAnimationFrame 
     * @property {boolean=} queueMicrotask 
     * @property {function(number): void=} cancelAnimationFrame 
     * @property {RequestIdleCallback=} requestIdleCallback 
     * @property {function(number): void=} cancelIdleCallback 
     */</span>

    <span class="s2">/** @type {Timers} */</span>
    <span class="s1">const timers = {</span>
        <span class="s1">setTimeout: _global.setTimeout,</span>
        <span class="s1">clearTimeout: _global.clearTimeout,</span>
        <span class="s1">setInterval: _global.setInterval,</span>
        <span class="s1">clearInterval: _global.clearInterval,</span>
        <span class="s1">Date: _global.Date,</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(setImmediatePresent) {</span>
        <span class="s1">timers.setImmediate = _global.setImmediate;</span>
        <span class="s1">timers.clearImmediate = _global.clearImmediate;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(hrtimePresent) {</span>
        <span class="s1">timers.hrtime = _global.process.hrtime;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(nextTickPresent) {</span>
        <span class="s1">timers.nextTick = _global.process.nextTick;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(performancePresent) {</span>
        <span class="s1">timers.performance = _global.performance;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(requestAnimationFramePresent) {</span>
        <span class="s1">timers.requestAnimationFrame = _global.requestAnimationFrame;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(queueMicrotaskPresent) {</span>
        <span class="s1">timers.queueMicrotask = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(cancelAnimationFramePresent) {</span>
        <span class="s1">timers.cancelAnimationFrame = _global.cancelAnimationFrame;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(requestIdleCallbackPresent) {</span>
        <span class="s1">timers.requestIdleCallback = _global.requestIdleCallback;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(cancelIdleCallbackPresent) {</span>
        <span class="s1">timers.cancelIdleCallback = _global.cancelIdleCallback;</span>
    <span class="s1">}</span>

    <span class="s1">const originalSetTimeout = _global.setImmediate || _global.setTimeout;</span>

    <span class="s2">/** 
     * @param {Date|number} [start] the system time - non-integer values are floored 
     * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll() 
     * @returns {Clock} 
     */</span>
    <span class="s3">function </span><span class="s1">createClock(start, loopLimit) {</span>
        <span class="s2">// eslint-disable-next-line no-param-reassign</span>
        <span class="s1">start = Math.floor(getEpoch(start));</span>
        <span class="s2">// eslint-disable-next-line no-param-reassign</span>
        <span class="s1">loopLimit = loopLimit || </span><span class="s4">1000</span><span class="s1">;</span>
        <span class="s1">let nanos = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">const adjustedSystemTime = [</span><span class="s4">0</span><span class="s1">, </span><span class="s4">0</span><span class="s1">]; </span><span class="s2">// [millis, nanoremainder]</span>

        <span class="s3">if </span><span class="s1">(NativeDate === undefined) {</span>
            <span class="s3">throw new </span><span class="s1">Error(</span>
                <span class="s0">&quot;The global scope doesn't have a `Date` object&quot; </span><span class="s1">+</span>
                    <span class="s0">&quot; (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">const clock = {</span>
            <span class="s1">now: start,</span>
            <span class="s1">Date: createDate(),</span>
            <span class="s1">loopLimit: loopLimit,</span>
        <span class="s1">};</span>

        <span class="s1">clock.Date.clock = clock;</span>

        <span class="s2">//eslint-disable-next-line jsdoc/require-jsdoc</span>
        <span class="s3">function </span><span class="s1">getTimeToNextFrame() {</span>
            <span class="s3">return </span><span class="s4">16 </span><span class="s1">- ((clock.now - start) % </span><span class="s4">16</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">//eslint-disable-next-line jsdoc/require-jsdoc</span>
        <span class="s3">function </span><span class="s1">hrtime(prev) {</span>
            <span class="s1">const millisSinceStart = clock.now - adjustedSystemTime[</span><span class="s4">0</span><span class="s1">] - start;</span>
            <span class="s1">const secsSinceStart = Math.floor(millisSinceStart / </span><span class="s4">1000</span><span class="s1">);</span>
            <span class="s1">const remainderInNanos =</span>
                <span class="s1">(millisSinceStart - secsSinceStart * </span><span class="s4">1</span><span class="s1">e3) * </span><span class="s4">1</span><span class="s1">e6 +</span>
                <span class="s1">nanos -</span>
                <span class="s1">adjustedSystemTime[</span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">if </span><span class="s1">(Array.isArray(prev)) {</span>
                <span class="s3">if </span><span class="s1">(prev[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">e9) {</span>
                    <span class="s3">throw new </span><span class="s1">TypeError(</span>
                        <span class="s0">&quot;Number of nanoseconds can't exceed a billion&quot;</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s1">const oldSecs = prev[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s1">let nanoDiff = remainderInNanos - prev[</span><span class="s4">1</span><span class="s1">];</span>
                <span class="s1">let secDiff = secsSinceStart - oldSecs;</span>

                <span class="s3">if </span><span class="s1">(nanoDiff &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">nanoDiff += </span><span class="s4">1</span><span class="s1">e9;</span>
                    <span class="s1">secDiff -= </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s3">return </span><span class="s1">[secDiff, nanoDiff];</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">[secsSinceStart, remainderInNanos];</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">fakePerformanceNow() {</span>
            <span class="s1">const hrt = hrtime();</span>
            <span class="s1">const millis = hrt[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">1000 </span><span class="s1">+ hrt[</span><span class="s4">1</span><span class="s1">] / </span><span class="s4">1</span><span class="s1">e6;</span>
            <span class="s3">return </span><span class="s1">millis;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(hrtimeBigintPresent) {</span>
            <span class="s1">hrtime.bigint = </span><span class="s3">function </span><span class="s1">() {</span>
                <span class="s1">const parts = hrtime();</span>
                <span class="s3">return </span><span class="s1">BigInt(parts[</span><span class="s4">0</span><span class="s1">]) * BigInt(</span><span class="s4">1</span><span class="s1">e9) + BigInt(parts[</span><span class="s4">1</span><span class="s1">]); </span><span class="s2">// eslint-disable-line</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">clock.requestIdleCallback = </span><span class="s3">function </span><span class="s1">requestIdleCallback(</span>
            <span class="s1">func,</span>
            <span class="s1">timeout</span>
        <span class="s1">) {</span>
            <span class="s1">let timeToNextIdlePeriod = </span><span class="s4">0</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s1">(clock.countTimers() &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">timeToNextIdlePeriod = </span><span class="s4">50</span><span class="s1">; </span><span class="s2">// const for now</span>
            <span class="s1">}</span>

            <span class="s1">const result = addTimer(clock, {</span>
                <span class="s1">func: func,</span>
                <span class="s1">args: Array.prototype.slice.call(arguments, </span><span class="s4">2</span><span class="s1">),</span>
                <span class="s1">delay:</span>
                    <span class="s3">typeof </span><span class="s1">timeout === </span><span class="s0">&quot;undefined&quot;</span>
                        <span class="s1">? timeToNextIdlePeriod</span>
                        <span class="s1">: Math.min(timeout, timeToNextIdlePeriod),</span>
                <span class="s1">idleCallback: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s1">});</span>

            <span class="s3">return </span><span class="s1">Number(result);</span>
        <span class="s1">};</span>

        <span class="s1">clock.cancelIdleCallback = </span><span class="s3">function </span><span class="s1">cancelIdleCallback(timerId) {</span>
            <span class="s3">return </span><span class="s1">clearTimer(clock, timerId, </span><span class="s0">&quot;IdleCallback&quot;</span><span class="s1">);</span>
        <span class="s1">};</span>

        <span class="s1">clock.setTimeout = </span><span class="s3">function </span><span class="s1">setTimeout(func, timeout) {</span>
            <span class="s3">return </span><span class="s1">addTimer(clock, {</span>
                <span class="s1">func: func,</span>
                <span class="s1">args: Array.prototype.slice.call(arguments, </span><span class="s4">2</span><span class="s1">),</span>
                <span class="s1">delay: timeout,</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_global.Promise !== </span><span class="s0">&quot;undefined&quot; </span><span class="s1">&amp;&amp; utilPromisify) {</span>
            <span class="s1">clock.setTimeout[utilPromisify.custom] =</span>
                <span class="s3">function </span><span class="s1">promisifiedSetTimeout(timeout, arg) {</span>
                    <span class="s3">return new </span><span class="s1">_global.Promise(</span><span class="s3">function </span><span class="s1">setTimeoutExecutor(</span>
                        <span class="s1">resolve</span>
                    <span class="s1">) {</span>
                        <span class="s1">addTimer(clock, {</span>
                            <span class="s1">func: resolve,</span>
                            <span class="s1">args: [arg],</span>
                            <span class="s1">delay: timeout,</span>
                        <span class="s1">});</span>
                    <span class="s1">});</span>
                <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">clock.clearTimeout = </span><span class="s3">function </span><span class="s1">clearTimeout(timerId) {</span>
            <span class="s3">return </span><span class="s1">clearTimer(clock, timerId, </span><span class="s0">&quot;Timeout&quot;</span><span class="s1">);</span>
        <span class="s1">};</span>

        <span class="s1">clock.nextTick = </span><span class="s3">function </span><span class="s1">nextTick(func) {</span>
            <span class="s3">return </span><span class="s1">enqueueJob(clock, {</span>
                <span class="s1">func: func,</span>
                <span class="s1">args: Array.prototype.slice.call(arguments, </span><span class="s4">1</span><span class="s1">),</span>
                <span class="s1">error: isNearInfiniteLimit ? </span><span class="s3">new </span><span class="s1">Error() : </span><span class="s3">null</span><span class="s1">,</span>
            <span class="s1">});</span>
        <span class="s1">};</span>

        <span class="s1">clock.queueMicrotask = </span><span class="s3">function </span><span class="s1">queueMicrotask(func) {</span>
            <span class="s3">return </span><span class="s1">clock.nextTick(func); </span><span class="s2">// explicitly drop additional arguments</span>
        <span class="s1">};</span>

        <span class="s1">clock.setInterval = </span><span class="s3">function </span><span class="s1">setInterval(func, timeout) {</span>
            <span class="s2">// eslint-disable-next-line no-param-reassign</span>
            <span class="s1">timeout = parseInt(timeout, </span><span class="s4">10</span><span class="s1">);</span>
            <span class="s3">return </span><span class="s1">addTimer(clock, {</span>
                <span class="s1">func: func,</span>
                <span class="s1">args: Array.prototype.slice.call(arguments, </span><span class="s4">2</span><span class="s1">),</span>
                <span class="s1">delay: timeout,</span>
                <span class="s1">interval: timeout,</span>
            <span class="s1">});</span>
        <span class="s1">};</span>

        <span class="s1">clock.clearInterval = </span><span class="s3">function </span><span class="s1">clearInterval(timerId) {</span>
            <span class="s3">return </span><span class="s1">clearTimer(clock, timerId, </span><span class="s0">&quot;Interval&quot;</span><span class="s1">);</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(setImmediatePresent) {</span>
            <span class="s1">clock.setImmediate = </span><span class="s3">function </span><span class="s1">setImmediate(func) {</span>
                <span class="s3">return </span><span class="s1">addTimer(clock, {</span>
                    <span class="s1">func: func,</span>
                    <span class="s1">args: Array.prototype.slice.call(arguments, </span><span class="s4">1</span><span class="s1">),</span>
                    <span class="s1">immediate: </span><span class="s3">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">};</span>

            <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_global.Promise !== </span><span class="s0">&quot;undefined&quot; </span><span class="s1">&amp;&amp; utilPromisify) {</span>
                <span class="s1">clock.setImmediate[utilPromisify.custom] =</span>
                    <span class="s3">function </span><span class="s1">promisifiedSetImmediate(arg) {</span>
                        <span class="s3">return new </span><span class="s1">_global.Promise(</span>
                            <span class="s3">function </span><span class="s1">setImmediateExecutor(resolve) {</span>
                                <span class="s1">addTimer(clock, {</span>
                                    <span class="s1">func: resolve,</span>
                                    <span class="s1">args: [arg],</span>
                                    <span class="s1">immediate: </span><span class="s3">true</span><span class="s1">,</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                        <span class="s1">);</span>
                    <span class="s1">};</span>
            <span class="s1">}</span>

            <span class="s1">clock.clearImmediate = </span><span class="s3">function </span><span class="s1">clearImmediate(timerId) {</span>
                <span class="s3">return </span><span class="s1">clearTimer(clock, timerId, </span><span class="s0">&quot;Immediate&quot;</span><span class="s1">);</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">clock.countTimers = </span><span class="s3">function </span><span class="s1">countTimers() {</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">Object.keys(clock.timers || {}).length +</span>
                <span class="s1">(clock.jobs || []).length</span>
            <span class="s1">);</span>
        <span class="s1">};</span>

        <span class="s1">clock.requestAnimationFrame = </span><span class="s3">function </span><span class="s1">requestAnimationFrame(func) {</span>
            <span class="s1">const result = addTimer(clock, {</span>
                <span class="s1">func: func,</span>
                <span class="s1">delay: getTimeToNextFrame(),</span>
                <span class="s1">get args() {</span>
                    <span class="s3">return </span><span class="s1">[fakePerformanceNow()];</span>
                <span class="s1">},</span>
                <span class="s1">animation: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s1">});</span>

            <span class="s3">return </span><span class="s1">Number(result);</span>
        <span class="s1">};</span>

        <span class="s1">clock.cancelAnimationFrame = </span><span class="s3">function </span><span class="s1">cancelAnimationFrame(timerId) {</span>
            <span class="s3">return </span><span class="s1">clearTimer(clock, timerId, </span><span class="s0">&quot;AnimationFrame&quot;</span><span class="s1">);</span>
        <span class="s1">};</span>

        <span class="s1">clock.runMicrotasks = </span><span class="s3">function </span><span class="s1">runMicrotasks() {</span>
            <span class="s1">runJobs(clock);</span>
        <span class="s1">};</span>

        <span class="s2">/** 
         * @param {number|string} tickValue milliseconds or a string parseable by parseTime 
         * @param {boolean} isAsync 
         * @param {Function} resolve 
         * @param {Function} reject 
         * @returns {number|undefined} will return the new `now` value or nothing for async 
         */</span>
        <span class="s3">function </span><span class="s1">doTick(tickValue, isAsync, resolve, reject) {</span>
            <span class="s1">const msFloat =</span>
                <span class="s3">typeof </span><span class="s1">tickValue === </span><span class="s0">&quot;number&quot;</span>
                    <span class="s1">? tickValue</span>
                    <span class="s1">: parseTime(tickValue);</span>
            <span class="s1">const ms = Math.floor(msFloat);</span>
            <span class="s1">const remainder = nanoRemainder(msFloat);</span>
            <span class="s1">let nanosTotal = nanos + remainder;</span>
            <span class="s1">let tickTo = clock.now + ms;</span>

            <span class="s3">if </span><span class="s1">(msFloat &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Negative ticks are not supported&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s2">// adjust for positive overflow</span>
            <span class="s3">if </span><span class="s1">(nanosTotal &gt;= </span><span class="s4">1</span><span class="s1">e6) {</span>
                <span class="s1">tickTo += </span><span class="s4">1</span><span class="s1">;</span>
                <span class="s1">nanosTotal -= </span><span class="s4">1</span><span class="s1">e6;</span>
            <span class="s1">}</span>

            <span class="s1">nanos = nanosTotal;</span>
            <span class="s1">let tickFrom = clock.now;</span>
            <span class="s1">let previous = clock.now;</span>
            <span class="s2">// ESLint fails to detect this correctly</span>
            <span class="s2">/* eslint-disable prefer-const */</span>
            <span class="s1">let timer,</span>
                <span class="s1">firstException,</span>
                <span class="s1">oldNow,</span>
                <span class="s1">nextPromiseTick,</span>
                <span class="s1">compensationCheck,</span>
                <span class="s1">postTimerCall;</span>
            <span class="s2">/* eslint-enable prefer-const */</span>

            <span class="s1">clock.duringTick = </span><span class="s3">true</span><span class="s1">;</span>

            <span class="s2">// perform microtasks</span>
            <span class="s1">oldNow = clock.now;</span>
            <span class="s1">runJobs(clock);</span>
            <span class="s3">if </span><span class="s1">(oldNow !== clock.now) {</span>
                <span class="s2">// compensate for any setSystemTime() call during microtask callback</span>
                <span class="s1">tickFrom += clock.now - oldNow;</span>
                <span class="s1">tickTo += clock.now - oldNow;</span>
            <span class="s1">}</span>

            <span class="s2">//eslint-disable-next-line jsdoc/require-jsdoc</span>
            <span class="s3">function </span><span class="s1">doTickInner() {</span>
                <span class="s2">// perform each timer in the requested range</span>
                <span class="s1">timer = firstTimerInRange(clock, tickFrom, tickTo);</span>
                <span class="s2">// eslint-disable-next-line no-unmodified-loop-condition</span>
                <span class="s3">while </span><span class="s1">(timer &amp;&amp; tickFrom &lt;= tickTo) {</span>
                    <span class="s3">if </span><span class="s1">(clock.timers[timer.id]) {</span>
                        <span class="s1">tickFrom = timer.callAt;</span>
                        <span class="s1">clock.now = timer.callAt;</span>
                        <span class="s1">oldNow = clock.now;</span>
                        <span class="s3">try </span><span class="s1">{</span>
                            <span class="s1">runJobs(clock);</span>
                            <span class="s1">callTimer(clock, timer);</span>
                        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                            <span class="s1">firstException = firstException || e;</span>
                        <span class="s1">}</span>

                        <span class="s3">if </span><span class="s1">(isAsync) {</span>
                            <span class="s2">// finish up after native setImmediate callback to allow</span>
                            <span class="s2">// all native es6 promises to process their callbacks after</span>
                            <span class="s2">// each timer fires.</span>
                            <span class="s1">originalSetTimeout(nextPromiseTick);</span>
                            <span class="s3">return</span><span class="s1">;</span>
                        <span class="s1">}</span>

                        <span class="s1">compensationCheck();</span>
                    <span class="s1">}</span>

                    <span class="s1">postTimerCall();</span>
                <span class="s1">}</span>

                <span class="s2">// perform process.nextTick()s again</span>
                <span class="s1">oldNow = clock.now;</span>
                <span class="s1">runJobs(clock);</span>
                <span class="s3">if </span><span class="s1">(oldNow !== clock.now) {</span>
                    <span class="s2">// compensate for any setSystemTime() call during process.nextTick() callback</span>
                    <span class="s1">tickFrom += clock.now - oldNow;</span>
                    <span class="s1">tickTo += clock.now - oldNow;</span>
                <span class="s1">}</span>
                <span class="s1">clock.duringTick = </span><span class="s3">false</span><span class="s1">;</span>

                <span class="s2">// corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]</span>
                <span class="s1">timer = firstTimerInRange(clock, tickFrom, tickTo);</span>
                <span class="s3">if </span><span class="s1">(timer) {</span>
                    <span class="s3">try </span><span class="s1">{</span>
                        <span class="s1">clock.tick(tickTo - clock.now); </span><span class="s2">// do it all again - for the remainder of the requested range</span>
                    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                        <span class="s1">firstException = firstException || e;</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s2">// no timers remaining in the requested range: move the clock all the way to the end</span>
                    <span class="s1">clock.now = tickTo;</span>

                    <span class="s2">// update nanos</span>
                    <span class="s1">nanos = nanosTotal;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(firstException) {</span>
                    <span class="s3">throw </span><span class="s1">firstException;</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(isAsync) {</span>
                    <span class="s1">resolve(clock.now);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">return </span><span class="s1">clock.now;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">nextPromiseTick =</span>
                <span class="s1">isAsync &amp;&amp;</span>
                <span class="s3">function </span><span class="s1">() {</span>
                    <span class="s3">try </span><span class="s1">{</span>
                        <span class="s1">compensationCheck();</span>
                        <span class="s1">postTimerCall();</span>
                        <span class="s1">doTickInner();</span>
                    <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                        <span class="s1">reject(e);</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>

            <span class="s1">compensationCheck = </span><span class="s3">function </span><span class="s1">() {</span>
                <span class="s2">// compensate for any setSystemTime() call during timer callback</span>
                <span class="s3">if </span><span class="s1">(oldNow !== clock.now) {</span>
                    <span class="s1">tickFrom += clock.now - oldNow;</span>
                    <span class="s1">tickTo += clock.now - oldNow;</span>
                    <span class="s1">previous += clock.now - oldNow;</span>
                <span class="s1">}</span>
            <span class="s1">};</span>

            <span class="s1">postTimerCall = </span><span class="s3">function </span><span class="s1">() {</span>
                <span class="s1">timer = firstTimerInRange(clock, previous, tickTo);</span>
                <span class="s1">previous = tickFrom;</span>
            <span class="s1">};</span>

            <span class="s3">return </span><span class="s1">doTickInner();</span>
        <span class="s1">}</span>

        <span class="s2">/** 
         * @param {string|number} tickValue number of milliseconds or a human-readable value like &quot;01:11:15&quot; 
         * @returns {number} will return the new `now` value 
         */</span>
        <span class="s1">clock.tick = </span><span class="s3">function </span><span class="s1">tick(tickValue) {</span>
            <span class="s3">return </span><span class="s1">doTick(tickValue, </span><span class="s3">false</span><span class="s1">);</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_global.Promise !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s2">/** 
             * @param {string|number} tickValue number of milliseconds or a human-readable value like &quot;01:11:15&quot; 
             * @returns {Promise} 
             */</span>
            <span class="s1">clock.tickAsync = </span><span class="s3">function </span><span class="s1">tickAsync(tickValue) {</span>
                <span class="s3">return new </span><span class="s1">_global.Promise(</span><span class="s3">function </span><span class="s1">(resolve, reject) {</span>
                    <span class="s1">originalSetTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
                        <span class="s3">try </span><span class="s1">{</span>
                            <span class="s1">doTick(tickValue, </span><span class="s3">true</span><span class="s1">, resolve, reject);</span>
                        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                            <span class="s1">reject(e);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">clock.next = </span><span class="s3">function </span><span class="s1">next() {</span>
            <span class="s1">runJobs(clock);</span>
            <span class="s1">const timer = firstTimer(clock);</span>
            <span class="s3">if </span><span class="s1">(!timer) {</span>
                <span class="s3">return </span><span class="s1">clock.now;</span>
            <span class="s1">}</span>

            <span class="s1">clock.duringTick = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s1">clock.now = timer.callAt;</span>
                <span class="s1">callTimer(clock, timer);</span>
                <span class="s1">runJobs(clock);</span>
                <span class="s3">return </span><span class="s1">clock.now;</span>
            <span class="s1">} </span><span class="s3">finally </span><span class="s1">{</span>
                <span class="s1">clock.duringTick = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_global.Promise !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s1">clock.nextAsync = </span><span class="s3">function </span><span class="s1">nextAsync() {</span>
                <span class="s3">return new </span><span class="s1">_global.Promise(</span><span class="s3">function </span><span class="s1">(resolve, reject) {</span>
                    <span class="s1">originalSetTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
                        <span class="s3">try </span><span class="s1">{</span>
                            <span class="s1">const timer = firstTimer(clock);</span>
                            <span class="s3">if </span><span class="s1">(!timer) {</span>
                                <span class="s1">resolve(clock.now);</span>
                                <span class="s3">return</span><span class="s1">;</span>
                            <span class="s1">}</span>

                            <span class="s1">let err;</span>
                            <span class="s1">clock.duringTick = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s1">clock.now = timer.callAt;</span>
                            <span class="s3">try </span><span class="s1">{</span>
                                <span class="s1">callTimer(clock, timer);</span>
                            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                                <span class="s1">err = e;</span>
                            <span class="s1">}</span>
                            <span class="s1">clock.duringTick = </span><span class="s3">false</span><span class="s1">;</span>

                            <span class="s1">originalSetTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
                                <span class="s3">if </span><span class="s1">(err) {</span>
                                    <span class="s1">reject(err);</span>
                                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                                    <span class="s1">resolve(clock.now);</span>
                                <span class="s1">}</span>
                            <span class="s1">});</span>
                        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                            <span class="s1">reject(e);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">clock.runAll = </span><span class="s3">function </span><span class="s1">runAll() {</span>
            <span class="s1">let numTimers, i;</span>
            <span class="s1">runJobs(clock);</span>
            <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; clock.loopLimit; i++) {</span>
                <span class="s3">if </span><span class="s1">(!clock.timers) {</span>
                    <span class="s1">resetIsNearInfiniteLimit();</span>
                    <span class="s3">return </span><span class="s1">clock.now;</span>
                <span class="s1">}</span>

                <span class="s1">numTimers = Object.keys(clock.timers).length;</span>
                <span class="s3">if </span><span class="s1">(numTimers === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">resetIsNearInfiniteLimit();</span>
                    <span class="s3">return </span><span class="s1">clock.now;</span>
                <span class="s1">}</span>

                <span class="s1">clock.next();</span>
                <span class="s1">checkIsNearInfiniteLimit(clock, i);</span>
            <span class="s1">}</span>

            <span class="s1">const excessJob = firstTimer(clock);</span>
            <span class="s3">throw </span><span class="s1">getInfiniteLoopError(clock, excessJob);</span>
        <span class="s1">};</span>

        <span class="s1">clock.runToFrame = </span><span class="s3">function </span><span class="s1">runToFrame() {</span>
            <span class="s3">return </span><span class="s1">clock.tick(getTimeToNextFrame());</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_global.Promise !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s1">clock.runAllAsync = </span><span class="s3">function </span><span class="s1">runAllAsync() {</span>
                <span class="s3">return new </span><span class="s1">_global.Promise(</span><span class="s3">function </span><span class="s1">(resolve, reject) {</span>
                    <span class="s1">let i = </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s2">/** 
                     * 
                     */</span>
                    <span class="s3">function </span><span class="s1">doRun() {</span>
                        <span class="s1">originalSetTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
                            <span class="s3">try </span><span class="s1">{</span>
                                <span class="s1">let numTimers;</span>
                                <span class="s3">if </span><span class="s1">(i &lt; clock.loopLimit) {</span>
                                    <span class="s3">if </span><span class="s1">(!clock.timers) {</span>
                                        <span class="s1">resetIsNearInfiniteLimit();</span>
                                        <span class="s1">resolve(clock.now);</span>
                                        <span class="s3">return</span><span class="s1">;</span>
                                    <span class="s1">}</span>

                                    <span class="s1">numTimers = Object.keys(</span>
                                        <span class="s1">clock.timers</span>
                                    <span class="s1">).length;</span>
                                    <span class="s3">if </span><span class="s1">(numTimers === </span><span class="s4">0</span><span class="s1">) {</span>
                                        <span class="s1">resetIsNearInfiniteLimit();</span>
                                        <span class="s1">resolve(clock.now);</span>
                                        <span class="s3">return</span><span class="s1">;</span>
                                    <span class="s1">}</span>

                                    <span class="s1">clock.next();</span>

                                    <span class="s1">i++;</span>

                                    <span class="s1">doRun();</span>
                                    <span class="s1">checkIsNearInfiniteLimit(clock, i);</span>
                                    <span class="s3">return</span><span class="s1">;</span>
                                <span class="s1">}</span>

                                <span class="s1">const excessJob = firstTimer(clock);</span>
                                <span class="s1">reject(getInfiniteLoopError(clock, excessJob));</span>
                            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                                <span class="s1">reject(e);</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s1">doRun();</span>
                <span class="s1">});</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">clock.runToLast = </span><span class="s3">function </span><span class="s1">runToLast() {</span>
            <span class="s1">const timer = lastTimer(clock);</span>
            <span class="s3">if </span><span class="s1">(!timer) {</span>
                <span class="s1">runJobs(clock);</span>
                <span class="s3">return </span><span class="s1">clock.now;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">clock.tick(timer.callAt - clock.now);</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">_global.Promise !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s1">clock.runToLastAsync = </span><span class="s3">function </span><span class="s1">runToLastAsync() {</span>
                <span class="s3">return new </span><span class="s1">_global.Promise(</span><span class="s3">function </span><span class="s1">(resolve, reject) {</span>
                    <span class="s1">originalSetTimeout(</span><span class="s3">function </span><span class="s1">() {</span>
                        <span class="s3">try </span><span class="s1">{</span>
                            <span class="s1">const timer = lastTimer(clock);</span>
                            <span class="s3">if </span><span class="s1">(!timer) {</span>
                                <span class="s1">resolve(clock.now);</span>
                            <span class="s1">}</span>

                            <span class="s1">resolve(clock.tickAsync(timer.callAt - clock.now));</span>
                        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                            <span class="s1">reject(e);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s1">clock.reset = </span><span class="s3">function </span><span class="s1">reset() {</span>
            <span class="s1">nanos = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">clock.timers = {};</span>
            <span class="s1">clock.jobs = [];</span>
            <span class="s1">clock.now = start;</span>
        <span class="s1">};</span>

        <span class="s1">clock.setSystemTime = </span><span class="s3">function </span><span class="s1">setSystemTime(systemTime) {</span>
            <span class="s2">// determine time difference</span>
            <span class="s1">const newNow = getEpoch(systemTime);</span>
            <span class="s1">const difference = newNow - clock.now;</span>
            <span class="s1">let id, timer;</span>

            <span class="s1">adjustedSystemTime[</span><span class="s4">0</span><span class="s1">] = adjustedSystemTime[</span><span class="s4">0</span><span class="s1">] + difference;</span>
            <span class="s1">adjustedSystemTime[</span><span class="s4">1</span><span class="s1">] = adjustedSystemTime[</span><span class="s4">1</span><span class="s1">] + nanos;</span>
            <span class="s2">// update 'system clock'</span>
            <span class="s1">clock.now = newNow;</span>
            <span class="s1">nanos = </span><span class="s4">0</span><span class="s1">;</span>

            <span class="s2">// update timers and intervals to keep them stable</span>
            <span class="s3">for </span><span class="s1">(id </span><span class="s3">in </span><span class="s1">clock.timers) {</span>
                <span class="s3">if </span><span class="s1">(clock.timers.hasOwnProperty(id)) {</span>
                    <span class="s1">timer = clock.timers[id];</span>
                    <span class="s1">timer.createdAt += difference;</span>
                    <span class="s1">timer.callAt += difference;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">};</span>

        <span class="s2">/** 
         * @param {string|number} tickValue number of milliseconds or a human-readable value like &quot;01:11:15&quot; 
         * @returns {number} will return the new `now` value 
         */</span>
        <span class="s1">clock.jump = </span><span class="s3">function </span><span class="s1">jump(tickValue) {</span>
            <span class="s1">const msFloat =</span>
                <span class="s3">typeof </span><span class="s1">tickValue === </span><span class="s0">&quot;number&quot;</span>
                    <span class="s1">? tickValue</span>
                    <span class="s1">: parseTime(tickValue);</span>
            <span class="s1">const ms = Math.floor(msFloat);</span>

            <span class="s3">for </span><span class="s1">(const timer of Object.values(clock.timers)) {</span>
                <span class="s3">if </span><span class="s1">(clock.now + ms &gt; timer.callAt) {</span>
                    <span class="s1">timer.callAt = clock.now + ms;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">clock.tick(ms);</span>
        <span class="s1">};</span>

        <span class="s3">if </span><span class="s1">(performancePresent) {</span>
            <span class="s1">clock.performance = Object.create(</span><span class="s3">null</span><span class="s1">);</span>
            <span class="s1">clock.performance.now = fakePerformanceNow;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(hrtimePresent) {</span>
            <span class="s1">clock.hrtime = hrtime;</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">clock;</span>
    <span class="s1">}</span>

    <span class="s2">/* eslint-disable complexity */</span>

    <span class="s2">/** 
     * @param {Config=} [config] Optional config 
     * @returns {Clock} 
     */</span>
    <span class="s3">function </span><span class="s1">install(config) {</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">arguments.length &gt; </span><span class="s4">1 </span><span class="s1">||</span>
            <span class="s1">config </span><span class="s3">instanceof </span><span class="s1">Date ||</span>
            <span class="s1">Array.isArray(config) ||</span>
            <span class="s3">typeof </span><span class="s1">config === </span><span class="s0">&quot;number&quot;</span>
        <span class="s1">) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span>
                <span class="s1">`FakeTimers.install called </span><span class="s3">with </span><span class="s1">${String(</span>
                    <span class="s1">config</span>
                <span class="s1">)} install requires an object parameter`</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(_global.Date.isFake === </span><span class="s3">true</span><span class="s1">) {</span>
            <span class="s2">// Timers are already faked; this is a problem.</span>
            <span class="s2">// Make the user reset timers before continuing.</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span>
                <span class="s0">&quot;Can't install fake timers twice on the same global object.&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">// eslint-disable-next-line no-param-reassign</span>
        <span class="s1">config = </span><span class="s3">typeof </span><span class="s1">config !== </span><span class="s0">&quot;undefined&quot; </span><span class="s1">? config : {};</span>
        <span class="s1">config.shouldAdvanceTime = config.shouldAdvanceTime || </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">config.advanceTimeDelta = config.advanceTimeDelta || </span><span class="s4">20</span><span class="s1">;</span>
        <span class="s1">config.shouldClearNativeTimers =</span>
            <span class="s1">config.shouldClearNativeTimers || </span><span class="s3">false</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s1">(config.target) {</span>
            <span class="s3">throw new </span><span class="s1">TypeError(</span>
                <span class="s0">&quot;config.target is no longer supported. Use `withGlobal(target)` instead.&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">let i, l;</span>
        <span class="s1">const clock = createClock(config.now, config.loopLimit);</span>
        <span class="s1">clock.shouldClearNativeTimers = config.shouldClearNativeTimers;</span>

        <span class="s1">clock.uninstall = </span><span class="s3">function </span><span class="s1">() {</span>
            <span class="s3">return </span><span class="s1">uninstall(clock, config);</span>
        <span class="s1">};</span>

        <span class="s1">clock.methods = config.toFake || [];</span>

        <span class="s3">if </span><span class="s1">(clock.methods.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">// do not fake nextTick by default - GitHub#126</span>
            <span class="s1">clock.methods = Object.keys(timers).filter(</span><span class="s3">function </span><span class="s1">(key) {</span>
                <span class="s3">return </span><span class="s1">key !== </span><span class="s0">&quot;nextTick&quot; </span><span class="s1">&amp;&amp; key !== </span><span class="s0">&quot;queueMicrotask&quot;</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(config.shouldAdvanceTime === </span><span class="s3">true</span><span class="s1">) {</span>
            <span class="s1">const intervalTick = doIntervalTick.bind(</span>
                <span class="s3">null</span><span class="s1">,</span>
                <span class="s1">clock,</span>
                <span class="s1">config.advanceTimeDelta</span>
            <span class="s1">);</span>
            <span class="s1">const intervalId = _global.setInterval(</span>
                <span class="s1">intervalTick,</span>
                <span class="s1">config.advanceTimeDelta</span>
            <span class="s1">);</span>
            <span class="s1">clock.attachedInterval = intervalId;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">(clock.methods.includes(</span><span class="s0">&quot;performance&quot;</span><span class="s1">)) {</span>
            <span class="s1">const proto = (() =&gt; {</span>
                <span class="s3">if </span><span class="s1">(hasPerformancePrototype) {</span>
                    <span class="s3">return </span><span class="s1">_global.Performance.prototype;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(hasPerformanceConstructorPrototype) {</span>
                    <span class="s3">return </span><span class="s1">_global.performance.constructor.prototype;</span>
                <span class="s1">}</span>
            <span class="s1">})();</span>
            <span class="s3">if </span><span class="s1">(proto) {</span>
                <span class="s1">Object.getOwnPropertyNames(proto).forEach(</span><span class="s3">function </span><span class="s1">(name) {</span>
                    <span class="s3">if </span><span class="s1">(name !== </span><span class="s0">&quot;now&quot;</span><span class="s1">) {</span>
                        <span class="s1">clock.performance[name] =</span>
                            <span class="s1">name.indexOf(</span><span class="s0">&quot;getEntries&quot;</span><span class="s1">) === </span><span class="s4">0</span>
                                <span class="s1">? NOOP_ARRAY</span>
                                <span class="s1">: NOOP;</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">((config.toFake || []).includes(</span><span class="s0">&quot;performance&quot;</span><span class="s1">)) {</span>
                <span class="s2">// user explicitly tried to fake performance when not present</span>
                <span class="s3">throw new </span><span class="s1">ReferenceError(</span>
                    <span class="s0">&quot;non-existent performance object cannot be faked&quot;</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">, l = clock.methods.length; i &lt; l; i++) {</span>
            <span class="s1">const nameOfMethodToReplace = clock.methods[i];</span>
            <span class="s3">if </span><span class="s1">(nameOfMethodToReplace === </span><span class="s0">&quot;hrtime&quot;</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">_global.process &amp;&amp;</span>
                    <span class="s3">typeof </span><span class="s1">_global.process.hrtime === </span><span class="s0">&quot;function&quot;</span>
                <span class="s1">) {</span>
                    <span class="s1">hijackMethod(_global.process, nameOfMethodToReplace, clock);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(nameOfMethodToReplace === </span><span class="s0">&quot;nextTick&quot;</span><span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">_global.process &amp;&amp;</span>
                    <span class="s3">typeof </span><span class="s1">_global.process.nextTick === </span><span class="s0">&quot;function&quot;</span>
                <span class="s1">) {</span>
                    <span class="s1">hijackMethod(_global.process, nameOfMethodToReplace, clock);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">hijackMethod(_global, nameOfMethodToReplace, clock);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">return </span><span class="s1">clock;</span>
    <span class="s1">}</span>

    <span class="s2">/* eslint-enable complexity */</span>

    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">timers: timers,</span>
        <span class="s1">createClock: createClock,</span>
        <span class="s1">install: install,</span>
        <span class="s1">withGlobal: withGlobal,</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">/** 
 * @typedef {object} FakeTimers 
 * @property {Timers} timers 
 * @property {createClock} createClock 
 * @property {Function} install 
 * @property {withGlobal} withGlobal 
 */</span>

<span class="s2">/* eslint-enable complexity */</span>

<span class="s2">/** @type {FakeTimers} */</span>
<span class="s1">const defaultImplementation = withGlobal(globalObject);</span>

<span class="s1">exports.timers = defaultImplementation.timers;</span>
<span class="s1">exports.createClock = defaultImplementation.createClock;</span>
<span class="s1">exports.install = defaultImplementation.install;</span>
<span class="s1">exports.withGlobal = withGlobal;</span>
</pre>
</body>
</html>
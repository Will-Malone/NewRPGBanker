<html>
<head>
<title>dumper.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dumper.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">/*eslint-disable no-use-before-define*/</span>

<span class="s3">var </span><span class="s1">common              = require(</span><span class="s0">'./common'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">YAMLException       = require(</span><span class="s0">'./exception'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">DEFAULT_FULL_SCHEMA = require(</span><span class="s0">'./schema/default_full'</span><span class="s1">);</span>
<span class="s3">var </span><span class="s1">DEFAULT_SAFE_SCHEMA = require(</span><span class="s0">'./schema/default_safe'</span><span class="s1">);</span>

<span class="s3">var </span><span class="s1">_toString       = Object.prototype.toString;</span>
<span class="s3">var </span><span class="s1">_hasOwnProperty = Object.prototype.hasOwnProperty;</span>

<span class="s3">var </span><span class="s1">CHAR_TAB                  = </span><span class="s4">0</span><span class="s1">x09; </span><span class="s2">/* Tab */</span>
<span class="s3">var </span><span class="s1">CHAR_LINE_FEED            = </span><span class="s4">0</span><span class="s1">x0A; </span><span class="s2">/* LF */</span>
<span class="s3">var </span><span class="s1">CHAR_CARRIAGE_RETURN      = </span><span class="s4">0</span><span class="s1">x0D; </span><span class="s2">/* CR */</span>
<span class="s3">var </span><span class="s1">CHAR_SPACE                = </span><span class="s4">0</span><span class="s1">x20; </span><span class="s2">/* Space */</span>
<span class="s3">var </span><span class="s1">CHAR_EXCLAMATION          = </span><span class="s4">0</span><span class="s1">x21; </span><span class="s2">/* ! */</span>
<span class="s3">var </span><span class="s1">CHAR_DOUBLE_QUOTE         = </span><span class="s4">0</span><span class="s1">x22; </span><span class="s2">/* &quot; */</span>
<span class="s3">var </span><span class="s1">CHAR_SHARP                = </span><span class="s4">0</span><span class="s1">x23; </span><span class="s2">/* # */</span>
<span class="s3">var </span><span class="s1">CHAR_PERCENT              = </span><span class="s4">0</span><span class="s1">x25; </span><span class="s2">/* % */</span>
<span class="s3">var </span><span class="s1">CHAR_AMPERSAND            = </span><span class="s4">0</span><span class="s1">x26; </span><span class="s2">/* &amp; */</span>
<span class="s3">var </span><span class="s1">CHAR_SINGLE_QUOTE         = </span><span class="s4">0</span><span class="s1">x27; </span><span class="s2">/* ' */</span>
<span class="s3">var </span><span class="s1">CHAR_ASTERISK             = </span><span class="s4">0</span><span class="s1">x2A; </span><span class="s2">/* * */</span>
<span class="s3">var </span><span class="s1">CHAR_COMMA                = </span><span class="s4">0</span><span class="s1">x2C; </span><span class="s2">/* , */</span>
<span class="s3">var </span><span class="s1">CHAR_MINUS                = </span><span class="s4">0</span><span class="s1">x2D; </span><span class="s2">/* - */</span>
<span class="s3">var </span><span class="s1">CHAR_COLON                = </span><span class="s4">0</span><span class="s1">x3A; </span><span class="s2">/* : */</span>
<span class="s3">var </span><span class="s1">CHAR_EQUALS               = </span><span class="s4">0</span><span class="s1">x3D; </span><span class="s2">/* = */</span>
<span class="s3">var </span><span class="s1">CHAR_GREATER_THAN         = </span><span class="s4">0</span><span class="s1">x3E; </span><span class="s2">/* &gt; */</span>
<span class="s3">var </span><span class="s1">CHAR_QUESTION             = </span><span class="s4">0</span><span class="s1">x3F; </span><span class="s2">/* ? */</span>
<span class="s3">var </span><span class="s1">CHAR_COMMERCIAL_AT        = </span><span class="s4">0</span><span class="s1">x40; </span><span class="s2">/* @ */</span>
<span class="s3">var </span><span class="s1">CHAR_LEFT_SQUARE_BRACKET  = </span><span class="s4">0</span><span class="s1">x5B; </span><span class="s2">/* [ */</span>
<span class="s3">var </span><span class="s1">CHAR_RIGHT_SQUARE_BRACKET = </span><span class="s4">0</span><span class="s1">x5D; </span><span class="s2">/* ] */</span>
<span class="s3">var </span><span class="s1">CHAR_GRAVE_ACCENT         = </span><span class="s4">0</span><span class="s1">x60; </span><span class="s2">/* ` */</span>
<span class="s3">var </span><span class="s1">CHAR_LEFT_CURLY_BRACKET   = </span><span class="s4">0</span><span class="s1">x7B; </span><span class="s2">/* { */</span>
<span class="s3">var </span><span class="s1">CHAR_VERTICAL_LINE        = </span><span class="s4">0</span><span class="s1">x7C; </span><span class="s2">/* | */</span>
<span class="s3">var </span><span class="s1">CHAR_RIGHT_CURLY_BRACKET  = </span><span class="s4">0</span><span class="s1">x7D; </span><span class="s2">/* } */</span>

<span class="s3">var </span><span class="s1">ESCAPE_SEQUENCES = {};</span>

<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x00]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">0'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x07]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">a'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x08]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">b'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x09]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">t'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0A]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">n'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0B]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">v'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0C]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">f'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x0D]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">r'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x1B]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">e'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x22]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">&quot;'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x5C]   = </span><span class="s0">'</span><span class="s5">\\\\</span><span class="s0">'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x85]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">N'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">xA0]   = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">_'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x2028] = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">L'</span><span class="s1">;</span>
<span class="s1">ESCAPE_SEQUENCES[</span><span class="s4">0</span><span class="s1">x2029] = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">P'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">DEPRECATED_BOOLEANS_SYNTAX = [</span>
  <span class="s0">'y'</span><span class="s1">, </span><span class="s0">'Y'</span><span class="s1">, </span><span class="s0">'yes'</span><span class="s1">, </span><span class="s0">'Yes'</span><span class="s1">, </span><span class="s0">'YES'</span><span class="s1">, </span><span class="s0">'on'</span><span class="s1">, </span><span class="s0">'On'</span><span class="s1">, </span><span class="s0">'ON'</span><span class="s1">,</span>
  <span class="s0">'n'</span><span class="s1">, </span><span class="s0">'N'</span><span class="s1">, </span><span class="s0">'no'</span><span class="s1">, </span><span class="s0">'No'</span><span class="s1">, </span><span class="s0">'NO'</span><span class="s1">, </span><span class="s0">'off'</span><span class="s1">, </span><span class="s0">'Off'</span><span class="s1">, </span><span class="s0">'OFF'</span>
<span class="s1">];</span>

<span class="s3">function </span><span class="s1">compileStyleMap(schema, map) {</span>
  <span class="s3">var </span><span class="s1">result, keys, index, length, tag, style, type;</span>

  <span class="s3">if </span><span class="s1">(map === </span><span class="s3">null</span><span class="s1">) </span><span class="s3">return </span><span class="s1">{};</span>

  <span class="s1">result = {};</span>
  <span class="s1">keys = Object.keys(map);</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = keys.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">tag = keys[index];</span>
    <span class="s1">style = String(map[tag]);</span>

    <span class="s3">if </span><span class="s1">(tag.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s1">) === </span><span class="s0">'!!'</span><span class="s1">) {</span>
      <span class="s1">tag = </span><span class="s0">'tag:yaml.org,2002:' </span><span class="s1">+ tag.slice(</span><span class="s4">2</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">type = schema.compiledTypeMap[</span><span class="s0">'fallback'</span><span class="s1">][tag];</span>

    <span class="s3">if </span><span class="s1">(type &amp;&amp; _hasOwnProperty.call(type.styleAliases, style)) {</span>
      <span class="s1">style = type.styleAliases[style];</span>
    <span class="s1">}</span>

    <span class="s1">result[tag] = style;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">encodeHex(character) {</span>
  <span class="s3">var </span><span class="s1">string, handle, length;</span>

  <span class="s1">string = character.toString(</span><span class="s4">16</span><span class="s1">).toUpperCase();</span>

  <span class="s3">if </span><span class="s1">(character &lt;= </span><span class="s4">0</span><span class="s1">xFF) {</span>
    <span class="s1">handle = </span><span class="s0">'x'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(character &lt;= </span><span class="s4">0</span><span class="s1">xFFFF) {</span>
    <span class="s1">handle = </span><span class="s0">'u'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(character &lt;= </span><span class="s4">0</span><span class="s1">xFFFFFFFF) {</span>
    <span class="s1">handle = </span><span class="s0">'U'</span><span class="s1">;</span>
    <span class="s1">length = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'code point within a string may not be greater than 0xFFFFFFFF'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">' </span><span class="s1">+ handle + common.repeat(</span><span class="s0">'0'</span><span class="s1">, length - string.length) + string;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">State(options) {</span>
  <span class="s3">this</span><span class="s1">.schema        = options[</span><span class="s0">'schema'</span><span class="s1">] || DEFAULT_FULL_SCHEMA;</span>
  <span class="s3">this</span><span class="s1">.indent        = Math.max(</span><span class="s4">1</span><span class="s1">, (options[</span><span class="s0">'indent'</span><span class="s1">] || </span><span class="s4">2</span><span class="s1">));</span>
  <span class="s3">this</span><span class="s1">.noArrayIndent = options[</span><span class="s0">'noArrayIndent'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.skipInvalid   = options[</span><span class="s0">'skipInvalid'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.flowLevel     = (common.isNothing(options[</span><span class="s0">'flowLevel'</span><span class="s1">]) ? -</span><span class="s4">1 </span><span class="s1">: options[</span><span class="s0">'flowLevel'</span><span class="s1">]);</span>
  <span class="s3">this</span><span class="s1">.styleMap      = compileStyleMap(</span><span class="s3">this</span><span class="s1">.schema, options[</span><span class="s0">'styles'</span><span class="s1">] || </span><span class="s3">null</span><span class="s1">);</span>
  <span class="s3">this</span><span class="s1">.sortKeys      = options[</span><span class="s0">'sortKeys'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.lineWidth     = options[</span><span class="s0">'lineWidth'</span><span class="s1">] || </span><span class="s4">80</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.noRefs        = options[</span><span class="s0">'noRefs'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.noCompatMode  = options[</span><span class="s0">'noCompatMode'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.condenseFlow  = options[</span><span class="s0">'condenseFlow'</span><span class="s1">] || </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">this</span><span class="s1">.implicitTypes = </span><span class="s3">this</span><span class="s1">.schema.compiledImplicit;</span>
  <span class="s3">this</span><span class="s1">.explicitTypes = </span><span class="s3">this</span><span class="s1">.schema.compiledExplicit;</span>

  <span class="s3">this</span><span class="s1">.tag = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">this</span><span class="s1">.result = </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s3">this</span><span class="s1">.duplicates = [];</span>
  <span class="s3">this</span><span class="s1">.usedDuplicates = </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Indents every line in a string. Empty lines (\n only) are not indented.</span>
<span class="s3">function </span><span class="s1">indentString(string, spaces) {</span>
  <span class="s3">var </span><span class="s1">ind = common.repeat(</span><span class="s0">' '</span><span class="s1">, spaces),</span>
      <span class="s1">position = </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">next = -</span><span class="s4">1</span><span class="s1">,</span>
      <span class="s1">result = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">line,</span>
      <span class="s1">length = string.length;</span>

  <span class="s3">while </span><span class="s1">(position &lt; length) {</span>
    <span class="s1">next = string.indexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">, position);</span>
    <span class="s3">if </span><span class="s1">(next === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">line = string.slice(position);</span>
      <span class="s1">position = length;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">line = string.slice(position, next + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">position = next + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(line.length &amp;&amp; line !== </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">) result += ind;</span>

    <span class="s1">result += line;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">generateNextLine(state, level) {</span>
  <span class="s3">return </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ common.repeat(</span><span class="s0">' '</span><span class="s1">, state.indent * level);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">testImplicitResolving(state, str) {</span>
  <span class="s3">var </span><span class="s1">index, length, type;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = state.implicitTypes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">type = state.implicitTypes[index];</span>

    <span class="s3">if </span><span class="s1">(type.resolve(str)) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// [33] s-white ::= s-space | s-tab</span>
<span class="s3">function </span><span class="s1">isWhitespace(c) {</span>
  <span class="s3">return </span><span class="s1">c === CHAR_SPACE || c === CHAR_TAB;</span>
<span class="s1">}</span>

<span class="s2">// Returns true if the character can be printed without escaping.</span>
<span class="s2">// From YAML 1.2: &quot;any allowed characters known to be non-printable</span>
<span class="s2">// should also be escaped. [However,] This isn’t mandatory&quot;</span>
<span class="s2">// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.</span>
<span class="s3">function </span><span class="s1">isPrintable(c) {</span>
  <span class="s3">return  </span><span class="s1">(</span><span class="s4">0</span><span class="s1">x00020 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x00007E)</span>
      <span class="s1">|| ((</span><span class="s4">0</span><span class="s1">x000A1 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x00D7FF) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">x2028 &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">x2029)</span>
      <span class="s1">|| ((</span><span class="s4">0</span><span class="s1">x0E000 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x00FFFD) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF </span><span class="s2">/* BOM */</span><span class="s1">)</span>
      <span class="s1">||  (</span><span class="s4">0</span><span class="s1">x10000 &lt;= c &amp;&amp; c &lt;= </span><span class="s4">0</span><span class="s1">x10FFFF);</span>
<span class="s1">}</span>

<span class="s2">// [34] ns-char ::= nb-char - s-white</span>
<span class="s2">// [27] nb-char ::= c-printable - b-char - c-byte-order-mark</span>
<span class="s2">// [26] b-char  ::= b-line-feed | b-carriage-return</span>
<span class="s2">// [24] b-line-feed       ::=     #xA    /* LF */</span>
<span class="s2">// [25] b-carriage-return ::=     #xD    /* CR */</span>
<span class="s2">// [3]  c-byte-order-mark ::=     #xFEFF</span>
<span class="s3">function </span><span class="s1">isNsChar(c) {</span>
  <span class="s3">return </span><span class="s1">isPrintable(c) &amp;&amp; !isWhitespace(c)</span>
    <span class="s2">// byte-order-mark</span>
    <span class="s1">&amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF</span>
    <span class="s2">// b-char</span>
    <span class="s1">&amp;&amp; c !== CHAR_CARRIAGE_RETURN</span>
    <span class="s1">&amp;&amp; c !== CHAR_LINE_FEED;</span>
<span class="s1">}</span>

<span class="s2">// Simplified test for values allowed after the first character in plain style.</span>
<span class="s3">function </span><span class="s1">isPlainSafe(c, prev) {</span>
  <span class="s2">// Uses a subset of nb-char - c-flow-indicator - &quot;:&quot; - &quot;#&quot;</span>
  <span class="s2">// where nb-char ::= c-printable - b-char - c-byte-order-mark.</span>
  <span class="s3">return </span><span class="s1">isPrintable(c) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF</span>
    <span class="s2">// - c-flow-indicator</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMA</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s2">// - &quot;:&quot; - &quot;#&quot;</span>
    <span class="s2">// /* An ns-char preceding */ &quot;#&quot;</span>
    <span class="s1">&amp;&amp; c !== CHAR_COLON</span>
    <span class="s1">&amp;&amp; ((c !== CHAR_SHARP) || (prev &amp;&amp; isNsChar(prev)));</span>
<span class="s1">}</span>

<span class="s2">// Simplified test for values allowed as the first character in plain style.</span>
<span class="s3">function </span><span class="s1">isPlainSafeFirst(c) {</span>
  <span class="s2">// Uses a subset of ns-char - c-indicator</span>
  <span class="s2">// where ns-char = nb-char - s-white.</span>
  <span class="s3">return </span><span class="s1">isPrintable(c) &amp;&amp; c !== </span><span class="s4">0</span><span class="s1">xFEFF</span>
    <span class="s1">&amp;&amp; !isWhitespace(c) </span><span class="s2">// - s-white</span>
    <span class="s2">// - (c-indicator ::=</span>
    <span class="s2">// “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”</span>
    <span class="s1">&amp;&amp; c !== CHAR_MINUS</span>
    <span class="s1">&amp;&amp; c !== CHAR_QUESTION</span>
    <span class="s1">&amp;&amp; c !== CHAR_COLON</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMA</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_SQUARE_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_LEFT_CURLY_BRACKET</span>
    <span class="s1">&amp;&amp; c !== CHAR_RIGHT_CURLY_BRACKET</span>
    <span class="s2">// | “#” | “&amp;” | “*” | “!” | “|” | “=” | “&gt;” | “'” | “&quot;”</span>
    <span class="s1">&amp;&amp; c !== CHAR_SHARP</span>
    <span class="s1">&amp;&amp; c !== CHAR_AMPERSAND</span>
    <span class="s1">&amp;&amp; c !== CHAR_ASTERISK</span>
    <span class="s1">&amp;&amp; c !== CHAR_EXCLAMATION</span>
    <span class="s1">&amp;&amp; c !== CHAR_VERTICAL_LINE</span>
    <span class="s1">&amp;&amp; c !== CHAR_EQUALS</span>
    <span class="s1">&amp;&amp; c !== CHAR_GREATER_THAN</span>
    <span class="s1">&amp;&amp; c !== CHAR_SINGLE_QUOTE</span>
    <span class="s1">&amp;&amp; c !== CHAR_DOUBLE_QUOTE</span>
    <span class="s2">// | “%” | “@” | “`”)</span>
    <span class="s1">&amp;&amp; c !== CHAR_PERCENT</span>
    <span class="s1">&amp;&amp; c !== CHAR_COMMERCIAL_AT</span>
    <span class="s1">&amp;&amp; c !== CHAR_GRAVE_ACCENT;</span>
<span class="s1">}</span>

<span class="s2">// Determines whether block indentation indicator is required.</span>
<span class="s3">function </span><span class="s1">needIndentIndicator(string) {</span>
  <span class="s3">var </span><span class="s1">leadingSpaceRe = /^\n* /;</span>
  <span class="s3">return </span><span class="s1">leadingSpaceRe.test(string);</span>
<span class="s1">}</span>

<span class="s3">var </span><span class="s1">STYLE_PLAIN   = </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">STYLE_SINGLE  = </span><span class="s4">2</span><span class="s1">,</span>
    <span class="s1">STYLE_LITERAL = </span><span class="s4">3</span><span class="s1">,</span>
    <span class="s1">STYLE_FOLDED  = </span><span class="s4">4</span><span class="s1">,</span>
    <span class="s1">STYLE_DOUBLE  = </span><span class="s4">5</span><span class="s1">;</span>

<span class="s2">// Determines which scalar styles are possible and returns the preferred style.</span>
<span class="s2">// lineWidth = -1 =&gt; no limit.</span>
<span class="s2">// Pre-conditions: str.length &gt; 0.</span>
<span class="s2">// Post-conditions:</span>
<span class="s2">//    STYLE_PLAIN or STYLE_SINGLE =&gt; no \n are in the string.</span>
<span class="s2">//    STYLE_LITERAL =&gt; no lines are suitable for folding (or lineWidth is -1).</span>
<span class="s2">//    STYLE_FOLDED =&gt; a line &gt; lineWidth and can be folded (and lineWidth != -1).</span>
<span class="s3">function </span><span class="s1">chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {</span>
  <span class="s3">var </span><span class="s1">i;</span>
  <span class="s3">var </span><span class="s1">char, prev_char;</span>
  <span class="s3">var </span><span class="s1">hasLineBreak = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">hasFoldableLine = </span><span class="s3">false</span><span class="s1">; </span><span class="s2">// only checked if shouldTrackWidth</span>
  <span class="s3">var </span><span class="s1">shouldTrackWidth = lineWidth !== -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">previousLineBreak = -</span><span class="s4">1</span><span class="s1">; </span><span class="s2">// count the first line correctly</span>
  <span class="s3">var </span><span class="s1">plain = isPlainSafeFirst(string.charCodeAt(</span><span class="s4">0</span><span class="s1">))</span>
          <span class="s1">&amp;&amp; !isWhitespace(string.charCodeAt(string.length - </span><span class="s4">1</span><span class="s1">));</span>

  <span class="s3">if </span><span class="s1">(singleLineOnly) {</span>
    <span class="s2">// Case: no block styles.</span>
    <span class="s2">// Check for disallowed characters to rule out plain and single.</span>
    <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; i++) {</span>
      <span class="s1">char = string.charCodeAt(i);</span>
      <span class="s3">if </span><span class="s1">(!isPrintable(char)) {</span>
        <span class="s3">return </span><span class="s1">STYLE_DOUBLE;</span>
      <span class="s1">}</span>
      <span class="s1">prev_char = i &gt; </span><span class="s4">0 </span><span class="s1">? string.charCodeAt(i - </span><span class="s4">1</span><span class="s1">) : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">plain = plain &amp;&amp; isPlainSafe(char, prev_char);</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s2">// Case: block styles permitted.</span>
    <span class="s3">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; i++) {</span>
      <span class="s1">char = string.charCodeAt(i);</span>
      <span class="s3">if </span><span class="s1">(char === CHAR_LINE_FEED) {</span>
        <span class="s1">hasLineBreak = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s2">// Check if any line can be folded.</span>
        <span class="s3">if </span><span class="s1">(shouldTrackWidth) {</span>
          <span class="s1">hasFoldableLine = hasFoldableLine ||</span>
            <span class="s2">// Foldable line = too long, and not more-indented.</span>
            <span class="s1">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s1">&gt; lineWidth &amp;&amp;</span>
             <span class="s1">string[previousLineBreak + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">' '</span><span class="s1">);</span>
          <span class="s1">previousLineBreak = i;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!isPrintable(char)) {</span>
        <span class="s3">return </span><span class="s1">STYLE_DOUBLE;</span>
      <span class="s1">}</span>
      <span class="s1">prev_char = i &gt; </span><span class="s4">0 </span><span class="s1">? string.charCodeAt(i - </span><span class="s4">1</span><span class="s1">) : </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s1">plain = plain &amp;&amp; isPlainSafe(char, prev_char);</span>
    <span class="s1">}</span>
    <span class="s2">// in case the end is missing a \n</span>
    <span class="s1">hasFoldableLine = hasFoldableLine || (shouldTrackWidth &amp;&amp;</span>
      <span class="s1">(i - previousLineBreak - </span><span class="s4">1 </span><span class="s1">&gt; lineWidth &amp;&amp;</span>
       <span class="s1">string[previousLineBreak + </span><span class="s4">1</span><span class="s1">] !== </span><span class="s0">' '</span><span class="s1">));</span>
  <span class="s1">}</span>
  <span class="s2">// Although every style can represent \n without escaping, prefer block styles</span>
  <span class="s2">// for multiline, since they're more readable and they don't add empty lines.</span>
  <span class="s2">// Also prefer folding a super-long line.</span>
  <span class="s3">if </span><span class="s1">(!hasLineBreak &amp;&amp; !hasFoldableLine) {</span>
    <span class="s2">// Strings interpretable as another type have to be quoted;</span>
    <span class="s2">// e.g. the string 'true' vs. the boolean true.</span>
    <span class="s3">return </span><span class="s1">plain &amp;&amp; !testAmbiguousType(string)</span>
      <span class="s1">? STYLE_PLAIN : STYLE_SINGLE;</span>
  <span class="s1">}</span>
  <span class="s2">// Edge case: block indentation indicator can only have one digit.</span>
  <span class="s3">if </span><span class="s1">(indentPerLevel &gt; </span><span class="s4">9 </span><span class="s1">&amp;&amp; needIndentIndicator(string)) {</span>
    <span class="s3">return </span><span class="s1">STYLE_DOUBLE;</span>
  <span class="s1">}</span>
  <span class="s2">// At this point we know block styles are valid.</span>
  <span class="s2">// Prefer literal style unless we want to fold.</span>
  <span class="s3">return </span><span class="s1">hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;</span>
<span class="s1">}</span>

<span class="s2">// Note: line breaking/folding is implemented for only the folded style.</span>
<span class="s2">// NB. We drop the last trailing newline (if any) of a returned block scalar</span>
<span class="s2">//  since the dumper adds its own newline. This always works:</span>
<span class="s2">//    • No ending newline =&gt; unaffected; already using strip &quot;-&quot; chomping.</span>
<span class="s2">//    • Ending newline    =&gt; removed then restored.</span>
<span class="s2">//  Importantly, this keeps the &quot;+&quot; chomp indicator from gaining an extra line.</span>
<span class="s3">function </span><span class="s1">writeScalar(state, string, level, iskey) {</span>
  <span class="s1">state.dump = (</span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">if </span><span class="s1">(string.length === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s0">&quot;''&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(!state.noCompatMode &amp;&amp;</span>
        <span class="s1">DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">return </span><span class="s0">&quot;'&quot; </span><span class="s1">+ string + </span><span class="s0">&quot;'&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">indent = state.indent * Math.max(</span><span class="s4">1</span><span class="s1">, level); </span><span class="s2">// no 0-indent scalars</span>
    <span class="s2">// As indentation gets deeper, let the width decrease monotonically</span>
    <span class="s2">// to the lower bound min(state.lineWidth, 40).</span>
    <span class="s2">// Note that this implies</span>
    <span class="s2">//  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.</span>
    <span class="s2">//  state.lineWidth &gt; 40 + state.indent: width decreases until the lower bound.</span>
    <span class="s2">// This behaves better than a constant minimum width which disallows narrower options,</span>
    <span class="s2">// or an indent threshold which causes the width to suddenly increase.</span>
    <span class="s3">var </span><span class="s1">lineWidth = state.lineWidth === -</span><span class="s4">1</span>
      <span class="s1">? -</span><span class="s4">1 </span><span class="s1">: Math.max(Math.min(state.lineWidth, </span><span class="s4">40</span><span class="s1">), state.lineWidth - indent);</span>

    <span class="s2">// Without knowing if keys are implicit/explicit, assume implicit for safety.</span>
    <span class="s3">var </span><span class="s1">singleLineOnly = iskey</span>
      <span class="s2">// No block styles in flow mode.</span>
      <span class="s1">|| (state.flowLevel &gt; -</span><span class="s4">1 </span><span class="s1">&amp;&amp; level &gt;= state.flowLevel);</span>
    <span class="s3">function </span><span class="s1">testAmbiguity(string) {</span>
      <span class="s3">return </span><span class="s1">testImplicitResolving(state, string);</span>
    <span class="s1">}</span>

    <span class="s3">switch </span><span class="s1">(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {</span>
      <span class="s3">case </span><span class="s1">STYLE_PLAIN:</span>
        <span class="s3">return </span><span class="s1">string;</span>
      <span class="s3">case </span><span class="s1">STYLE_SINGLE:</span>
        <span class="s3">return </span><span class="s0">&quot;'&quot; </span><span class="s1">+ string.replace(/</span><span class="s0">'/g, &quot;''&quot;) + &quot;'&quot;;</span>
      <span class="s3">case </span><span class="s1">STYLE_LITERAL:</span>
        <span class="s3">return </span><span class="s0">'|' </span><span class="s1">+ blockHeader(string, state.indent)</span>
          <span class="s1">+ dropEndingNewline(indentString(string, indent));</span>
      <span class="s3">case </span><span class="s1">STYLE_FOLDED:</span>
        <span class="s3">return </span><span class="s0">'&gt;' </span><span class="s1">+ blockHeader(string, state.indent)</span>
          <span class="s1">+ dropEndingNewline(indentString(foldString(string, lineWidth), indent));</span>
      <span class="s3">case </span><span class="s1">STYLE_DOUBLE:</span>
        <span class="s3">return </span><span class="s0">'&quot;' </span><span class="s1">+ escapeString(string, lineWidth) + </span><span class="s0">'&quot;'</span><span class="s1">;</span>
      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'impossible error: invalid scalar style'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}());</span>
<span class="s1">}</span>

<span class="s2">// Pre-conditions: string is valid for a block scalar, 1 &lt;= indentPerLevel &lt;= 9.</span>
<span class="s3">function </span><span class="s1">blockHeader(string, indentPerLevel) {</span>
  <span class="s3">var </span><span class="s1">indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s2">// note the special case: the string '\n' counts as a &quot;trailing&quot; empty line.</span>
  <span class="s3">var </span><span class="s1">clip =          string[string.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">keep = clip &amp;&amp; (string[string.length - </span><span class="s4">2</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">|| string === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
  <span class="s3">var </span><span class="s1">chomp = keep ? </span><span class="s0">'+' </span><span class="s1">: (clip ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'-'</span><span class="s1">);</span>

  <span class="s3">return </span><span class="s1">indentIndicator + chomp + </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// (See the note for writeScalar.)</span>
<span class="s3">function </span><span class="s1">dropEndingNewline(string) {</span>
  <span class="s3">return </span><span class="s1">string[string.length - </span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">? string.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">) : string;</span>
<span class="s1">}</span>

<span class="s2">// Note: a long line without a suitable break point will exceed the width limit.</span>
<span class="s2">// Pre-conditions: every char in str isPrintable, str.length &gt; 0, width &gt; 0.</span>
<span class="s3">function </span><span class="s1">foldString(string, width) {</span>
  <span class="s2">// In folded style, $k$ consecutive newlines output as $k+1$ newlines—</span>
  <span class="s2">// unless they're before or after a more-indented line, or at the very</span>
  <span class="s2">// beginning or end, in which case $k$ maps to $k$.</span>
  <span class="s2">// Therefore, parse each chunk as newline(s) followed by a content line.</span>
  <span class="s3">var </span><span class="s1">lineRe = /(\n+)([^\n]*)/g;</span>

  <span class="s2">// first line (possibly an empty line)</span>
  <span class="s3">var </span><span class="s1">result = (</span><span class="s3">function </span><span class="s1">() {</span>
    <span class="s3">var </span><span class="s1">nextLF = string.indexOf(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
    <span class="s1">nextLF = nextLF !== -</span><span class="s4">1 </span><span class="s1">? nextLF : string.length;</span>
    <span class="s1">lineRe.lastIndex = nextLF;</span>
    <span class="s3">return </span><span class="s1">foldLine(string.slice(</span><span class="s4">0</span><span class="s1">, nextLF), width);</span>
  <span class="s1">}());</span>
  <span class="s2">// If we haven't reached the first content line yet, don't add an extra \n.</span>
  <span class="s3">var </span><span class="s1">prevMoreIndented = string[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">|| string[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">moreIndented;</span>

  <span class="s2">// rest of the lines</span>
  <span class="s3">var </span><span class="s1">match;</span>
  <span class="s3">while </span><span class="s1">((match = lineRe.exec(string))) {</span>
    <span class="s3">var </span><span class="s1">prefix = match[</span><span class="s4">1</span><span class="s1">], line = match[</span><span class="s4">2</span><span class="s1">];</span>
    <span class="s1">moreIndented = (line[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">);</span>
    <span class="s1">result += prefix</span>
      <span class="s1">+ (!prevMoreIndented &amp;&amp; !moreIndented &amp;&amp; line !== </span><span class="s0">''</span>
        <span class="s1">? </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">)</span>
      <span class="s1">+ foldLine(line, width);</span>
    <span class="s1">prevMoreIndented = moreIndented;</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s2">// Greedy line breaking.</span>
<span class="s2">// Picks the longest line under the limit each time,</span>
<span class="s2">// otherwise settles for the shortest line over the limit.</span>
<span class="s2">// NB. More-indented lines *cannot* be folded, as that would add an extra \n.</span>
<span class="s3">function </span><span class="s1">foldLine(line, width) {</span>
  <span class="s3">if </span><span class="s1">(line === </span><span class="s0">'' </span><span class="s1">|| line[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">' '</span><span class="s1">) </span><span class="s3">return </span><span class="s1">line;</span>

  <span class="s2">// Since a more-indented line adds a \n, breaks can't be followed by a space.</span>
  <span class="s3">var </span><span class="s1">breakRe = / [^ ]/g; </span><span class="s2">// note: the match index will always be &lt;= length-2.</span>
  <span class="s3">var </span><span class="s1">match;</span>
  <span class="s2">// start is an inclusive index. end, curr, and next are exclusive.</span>
  <span class="s3">var </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">, end, curr = </span><span class="s4">0</span><span class="s1">, next = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">result = </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s2">// Invariants: 0 &lt;= start &lt;= length-1.</span>
  <span class="s2">//   0 &lt;= curr &lt;= next &lt;= max(0, length-2). curr - start &lt;= width.</span>
  <span class="s2">// Inside the loop:</span>
  <span class="s2">//   A match implies length &gt;= 2, so curr and next are &lt;= length-2.</span>
  <span class="s3">while </span><span class="s1">((match = breakRe.exec(line))) {</span>
    <span class="s1">next = match.index;</span>
    <span class="s2">// maintain invariant: curr - start &lt;= width</span>
    <span class="s3">if </span><span class="s1">(next - start &gt; width) {</span>
      <span class="s1">end = (curr &gt; start) ? curr : next; </span><span class="s2">// derive end &lt;= length-2</span>
      <span class="s1">result += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ line.slice(start, end);</span>
      <span class="s2">// skip the space that was output as \n</span>
      <span class="s1">start = end + </span><span class="s4">1</span><span class="s1">;                    </span><span class="s2">// derive start &lt;= length-1</span>
    <span class="s1">}</span>
    <span class="s1">curr = next;</span>
  <span class="s1">}</span>

  <span class="s2">// By the invariants, start &lt;= length-1, so there is something left over.</span>
  <span class="s2">// It is either the whole string or a part starting from non-whitespace.</span>
  <span class="s1">result += </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>
  <span class="s2">// Insert a break if the remainder is too long and there is a break available.</span>
  <span class="s3">if </span><span class="s1">(line.length - start &gt; width &amp;&amp; curr &gt; start) {</span>
    <span class="s1">result += line.slice(start, curr) + </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">' </span><span class="s1">+ line.slice(curr + </span><span class="s4">1</span><span class="s1">);</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">result += line.slice(start);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result.slice(</span><span class="s4">1</span><span class="s1">); </span><span class="s2">// drop extra \n joiner</span>
<span class="s1">}</span>

<span class="s2">// Escapes a double-quoted string.</span>
<span class="s3">function </span><span class="s1">escapeString(string) {</span>
  <span class="s3">var </span><span class="s1">result = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s3">var </span><span class="s1">char, nextChar;</span>
  <span class="s3">var </span><span class="s1">escapeSeq;</span>

  <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; string.length; i++) {</span>
    <span class="s1">char = string.charCodeAt(i);</span>
    <span class="s2">// Check for surrogate pairs (reference Unicode 3.0 section &quot;3.7 Surrogates&quot;).</span>
    <span class="s3">if </span><span class="s1">(char &gt;= </span><span class="s4">0</span><span class="s1">xD800 &amp;&amp; char &lt;= </span><span class="s4">0</span><span class="s1">xDBFF</span><span class="s2">/* high surrogate */</span><span class="s1">) {</span>
      <span class="s1">nextChar = string.charCodeAt(i + </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s3">if </span><span class="s1">(nextChar &gt;= </span><span class="s4">0</span><span class="s1">xDC00 &amp;&amp; nextChar &lt;= </span><span class="s4">0</span><span class="s1">xDFFF</span><span class="s2">/* low surrogate */</span><span class="s1">) {</span>
        <span class="s2">// Combine the surrogate pair and store it escaped.</span>
        <span class="s1">result += encodeHex((char - </span><span class="s4">0</span><span class="s1">xD800) * </span><span class="s4">0</span><span class="s1">x400 + nextChar - </span><span class="s4">0</span><span class="s1">xDC00 + </span><span class="s4">0</span><span class="s1">x10000);</span>
        <span class="s2">// Advance index one extra since we already used that char here.</span>
        <span class="s1">i++; </span><span class="s3">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">escapeSeq = ESCAPE_SEQUENCES[char];</span>
    <span class="s1">result += !escapeSeq &amp;&amp; isPrintable(char)</span>
      <span class="s1">? string[i]</span>
      <span class="s1">: escapeSeq || encodeHex(char);</span>
  <span class="s1">}</span>

  <span class="s3">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeFlowSequence(state, level, object) {</span>
  <span class="s3">var </span><span class="s1">_result = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag    = state.tag,</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">// Write only valid elements.</span>
    <span class="s3">if </span><span class="s1">(writeNode(state, level, object[index], </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">)) {</span>
      <span class="s3">if </span><span class="s1">(index !== </span><span class="s4">0</span><span class="s1">) _result += </span><span class="s0">',' </span><span class="s1">+ (!state.condenseFlow ? </span><span class="s0">' ' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">);</span>
      <span class="s1">_result += state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = </span><span class="s0">'[' </span><span class="s1">+ _result + </span><span class="s0">']'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeBlockSequence(state, level, object, compact) {</span>
  <span class="s3">var </span><span class="s1">_result = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag    = state.tag,</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">// Write only valid elements.</span>
    <span class="s3">if </span><span class="s1">(writeNode(state, level + </span><span class="s4">1</span><span class="s1">, object[index], </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">)) {</span>
      <span class="s3">if </span><span class="s1">(!compact || index !== </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">_result += generateNextLine(state, level);</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">_result += </span><span class="s0">'-'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">_result += </span><span class="s0">'- '</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">_result += state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = _result || </span><span class="s0">'[]'</span><span class="s1">; </span><span class="s2">// Empty sequence if no valid values.</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeFlowMapping(state, level, object) {</span>
  <span class="s3">var </span><span class="s1">_result       = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag          = state.tag,</span>
      <span class="s1">objectKeyList = Object.keys(object),</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">objectKey,</span>
      <span class="s1">objectValue,</span>
      <span class="s1">pairBuffer;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>

    <span class="s1">pairBuffer = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(index !== </span><span class="s4">0</span><span class="s1">) pairBuffer += </span><span class="s0">', '</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(state.condenseFlow) pairBuffer += </span><span class="s0">'&quot;'</span><span class="s1">;</span>

    <span class="s1">objectKey = objectKeyList[index];</span>
    <span class="s1">objectValue = object[objectKey];</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level, objectKey, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid key;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(state.dump.length &gt; </span><span class="s4">1024</span><span class="s1">) pairBuffer += </span><span class="s0">'? '</span><span class="s1">;</span>

    <span class="s1">pairBuffer += state.dump + (state.condenseFlow ? </span><span class="s0">'&quot;' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) + </span><span class="s0">':' </span><span class="s1">+ (state.condenseFlow ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">' '</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level, objectValue, </span><span class="s3">false</span><span class="s1">, </span><span class="s3">false</span><span class="s1">)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s2">// Both key and value are valid.</span>
    <span class="s1">_result += pairBuffer;</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = </span><span class="s0">'{' </span><span class="s1">+ _result + </span><span class="s0">'}'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">writeBlockMapping(state, level, object, compact) {</span>
  <span class="s3">var </span><span class="s1">_result       = </span><span class="s0">''</span><span class="s1">,</span>
      <span class="s1">_tag          = state.tag,</span>
      <span class="s1">objectKeyList = Object.keys(object),</span>
      <span class="s1">index,</span>
      <span class="s1">length,</span>
      <span class="s1">objectKey,</span>
      <span class="s1">objectValue,</span>
      <span class="s1">explicitPair,</span>
      <span class="s1">pairBuffer;</span>

  <span class="s2">// Allow sorting keys so that the output file is deterministic</span>
  <span class="s3">if </span><span class="s1">(state.sortKeys === </span><span class="s3">true</span><span class="s1">) {</span>
    <span class="s2">// Default sorting</span>
    <span class="s1">objectKeyList.sort();</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">state.sortKeys === </span><span class="s0">'function'</span><span class="s1">) {</span>
    <span class="s2">// Custom sort function</span>
    <span class="s1">objectKeyList.sort(state.sortKeys);</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(state.sortKeys) {</span>
    <span class="s2">// Something is wrong</span>
    <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'sortKeys must be a boolean or a function'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">pairBuffer = </span><span class="s0">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(!compact || index !== </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">pairBuffer += generateNextLine(state, level);</span>
    <span class="s1">}</span>

    <span class="s1">objectKey = objectKeyList[index];</span>
    <span class="s1">objectValue = object[objectKey];</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level + </span><span class="s4">1</span><span class="s1">, objectKey, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid key.</span>
    <span class="s1">}</span>

    <span class="s1">explicitPair = (state.tag !== </span><span class="s3">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s0">'?'</span><span class="s1">) ||</span>
                   <span class="s1">(state.dump &amp;&amp; state.dump.length &gt; </span><span class="s4">1024</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(explicitPair) {</span>
      <span class="s3">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">pairBuffer += </span><span class="s0">'?'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">pairBuffer += </span><span class="s0">'? '</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s3">if </span><span class="s1">(explicitPair) {</span>
      <span class="s1">pairBuffer += generateNextLine(state, level);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(!writeNode(state, level + </span><span class="s4">1</span><span class="s1">, objectValue, </span><span class="s3">true</span><span class="s1">, explicitPair)) {</span>
      <span class="s3">continue</span><span class="s1">; </span><span class="s2">// Skip this pair because of invalid value.</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(state.dump &amp;&amp; CHAR_LINE_FEED === state.dump.charCodeAt(</span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s1">pairBuffer += </span><span class="s0">':'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">pairBuffer += </span><span class="s0">': '</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">pairBuffer += state.dump;</span>

    <span class="s2">// Both key and value are valid.</span>
    <span class="s1">_result += pairBuffer;</span>
  <span class="s1">}</span>

  <span class="s1">state.tag = _tag;</span>
  <span class="s1">state.dump = _result || </span><span class="s0">'{}'</span><span class="s1">; </span><span class="s2">// Empty mapping if no valid pairs.</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">detectType(state, object, explicit) {</span>
  <span class="s3">var </span><span class="s1">_result, typeList, index, length, type, style;</span>

  <span class="s1">typeList = explicit ? state.explicitTypes : state.implicitTypes;</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = typeList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">type = typeList[index];</span>

    <span class="s3">if </span><span class="s1">((type.instanceOf  || type.predicate) &amp;&amp;</span>
        <span class="s1">(!type.instanceOf || ((</span><span class="s3">typeof </span><span class="s1">object === </span><span class="s0">'object'</span><span class="s1">) &amp;&amp; (object </span><span class="s3">instanceof </span><span class="s1">type.instanceOf))) &amp;&amp;</span>
        <span class="s1">(!type.predicate  || type.predicate(object))) {</span>

      <span class="s1">state.tag = explicit ? type.tag : </span><span class="s0">'?'</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(type.represent) {</span>
        <span class="s1">style = state.styleMap[type.tag] || type.defaultStyle;</span>

        <span class="s3">if </span><span class="s1">(_toString.call(type.represent) === </span><span class="s0">'[object Function]'</span><span class="s1">) {</span>
          <span class="s1">_result = type.represent(object, style);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(_hasOwnProperty.call(type.represent, style)) {</span>
          <span class="s1">_result = type.represent[style](object, style);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'!&lt;' </span><span class="s1">+ type.tag + </span><span class="s0">'&gt; tag resolver accepts not &quot;' </span><span class="s1">+ style + </span><span class="s0">'&quot; style'</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">state.dump = _result;</span>
      <span class="s1">}</span>

      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">// Serializes `object` and writes it to global `result`.</span>
<span class="s2">// Returns true on success, or false on invalid object.</span>
<span class="s2">//</span>
<span class="s3">function </span><span class="s1">writeNode(state, level, object, block, compact, iskey) {</span>
  <span class="s1">state.tag = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">state.dump = object;</span>

  <span class="s3">if </span><span class="s1">(!detectType(state, object, </span><span class="s3">false</span><span class="s1">)) {</span>
    <span class="s1">detectType(state, object, </span><span class="s3">true</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">type = _toString.call(state.dump);</span>

  <span class="s3">if </span><span class="s1">(block) {</span>
    <span class="s1">block = (state.flowLevel &lt; </span><span class="s4">0 </span><span class="s1">|| state.flowLevel &gt; level);</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">objectOrArray = type === </span><span class="s0">'[object Object]' </span><span class="s1">|| type === </span><span class="s0">'[object Array]'</span><span class="s1">,</span>
      <span class="s1">duplicateIndex,</span>
      <span class="s1">duplicate;</span>

  <span class="s3">if </span><span class="s1">(objectOrArray) {</span>
    <span class="s1">duplicateIndex = state.duplicates.indexOf(object);</span>
    <span class="s1">duplicate = duplicateIndex !== -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">((state.tag !== </span><span class="s3">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s0">'?'</span><span class="s1">) || duplicate || (state.indent !== </span><span class="s4">2 </span><span class="s1">&amp;&amp; level &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
    <span class="s1">compact = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(duplicate &amp;&amp; state.usedDuplicates[duplicateIndex]) {</span>
    <span class="s1">state.dump = </span><span class="s0">'*ref_' </span><span class="s1">+ duplicateIndex;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s3">if </span><span class="s1">(objectOrArray &amp;&amp; duplicate &amp;&amp; !state.usedDuplicates[duplicateIndex]) {</span>
      <span class="s1">state.usedDuplicates[duplicateIndex] = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(type === </span><span class="s0">'[object Object]'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(block &amp;&amp; (Object.keys(state.dump).length !== </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">writeBlockMapping(state, level, state.dump, compact);</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">writeFlowMapping(state, level, state.dump);</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + </span><span class="s0">' ' </span><span class="s1">+ state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s0">'[object Array]'</span><span class="s1">) {</span>
      <span class="s3">var </span><span class="s1">arrayLevel = (state.noArrayIndent &amp;&amp; (level &gt; </span><span class="s4">0</span><span class="s1">)) ? level - </span><span class="s4">1 </span><span class="s1">: level;</span>
      <span class="s3">if </span><span class="s1">(block &amp;&amp; (state.dump.length !== </span><span class="s4">0</span><span class="s1">)) {</span>
        <span class="s1">writeBlockSequence(state, arrayLevel, state.dump, compact);</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">writeFlowSequence(state, arrayLevel, state.dump);</span>
        <span class="s3">if </span><span class="s1">(duplicate) {</span>
          <span class="s1">state.dump = </span><span class="s0">'&amp;ref_' </span><span class="s1">+ duplicateIndex + </span><span class="s0">' ' </span><span class="s1">+ state.dump;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s0">'[object String]'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(state.tag !== </span><span class="s0">'?'</span><span class="s1">) {</span>
        <span class="s1">writeScalar(state, state.dump, level, iskey);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">if </span><span class="s1">(state.skipInvalid) </span><span class="s3">return false</span><span class="s1">;</span>
      <span class="s3">throw new </span><span class="s1">YAMLException(</span><span class="s0">'unacceptable kind of an object to dump ' </span><span class="s1">+ type);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(state.tag !== </span><span class="s3">null </span><span class="s1">&amp;&amp; state.tag !== </span><span class="s0">'?'</span><span class="s1">) {</span>
      <span class="s1">state.dump = </span><span class="s0">'!&lt;' </span><span class="s1">+ state.tag + </span><span class="s0">'&gt; ' </span><span class="s1">+ state.dump;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">getDuplicateReferences(object, state) {</span>
  <span class="s3">var </span><span class="s1">objects = [],</span>
      <span class="s1">duplicatesIndexes = [],</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s1">inspectNode(object, objects, duplicatesIndexes);</span>

  <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = duplicatesIndexes.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">state.duplicates.push(objects[duplicatesIndexes[index]]);</span>
  <span class="s1">}</span>
  <span class="s1">state.usedDuplicates = </span><span class="s3">new </span><span class="s1">Array(length);</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">inspectNode(object, objects, duplicatesIndexes) {</span>
  <span class="s3">var </span><span class="s1">objectKeyList,</span>
      <span class="s1">index,</span>
      <span class="s1">length;</span>

  <span class="s3">if </span><span class="s1">(object !== </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">object === </span><span class="s0">'object'</span><span class="s1">) {</span>
    <span class="s1">index = objects.indexOf(object);</span>
    <span class="s3">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(duplicatesIndexes.indexOf(index) === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">duplicatesIndexes.push(index);</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">objects.push(object);</span>

      <span class="s3">if </span><span class="s1">(Array.isArray(object)) {</span>
        <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = object.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">inspectNode(object[index], objects, duplicatesIndexes);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">objectKeyList = Object.keys(object);</span>

        <span class="s3">for </span><span class="s1">(index = </span><span class="s4">0</span><span class="s1">, length = objectKeyList.length; index &lt; length; index += </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">dump(input, options) {</span>
  <span class="s1">options = options || {};</span>

  <span class="s3">var </span><span class="s1">state = </span><span class="s3">new </span><span class="s1">State(options);</span>

  <span class="s3">if </span><span class="s1">(!state.noRefs) getDuplicateReferences(input, state);</span>

  <span class="s3">if </span><span class="s1">(writeNode(state, </span><span class="s4">0</span><span class="s1">, input, </span><span class="s3">true</span><span class="s1">, </span><span class="s3">true</span><span class="s1">)) </span><span class="s3">return </span><span class="s1">state.dump + </span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">;</span>

  <span class="s3">return </span><span class="s0">''</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">safeDump(input, options) {</span>
  <span class="s3">return </span><span class="s1">dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));</span>
<span class="s1">}</span>

<span class="s1">module.exports.dump     = dump;</span>
<span class="s1">module.exports.safeDump = safeDump;</span>
</pre>
</body>
</html>
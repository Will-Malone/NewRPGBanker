<html>
<head>
<title>fetch.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #6897bb; font-style: italic;}
.s3 { color: #cc7832; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fetch.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unwrapFetchResult&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchToTemp&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;fileName&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;basename&quot;</span><span class="s0">,</span><span class="s1">&quot;tmpDir&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;os&quot;</span><span class="s0">,</span><span class="s1">&quot;tmpdir&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;dest&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;createWriteStream&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;pipe&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;logger&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;CLIError&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/fetch.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import * as os from 'os';</span><span class="s3">\n</span><span class="s1">import * as path from 'path';</span><span class="s3">\n</span><span class="s1">import * as fs from 'fs';</span><span class="s3">\n\n</span><span class="s1">import nodeFetch, {</span><span class="s3">\n  </span><span class="s1">RequestInit as FetchOptions,</span><span class="s3">\n  </span><span class="s1">Response,</span><span class="s3">\n  </span><span class="s1">Request,</span><span class="s3">\n  </span><span class="s1">Headers,</span><span class="s3">\n</span><span class="s1">} from 'node-fetch';</span><span class="s3">\n</span><span class="s1">import {CLIError} from './errors';</span><span class="s3">\n</span><span class="s1">import logger from './logger';</span><span class="s3">\n\n</span><span class="s1">async function unwrapFetchResult(response: Response) {</span><span class="s3">\n  </span><span class="s1">const data = await response.text();</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return JSON.parse(data);</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">return data;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Downloads the given `url` to the OS's temp folder and</span><span class="s3">\n </span><span class="s1">* returns the path to it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const fetchToTemp = (url: string): Promise&lt;string&gt; =&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">const fileName = path.basename(url);</span><span class="s3">\n      </span><span class="s1">const tmpDir = path.join(os.tmpdir(), fileName);</span><span class="s3">\n\n      </span><span class="s1">nodeFetch(url).then((result) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (result.status &gt;= 400) {</span><span class="s3">\n          </span><span class="s1">return reject(`Fetch request failed with status ${result.status}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const dest = fs.createWriteStream(tmpDir);</span><span class="s3">\n        </span><span class="s1">result.body.pipe(dest);</span><span class="s3">\n\n        </span><span class="s1">result.body.on('end', () =&gt; {</span><span class="s3">\n          </span><span class="s1">resolve(tmpDir);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">result.body.on('error', reject);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">logger.error(e as any);</span><span class="s3">\n    </span><span class="s1">throw e;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const fetch = async (</span><span class="s3">\n  </span><span class="s1">url: string | Request,</span><span class="s3">\n  </span><span class="s1">options?: FetchOptions,</span><span class="s3">\n</span><span class="s1">): Promise&lt;{status: number; data: any; headers: Headers}&gt; =&gt; {</span><span class="s3">\n  </span><span class="s1">const result = await nodeFetch(url, options);</span><span class="s3">\n  </span><span class="s1">const data = await unwrapFetchResult(result);</span><span class="s3">\n\n  </span><span class="s1">if (result.status &gt;= 400) {</span><span class="s3">\n    </span><span class="s1">throw new CLIError(</span><span class="s3">\n      </span><span class="s1">`Fetch request failed with status ${result.status}: ${data}.`,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">status: result.status,</span><span class="s3">\n    </span><span class="s1">headers: result.headers,</span><span class="s3">\n    </span><span class="s1">data,</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export {fetch, fetchToTemp};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AACA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAA;IAAA;EAAA;EAAA;AAAA;AAMA;AACA;AAA8B;AAAA;AAAA;AAE9B,eAAeA,iBAAiB,CAACC,QAAkB,EAAE;EACnD,MAAMC,IAAI,GAAG,MAAMD,QAAQ,CAACE,IAAI,EAAE;EAElC,IAAI;IACF,OAAOC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;EACzB,CAAC,CAAC,OAAOI,CAAC,EAAE;IACV,OAAOJ,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA,MAAMK,WAAW,GAAIC,GAAW,IAAsB;EACpD,IAAI;IACF,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMC,QAAQ,GAAGC,IAAI,GAACC,QAAQ,CAACN,GAAG,CAAC;MACnC,MAAMO,MAAM,GAAGF,IAAI,GAACG,IAAI,CAACC,EAAE,GAACC,MAAM,EAAE,EAAEN,QAAQ,CAAC;MAE/C,IAAAO,oBAAS,EAACX,GAAG,CAAC,CAACY,IAAI,CAAEC,MAAM,IAAK;QAC9B,IAAIA,MAAM,CAACC,MAAM,IAAI,GAAG,EAAE;UACxB,OAAOX,MAAM,CAAE,oCAAmCU,MAAM,CAACC,MAAO,EAAC,CAAC;QACpE;QAEA,MAAMC,IAAI,GAAGC,EAAE,GAACC,iBAAiB,CAACV,MAAM,CAAC;QACzCM,MAAM,CAACK,IAAI,CAACC,IAAI,CAACJ,IAAI,CAAC;QAEtBF,MAAM,CAACK,IAAI,CAACE,EAAE,CAAC,KAAK,EAAE,MAAM;UAC1BlB,OAAO,CAACK,MAAM,CAAC;QACjB,CAAC,CAAC;QAEFM,MAAM,CAACK,IAAI,CAACE,EAAE,CAAC,OAAO,EAAEjB,MAAM,CAAC;MACjC,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOL,CAAC,EAAE;IACVuB,eAAM,CAACC,KAAK,CAACxB,CAAC,CAAQ;IACtB,MAAMA,CAAC;EACT;AACF,CAAC;AAAC;AAEF,MAAMyB,KAAK,GAAG,OACZvB,GAAqB,EACrBwB,OAAsB,KACqC;EAC3D,MAAMX,MAAM,GAAG,MAAM,IAAAF,oBAAS,EAACX,GAAG,EAAEwB,OAAO,CAAC;EAC5C,MAAM9B,IAAI,GAAG,MAAMF,iBAAiB,CAACqB,MAAM,CAAC;EAE5C,IAAIA,MAAM,CAACC,MAAM,IAAI,GAAG,EAAE;IACxB,MAAM,IAAIW,gBAAQ,CACf,oCAAmCZ,MAAM,CAACC,MAAO,KAAIpB,IAAK,GAAE,CAC9D;EACH;EAEA,OAAO;IACLoB,MAAM,EAAED,MAAM,CAACC,MAAM;IACrBY,OAAO,EAAEb,MAAM,CAACa,OAAO;IACvBhC;EACF,CAAC;AACH,CAAC;AAAC&quot;</span><span class="s0">}</span></pre>
</body>
</html>
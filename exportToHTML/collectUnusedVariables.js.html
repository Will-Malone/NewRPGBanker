<html>
<head>
<title>collectUnusedVariables.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
collectUnusedVariables.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__classPrivateFieldSet = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__classPrivateFieldSet) || </span><span class="s2">function </span><span class="s1">(receiver, state, value, kind, f) {</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;m&quot;</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private method is not writable&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">&amp;&amp; !f) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private accessor was defined without a setter&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">state === </span><span class="s0">&quot;function&quot; </span><span class="s1">? receiver !== state || !f : !state.has(receiver)) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Cannot write private member to an object whose class did not declare it&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__classPrivateFieldGet = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__classPrivateFieldGet) || </span><span class="s2">function </span><span class="s1">(receiver, state, kind, f) {</span>
    <span class="s2">if </span><span class="s1">(kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">&amp;&amp; !f) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Private accessor was defined without a getter&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">state === </span><span class="s0">&quot;function&quot; </span><span class="s1">? receiver !== state || !f : !state.has(receiver)) </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Cannot read private member from an object whose class did not declare it&quot;</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">kind === </span><span class="s0">&quot;m&quot; </span><span class="s1">? f : kind === </span><span class="s0">&quot;a&quot; </span><span class="s1">? f.call(receiver) : f ? f.value : state.get(receiver);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">_UnusedVarsVisitor_scopeManager;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.collectUnusedVariables = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">const scope_manager_1 = require(</span><span class="s0">&quot;@typescript-eslint/scope-manager&quot;</span><span class="s1">);</span>
<span class="s1">const Visitor_1 = require(</span><span class="s0">&quot;@typescript-eslint/scope-manager/dist/referencer/Visitor&quot;</span><span class="s1">);</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">class UnusedVarsVisitor extends Visitor_1.Visitor {</span>
    <span class="s4">// readonly #unusedVariables = new Set&lt;TSESLint.Scope.Variable&gt;();</span>
    <span class="s1">constructor(context) {</span>
        <span class="s1">super({</span>
            <span class="s1">visitChildrenEvenIfSelectorExists: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">});</span>
        <span class="s1">_UnusedVarsVisitor_scopeManager.set(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">void </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s4">//#endregion HELPERS</span>
        <span class="s4">//#region VISITORS</span>
        <span class="s4">// NOTE - This is a simple visitor - meaning it does not support selectors</span>
        <span class="s2">this</span><span class="s1">.ClassDeclaration = </span><span class="s2">this</span><span class="s1">.visitClass;</span>
        <span class="s2">this</span><span class="s1">.ClassExpression = </span><span class="s2">this</span><span class="s1">.visitClass;</span>
        <span class="s2">this</span><span class="s1">.FunctionDeclaration = </span><span class="s2">this</span><span class="s1">.visitFunction;</span>
        <span class="s2">this</span><span class="s1">.FunctionExpression = </span><span class="s2">this</span><span class="s1">.visitFunction;</span>
        <span class="s2">this</span><span class="s1">.MethodDefinition = </span><span class="s2">this</span><span class="s1">.visitSetter;</span>
        <span class="s2">this</span><span class="s1">.Property = </span><span class="s2">this</span><span class="s1">.visitSetter;</span>
        <span class="s2">this</span><span class="s1">.TSCallSignatureDeclaration = </span><span class="s2">this</span><span class="s1">.visitFunctionTypeSignature;</span>
        <span class="s2">this</span><span class="s1">.TSConstructorType = </span><span class="s2">this</span><span class="s1">.visitFunctionTypeSignature;</span>
        <span class="s2">this</span><span class="s1">.TSConstructSignatureDeclaration = </span><span class="s2">this</span><span class="s1">.visitFunctionTypeSignature;</span>
        <span class="s2">this</span><span class="s1">.TSDeclareFunction = </span><span class="s2">this</span><span class="s1">.visitFunctionTypeSignature;</span>
        <span class="s2">this</span><span class="s1">.TSEmptyBodyFunctionExpression = </span><span class="s2">this</span><span class="s1">.visitFunctionTypeSignature;</span>
        <span class="s2">this</span><span class="s1">.TSFunctionType = </span><span class="s2">this</span><span class="s1">.visitFunctionTypeSignature;</span>
        <span class="s2">this</span><span class="s1">.TSMethodSignature = </span><span class="s2">this</span><span class="s1">.visitFunctionTypeSignature;</span>
        <span class="s1">__classPrivateFieldSet(</span><span class="s2">this</span><span class="s1">, _UnusedVarsVisitor_scopeManager, utils_1.ESLintUtils.nullThrows(context.getSourceCode().scopeManager, </span><span class="s0">'Missing required scope manager'</span><span class="s1">), </span><span class="s0">&quot;f&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">static collectUnusedVariables(context) {</span>
        <span class="s1">const program = context.getSourceCode().ast;</span>
        <span class="s1">const cached = </span><span class="s2">this</span><span class="s1">.RESULTS_CACHE.get(program);</span>
        <span class="s2">if </span><span class="s1">(cached) {</span>
            <span class="s2">return </span><span class="s1">cached;</span>
        <span class="s1">}</span>
        <span class="s1">const visitor = </span><span class="s2">new this</span><span class="s1">(context);</span>
        <span class="s1">visitor.visit(program);</span>
        <span class="s1">const unusedVars = visitor.collectUnusedVariables(visitor.getScope(program));</span>
        <span class="s2">this</span><span class="s1">.RESULTS_CACHE.set(program, unusedVars);</span>
        <span class="s2">return </span><span class="s1">unusedVars;</span>
    <span class="s1">}</span>
    <span class="s1">collectUnusedVariables(scope, unusedVariables = </span><span class="s2">new </span><span class="s1">Set()) {</span>
        <span class="s2">for </span><span class="s1">(const variable of scope.variables) {</span>
            <span class="s2">if </span><span class="s1">(</span>
            <span class="s4">// skip function expression names,</span>
            <span class="s1">scope.functionExpressionScope ||</span>
                <span class="s4">// variables marked with markVariableAsUsed(),</span>
                <span class="s1">variable.eslintUsed ||</span>
                <span class="s4">// implicit lib variables (from @typescript-eslint/scope-manager),</span>
                <span class="s1">variable </span><span class="s2">instanceof </span><span class="s1">scope_manager_1.ImplicitLibVariable ||</span>
                <span class="s4">// basic exported variables</span>
                <span class="s1">isExported(variable) ||</span>
                <span class="s4">// variables implicitly exported via a merged declaration</span>
                <span class="s1">isMergableExported(variable) ||</span>
                <span class="s4">// used variables</span>
                <span class="s1">isUsedVariable(variable)) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">unusedVariables.add(variable);</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(const childScope of scope.childScopes) {</span>
            <span class="s2">this</span><span class="s1">.collectUnusedVariables(childScope, unusedVariables);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">unusedVariables;</span>
    <span class="s1">}</span>
    <span class="s4">//#region HELPERS</span>
    <span class="s1">getScope(currentNode) {</span>
        <span class="s4">// On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.</span>
        <span class="s1">const inner = currentNode.type !== utils_1.AST_NODE_TYPES.Program;</span>
        <span class="s1">let node = currentNode;</span>
        <span class="s2">while </span><span class="s1">(node) {</span>
            <span class="s1">const scope = __classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _UnusedVarsVisitor_scopeManager, </span><span class="s0">&quot;f&quot;</span><span class="s1">).acquire(node, inner);</span>
            <span class="s2">if </span><span class="s1">(scope) {</span>
                <span class="s2">if </span><span class="s1">(scope.type === </span><span class="s0">'function-expression-name'</span><span class="s1">) {</span>
                    <span class="s2">return </span><span class="s1">scope.childScopes[</span><span class="s3">0</span><span class="s1">];</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">scope;</span>
            <span class="s1">}</span>
            <span class="s1">node = node.parent;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">__classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _UnusedVarsVisitor_scopeManager, </span><span class="s0">&quot;f&quot;</span><span class="s1">).scopes[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s1">}</span>
    <span class="s1">markVariableAsUsed(variableOrIdentifierOrName, parent) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">variableOrIdentifierOrName !== </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">!(</span><span class="s0">'type' </span><span class="s2">in </span><span class="s1">variableOrIdentifierOrName)) {</span>
            <span class="s1">variableOrIdentifierOrName.eslintUsed = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">let name;</span>
        <span class="s1">let node;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">variableOrIdentifierOrName === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">name = variableOrIdentifierOrName;</span>
            <span class="s1">node = parent;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">name = variableOrIdentifierOrName.name;</span>
            <span class="s1">node = variableOrIdentifierOrName;</span>
        <span class="s1">}</span>
        <span class="s1">let currentScope = </span><span class="s2">this</span><span class="s1">.getScope(node);</span>
        <span class="s2">while </span><span class="s1">(currentScope) {</span>
            <span class="s1">const variable = currentScope.variables.find(scopeVar =&gt; scopeVar.name === name);</span>
            <span class="s2">if </span><span class="s1">(variable) {</span>
                <span class="s1">variable.eslintUsed = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">currentScope = currentScope.upper;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">visitClass(node) {</span>
        <span class="s4">// skip a variable of class itself name in the class scope</span>
        <span class="s1">const scope = </span><span class="s2">this</span><span class="s1">.getScope(node);</span>
        <span class="s2">for </span><span class="s1">(const variable of scope.variables) {</span>
            <span class="s2">if </span><span class="s1">(variable.identifiers[</span><span class="s3">0</span><span class="s1">] === scope.block.id) {</span>
                <span class="s2">this</span><span class="s1">.markVariableAsUsed(variable);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">visitFunction(node) {</span>
        <span class="s1">const scope = </span><span class="s2">this</span><span class="s1">.getScope(node);</span>
        <span class="s4">// skip implicit &quot;arguments&quot; variable</span>
        <span class="s1">const variable = scope.set.get(</span><span class="s0">'arguments'</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">((variable === </span><span class="s2">null </span><span class="s1">|| variable === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: variable.defs.length) === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.markVariableAsUsed(variable);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">visitFunctionTypeSignature(node) {</span>
        <span class="s4">// function type signature params create variables because they can be referenced within the signature,</span>
        <span class="s4">// but they obviously aren't unused variables for the purposes of this rule.</span>
        <span class="s2">for </span><span class="s1">(const param of node.params) {</span>
            <span class="s2">this</span><span class="s1">.visitPattern(param, name =&gt; {</span>
                <span class="s2">this</span><span class="s1">.markVariableAsUsed(name);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">visitSetter(node) {</span>
        <span class="s2">if </span><span class="s1">(node.kind === </span><span class="s0">'set'</span><span class="s1">) {</span>
            <span class="s4">// ignore setter parameters because they're syntactically required to exist</span>
            <span class="s2">for </span><span class="s1">(const param of node.value.params) {</span>
                <span class="s2">this</span><span class="s1">.visitPattern(param, id =&gt; {</span>
                    <span class="s2">this</span><span class="s1">.markVariableAsUsed(id);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ForInStatement(node) {</span>
        <span class="s4">/** 
         * (Brad Zacher): I hate that this has to exist. 
         * But it is required for compat with the base ESLint rule. 
         * 
         * In 2015, ESLint decided to add an exception for these two specific cases 
         * ``` 
         * for (var key in object) return; 
         * 
         * var key; 
         * for (key in object) return; 
         * ``` 
         * 
         * I disagree with it, but what are you going to do... 
         * 
         * https://github.com/eslint/eslint/issues/2342 
         */</span>
        <span class="s1">let idOrVariable;</span>
        <span class="s2">if </span><span class="s1">(node.left.type === utils_1.AST_NODE_TYPES.VariableDeclaration) {</span>
            <span class="s1">const variable = __classPrivateFieldGet(</span><span class="s2">this</span><span class="s1">, _UnusedVarsVisitor_scopeManager, </span><span class="s0">&quot;f&quot;</span><span class="s1">).getDeclaredVariables(node.left)[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(!variable) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">idOrVariable = variable;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node.left.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
            <span class="s1">idOrVariable = node.left;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(idOrVariable == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">let body = node.body;</span>
        <span class="s2">if </span><span class="s1">(node.body.type === utils_1.AST_NODE_TYPES.BlockStatement) {</span>
            <span class="s2">if </span><span class="s1">(node.body.body.length !== </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">body = node.body.body[</span><span class="s3">0</span><span class="s1">];</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(body.type !== utils_1.AST_NODE_TYPES.ReturnStatement) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.markVariableAsUsed(idOrVariable);</span>
    <span class="s1">}</span>
    <span class="s1">Identifier(node) {</span>
        <span class="s1">const scope = </span><span class="s2">this</span><span class="s1">.getScope(node);</span>
        <span class="s2">if </span><span class="s1">(scope.type === utils_1.TSESLint.Scope.ScopeType.</span><span class="s2">function </span><span class="s1">&amp;&amp;</span>
            <span class="s1">node.name === </span><span class="s0">'this'</span><span class="s1">) {</span>
            <span class="s4">// this parameters should always be considered used as they're pseudo-parameters</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s0">'params' </span><span class="s2">in </span><span class="s1">scope.block &amp;&amp; scope.block.params.includes(node)) {</span>
                <span class="s2">this</span><span class="s1">.markVariableAsUsed(node);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TSEnumDeclaration(node) {</span>
        <span class="s4">// enum members create variables because they can be referenced within the enum,</span>
        <span class="s4">// but they obviously aren't unused variables for the purposes of this rule.</span>
        <span class="s1">const scope = </span><span class="s2">this</span><span class="s1">.getScope(node);</span>
        <span class="s2">for </span><span class="s1">(const variable of scope.variables) {</span>
            <span class="s2">this</span><span class="s1">.markVariableAsUsed(variable);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TSMappedType(node) {</span>
        <span class="s4">// mapped types create a variable for their type name, but it's not necessary to reference it,</span>
        <span class="s4">// so we shouldn't consider it as unused for the purpose of this rule.</span>
        <span class="s2">this</span><span class="s1">.markVariableAsUsed(node.typeParameter.name);</span>
    <span class="s1">}</span>
    <span class="s1">TSModuleDeclaration(node) {</span>
        <span class="s4">// -- global augmentation can be in any file, and they do not need exports</span>
        <span class="s2">if </span><span class="s1">(node.global === </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.markVariableAsUsed(</span><span class="s0">'global'</span><span class="s1">, node.parent);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TSParameterProperty(node) {</span>
        <span class="s1">let identifier = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">switch </span><span class="s1">(node.parameter.type) {</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.AssignmentPattern:</span>
                <span class="s2">if </span><span class="s1">(node.parameter.left.type === utils_1.AST_NODE_TYPES.Identifier) {</span>
                    <span class="s1">identifier = node.parameter.left;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.Identifier:</span>
                <span class="s1">identifier = node.parameter;</span>
                <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(identifier) {</span>
            <span class="s2">this</span><span class="s1">.markVariableAsUsed(identifier);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">_UnusedVarsVisitor_scopeManager = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s1">UnusedVarsVisitor.RESULTS_CACHE = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s4">//#region private helpers</span>
<span class="s4">/** 
 * Checks the position of given nodes. 
 * @param inner A node which is expected as inside. 
 * @param outer A node which is expected as outside. 
 * @returns `true` if the `inner` node exists in the `outer` node. 
 */</span>
<span class="s2">function </span><span class="s1">isInside(inner, outer) {</span>
    <span class="s2">return </span><span class="s1">inner.range[</span><span class="s3">0</span><span class="s1">] &gt;= outer.range[</span><span class="s3">0</span><span class="s1">] &amp;&amp; inner.range[</span><span class="s3">1</span><span class="s1">] &lt;= outer.range[</span><span class="s3">1</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Determine if an identifier is referencing an enclosing name. 
 * This only applies to declarations that create their own scope (modules, functions, classes) 
 * @param ref The reference to check. 
 * @param nodes The candidate function nodes. 
 * @returns True if it's a self-reference, false if not. 
 */</span>
<span class="s2">function </span><span class="s1">isSelfReference(ref, nodes) {</span>
    <span class="s1">let scope = ref.from;</span>
    <span class="s2">while </span><span class="s1">(scope) {</span>
        <span class="s2">if </span><span class="s1">(nodes.has(scope.block)) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">scope = scope.upper;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">const MERGABLE_TYPES = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s1">utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.TSModuleDeclaration,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.ClassDeclaration,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.FunctionDeclaration,</span>
<span class="s1">]);</span>
<span class="s4">/** 
 * Determine if the variable is directly exported 
 * @param variable the variable to check 
 * @param target the type of node that is expected to be exported 
 */</span>
<span class="s2">function </span><span class="s1">isMergableExported(variable) {</span>
    <span class="s2">var </span><span class="s1">_a, _b;</span>
    <span class="s4">// If all of the merged things are of the same type, TS will error if not all of them are exported - so we only need to find one</span>
    <span class="s2">for </span><span class="s1">(const def of variable.defs) {</span>
        <span class="s4">// parameters can never be exported.</span>
        <span class="s4">// their `node` prop points to the function decl, which can be exported</span>
        <span class="s4">// so we need to special case them</span>
        <span class="s2">if </span><span class="s1">(def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((MERGABLE_TYPES.has(def.node.type) &amp;&amp;</span>
            <span class="s1">((_a = def.node.parent) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.type) === utils_1.AST_NODE_TYPES.ExportNamedDeclaration) ||</span>
            <span class="s1">((_b = def.node.parent) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _b.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Determines if a given variable is being exported from a module. 
 * @param variable eslint-scope variable object. 
 * @returns True if the variable is exported, false if not. 
 */</span>
<span class="s2">function </span><span class="s1">isExported(variable) {</span>
    <span class="s1">const definition = variable.defs[</span><span class="s3">0</span><span class="s1">];</span>
    <span class="s2">if </span><span class="s1">(definition) {</span>
        <span class="s1">let node = definition.node;</span>
        <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {</span>
            <span class="s1">node = node.parent;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(definition.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">node.parent.type.indexOf(</span><span class="s0">'Export'</span><span class="s1">) === </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Determines if the variable is used. 
 * @param variable The variable to check. 
 * @returns True if the variable is used 
 */</span>
<span class="s2">function </span><span class="s1">isUsedVariable(variable) {</span>
    <span class="s4">/** 
     * Gets a list of function definitions for a specified variable. 
     * @param variable eslint-scope variable object. 
     * @returns Function nodes. 
     */</span>
    <span class="s2">function </span><span class="s1">getFunctionDefinitions(variable) {</span>
        <span class="s1">const functionDefinitions = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s1">variable.defs.forEach(def =&gt; {</span>
            <span class="s2">var </span><span class="s1">_a, _b;</span>
            <span class="s4">// FunctionDeclarations</span>
            <span class="s2">if </span><span class="s1">(def.type === utils_1.TSESLint.Scope.DefinitionType.FunctionName) {</span>
                <span class="s1">functionDefinitions.add(def.node);</span>
            <span class="s1">}</span>
            <span class="s4">// FunctionExpressions</span>
            <span class="s2">if </span><span class="s1">(def.type === utils_1.TSESLint.Scope.DefinitionType.Variable &amp;&amp;</span>
                <span class="s1">(((_a = def.node.init) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.type) === utils_1.AST_NODE_TYPES.FunctionExpression ||</span>
                    <span class="s1">((_b = def.node.init) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _b.type) === utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {</span>
                <span class="s1">functionDefinitions.add(def.node.init);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">functionDefinitions;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getTypeDeclarations(variable) {</span>
        <span class="s1">const nodes = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s1">variable.defs.forEach(def =&gt; {</span>
            <span class="s2">if </span><span class="s1">(def.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration ||</span>
                <span class="s1">def.node.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {</span>
                <span class="s1">nodes.add(def.node);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">nodes;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">getModuleDeclarations(variable) {</span>
        <span class="s1">const nodes = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s1">variable.defs.forEach(def =&gt; {</span>
            <span class="s2">if </span><span class="s1">(def.node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration) {</span>
                <span class="s1">nodes.add(def.node);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">nodes;</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Checks if the ref is contained within one of the given nodes 
     */</span>
    <span class="s2">function </span><span class="s1">isInsideOneOf(ref, nodes) {</span>
        <span class="s2">for </span><span class="s1">(const node of nodes) {</span>
            <span class="s2">if </span><span class="s1">(isInside(ref.identifier, node)) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * If a given reference is left-hand side of an assignment, this gets 
     * the right-hand side node of the assignment. 
     * 
     * In the following cases, this returns null. 
     * 
     * - The reference is not the LHS of an assignment expression. 
     * - The reference is inside of a loop. 
     * - The reference is inside of a function scope which is different from 
     *   the declaration. 
     * @param ref A reference to check. 
     * @param prevRhsNode The previous RHS node. 
     * @returns The RHS node or null. 
     */</span>
    <span class="s2">function </span><span class="s1">getRhsNode(ref, prevRhsNode) {</span>
        <span class="s4">/** 
         * Checks whether the given node is in a loop or not. 
         * @param node The node to check. 
         * @returns `true` if the node is in a loop. 
         */</span>
        <span class="s2">function </span><span class="s1">isInLoop(node) {</span>
            <span class="s1">let currentNode = node;</span>
            <span class="s2">while </span><span class="s1">(currentNode) {</span>
                <span class="s2">if </span><span class="s1">(utils_1.ASTUtils.isFunction(currentNode)) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(utils_1.ASTUtils.isLoop(currentNode)) {</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">currentNode = currentNode.parent;</span>
            <span class="s1">}</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">const id = ref.identifier;</span>
        <span class="s1">const parent = id.parent;</span>
        <span class="s1">const grandparent = parent.parent;</span>
        <span class="s1">const refScope = ref.from.variableScope;</span>
        <span class="s1">const varScope = ref.resolved.scope.variableScope;</span>
        <span class="s1">const canBeUsedLater = refScope !== varScope || isInLoop(id);</span>
        <span class="s4">/* 
         * Inherits the previous node if this reference is in the node. 
         * This is for `a = a + a`-like code. 
         */</span>
        <span class="s2">if </span><span class="s1">(prevRhsNode &amp;&amp; isInside(id, prevRhsNode)) {</span>
            <span class="s2">return </span><span class="s1">prevRhsNode;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression &amp;&amp;</span>
            <span class="s1">grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement &amp;&amp;</span>
            <span class="s1">id === parent.left &amp;&amp;</span>
            <span class="s1">!canBeUsedLater) {</span>
            <span class="s2">return </span><span class="s1">parent.right;</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">/** 
     * Checks whether a given reference is a read to update itself or not. 
     * @param ref A reference to check. 
     * @param rhsNode The RHS node of the previous assignment. 
     * @returns The reference is a read to update itself. 
     */</span>
    <span class="s2">function </span><span class="s1">isReadForItself(ref, rhsNode) {</span>
        <span class="s4">/** 
         * Checks whether a given Identifier node exists inside of a function node which can be used later. 
         * 
         * &quot;can be used later&quot; means: 
         * - the function is assigned to a variable. 
         * - the function is bound to a property and the object can be used later. 
         * - the function is bound as an argument of a function call. 
         * 
         * If a reference exists in a function which can be used later, the reference is read when the function is called. 
         * @param id An Identifier node to check. 
         * @param rhsNode The RHS node of the previous assignment. 
         * @returns `true` if the `id` node exists inside of a function node which can be used later. 
         */</span>
        <span class="s2">function </span><span class="s1">isInsideOfStorableFunction(id, rhsNode) {</span>
            <span class="s4">/** 
             * Finds a function node from ancestors of a node. 
             * @param node A start node to find. 
             * @returns A found function node. 
             */</span>
            <span class="s2">function </span><span class="s1">getUpperFunction(node) {</span>
                <span class="s1">let currentNode = node;</span>
                <span class="s2">while </span><span class="s1">(currentNode) {</span>
                    <span class="s2">if </span><span class="s1">(utils_1.ASTUtils.isFunction(currentNode)) {</span>
                        <span class="s2">return </span><span class="s1">currentNode;</span>
                    <span class="s1">}</span>
                    <span class="s1">currentNode = currentNode.parent;</span>
                <span class="s1">}</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">/** 
             * Checks whether a given function node is stored to somewhere or not. 
             * If the function node is stored, the function can be used later. 
             * @param funcNode A function node to check. 
             * @param rhsNode The RHS node of the previous assignment. 
             * @returns `true` if under the following conditions: 
             *      - the funcNode is assigned to a variable. 
             *      - the funcNode is bound as an argument of a function call. 
             *      - the function is bound to a property and the object satisfies above conditions. 
             */</span>
            <span class="s2">function </span><span class="s1">isStorableFunction(funcNode, rhsNode) {</span>
                <span class="s1">let node = funcNode;</span>
                <span class="s1">let parent = funcNode.parent;</span>
                <span class="s2">while </span><span class="s1">(parent &amp;&amp; isInside(parent, rhsNode)) {</span>
                    <span class="s2">switch </span><span class="s1">(parent.type) {</span>
                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.SequenceExpression:</span>
                            <span class="s2">if </span><span class="s1">(parent.expressions[parent.expressions.length - </span><span class="s3">1</span><span class="s1">] !== node) {</span>
                                <span class="s2">return false</span><span class="s1">;</span>
                            <span class="s1">}</span>
                            <span class="s2">break</span><span class="s1">;</span>
                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.CallExpression:</span>
                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.NewExpression:</span>
                            <span class="s2">return </span><span class="s1">parent.callee !== node;</span>
                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.AssignmentExpression:</span>
                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TaggedTemplateExpression:</span>
                        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.YieldExpression:</span>
                            <span class="s2">return true</span><span class="s1">;</span>
                        <span class="s2">default</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">(parent.type.endsWith(</span><span class="s0">'Statement'</span><span class="s1">) ||</span>
                                <span class="s1">parent.type.endsWith(</span><span class="s0">'Declaration'</span><span class="s1">)) {</span>
                                <span class="s4">/* 
                                 * If it encountered statements, this is a complex pattern. 
                                 * Since analyzing complex patterns is hard, this returns `true` to avoid false positive. 
                                 */</span>
                                <span class="s2">return true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s1">node = parent;</span>
                    <span class="s1">parent = parent.parent;</span>
                <span class="s1">}</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const funcNode = getUpperFunction(id);</span>
            <span class="s2">return </span><span class="s1">(!!funcNode &amp;&amp;</span>
                <span class="s1">isInside(funcNode, rhsNode) &amp;&amp;</span>
                <span class="s1">isStorableFunction(funcNode, rhsNode));</span>
        <span class="s1">}</span>
        <span class="s1">const id = ref.identifier;</span>
        <span class="s1">const parent = id.parent;</span>
        <span class="s1">const grandparent = parent.parent;</span>
        <span class="s2">return </span><span class="s1">(ref.isRead() &amp;&amp; </span><span class="s4">// in RHS of an assignment for itself. e.g. `a = a + 1`</span>
            <span class="s4">// self update. e.g. `a += 1`, `a++`</span>
            <span class="s1">((parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression &amp;&amp;</span>
                <span class="s1">grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement &amp;&amp;</span>
                <span class="s1">parent.left === id) ||</span>
                <span class="s1">(parent.type === utils_1.AST_NODE_TYPES.UpdateExpression &amp;&amp;</span>
                    <span class="s1">grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) ||</span>
                <span class="s1">(!!rhsNode &amp;&amp;</span>
                    <span class="s1">isInside(id, rhsNode) &amp;&amp;</span>
                    <span class="s1">!isInsideOfStorableFunction(id, rhsNode))));</span>
    <span class="s1">}</span>
    <span class="s1">const functionNodes = getFunctionDefinitions(variable);</span>
    <span class="s1">const isFunctionDefinition = functionNodes.size &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">const typeDeclNodes = getTypeDeclarations(variable);</span>
    <span class="s1">const isTypeDecl = typeDeclNodes.size &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">const moduleDeclNodes = getModuleDeclarations(variable);</span>
    <span class="s1">const isModuleDecl = moduleDeclNodes.size &gt; </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">let rhsNode = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">variable.references.some(ref =&gt; {</span>
        <span class="s1">const forItself = isReadForItself(ref, rhsNode);</span>
        <span class="s1">rhsNode = getRhsNode(ref, rhsNode);</span>
        <span class="s2">return </span><span class="s1">(ref.isRead() &amp;&amp;</span>
            <span class="s1">!forItself &amp;&amp;</span>
            <span class="s1">!(isFunctionDefinition &amp;&amp; isSelfReference(ref, functionNodes)) &amp;&amp;</span>
            <span class="s1">!(isTypeDecl &amp;&amp; isInsideOneOf(ref, typeDeclNodes)) &amp;&amp;</span>
            <span class="s1">!(isModuleDecl &amp;&amp; isSelfReference(ref, moduleDeclNodes)));</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s4">//#endregion private helpers</span>
<span class="s4">/** 
 * Collects the set of unused variables for a given context. 
 * 
 * Due to complexity, this does not take into consideration: 
 * - variables within declaration files 
 * - variables within ambient module declarations 
 */</span>
<span class="s2">function </span><span class="s1">collectUnusedVariables(context) {</span>
    <span class="s2">return </span><span class="s1">UnusedVarsVisitor.collectUnusedVariables(context);</span>
<span class="s1">}</span>
<span class="s1">exports.collectUnusedVariables = collectUnusedVariables;</span>
<span class="s4">//# sourceMappingURL=collectUnusedVariables.js.map</span></pre>
</body>
</html>
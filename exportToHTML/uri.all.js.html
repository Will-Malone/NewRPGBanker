<html>
<head>
<title>uri.all.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
uri.all.js</font>
</center></td></tr></table>
<pre><span class="s0">/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(global, factory) {</span>
	<span class="s2">typeof </span><span class="s1">exports === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module !== </span><span class="s3">'undefined' </span><span class="s1">? factory(exports) :</span>
	<span class="s2">typeof </span><span class="s1">define === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; define.amd ? define([</span><span class="s3">'exports'</span><span class="s1">], factory) :</span>
	<span class="s1">(factory((global.URI = global.URI || {})));</span>
<span class="s1">}(</span><span class="s2">this</span><span class="s1">, (</span><span class="s2">function </span><span class="s1">(exports) { </span><span class="s3">'use strict'</span><span class="s1">;</span>

<span class="s2">function </span><span class="s1">merge() {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_len = arguments.length, sets = Array(_len), _key = </span><span class="s4">0</span><span class="s1">; _key &lt; _len; _key++) {</span>
        <span class="s1">sets[_key] = arguments[_key];</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(sets.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">sets[</span><span class="s4">0</span><span class="s1">] = sets[</span><span class="s4">0</span><span class="s1">].slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s2">var </span><span class="s1">xl = sets.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">x = </span><span class="s4">1</span><span class="s1">; x &lt; xl; ++x) {</span>
            <span class="s1">sets[x] = sets[x].slice(</span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">sets[xl] = sets[xl].slice(</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">sets.join(</span><span class="s3">''</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">sets[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">subexp(str) {</span>
    <span class="s2">return </span><span class="s3">&quot;(?:&quot; </span><span class="s1">+ str + </span><span class="s3">&quot;)&quot;</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">typeOf(o) {</span>
    <span class="s2">return </span><span class="s1">o === undefined ? </span><span class="s3">&quot;undefined&quot; </span><span class="s1">: o === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;null&quot; </span><span class="s1">: Object.prototype.toString.call(o).split(</span><span class="s3">&quot; &quot;</span><span class="s1">).pop().split(</span><span class="s3">&quot;]&quot;</span><span class="s1">).shift().toLowerCase();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toUpperCase(str) {</span>
    <span class="s2">return </span><span class="s1">str.toUpperCase();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toArray(obj) {</span>
    <span class="s2">return </span><span class="s1">obj !== undefined &amp;&amp; obj !== </span><span class="s2">null </span><span class="s1">? obj </span><span class="s2">instanceof </span><span class="s1">Array ? obj : </span><span class="s2">typeof </span><span class="s1">obj.length !== </span><span class="s3">&quot;number&quot; </span><span class="s1">|| obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assign(target, source) {</span>
    <span class="s2">var </span><span class="s1">obj = target;</span>
    <span class="s2">if </span><span class="s1">(source) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">source) {</span>
            <span class="s1">obj[key] = source[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">obj;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">buildExps(isIRI) {</span>
    <span class="s2">var </span><span class="s1">ALPHA$$ = </span><span class="s3">&quot;[A-Za-z]&quot;</span><span class="s1">,</span>
        <span class="s1">CR$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">x0D]&quot;</span><span class="s1">,</span>
        <span class="s1">DIGIT$$ = </span><span class="s3">&quot;[0-9]&quot;</span><span class="s1">,</span>
        <span class="s1">DQUOTE$$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">x22]&quot;</span><span class="s1">,</span>
        <span class="s1">HEXDIG$$ = merge(DIGIT$$, </span><span class="s3">&quot;[A-Fa-f]&quot;</span><span class="s1">),</span>
        <span class="s0">//case-insensitive</span>
    <span class="s1">LF$$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">x0A]&quot;</span><span class="s1">,</span>
        <span class="s1">SP$$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">x20]&quot;</span><span class="s1">,</span>
        <span class="s1">PCT_ENCODED$ = subexp(subexp(</span><span class="s3">&quot;%[EFef]&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;%[89A-Fa-f]&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$)),</span>
        <span class="s0">//expanded</span>
    <span class="s1">GEN_DELIMS$$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">?</span><span class="s5">\\</span><span class="s3">#</span><span class="s5">\\</span><span class="s3">[</span><span class="s5">\\</span><span class="s3">]</span><span class="s5">\\</span><span class="s3">@]&quot;</span><span class="s1">,</span>
        <span class="s1">SUB_DELIMS$$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">!</span><span class="s5">\\</span><span class="s3">$</span><span class="s5">\\</span><span class="s3">&amp;</span><span class="s5">\\</span><span class="s3">'</span><span class="s5">\\</span><span class="s3">(</span><span class="s5">\\</span><span class="s3">)</span><span class="s5">\\</span><span class="s3">*</span><span class="s5">\\</span><span class="s3">+</span><span class="s5">\\</span><span class="s3">,</span><span class="s5">\\</span><span class="s3">;</span><span class="s5">\\</span><span class="s3">=]&quot;</span><span class="s1">,</span>
        <span class="s1">RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),</span>
        <span class="s1">UCSCHAR$$ = isIRI ? </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">xA0-</span><span class="s5">\\</span><span class="s3">u200D</span><span class="s5">\\</span><span class="s3">u2010-</span><span class="s5">\\</span><span class="s3">u2029</span><span class="s5">\\</span><span class="s3">u202F-</span><span class="s5">\\</span><span class="s3">uD7FF</span><span class="s5">\\</span><span class="s3">uF900-</span><span class="s5">\\</span><span class="s3">uFDCF</span><span class="s5">\\</span><span class="s3">uFDF0-</span><span class="s5">\\</span><span class="s3">uFFEF]&quot; </span><span class="s1">: </span><span class="s3">&quot;[]&quot;</span><span class="s1">,</span>
        <span class="s0">//subset, excludes bidi control characters</span>
    <span class="s1">IPRIVATE$$ = isIRI ? </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">uE000-</span><span class="s5">\\</span><span class="s3">uF8FF]&quot; </span><span class="s1">: </span><span class="s3">&quot;[]&quot;</span><span class="s1">,</span>
        <span class="s0">//subset</span>
    <span class="s1">UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">-</span><span class="s5">\\</span><span class="s3">.</span><span class="s5">\\</span><span class="s3">_</span><span class="s5">\\</span><span class="s3">~]&quot;</span><span class="s1">, UCSCHAR$$),</span>
        <span class="s1">SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">+</span><span class="s5">\\</span><span class="s3">-</span><span class="s5">\\</span><span class="s3">.]&quot;</span><span class="s1">) + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">USERINFO$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">:]&quot;</span><span class="s1">)) + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">DEC_OCTET$ = subexp(subexp(</span><span class="s3">&quot;25[0-5]&quot;</span><span class="s1">) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;2[0-4]&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;1&quot; </span><span class="s1">+ DIGIT$$ + DIGIT$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;[1-9]&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ DIGIT$$),</span>
        <span class="s1">DEC_OCTET_RELAXED$ = subexp(subexp(</span><span class="s3">&quot;25[0-5]&quot;</span><span class="s1">) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;2[0-4]&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;1&quot; </span><span class="s1">+ DIGIT$$ + DIGIT$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;0?[1-9]&quot; </span><span class="s1">+ DIGIT$$) + </span><span class="s3">&quot;|0?0?&quot; </span><span class="s1">+ DIGIT$$),</span>
        <span class="s0">//relaxed parsing rules</span>
    <span class="s1">IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">.&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">.&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">.&quot; </span><span class="s1">+ DEC_OCTET_RELAXED$),</span>
        <span class="s1">H16$ = subexp(HEXDIG$$ + </span><span class="s3">&quot;{1,4}&quot;</span><span class="s1">),</span>
        <span class="s1">LS32$ = subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ H16$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ IPV4ADDRESS$),</span>
        <span class="s1">IPV6ADDRESS1$ = subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{6}&quot; </span><span class="s1">+ LS32$),</span>
        <span class="s0">//                           6( h16 &quot;:&quot; ) ls32</span>
    <span class="s1">IPV6ADDRESS2$ = subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{5}&quot; </span><span class="s1">+ LS32$),</span>
        <span class="s0">//                      &quot;::&quot; 5( h16 &quot;:&quot; ) ls32</span>
    <span class="s1">IPV6ADDRESS3$ = subexp(subexp(H16$) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{4}&quot; </span><span class="s1">+ LS32$),</span>
        <span class="s0">//[               h16 ] &quot;::&quot; 4( h16 &quot;:&quot; ) ls32</span>
    <span class="s1">IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{0,1}&quot; </span><span class="s1">+ H16$) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{3}&quot; </span><span class="s1">+ LS32$),</span>
        <span class="s0">//[ *1( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 3( h16 &quot;:&quot; ) ls32</span>
    <span class="s1">IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{0,2}&quot; </span><span class="s1">+ H16$) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{2}&quot; </span><span class="s1">+ LS32$),</span>
        <span class="s0">//[ *2( h16 &quot;:&quot; ) h16 ] &quot;::&quot; 2( h16 &quot;:&quot; ) ls32</span>
    <span class="s1">IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{0,3}&quot; </span><span class="s1">+ H16$) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ LS32$),</span>
        <span class="s0">//[ *3( h16 &quot;:&quot; ) h16 ] &quot;::&quot;    h16 &quot;:&quot;   ls32</span>
    <span class="s1">IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{0,4}&quot; </span><span class="s1">+ H16$) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ LS32$),</span>
        <span class="s0">//[ *4( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              ls32</span>
    <span class="s1">IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{0,5}&quot; </span><span class="s1">+ H16$) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ H16$),</span>
        <span class="s0">//[ *5( h16 &quot;:&quot; ) h16 ] &quot;::&quot;              h16</span>
    <span class="s1">IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">) + </span><span class="s3">&quot;{0,6}&quot; </span><span class="s1">+ H16$) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">:&quot;</span><span class="s1">),</span>
        <span class="s0">//[ *6( h16 &quot;:&quot; ) h16 ] &quot;::&quot;</span>
    <span class="s1">IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(</span><span class="s3">&quot;|&quot;</span><span class="s1">)),</span>
        <span class="s1">ZONEID$ = subexp(subexp(UNRESERVED$$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PCT_ENCODED$) + </span><span class="s3">&quot;+&quot;</span><span class="s1">),</span>
        <span class="s0">//RFC 6874</span>
    <span class="s1">IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">%25&quot; </span><span class="s1">+ ZONEID$),</span>
        <span class="s0">//RFC 6874</span>
    <span class="s1">IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">%25|</span><span class="s5">\\</span><span class="s3">%(?!&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">&quot;{2})&quot;</span><span class="s1">) + ZONEID$),</span>
        <span class="s0">//RFC 6874, with relaxed parsing rules</span>
    <span class="s1">IPVFUTURE$ = subexp(</span><span class="s3">&quot;[vV]&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">&quot;+</span><span class="s5">\\</span><span class="s3">.&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">:]&quot;</span><span class="s1">) + </span><span class="s3">&quot;+&quot;</span><span class="s1">),</span>
        <span class="s1">IP_LITERAL$ = subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">[&quot; </span><span class="s1">+ subexp(IPV6ADDRZ_RELAXED$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ IPV6ADDRESS$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ IPVFUTURE$) + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">]&quot;</span><span class="s1">),</span>
        <span class="s0">//RFC 6874</span>
    <span class="s1">REG_NAME$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$)) + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">HOST$ = subexp(IP_LITERAL$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ IPV4ADDRESS$ + </span><span class="s3">&quot;(?!&quot; </span><span class="s1">+ REG_NAME$ + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ </span><span class="s3">&quot;|&quot; </span><span class="s1">+ REG_NAME$),</span>
        <span class="s1">PORT$ = subexp(DIGIT$$ + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">AUTHORITY$ = subexp(subexp(USERINFO$ + </span><span class="s3">&quot;@&quot;</span><span class="s1">) + </span><span class="s3">&quot;?&quot; </span><span class="s1">+ HOST$ + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ PORT$) + </span><span class="s3">&quot;?&quot;</span><span class="s1">),</span>
        <span class="s1">PCHAR$ = subexp(PCT_ENCODED$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">@]&quot;</span><span class="s1">)),</span>
        <span class="s1">SEGMENT$ = subexp(PCHAR$ + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">SEGMENT_NZ$ = subexp(PCHAR$ + </span><span class="s3">&quot;+&quot;</span><span class="s1">),</span>
        <span class="s1">SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ merge(UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">@]&quot;</span><span class="s1">)) + </span><span class="s3">&quot;+&quot;</span><span class="s1">),</span>
        <span class="s1">PATH_ABEMPTY$ = subexp(subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">/&quot; </span><span class="s1">+ SEGMENT$) + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">PATH_ABSOLUTE$ = subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">/&quot; </span><span class="s1">+ subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + </span><span class="s3">&quot;?&quot;</span><span class="s1">),</span>
        <span class="s0">//simplified</span>
    <span class="s1">PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),</span>
        <span class="s0">//simplified</span>
    <span class="s1">PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),</span>
        <span class="s0">//simplified</span>
    <span class="s1">PATH_EMPTY$ = </span><span class="s3">&quot;(?!&quot; </span><span class="s1">+ PCHAR$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">,</span>
        <span class="s1">PATH$ = subexp(PATH_ABEMPTY$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_EMPTY$),</span>
        <span class="s1">QUERY$ = subexp(subexp(PCHAR$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ merge(</span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">?]&quot;</span><span class="s1">, IPRIVATE$$)) + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">FRAGMENT$ = subexp(subexp(PCHAR$ + </span><span class="s3">&quot;|[</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">?]&quot;</span><span class="s1">) + </span><span class="s3">&quot;*&quot;</span><span class="s1">),</span>
        <span class="s1">HIER_PART$ = subexp(subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">/&quot; </span><span class="s1">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_EMPTY$),</span>
        <span class="s1">URI$ = subexp(SCHEME$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ HIER_PART$ + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">?&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">&quot;?&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">#&quot; </span><span class="s1">+ FRAGMENT$) + </span><span class="s3">&quot;?&quot;</span><span class="s1">),</span>
        <span class="s1">RELATIVE_PART$ = subexp(subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">/&quot; </span><span class="s1">+ AUTHORITY$ + PATH_ABEMPTY$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_EMPTY$),</span>
        <span class="s1">RELATIVE$ = subexp(RELATIVE_PART$ + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">?&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">&quot;?&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">#&quot; </span><span class="s1">+ FRAGMENT$) + </span><span class="s3">&quot;?&quot;</span><span class="s1">),</span>
        <span class="s1">URI_REFERENCE$ = subexp(URI$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ RELATIVE$),</span>
        <span class="s1">ABSOLUTE_URI$ = subexp(SCHEME$ + </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ HIER_PART$ + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">?&quot; </span><span class="s1">+ QUERY$) + </span><span class="s3">&quot;?&quot;</span><span class="s1">),</span>
        <span class="s1">GENERIC_REF$ = </span><span class="s3">&quot;^(&quot; </span><span class="s1">+ SCHEME$ + </span><span class="s3">&quot;)</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">/(&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;(&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">&quot;)@&quot;</span><span class="s1">) + </span><span class="s3">&quot;?(&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:(&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?(&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">?(&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">#(&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?$&quot;</span><span class="s1">,</span>
        <span class="s1">RELATIVE_REF$ = </span><span class="s3">&quot;^(){0}&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">/(&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;(&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">&quot;)@&quot;</span><span class="s1">) + </span><span class="s3">&quot;?(&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:(&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?(&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_NOSCHEME$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">?(&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">#(&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?$&quot;</span><span class="s1">,</span>
        <span class="s1">ABSOLUTE_REF$ = </span><span class="s3">&quot;^(&quot; </span><span class="s1">+ SCHEME$ + </span><span class="s3">&quot;)</span><span class="s5">\\</span><span class="s3">:&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">/(&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;(&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">&quot;)@&quot;</span><span class="s1">) + </span><span class="s3">&quot;?(&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:(&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?(&quot; </span><span class="s1">+ PATH_ABEMPTY$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ABSOLUTE$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_ROOTLESS$ + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ PATH_EMPTY$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">?(&quot; </span><span class="s1">+ QUERY$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?$&quot;</span><span class="s1">,</span>
        <span class="s1">SAMEDOC_REF$ = </span><span class="s3">&quot;^&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">#(&quot; </span><span class="s1">+ FRAGMENT$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?$&quot;</span><span class="s1">,</span>
        <span class="s1">AUTHORITY_REF$ = </span><span class="s3">&quot;^&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;(&quot; </span><span class="s1">+ USERINFO$ + </span><span class="s3">&quot;)@&quot;</span><span class="s1">) + </span><span class="s3">&quot;?(&quot; </span><span class="s1">+ HOST$ + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">:(&quot; </span><span class="s1">+ PORT$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?$&quot;</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">NOT_SCHEME: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^]&quot;</span><span class="s1">, ALPHA$$, DIGIT$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">+</span><span class="s5">\\</span><span class="s3">-</span><span class="s5">\\</span><span class="s3">.]&quot;</span><span class="s1">), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">NOT_USERINFO: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^</span><span class="s5">\\</span><span class="s3">%</span><span class="s5">\\</span><span class="s3">:]&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">NOT_HOST: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^</span><span class="s5">\\</span><span class="s3">%</span><span class="s5">\\</span><span class="s3">[</span><span class="s5">\\</span><span class="s3">]</span><span class="s5">\\</span><span class="s3">:]&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">NOT_PATH: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^</span><span class="s5">\\</span><span class="s3">%</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">@]&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">NOT_PATH_NOSCHEME: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^</span><span class="s5">\\</span><span class="s3">%</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">@]&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">NOT_QUERY: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^</span><span class="s5">\\</span><span class="s3">%]&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">@</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">?]&quot;</span><span class="s1">, IPRIVATE$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">NOT_FRAGMENT: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^</span><span class="s5">\\</span><span class="s3">%]&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">@</span><span class="s5">\\</span><span class="s3">/</span><span class="s5">\\</span><span class="s3">?]&quot;</span><span class="s1">), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">ESCAPE: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^]&quot;</span><span class="s1">, UNRESERVED$$, SUB_DELIMS$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">UNRESERVED: </span><span class="s2">new </span><span class="s1">RegExp(UNRESERVED$$, </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">OTHER_CHARS: </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^</span><span class="s5">\\</span><span class="s3">%]&quot;</span><span class="s1">, UNRESERVED$$, RESERVED$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">PCT_ENCODED: </span><span class="s2">new </span><span class="s1">RegExp(PCT_ENCODED$, </span><span class="s3">&quot;g&quot;</span><span class="s1">),</span>
        <span class="s1">IPV4ADDRESS: </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">&quot;^(&quot; </span><span class="s1">+ IPV4ADDRESS$ + </span><span class="s3">&quot;)$&quot;</span><span class="s1">),</span>
        <span class="s1">IPV6ADDRESS: </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s3">&quot;^</span><span class="s5">\\</span><span class="s3">[?(&quot; </span><span class="s1">+ IPV6ADDRESS$ + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ subexp(subexp(</span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">%25|</span><span class="s5">\\</span><span class="s3">%(?!&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">&quot;{2})&quot;</span><span class="s1">) + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ ZONEID$ + </span><span class="s3">&quot;)&quot;</span><span class="s1">) + </span><span class="s3">&quot;?</span><span class="s5">\\</span><span class="s3">]?$&quot;</span><span class="s1">) </span><span class="s0">//RFC 6874, with relaxed parsing rules</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">URI_PROTOCOL = buildExps(</span><span class="s2">false</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">IRI_PROTOCOL = buildExps(</span><span class="s2">true</span><span class="s1">);</span>

<span class="s2">var </span><span class="s1">slicedToArray = </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">function </span><span class="s1">sliceIterator(arr, i) {</span>
    <span class="s2">var </span><span class="s1">_arr = [];</span>
    <span class="s2">var </span><span class="s1">_n = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">_d = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">_e = undefined;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">_arr.push(_s.value);</span>

        <span class="s2">if </span><span class="s1">(i &amp;&amp; _arr.length === i) </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
      <span class="s1">_d = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">_e = err;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(!_n &amp;&amp; _i[</span><span class="s3">&quot;return&quot;</span><span class="s1">]) _i[</span><span class="s3">&quot;return&quot;</span><span class="s1">]();</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(_d) </span><span class="s2">throw </span><span class="s1">_e;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">_arr;</span>
  <span class="s1">}</span>

  <span class="s2">return function </span><span class="s1">(arr, i) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(arr)) {</span>
      <span class="s2">return </span><span class="s1">arr;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Symbol.iterator </span><span class="s2">in </span><span class="s1">Object(arr)) {</span>
      <span class="s2">return </span><span class="s1">sliceIterator(arr, i);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">&quot;Invalid attempt to destructure non-iterable instance&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">}();</span>













<span class="s2">var </span><span class="s1">toConsumableArray = </span><span class="s2">function </span><span class="s1">(arr) {</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(arr)) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, arr2 = Array(arr.length); i &lt; arr.length; i++) arr2[i] = arr[i];</span>

    <span class="s2">return </span><span class="s1">arr2;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">Array.from(arr);</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">/** Highest positive signed 32-bit float value */</span>

<span class="s2">var </span><span class="s1">maxInt = </span><span class="s4">2147483647</span><span class="s1">; </span><span class="s0">// aka. 0x7FFFFFFF or 2^31-1</span>

<span class="s0">/** Bootstring parameters */</span>
<span class="s2">var </span><span class="s1">base = </span><span class="s4">36</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">tMin = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">tMax = </span><span class="s4">26</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">skew = </span><span class="s4">38</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">damp = </span><span class="s4">700</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">initialBias = </span><span class="s4">72</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">initialN = </span><span class="s4">128</span><span class="s1">; </span><span class="s0">// 0x80</span>
<span class="s2">var </span><span class="s1">delimiter = </span><span class="s3">'-'</span><span class="s1">; </span><span class="s0">// '\x2D'</span>

<span class="s0">/** Regular expressions */</span>
<span class="s2">var </span><span class="s1">regexPunycode = /^xn--/;</span>
<span class="s2">var </span><span class="s1">regexNonASCII = /[^\</span><span class="s4">0</span><span class="s1">-\x7E]/; </span><span class="s0">// non-ASCII chars</span>
<span class="s2">var </span><span class="s1">regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; </span><span class="s0">// RFC 3490 separators</span>

<span class="s0">/** Error messages */</span>
<span class="s2">var </span><span class="s1">errors = {</span>
	<span class="s3">'overflow'</span><span class="s1">: </span><span class="s3">'Overflow: input needs wider integers to process'</span><span class="s1">,</span>
	<span class="s3">'not-basic'</span><span class="s1">: </span><span class="s3">'Illegal input &gt;= 0x80 (not a basic code point)'</span><span class="s1">,</span>
	<span class="s3">'invalid-input'</span><span class="s1">: </span><span class="s3">'Invalid input'</span>
<span class="s1">};</span>

<span class="s0">/** Convenience shortcuts */</span>
<span class="s2">var </span><span class="s1">baseMinusTMin = base - tMin;</span>
<span class="s2">var </span><span class="s1">floor = Math.floor;</span>
<span class="s2">var </span><span class="s1">stringFromCharCode = String.fromCharCode;</span>

<span class="s0">/*--------------------------------------------------------------------------*/</span>

<span class="s0">/** 
 * A generic error utility function. 
 * @private 
 * @param {String} type The error type. 
 * @returns {Error} Throws a `RangeError` with the applicable error message. 
 */</span>
<span class="s2">function </span><span class="s1">error$1(type) {</span>
	<span class="s2">throw new </span><span class="s1">RangeError(errors[type]);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * A generic `Array#map` utility function. 
 * @private 
 * @param {Array} array The array to iterate over. 
 * @param {Function} callback The function that gets called for every array 
 * item. 
 * @returns {Array} A new array of values returned by the callback function. 
 */</span>
<span class="s2">function </span><span class="s1">map(array, fn) {</span>
	<span class="s2">var </span><span class="s1">result = [];</span>
	<span class="s2">var </span><span class="s1">length = array.length;</span>
	<span class="s2">while </span><span class="s1">(length--) {</span>
		<span class="s1">result[length] = fn(array[length]);</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * A simple `Array#map`-like wrapper to work with domain name strings or email 
 * addresses. 
 * @private 
 * @param {String} domain The domain name or email address. 
 * @param {Function} callback The function that gets called for every 
 * character. 
 * @returns {Array} A new string of characters returned by the callback 
 * function. 
 */</span>
<span class="s2">function </span><span class="s1">mapDomain(string, fn) {</span>
	<span class="s2">var </span><span class="s1">parts = string.split(</span><span class="s3">'@'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">result = </span><span class="s3">''</span><span class="s1">;</span>
	<span class="s2">if </span><span class="s1">(parts.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
		<span class="s0">// In email addresses, only the domain name should be punycoded. Leave</span>
		<span class="s0">// the local part (i.e. everything up to `@`) intact.</span>
		<span class="s1">result = parts[</span><span class="s4">0</span><span class="s1">] + </span><span class="s3">'@'</span><span class="s1">;</span>
		<span class="s1">string = parts[</span><span class="s4">1</span><span class="s1">];</span>
	<span class="s1">}</span>
	<span class="s0">// Avoid `split(regex)` for IE8 compatibility. See #17.</span>
	<span class="s1">string = string.replace(regexSeparators, </span><span class="s3">'</span><span class="s5">\x</span><span class="s3">2E'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">labels = string.split(</span><span class="s3">'.'</span><span class="s1">);</span>
	<span class="s2">var </span><span class="s1">encoded = map(labels, fn).join(</span><span class="s3">'.'</span><span class="s1">);</span>
	<span class="s2">return </span><span class="s1">result + encoded;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Creates an array containing the numeric code points of each Unicode 
 * character in the string. While JavaScript uses UCS-2 internally, 
 * this function will convert a pair of surrogate halves (each of which 
 * UCS-2 exposes as separate characters) into a single code point, 
 * matching UTF-16. 
 * @see `punycode.ucs2.encode` 
 * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt; 
 * @memberOf punycode.ucs2 
 * @name decode 
 * @param {String} string The Unicode input string (UCS-2). 
 * @returns {Array} The new array of code points. 
 */</span>
<span class="s2">function </span><span class="s1">ucs2decode(string) {</span>
	<span class="s2">var </span><span class="s1">output = [];</span>
	<span class="s2">var </span><span class="s1">counter = </span><span class="s4">0</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">length = string.length;</span>
	<span class="s2">while </span><span class="s1">(counter &lt; length) {</span>
		<span class="s2">var </span><span class="s1">value = string.charCodeAt(counter++);</span>
		<span class="s2">if </span><span class="s1">(value &gt;= </span><span class="s4">0</span><span class="s1">xD800 &amp;&amp; value &lt;= </span><span class="s4">0</span><span class="s1">xDBFF &amp;&amp; counter &lt; length) {</span>
			<span class="s0">// It's a high surrogate, and there is a next character.</span>
			<span class="s2">var </span><span class="s1">extra = string.charCodeAt(counter++);</span>
			<span class="s2">if </span><span class="s1">((extra &amp; </span><span class="s4">0</span><span class="s1">xFC00) == </span><span class="s4">0</span><span class="s1">xDC00) {</span>
				<span class="s0">// Low surrogate.</span>
				<span class="s1">output.push(((value &amp; </span><span class="s4">0</span><span class="s1">x3FF) &lt;&lt; </span><span class="s4">10</span><span class="s1">) + (extra &amp; </span><span class="s4">0</span><span class="s1">x3FF) + </span><span class="s4">0</span><span class="s1">x10000);</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s0">// It's an unmatched surrogate; only append this code unit, in case the</span>
				<span class="s0">// next code unit is the high surrogate of a surrogate pair.</span>
				<span class="s1">output.push(value);</span>
				<span class="s1">counter--;</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s1">output.push(value);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">output;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Creates a string based on an array of numeric code points. 
 * @see `punycode.ucs2.decode` 
 * @memberOf punycode.ucs2 
 * @name encode 
 * @param {Array} codePoints The array of numeric code points. 
 * @returns {String} The new Unicode string (UCS-2). 
 */</span>
<span class="s2">var </span><span class="s1">ucs2encode = </span><span class="s2">function </span><span class="s1">ucs2encode(array) {</span>
	<span class="s2">return </span><span class="s1">String.fromCodePoint.apply(String, toConsumableArray(array));</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Converts a basic code point into a digit/integer. 
 * @see `digitToBasic()` 
 * @private 
 * @param {Number} codePoint The basic numeric code point value. 
 * @returns {Number} The numeric value of a basic code point (for use in 
 * representing integers) in the range `0` to `base - 1`, or `base` if 
 * the code point does not represent a value. 
 */</span>
<span class="s2">var </span><span class="s1">basicToDigit = </span><span class="s2">function </span><span class="s1">basicToDigit(codePoint) {</span>
	<span class="s2">if </span><span class="s1">(codePoint - </span><span class="s4">0</span><span class="s1">x30 &lt; </span><span class="s4">0</span><span class="s1">x0A) {</span>
		<span class="s2">return </span><span class="s1">codePoint - </span><span class="s4">0</span><span class="s1">x16;</span>
	<span class="s1">}</span>
	<span class="s2">if </span><span class="s1">(codePoint - </span><span class="s4">0</span><span class="s1">x41 &lt; </span><span class="s4">0</span><span class="s1">x1A) {</span>
		<span class="s2">return </span><span class="s1">codePoint - </span><span class="s4">0</span><span class="s1">x41;</span>
	<span class="s1">}</span>
	<span class="s2">if </span><span class="s1">(codePoint - </span><span class="s4">0</span><span class="s1">x61 &lt; </span><span class="s4">0</span><span class="s1">x1A) {</span>
		<span class="s2">return </span><span class="s1">codePoint - </span><span class="s4">0</span><span class="s1">x61;</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">base;</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Converts a digit/integer into a basic code point. 
 * @see `basicToDigit()` 
 * @private 
 * @param {Number} digit The numeric value of a basic code point. 
 * @returns {Number} The basic code point whose value (when used for 
 * representing integers) is `digit`, which needs to be in the range 
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is 
 * used; else, the lowercase form is used. The behavior is undefined 
 * if `flag` is non-zero and `digit` has no uppercase form. 
 */</span>
<span class="s2">var </span><span class="s1">digitToBasic = </span><span class="s2">function </span><span class="s1">digitToBasic(digit, flag) {</span>
	<span class="s0">//  0..25 map to ASCII a..z or A..Z</span>
	<span class="s0">// 26..35 map to ASCII 0..9</span>
	<span class="s2">return </span><span class="s1">digit + </span><span class="s4">22 </span><span class="s1">+ </span><span class="s4">75 </span><span class="s1">* (digit &lt; </span><span class="s4">26</span><span class="s1">) - ((flag != </span><span class="s4">0</span><span class="s1">) &lt;&lt; </span><span class="s4">5</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Bias adaptation function as per section 3.4 of RFC 3492. 
 * https://tools.ietf.org/html/rfc3492#section-3.4 
 * @private 
 */</span>
<span class="s2">var </span><span class="s1">adapt = </span><span class="s2">function </span><span class="s1">adapt(delta, numPoints, firstTime) {</span>
	<span class="s2">var </span><span class="s1">k = </span><span class="s4">0</span><span class="s1">;</span>
	<span class="s1">delta = firstTime ? floor(delta / damp) : delta &gt;&gt; </span><span class="s4">1</span><span class="s1">;</span>
	<span class="s1">delta += floor(delta / numPoints);</span>
	<span class="s2">for </span><span class="s1">(; </span><span class="s0">/* no initialization */</span><span class="s1">delta &gt; baseMinusTMin * tMax &gt;&gt; </span><span class="s4">1</span><span class="s1">; k += base) {</span>
		<span class="s1">delta = floor(delta / baseMinusTMin);</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">floor(k + (baseMinusTMin + </span><span class="s4">1</span><span class="s1">) * delta / (delta + skew));</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode 
 * symbols. 
 * @memberOf punycode 
 * @param {String} input The Punycode string of ASCII-only symbols. 
 * @returns {String} The resulting string of Unicode symbols. 
 */</span>
<span class="s2">var </span><span class="s1">decode = </span><span class="s2">function </span><span class="s1">decode(input) {</span>
	<span class="s0">// Don't use UCS-2.</span>
	<span class="s2">var </span><span class="s1">output = [];</span>
	<span class="s2">var </span><span class="s1">inputLength = input.length;</span>
	<span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">n = initialN;</span>
	<span class="s2">var </span><span class="s1">bias = initialBias;</span>

	<span class="s0">// Handle the basic code points: let `basic` be the number of input code</span>
	<span class="s0">// points before the last delimiter, or `0` if there is none, then copy</span>
	<span class="s0">// the first basic code points to the output.</span>

	<span class="s2">var </span><span class="s1">basic = input.lastIndexOf(delimiter);</span>
	<span class="s2">if </span><span class="s1">(basic &lt; </span><span class="s4">0</span><span class="s1">) {</span>
		<span class="s1">basic = </span><span class="s4">0</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; basic; ++j) {</span>
		<span class="s0">// if it's not a basic code point</span>
		<span class="s2">if </span><span class="s1">(input.charCodeAt(j) &gt;= </span><span class="s4">0</span><span class="s1">x80) {</span>
			<span class="s1">error$1(</span><span class="s3">'not-basic'</span><span class="s1">);</span>
		<span class="s1">}</span>
		<span class="s1">output.push(input.charCodeAt(j));</span>
	<span class="s1">}</span>

	<span class="s0">// Main decoding loop: start just after the last delimiter if any basic code</span>
	<span class="s0">// points were copied; start at the beginning otherwise.</span>

	<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">index = basic &gt; </span><span class="s4">0 </span><span class="s1">? basic + </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">; index &lt; inputLength;) </span><span class="s0">/* no final expression */</span><span class="s1">{</span>

		<span class="s0">// `index` is the index of the next character to be consumed.</span>
		<span class="s0">// Decode a generalized variable-length integer into `delta`,</span>
		<span class="s0">// which gets added to `i`. The overflow checking is easier</span>
		<span class="s0">// if we increase `i` as we go, then subtract off its starting</span>
		<span class="s0">// value at the end to obtain `delta`.</span>
		<span class="s2">var </span><span class="s1">oldi = i;</span>
		<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">w = </span><span class="s4">1</span><span class="s1">, k = base;; </span><span class="s0">/* no condition */</span><span class="s1">k += base) {</span>

			<span class="s2">if </span><span class="s1">(index &gt;= inputLength) {</span>
				<span class="s1">error$1(</span><span class="s3">'invalid-input'</span><span class="s1">);</span>
			<span class="s1">}</span>

			<span class="s2">var </span><span class="s1">digit = basicToDigit(input.charCodeAt(index++));</span>

			<span class="s2">if </span><span class="s1">(digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {</span>
				<span class="s1">error$1(</span><span class="s3">'overflow'</span><span class="s1">);</span>
			<span class="s1">}</span>

			<span class="s1">i += digit * w;</span>
			<span class="s2">var </span><span class="s1">t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;</span>

			<span class="s2">if </span><span class="s1">(digit &lt; t) {</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s2">var </span><span class="s1">baseMinusT = base - t;</span>
			<span class="s2">if </span><span class="s1">(w &gt; floor(maxInt / baseMinusT)) {</span>
				<span class="s1">error$1(</span><span class="s3">'overflow'</span><span class="s1">);</span>
			<span class="s1">}</span>

			<span class="s1">w *= baseMinusT;</span>
		<span class="s1">}</span>

		<span class="s2">var </span><span class="s1">out = output.length + </span><span class="s4">1</span><span class="s1">;</span>
		<span class="s1">bias = adapt(i - oldi, out, oldi == </span><span class="s4">0</span><span class="s1">);</span>

		<span class="s0">// `i` was supposed to wrap around from `out` to `0`,</span>
		<span class="s0">// incrementing `n` each time, so we'll fix that now:</span>
		<span class="s2">if </span><span class="s1">(floor(i / out) &gt; maxInt - n) {</span>
			<span class="s1">error$1(</span><span class="s3">'overflow'</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s1">n += floor(i / out);</span>
		<span class="s1">i %= out;</span>

		<span class="s0">// Insert `n` at position `i` of the output.</span>
		<span class="s1">output.splice(i++, </span><span class="s4">0</span><span class="s1">, n);</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">String.fromCodePoint.apply(String, output);</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Converts a string of Unicode symbols (e.g. a domain name label) to a 
 * Punycode string of ASCII-only symbols. 
 * @memberOf punycode 
 * @param {String} input The string of Unicode symbols. 
 * @returns {String} The resulting Punycode string of ASCII-only symbols. 
 */</span>
<span class="s2">var </span><span class="s1">encode = </span><span class="s2">function </span><span class="s1">encode(input) {</span>
	<span class="s2">var </span><span class="s1">output = [];</span>

	<span class="s0">// Convert the input in UCS-2 to an array of Unicode code points.</span>
	<span class="s1">input = ucs2decode(input);</span>

	<span class="s0">// Cache the length.</span>
	<span class="s2">var </span><span class="s1">inputLength = input.length;</span>

	<span class="s0">// Initialize the state.</span>
	<span class="s2">var </span><span class="s1">n = initialN;</span>
	<span class="s2">var </span><span class="s1">delta = </span><span class="s4">0</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">bias = initialBias;</span>

	<span class="s0">// Handle the basic code points.</span>
	<span class="s2">var </span><span class="s1">_iteratorNormalCompletion = </span><span class="s2">true</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">_didIteratorError = </span><span class="s2">false</span><span class="s1">;</span>
	<span class="s2">var </span><span class="s1">_iteratorError = undefined;</span>

	<span class="s2">try </span><span class="s1">{</span>
		<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = </span><span class="s2">true</span><span class="s1">) {</span>
			<span class="s2">var </span><span class="s1">_currentValue2 = _step.value;</span>

			<span class="s2">if </span><span class="s1">(_currentValue2 &lt; </span><span class="s4">0</span><span class="s1">x80) {</span>
				<span class="s1">output.push(stringFromCharCode(_currentValue2));</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
		<span class="s1">_didIteratorError = </span><span class="s2">true</span><span class="s1">;</span>
		<span class="s1">_iteratorError = err;</span>
	<span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
		<span class="s2">try </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(!_iteratorNormalCompletion &amp;&amp; _iterator.</span><span class="s2">return</span><span class="s1">) {</span>
				<span class="s1">_iterator.</span><span class="s2">return</span><span class="s1">();</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(_didIteratorError) {</span>
				<span class="s2">throw </span><span class="s1">_iteratorError;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">var </span><span class="s1">basicLength = output.length;</span>
	<span class="s2">var </span><span class="s1">handledCPCount = basicLength;</span>

	<span class="s0">// `handledCPCount` is the number of code points that have been handled;</span>
	<span class="s0">// `basicLength` is the number of basic code points.</span>

	<span class="s0">// Finish the basic string with a delimiter unless it's empty.</span>
	<span class="s2">if </span><span class="s1">(basicLength) {</span>
		<span class="s1">output.push(delimiter);</span>
	<span class="s1">}</span>

	<span class="s0">// Main encoding loop:</span>
	<span class="s2">while </span><span class="s1">(handledCPCount &lt; inputLength) {</span>

		<span class="s0">// All non-basic code points &lt; n have been handled already. Find the next</span>
		<span class="s0">// larger one:</span>
		<span class="s2">var </span><span class="s1">m = maxInt;</span>
		<span class="s2">var </span><span class="s1">_iteratorNormalCompletion2 = </span><span class="s2">true</span><span class="s1">;</span>
		<span class="s2">var </span><span class="s1">_didIteratorError2 = </span><span class="s2">false</span><span class="s1">;</span>
		<span class="s2">var </span><span class="s1">_iteratorError2 = undefined;</span>

		<span class="s2">try </span><span class="s1">{</span>
			<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = </span><span class="s2">true</span><span class="s1">) {</span>
				<span class="s2">var </span><span class="s1">currentValue = _step2.value;</span>

				<span class="s2">if </span><span class="s1">(currentValue &gt;= n &amp;&amp; currentValue &lt; m) {</span>
					<span class="s1">m = currentValue;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s0">// Increase `delta` enough to advance the decoder's &lt;n,i&gt; state to &lt;m,0&gt;,</span>
			<span class="s0">// but guard against overflow.</span>
		<span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
			<span class="s1">_didIteratorError2 = </span><span class="s2">true</span><span class="s1">;</span>
			<span class="s1">_iteratorError2 = err;</span>
		<span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
			<span class="s2">try </span><span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(!_iteratorNormalCompletion2 &amp;&amp; _iterator2.</span><span class="s2">return</span><span class="s1">) {</span>
					<span class="s1">_iterator2.</span><span class="s2">return</span><span class="s1">();</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(_didIteratorError2) {</span>
					<span class="s2">throw </span><span class="s1">_iteratorError2;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">var </span><span class="s1">handledCPCountPlusOne = handledCPCount + </span><span class="s4">1</span><span class="s1">;</span>
		<span class="s2">if </span><span class="s1">(m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {</span>
			<span class="s1">error$1(</span><span class="s3">'overflow'</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s1">delta += (m - n) * handledCPCountPlusOne;</span>
		<span class="s1">n = m;</span>

		<span class="s2">var </span><span class="s1">_iteratorNormalCompletion3 = </span><span class="s2">true</span><span class="s1">;</span>
		<span class="s2">var </span><span class="s1">_didIteratorError3 = </span><span class="s2">false</span><span class="s1">;</span>
		<span class="s2">var </span><span class="s1">_iteratorError3 = undefined;</span>

		<span class="s2">try </span><span class="s1">{</span>
			<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = </span><span class="s2">true</span><span class="s1">) {</span>
				<span class="s2">var </span><span class="s1">_currentValue = _step3.value;</span>

				<span class="s2">if </span><span class="s1">(_currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {</span>
					<span class="s1">error$1(</span><span class="s3">'overflow'</span><span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s2">if </span><span class="s1">(_currentValue == n) {</span>
					<span class="s0">// Represent delta as a generalized variable-length integer.</span>
					<span class="s2">var </span><span class="s1">q = delta;</span>
					<span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k = base;; </span><span class="s0">/* no condition */</span><span class="s1">k += base) {</span>
						<span class="s2">var </span><span class="s1">t = k &lt;= bias ? tMin : k &gt;= bias + tMax ? tMax : k - bias;</span>
						<span class="s2">if </span><span class="s1">(q &lt; t) {</span>
							<span class="s2">break</span><span class="s1">;</span>
						<span class="s1">}</span>
						<span class="s2">var </span><span class="s1">qMinusT = q - t;</span>
						<span class="s2">var </span><span class="s1">baseMinusT = base - t;</span>
						<span class="s1">output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, </span><span class="s4">0</span><span class="s1">)));</span>
						<span class="s1">q = floor(qMinusT / baseMinusT);</span>
					<span class="s1">}</span>

					<span class="s1">output.push(stringFromCharCode(digitToBasic(q, </span><span class="s4">0</span><span class="s1">)));</span>
					<span class="s1">bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);</span>
					<span class="s1">delta = </span><span class="s4">0</span><span class="s1">;</span>
					<span class="s1">++handledCPCount;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
			<span class="s1">_didIteratorError3 = </span><span class="s2">true</span><span class="s1">;</span>
			<span class="s1">_iteratorError3 = err;</span>
		<span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
			<span class="s2">try </span><span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(!_iteratorNormalCompletion3 &amp;&amp; _iterator3.</span><span class="s2">return</span><span class="s1">) {</span>
					<span class="s1">_iterator3.</span><span class="s2">return</span><span class="s1">();</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(_didIteratorError3) {</span>
					<span class="s2">throw </span><span class="s1">_iteratorError3;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">++delta;</span>
		<span class="s1">++n;</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">output.join(</span><span class="s3">''</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Converts a Punycode string representing a domain name or an email address 
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e. 
 * it doesn't matter if you call it on a string that has already been 
 * converted to Unicode. 
 * @memberOf punycode 
 * @param {String} input The Punycoded domain name or email address to 
 * convert to Unicode. 
 * @returns {String} The Unicode representation of the given Punycode 
 * string. 
 */</span>
<span class="s2">var </span><span class="s1">toUnicode = </span><span class="s2">function </span><span class="s1">toUnicode(input) {</span>
	<span class="s2">return </span><span class="s1">mapDomain(input, </span><span class="s2">function </span><span class="s1">(string) {</span>
		<span class="s2">return </span><span class="s1">regexPunycode.test(string) ? decode(string.slice(</span><span class="s4">4</span><span class="s1">).toLowerCase()) : string;</span>
	<span class="s1">});</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Converts a Unicode string representing a domain name or an email address to 
 * Punycode. Only the non-ASCII parts of the domain name will be converted, 
 * i.e. it doesn't matter if you call it with a domain that's already in 
 * ASCII. 
 * @memberOf punycode 
 * @param {String} input The domain name or email address to convert, as a 
 * Unicode string. 
 * @returns {String} The Punycode representation of the given domain name or 
 * email address. 
 */</span>
<span class="s2">var </span><span class="s1">toASCII = </span><span class="s2">function </span><span class="s1">toASCII(input) {</span>
	<span class="s2">return </span><span class="s1">mapDomain(input, </span><span class="s2">function </span><span class="s1">(string) {</span>
		<span class="s2">return </span><span class="s1">regexNonASCII.test(string) ? </span><span class="s3">'xn--' </span><span class="s1">+ encode(string) : string;</span>
	<span class="s1">});</span>
<span class="s1">};</span>

<span class="s0">/*--------------------------------------------------------------------------*/</span>

<span class="s0">/** Define the public API */</span>
<span class="s2">var </span><span class="s1">punycode = {</span>
	<span class="s0">/** 
  * A string representing the current Punycode.js version number. 
  * @memberOf punycode 
  * @type String 
  */</span>
	<span class="s3">'version'</span><span class="s1">: </span><span class="s3">'2.1.0'</span><span class="s1">,</span>
	<span class="s0">/** 
  * An object of methods to convert from JavaScript's internal character 
  * representation (UCS-2) to Unicode code points, and back. 
  * @see &lt;https://mathiasbynens.be/notes/javascript-encoding&gt; 
  * @memberOf punycode 
  * @type Object 
  */</span>
	<span class="s3">'ucs2'</span><span class="s1">: {</span>
		<span class="s3">'decode'</span><span class="s1">: ucs2decode,</span>
		<span class="s3">'encode'</span><span class="s1">: ucs2encode</span>
	<span class="s1">},</span>
	<span class="s3">'decode'</span><span class="s1">: decode,</span>
	<span class="s3">'encode'</span><span class="s1">: encode,</span>
	<span class="s3">'toASCII'</span><span class="s1">: toASCII,</span>
	<span class="s3">'toUnicode'</span><span class="s1">: toUnicode</span>
<span class="s1">};</span>

<span class="s0">/** 
 * URI.js 
 * 
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript. 
 * @author &lt;a href=&quot;mailto:gary.court@gmail.com&quot;&gt;Gary Court&lt;/a&gt; 
 * @see http://github.com/garycourt/uri-js 
 */</span>
<span class="s0">/** 
 * Copyright 2011 Gary Court. All rights reserved. 
 * 
 * Redistribution and use in source and binary forms, with or without modification, are 
 * permitted provided that the following conditions are met: 
 * 
 *    1. Redistributions of source code must retain the above copyright notice, this list of 
 *       conditions and the following disclaimer. 
 * 
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list 
 *       of conditions and the following disclaimer in the documentation and/or other materials 
 *       provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED 
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * 
 * The views and conclusions contained in the software and documentation are those of the 
 * authors and should not be interpreted as representing official policies, either expressed 
 * or implied, of Gary Court. 
 */</span>
<span class="s2">var </span><span class="s1">SCHEMES = {};</span>
<span class="s2">function </span><span class="s1">pctEncChar(chr) {</span>
    <span class="s2">var </span><span class="s1">c = chr.charCodeAt(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">e = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(c &lt; </span><span class="s4">16</span><span class="s1">) e = </span><span class="s3">&quot;%0&quot; </span><span class="s1">+ c.toString(</span><span class="s4">16</span><span class="s1">).toUpperCase();</span><span class="s2">else if </span><span class="s1">(c &lt; </span><span class="s4">128</span><span class="s1">) e = </span><span class="s3">&quot;%&quot; </span><span class="s1">+ c.toString(</span><span class="s4">16</span><span class="s1">).toUpperCase();</span><span class="s2">else if </span><span class="s1">(c &lt; </span><span class="s4">2048</span><span class="s1">) e = </span><span class="s3">&quot;%&quot; </span><span class="s1">+ (c &gt;&gt; </span><span class="s4">6 </span><span class="s1">| </span><span class="s4">192</span><span class="s1">).toString(</span><span class="s4">16</span><span class="s1">).toUpperCase() + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ (c &amp; </span><span class="s4">63 </span><span class="s1">| </span><span class="s4">128</span><span class="s1">).toString(</span><span class="s4">16</span><span class="s1">).toUpperCase();</span><span class="s2">else </span><span class="s1">e = </span><span class="s3">&quot;%&quot; </span><span class="s1">+ (c &gt;&gt; </span><span class="s4">12 </span><span class="s1">| </span><span class="s4">224</span><span class="s1">).toString(</span><span class="s4">16</span><span class="s1">).toUpperCase() + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ (c &gt;&gt; </span><span class="s4">6 </span><span class="s1">&amp; </span><span class="s4">63 </span><span class="s1">| </span><span class="s4">128</span><span class="s1">).toString(</span><span class="s4">16</span><span class="s1">).toUpperCase() + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ (c &amp; </span><span class="s4">63 </span><span class="s1">| </span><span class="s4">128</span><span class="s1">).toString(</span><span class="s4">16</span><span class="s1">).toUpperCase();</span>
    <span class="s2">return </span><span class="s1">e;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">pctDecChars(str) {</span>
    <span class="s2">var </span><span class="s1">newStr = </span><span class="s3">&quot;&quot;</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">il = str.length;</span>
    <span class="s2">while </span><span class="s1">(i &lt; il) {</span>
        <span class="s2">var </span><span class="s1">c = parseInt(str.substr(i + </span><span class="s4">1</span><span class="s1">, </span><span class="s4">2</span><span class="s1">), </span><span class="s4">16</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(c &lt; </span><span class="s4">128</span><span class="s1">) {</span>
            <span class="s1">newStr += String.fromCharCode(c);</span>
            <span class="s1">i += </span><span class="s4">3</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(c &gt;= </span><span class="s4">194 </span><span class="s1">&amp;&amp; c &lt; </span><span class="s4">224</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(il - i &gt;= </span><span class="s4">6</span><span class="s1">) {</span>
                <span class="s2">var </span><span class="s1">c2 = parseInt(str.substr(i + </span><span class="s4">4</span><span class="s1">, </span><span class="s4">2</span><span class="s1">), </span><span class="s4">16</span><span class="s1">);</span>
                <span class="s1">newStr += String.fromCharCode((c &amp; </span><span class="s4">31</span><span class="s1">) &lt;&lt; </span><span class="s4">6 </span><span class="s1">| c2 &amp; </span><span class="s4">63</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newStr += str.substr(i, </span><span class="s4">6</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">i += </span><span class="s4">6</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(c &gt;= </span><span class="s4">224</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(il - i &gt;= </span><span class="s4">9</span><span class="s1">) {</span>
                <span class="s2">var </span><span class="s1">_c = parseInt(str.substr(i + </span><span class="s4">4</span><span class="s1">, </span><span class="s4">2</span><span class="s1">), </span><span class="s4">16</span><span class="s1">);</span>
                <span class="s2">var </span><span class="s1">c3 = parseInt(str.substr(i + </span><span class="s4">7</span><span class="s1">, </span><span class="s4">2</span><span class="s1">), </span><span class="s4">16</span><span class="s1">);</span>
                <span class="s1">newStr += String.fromCharCode((c &amp; </span><span class="s4">15</span><span class="s1">) &lt;&lt; </span><span class="s4">12 </span><span class="s1">| (_c &amp; </span><span class="s4">63</span><span class="s1">) &lt;&lt; </span><span class="s4">6 </span><span class="s1">| c3 &amp; </span><span class="s4">63</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newStr += str.substr(i, </span><span class="s4">9</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">i += </span><span class="s4">9</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newStr += str.substr(i, </span><span class="s4">3</span><span class="s1">);</span>
            <span class="s1">i += </span><span class="s4">3</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newStr;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_normalizeComponentEncoding(components, protocol) {</span>
    <span class="s2">function </span><span class="s1">decodeUnreserved(str) {</span>
        <span class="s2">var </span><span class="s1">decStr = pctDecChars(str);</span>
        <span class="s2">return </span><span class="s1">!decStr.match(protocol.UNRESERVED) ? str : decStr;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, </span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s2">if </span><span class="s1">(components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s2">if </span><span class="s1">(components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s2">if </span><span class="s1">(components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s2">if </span><span class="s1">(components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);</span>
    <span class="s2">return </span><span class="s1">components;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">_stripLeadingZeros(str) {</span>
    <span class="s2">return </span><span class="s1">str.replace(/^</span><span class="s4">0</span><span class="s1">*(.*)/, </span><span class="s3">&quot;$1&quot;</span><span class="s1">) || </span><span class="s3">&quot;0&quot;</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_normalizeIPv4(host, protocol) {</span>
    <span class="s2">var </span><span class="s1">matches = host.match(protocol.IPV4ADDRESS) || [];</span>

    <span class="s2">var </span><span class="s1">_matches = slicedToArray(matches, </span><span class="s4">2</span><span class="s1">),</span>
        <span class="s1">address = _matches[</span><span class="s4">1</span><span class="s1">];</span>

    <span class="s2">if </span><span class="s1">(address) {</span>
        <span class="s2">return </span><span class="s1">address.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">).map(_stripLeadingZeros).join(</span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">host;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_normalizeIPv6(host, protocol) {</span>
    <span class="s2">var </span><span class="s1">matches = host.match(protocol.IPV6ADDRESS) || [];</span>

    <span class="s2">var </span><span class="s1">_matches2 = slicedToArray(matches, </span><span class="s4">3</span><span class="s1">),</span>
        <span class="s1">address = _matches2[</span><span class="s4">1</span><span class="s1">],</span>
        <span class="s1">zone = _matches2[</span><span class="s4">2</span><span class="s1">];</span>

    <span class="s2">if </span><span class="s1">(address) {</span>
        <span class="s2">var </span><span class="s1">_address$toLowerCase$ = address.toLowerCase().split(</span><span class="s3">'::'</span><span class="s1">).reverse(),</span>
            <span class="s1">_address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, </span><span class="s4">2</span><span class="s1">),</span>
            <span class="s1">last = _address$toLowerCase$2[</span><span class="s4">0</span><span class="s1">],</span>
            <span class="s1">first = _address$toLowerCase$2[</span><span class="s4">1</span><span class="s1">];</span>

        <span class="s2">var </span><span class="s1">firstFields = first ? first.split(</span><span class="s3">&quot;:&quot;</span><span class="s1">).map(_stripLeadingZeros) : [];</span>
        <span class="s2">var </span><span class="s1">lastFields = last.split(</span><span class="s3">&quot;:&quot;</span><span class="s1">).map(_stripLeadingZeros);</span>
        <span class="s2">var </span><span class="s1">isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - </span><span class="s4">1</span><span class="s1">]);</span>
        <span class="s2">var </span><span class="s1">fieldCount = isLastFieldIPv4Address ? </span><span class="s4">7 </span><span class="s1">: </span><span class="s4">8</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">lastFieldsStart = lastFields.length - fieldCount;</span>
        <span class="s2">var </span><span class="s1">fields = Array(fieldCount);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">x = </span><span class="s4">0</span><span class="s1">; x &lt; fieldCount; ++x) {</span>
            <span class="s1">fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || </span><span class="s3">''</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isLastFieldIPv4Address) {</span>
            <span class="s1">fields[fieldCount - </span><span class="s4">1</span><span class="s1">] = _normalizeIPv4(fields[fieldCount - </span><span class="s4">1</span><span class="s1">], protocol);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">allZeroFields = fields.reduce(</span><span class="s2">function </span><span class="s1">(acc, field, index) {</span>
            <span class="s2">if </span><span class="s1">(!field || field === </span><span class="s3">&quot;0&quot;</span><span class="s1">) {</span>
                <span class="s2">var </span><span class="s1">lastLongest = acc[acc.length - </span><span class="s4">1</span><span class="s1">];</span>
                <span class="s2">if </span><span class="s1">(lastLongest &amp;&amp; lastLongest.index + lastLongest.length === index) {</span>
                    <span class="s1">lastLongest.length++;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">acc.push({ index: index, length: </span><span class="s4">1 </span><span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">acc;</span>
        <span class="s1">}, []);</span>
        <span class="s2">var </span><span class="s1">longestZeroFields = allZeroFields.sort(</span><span class="s2">function </span><span class="s1">(a, b) {</span>
            <span class="s2">return </span><span class="s1">b.length - a.length;</span>
        <span class="s1">})[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s2">var </span><span class="s1">newHost = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(longestZeroFields &amp;&amp; longestZeroFields.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">var </span><span class="s1">newFirst = fields.slice(</span><span class="s4">0</span><span class="s1">, longestZeroFields.index);</span>
            <span class="s2">var </span><span class="s1">newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);</span>
            <span class="s1">newHost = newFirst.join(</span><span class="s3">&quot;:&quot;</span><span class="s1">) + </span><span class="s3">&quot;::&quot; </span><span class="s1">+ newLast.join(</span><span class="s3">&quot;:&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">newHost = fields.join(</span><span class="s3">&quot;:&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(zone) {</span>
            <span class="s1">newHost += </span><span class="s3">&quot;%&quot; </span><span class="s1">+ zone;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">newHost;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">host;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;</span>
<span class="s2">var </span><span class="s1">NO_MATCH_IS_UNDEFINED = </span><span class="s3">&quot;&quot;</span><span class="s1">.match(/(){</span><span class="s4">0</span><span class="s1">}/)[</span><span class="s4">1</span><span class="s1">] === undefined;</span>
<span class="s2">function </span><span class="s1">parse(uriString) {</span>
    <span class="s2">var </span><span class="s1">options = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : {};</span>

    <span class="s2">var </span><span class="s1">components = {};</span>
    <span class="s2">var </span><span class="s1">protocol = options.iri !== </span><span class="s2">false </span><span class="s1">? IRI_PROTOCOL : URI_PROTOCOL;</span>
    <span class="s2">if </span><span class="s1">(options.reference === </span><span class="s3">&quot;suffix&quot;</span><span class="s1">) uriString = (options.scheme ? options.scheme + </span><span class="s3">&quot;:&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">) + </span><span class="s3">&quot;//&quot; </span><span class="s1">+ uriString;</span>
    <span class="s2">var </span><span class="s1">matches = uriString.match(URI_PARSE);</span>
    <span class="s2">if </span><span class="s1">(matches) {</span>
        <span class="s2">if </span><span class="s1">(NO_MATCH_IS_UNDEFINED) {</span>
            <span class="s0">//store each component</span>
            <span class="s1">components.scheme = matches[</span><span class="s4">1</span><span class="s1">];</span>
            <span class="s1">components.userinfo = matches[</span><span class="s4">3</span><span class="s1">];</span>
            <span class="s1">components.host = matches[</span><span class="s4">4</span><span class="s1">];</span>
            <span class="s1">components.port = parseInt(matches[</span><span class="s4">5</span><span class="s1">], </span><span class="s4">10</span><span class="s1">);</span>
            <span class="s1">components.path = matches[</span><span class="s4">6</span><span class="s1">] || </span><span class="s3">&quot;&quot;</span><span class="s1">;</span>
            <span class="s1">components.query = matches[</span><span class="s4">7</span><span class="s1">];</span>
            <span class="s1">components.fragment = matches[</span><span class="s4">8</span><span class="s1">];</span>
            <span class="s0">//fix port number</span>
            <span class="s2">if </span><span class="s1">(isNaN(components.port)) {</span>
                <span class="s1">components.port = matches[</span><span class="s4">5</span><span class="s1">];</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">//IE FIX for improper RegExp matching</span>
            <span class="s0">//store each component</span>
            <span class="s1">components.scheme = matches[</span><span class="s4">1</span><span class="s1">] || undefined;</span>
            <span class="s1">components.userinfo = uriString.indexOf(</span><span class="s3">&quot;@&quot;</span><span class="s1">) !== -</span><span class="s4">1 </span><span class="s1">? matches[</span><span class="s4">3</span><span class="s1">] : undefined;</span>
            <span class="s1">components.host = uriString.indexOf(</span><span class="s3">&quot;//&quot;</span><span class="s1">) !== -</span><span class="s4">1 </span><span class="s1">? matches[</span><span class="s4">4</span><span class="s1">] : undefined;</span>
            <span class="s1">components.port = parseInt(matches[</span><span class="s4">5</span><span class="s1">], </span><span class="s4">10</span><span class="s1">);</span>
            <span class="s1">components.path = matches[</span><span class="s4">6</span><span class="s1">] || </span><span class="s3">&quot;&quot;</span><span class="s1">;</span>
            <span class="s1">components.query = uriString.indexOf(</span><span class="s3">&quot;?&quot;</span><span class="s1">) !== -</span><span class="s4">1 </span><span class="s1">? matches[</span><span class="s4">7</span><span class="s1">] : undefined;</span>
            <span class="s1">components.fragment = uriString.indexOf(</span><span class="s3">&quot;#&quot;</span><span class="s1">) !== -</span><span class="s4">1 </span><span class="s1">? matches[</span><span class="s4">8</span><span class="s1">] : undefined;</span>
            <span class="s0">//fix port number</span>
            <span class="s2">if </span><span class="s1">(isNaN(components.port)) {</span>
                <span class="s1">components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[</span><span class="s4">4</span><span class="s1">] : undefined;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(components.host) {</span>
            <span class="s0">//normalize IP hosts</span>
            <span class="s1">components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);</span>
        <span class="s1">}</span>
        <span class="s0">//determine reference type</span>
        <span class="s2">if </span><span class="s1">(components.scheme === undefined &amp;&amp; components.userinfo === undefined &amp;&amp; components.host === undefined &amp;&amp; components.port === undefined &amp;&amp; !components.path &amp;&amp; components.query === undefined) {</span>
            <span class="s1">components.reference = </span><span class="s3">&quot;same-document&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(components.scheme === undefined) {</span>
            <span class="s1">components.reference = </span><span class="s3">&quot;relative&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(components.fragment === undefined) {</span>
            <span class="s1">components.reference = </span><span class="s3">&quot;absolute&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">components.reference = </span><span class="s3">&quot;uri&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">//check for reference errors</span>
        <span class="s2">if </span><span class="s1">(options.reference &amp;&amp; options.reference !== </span><span class="s3">&quot;suffix&quot; </span><span class="s1">&amp;&amp; options.reference !== components.reference) {</span>
            <span class="s1">components.error = components.error || </span><span class="s3">&quot;URI is not a &quot; </span><span class="s1">+ options.reference + </span><span class="s3">&quot; reference.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">//find scheme handler</span>
        <span class="s2">var </span><span class="s1">schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s3">&quot;&quot;</span><span class="s1">).toLowerCase()];</span>
        <span class="s0">//check if scheme can't handle IRIs</span>
        <span class="s2">if </span><span class="s1">(!options.unicodeSupport &amp;&amp; (!schemeHandler || !schemeHandler.unicodeSupport)) {</span>
            <span class="s0">//if host component is a domain name</span>
            <span class="s2">if </span><span class="s1">(components.host &amp;&amp; (options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost)) {</span>
                <span class="s0">//convert Unicode IDN -&gt; ASCII IDN</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                    <span class="s1">components.error = components.error || </span><span class="s3">&quot;Host's domain name can not be converted to ASCII via punycode: &quot; </span><span class="s1">+ e;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">//convert IRI -&gt; URI</span>
            <span class="s1">_normalizeComponentEncoding(components, URI_PROTOCOL);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">//normalize encodings</span>
            <span class="s1">_normalizeComponentEncoding(components, protocol);</span>
        <span class="s1">}</span>
        <span class="s0">//perform scheme specific parsing</span>
        <span class="s2">if </span><span class="s1">(schemeHandler &amp;&amp; schemeHandler.parse) {</span>
            <span class="s1">schemeHandler.parse(components, options);</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">components.error = components.error || </span><span class="s3">&quot;URI can not be parsed.&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">components;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">_recomposeAuthority(components, options) {</span>
    <span class="s2">var </span><span class="s1">protocol = options.iri !== </span><span class="s2">false </span><span class="s1">? IRI_PROTOCOL : URI_PROTOCOL;</span>
    <span class="s2">var </span><span class="s1">uriTokens = [];</span>
    <span class="s2">if </span><span class="s1">(components.userinfo !== undefined) {</span>
        <span class="s1">uriTokens.push(components.userinfo);</span>
        <span class="s1">uriTokens.push(</span><span class="s3">&quot;@&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(components.host !== undefined) {</span>
        <span class="s0">//normalize IP hosts, add brackets and escape zone separator for IPv6</span>
        <span class="s1">uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, </span><span class="s2">function </span><span class="s1">(_, $1, $2) {</span>
            <span class="s2">return </span><span class="s3">&quot;[&quot; </span><span class="s1">+ $1 + ($2 ? </span><span class="s3">&quot;%25&quot; </span><span class="s1">+ $2 : </span><span class="s3">&quot;&quot;</span><span class="s1">) + </span><span class="s3">&quot;]&quot;</span><span class="s1">;</span>
        <span class="s1">}));</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">components.port === </span><span class="s3">&quot;number&quot; </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">components.port === </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">uriTokens.push(</span><span class="s3">&quot;:&quot;</span><span class="s1">);</span>
        <span class="s1">uriTokens.push(String(components.port));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">uriTokens.length ? uriTokens.join(</span><span class="s3">&quot;&quot;</span><span class="s1">) : undefined;</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">RDS1 = /^\.\.?\</span><span class="s0">//;</span>
<span class="s2">var </span><span class="s1">RDS2 = /^\/\.(\/|$)/;</span>
<span class="s2">var </span><span class="s1">RDS3 = /^\/\.\.(\/|$)/;</span>
<span class="s2">var </span><span class="s1">RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;</span>
<span class="s2">function </span><span class="s1">removeDotSegments(input) {</span>
    <span class="s2">var </span><span class="s1">output = [];</span>
    <span class="s2">while </span><span class="s1">(input.length) {</span>
        <span class="s2">if </span><span class="s1">(input.match(RDS1)) {</span>
            <span class="s1">input = input.replace(RDS1, </span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(input.match(RDS2)) {</span>
            <span class="s1">input = input.replace(RDS2, </span><span class="s3">&quot;/&quot;</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(input.match(RDS3)) {</span>
            <span class="s1">input = input.replace(RDS3, </span><span class="s3">&quot;/&quot;</span><span class="s1">);</span>
            <span class="s1">output.pop();</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(input === </span><span class="s3">&quot;.&quot; </span><span class="s1">|| input === </span><span class="s3">&quot;..&quot;</span><span class="s1">) {</span>
            <span class="s1">input = </span><span class="s3">&quot;&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">var </span><span class="s1">im = input.match(RDS5);</span>
            <span class="s2">if </span><span class="s1">(im) {</span>
                <span class="s2">var </span><span class="s1">s = im[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s1">input = input.slice(s.length);</span>
                <span class="s1">output.push(s);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Unexpected dot segment condition&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">output.join(</span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">serialize(components) {</span>
    <span class="s2">var </span><span class="s1">options = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : {};</span>

    <span class="s2">var </span><span class="s1">protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;</span>
    <span class="s2">var </span><span class="s1">uriTokens = [];</span>
    <span class="s0">//find scheme handler</span>
    <span class="s2">var </span><span class="s1">schemeHandler = SCHEMES[(options.scheme || components.scheme || </span><span class="s3">&quot;&quot;</span><span class="s1">).toLowerCase()];</span>
    <span class="s0">//perform scheme specific serialization</span>
    <span class="s2">if </span><span class="s1">(schemeHandler &amp;&amp; schemeHandler.serialize) schemeHandler.serialize(components, options);</span>
    <span class="s2">if </span><span class="s1">(components.host) {</span>
        <span class="s0">//if host component is an IPv6 address</span>
        <span class="s2">if </span><span class="s1">(protocol.IPV6ADDRESS.test(components.host)) {}</span>
        <span class="s0">//TODO: normalize IPv6 address as per RFC 5952</span>

        <span class="s0">//if host component is a domain name</span>
        <span class="s2">else if </span><span class="s1">(options.domainHost || schemeHandler &amp;&amp; schemeHandler.domainHost) {</span>
                <span class="s0">//convert IDN via punycode</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                    <span class="s1">components.error = components.error || </span><span class="s3">&quot;Host's domain name can not be converted to &quot; </span><span class="s1">+ (!options.iri ? </span><span class="s3">&quot;ASCII&quot; </span><span class="s1">: </span><span class="s3">&quot;Unicode&quot;</span><span class="s1">) + </span><span class="s3">&quot; via punycode: &quot; </span><span class="s1">+ e;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">//normalize encoding</span>
    <span class="s1">_normalizeComponentEncoding(components, protocol);</span>
    <span class="s2">if </span><span class="s1">(options.reference !== </span><span class="s3">&quot;suffix&quot; </span><span class="s1">&amp;&amp; components.scheme) {</span>
        <span class="s1">uriTokens.push(components.scheme);</span>
        <span class="s1">uriTokens.push(</span><span class="s3">&quot;:&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">authority = _recomposeAuthority(components, options);</span>
    <span class="s2">if </span><span class="s1">(authority !== undefined) {</span>
        <span class="s2">if </span><span class="s1">(options.reference !== </span><span class="s3">&quot;suffix&quot;</span><span class="s1">) {</span>
            <span class="s1">uriTokens.push(</span><span class="s3">&quot;//&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">uriTokens.push(authority);</span>
        <span class="s2">if </span><span class="s1">(components.path &amp;&amp; components.path.charAt(</span><span class="s4">0</span><span class="s1">) !== </span><span class="s3">&quot;/&quot;</span><span class="s1">) {</span>
            <span class="s1">uriTokens.push(</span><span class="s3">&quot;/&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(components.path !== undefined) {</span>
        <span class="s2">var </span><span class="s1">s = components.path;</span>
        <span class="s2">if </span><span class="s1">(!options.absolutePath &amp;&amp; (!schemeHandler || !schemeHandler.absolutePath)) {</span>
            <span class="s1">s = removeDotSegments(s);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(authority === undefined) {</span>
            <span class="s1">s = s.replace(/^\/\</span><span class="s0">//, &quot;/%2F&quot;); //don't allow the path to start with &quot;//&quot;</span>
        <span class="s1">}</span>
        <span class="s1">uriTokens.push(s);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(components.query !== undefined) {</span>
        <span class="s1">uriTokens.push(</span><span class="s3">&quot;?&quot;</span><span class="s1">);</span>
        <span class="s1">uriTokens.push(components.query);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(components.fragment !== undefined) {</span>
        <span class="s1">uriTokens.push(</span><span class="s3">&quot;#&quot;</span><span class="s1">);</span>
        <span class="s1">uriTokens.push(components.fragment);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">uriTokens.join(</span><span class="s3">&quot;&quot;</span><span class="s1">); </span><span class="s0">//merge tokens into a string</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">resolveComponents(base, relative) {</span>
    <span class="s2">var </span><span class="s1">options = arguments.length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">2</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">2</span><span class="s1">] : {};</span>
    <span class="s2">var </span><span class="s1">skipNormalization = arguments[</span><span class="s4">3</span><span class="s1">];</span>

    <span class="s2">var </span><span class="s1">target = {};</span>
    <span class="s2">if </span><span class="s1">(!skipNormalization) {</span>
        <span class="s1">base = parse(serialize(base, options), options); </span><span class="s0">//normalize base components</span>
        <span class="s1">relative = parse(serialize(relative, options), options); </span><span class="s0">//normalize relative components</span>
    <span class="s1">}</span>
    <span class="s1">options = options || {};</span>
    <span class="s2">if </span><span class="s1">(!options.tolerant &amp;&amp; relative.scheme) {</span>
        <span class="s1">target.scheme = relative.scheme;</span>
        <span class="s0">//target.authority = relative.authority;</span>
        <span class="s1">target.userinfo = relative.userinfo;</span>
        <span class="s1">target.host = relative.host;</span>
        <span class="s1">target.port = relative.port;</span>
        <span class="s1">target.path = removeDotSegments(relative.path || </span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
        <span class="s1">target.query = relative.query;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {</span>
            <span class="s0">//target.authority = relative.authority;</span>
            <span class="s1">target.userinfo = relative.userinfo;</span>
            <span class="s1">target.host = relative.host;</span>
            <span class="s1">target.port = relative.port;</span>
            <span class="s1">target.path = removeDotSegments(relative.path || </span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
            <span class="s1">target.query = relative.query;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!relative.path) {</span>
                <span class="s1">target.path = base.path;</span>
                <span class="s2">if </span><span class="s1">(relative.query !== undefined) {</span>
                    <span class="s1">target.query = relative.query;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">target.query = base.query;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(relative.path.charAt(</span><span class="s4">0</span><span class="s1">) === </span><span class="s3">&quot;/&quot;</span><span class="s1">) {</span>
                    <span class="s1">target.path = removeDotSegments(relative.path);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &amp;&amp; !base.path) {</span>
                        <span class="s1">target.path = </span><span class="s3">&quot;/&quot; </span><span class="s1">+ relative.path;</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!base.path) {</span>
                        <span class="s1">target.path = relative.path;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">target.path = base.path.slice(</span><span class="s4">0</span><span class="s1">, base.path.lastIndexOf(</span><span class="s3">&quot;/&quot;</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">) + relative.path;</span>
                    <span class="s1">}</span>
                    <span class="s1">target.path = removeDotSegments(target.path);</span>
                <span class="s1">}</span>
                <span class="s1">target.query = relative.query;</span>
            <span class="s1">}</span>
            <span class="s0">//target.authority = base.authority;</span>
            <span class="s1">target.userinfo = base.userinfo;</span>
            <span class="s1">target.host = base.host;</span>
            <span class="s1">target.port = base.port;</span>
        <span class="s1">}</span>
        <span class="s1">target.scheme = base.scheme;</span>
    <span class="s1">}</span>
    <span class="s1">target.fragment = relative.fragment;</span>
    <span class="s2">return </span><span class="s1">target;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">resolve(baseURI, relativeURI, options) {</span>
    <span class="s2">var </span><span class="s1">schemelessOptions = assign({ scheme: </span><span class="s3">'null' </span><span class="s1">}, options);</span>
    <span class="s2">return </span><span class="s1">serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, </span><span class="s2">true</span><span class="s1">), schemelessOptions);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">normalize(uri, options) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">uri === </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">uri = serialize(parse(uri, options), options);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(typeOf(uri) === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s1">uri = parse(serialize(uri, options), options);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">uri;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">equal(uriA, uriB, options) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">uriA === </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">uriA = serialize(parse(uriA, options), options);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(typeOf(uriA) === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s1">uriA = serialize(uriA, options);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">uriB === </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">uriB = serialize(parse(uriB, options), options);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(typeOf(uriB) === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s1">uriB = serialize(uriB, options);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">uriA === uriB;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">escapeComponent(str, options) {</span>
    <span class="s2">return </span><span class="s1">str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">unescapeComponent(str, options) {</span>
    <span class="s2">return </span><span class="s1">str &amp;&amp; str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">handler = {</span>
    <span class="s1">scheme: </span><span class="s3">&quot;http&quot;</span><span class="s1">,</span>
    <span class="s1">domainHost: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">parse: </span><span class="s2">function </span><span class="s1">parse(components, options) {</span>
        <span class="s0">//report missing host</span>
        <span class="s2">if </span><span class="s1">(!components.host) {</span>
            <span class="s1">components.error = components.error || </span><span class="s3">&quot;HTTP URIs must have a host.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">components;</span>
    <span class="s1">},</span>
    <span class="s1">serialize: </span><span class="s2">function </span><span class="s1">serialize(components, options) {</span>
        <span class="s2">var </span><span class="s1">secure = String(components.scheme).toLowerCase() === </span><span class="s3">&quot;https&quot;</span><span class="s1">;</span>
        <span class="s0">//normalize the default port</span>
        <span class="s2">if </span><span class="s1">(components.port === (secure ? </span><span class="s4">443 </span><span class="s1">: </span><span class="s4">80</span><span class="s1">) || components.port === </span><span class="s3">&quot;&quot;</span><span class="s1">) {</span>
            <span class="s1">components.port = undefined;</span>
        <span class="s1">}</span>
        <span class="s0">//normalize the empty path</span>
        <span class="s2">if </span><span class="s1">(!components.path) {</span>
            <span class="s1">components.path = </span><span class="s3">&quot;/&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">//NOTE: We do not parse query strings for HTTP URIs</span>
        <span class="s0">//as WWW Form Url Encoded query strings are part of the HTML4+ spec,</span>
        <span class="s0">//and not the HTTP spec.</span>
        <span class="s2">return </span><span class="s1">components;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">var </span><span class="s1">handler$1 = {</span>
    <span class="s1">scheme: </span><span class="s3">&quot;https&quot;</span><span class="s1">,</span>
    <span class="s1">domainHost: handler.domainHost,</span>
    <span class="s1">parse: handler.parse,</span>
    <span class="s1">serialize: handler.serialize</span>
<span class="s1">};</span>

<span class="s2">function </span><span class="s1">isSecure(wsComponents) {</span>
    <span class="s2">return typeof </span><span class="s1">wsComponents.secure === </span><span class="s3">'boolean' </span><span class="s1">? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === </span><span class="s3">&quot;wss&quot;</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">//RFC 6455</span>
<span class="s2">var </span><span class="s1">handler$2 = {</span>
    <span class="s1">scheme: </span><span class="s3">&quot;ws&quot;</span><span class="s1">,</span>
    <span class="s1">domainHost: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">parse: </span><span class="s2">function </span><span class="s1">parse(components, options) {</span>
        <span class="s2">var </span><span class="s1">wsComponents = components;</span>
        <span class="s0">//indicate if the secure flag is set</span>
        <span class="s1">wsComponents.secure = isSecure(wsComponents);</span>
        <span class="s0">//construct resouce name</span>
        <span class="s1">wsComponents.resourceName = (wsComponents.path || </span><span class="s3">'/'</span><span class="s1">) + (wsComponents.query ? </span><span class="s3">'?' </span><span class="s1">+ wsComponents.query : </span><span class="s3">''</span><span class="s1">);</span>
        <span class="s1">wsComponents.path = undefined;</span>
        <span class="s1">wsComponents.query = undefined;</span>
        <span class="s2">return </span><span class="s1">wsComponents;</span>
    <span class="s1">},</span>
    <span class="s1">serialize: </span><span class="s2">function </span><span class="s1">serialize(wsComponents, options) {</span>
        <span class="s0">//normalize the default port</span>
        <span class="s2">if </span><span class="s1">(wsComponents.port === (isSecure(wsComponents) ? </span><span class="s4">443 </span><span class="s1">: </span><span class="s4">80</span><span class="s1">) || wsComponents.port === </span><span class="s3">&quot;&quot;</span><span class="s1">) {</span>
            <span class="s1">wsComponents.port = undefined;</span>
        <span class="s1">}</span>
        <span class="s0">//ensure scheme matches secure flag</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">wsComponents.secure === </span><span class="s3">'boolean'</span><span class="s1">) {</span>
            <span class="s1">wsComponents.scheme = wsComponents.secure ? </span><span class="s3">'wss' </span><span class="s1">: </span><span class="s3">'ws'</span><span class="s1">;</span>
            <span class="s1">wsComponents.secure = undefined;</span>
        <span class="s1">}</span>
        <span class="s0">//reconstruct path from resource name</span>
        <span class="s2">if </span><span class="s1">(wsComponents.resourceName) {</span>
            <span class="s2">var </span><span class="s1">_wsComponents$resourc = wsComponents.resourceName.split(</span><span class="s3">'?'</span><span class="s1">),</span>
                <span class="s1">_wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, </span><span class="s4">2</span><span class="s1">),</span>
                <span class="s1">path = _wsComponents$resourc2[</span><span class="s4">0</span><span class="s1">],</span>
                <span class="s1">query = _wsComponents$resourc2[</span><span class="s4">1</span><span class="s1">];</span>

            <span class="s1">wsComponents.path = path &amp;&amp; path !== </span><span class="s3">'/' </span><span class="s1">? path : undefined;</span>
            <span class="s1">wsComponents.query = query;</span>
            <span class="s1">wsComponents.resourceName = undefined;</span>
        <span class="s1">}</span>
        <span class="s0">//forbid fragment component</span>
        <span class="s1">wsComponents.fragment = undefined;</span>
        <span class="s2">return </span><span class="s1">wsComponents;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">var </span><span class="s1">handler$3 = {</span>
    <span class="s1">scheme: </span><span class="s3">&quot;wss&quot;</span><span class="s1">,</span>
    <span class="s1">domainHost: handler$2.domainHost,</span>
    <span class="s1">parse: handler$2.parse,</span>
    <span class="s1">serialize: handler$2.serialize</span>
<span class="s1">};</span>

<span class="s2">var </span><span class="s1">O = {};</span>
<span class="s2">var </span><span class="s1">isIRI = </span><span class="s2">true</span><span class="s1">;</span>
<span class="s0">//RFC 3986</span>
<span class="s2">var </span><span class="s1">UNRESERVED$$ = </span><span class="s3">&quot;[A-Za-z0-9</span><span class="s5">\\</span><span class="s3">-</span><span class="s5">\\</span><span class="s3">.</span><span class="s5">\\</span><span class="s3">_</span><span class="s5">\\</span><span class="s3">~&quot; </span><span class="s1">+ (isIRI ? </span><span class="s3">&quot;</span><span class="s5">\\</span><span class="s3">xA0-</span><span class="s5">\\</span><span class="s3">u200D</span><span class="s5">\\</span><span class="s3">u2010-</span><span class="s5">\\</span><span class="s3">u2029</span><span class="s5">\\</span><span class="s3">u202F-</span><span class="s5">\\</span><span class="s3">uD7FF</span><span class="s5">\\</span><span class="s3">uF900-</span><span class="s5">\\</span><span class="s3">uFDCF</span><span class="s5">\\</span><span class="s3">uFDF0-</span><span class="s5">\\</span><span class="s3">uFFEF&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">) + </span><span class="s3">&quot;]&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">HEXDIG$$ = </span><span class="s3">&quot;[0-9A-Fa-f]&quot;</span><span class="s1">; </span><span class="s0">//case-insensitive</span>
<span class="s2">var </span><span class="s1">PCT_ENCODED$ = subexp(subexp(</span><span class="s3">&quot;%[EFef]&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$ + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;%[89A-Fa-f]&quot; </span><span class="s1">+ HEXDIG$$ + </span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$) + </span><span class="s3">&quot;|&quot; </span><span class="s1">+ subexp(</span><span class="s3">&quot;%&quot; </span><span class="s1">+ HEXDIG$$ + HEXDIG$$)); </span><span class="s0">//expanded</span>
<span class="s0">//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] &amp; ; =</span>
<span class="s0">//const ATEXT$$ = &quot;[A-Za-z0-9\\!\\#\\$\\%\\&amp;\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]&quot;;</span>
<span class="s0">//const WSP$$ = &quot;[\\x20\\x09]&quot;;</span>
<span class="s0">//const OBS_QTEXT$$ = &quot;[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]&quot;;  //(%d1-8 / %d11-12 / %d14-31 / %d127)</span>
<span class="s0">//const QTEXT$$ = merge(&quot;[\\x21\\x23-\\x5B\\x5D-\\x7E]&quot;, OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext</span>
<span class="s0">//const VCHAR$$ = &quot;[\\x21-\\x7E]&quot;;</span>
<span class="s0">//const WSP$$ = &quot;[\\x20\\x09]&quot;;</span>
<span class="s0">//const OBS_QP$ = subexp(&quot;\\\\&quot; + merge(&quot;[\\x00\\x0D\\x0A]&quot;, OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext</span>
<span class="s0">//const FWS$ = subexp(subexp(WSP$$ + &quot;*&quot; + &quot;\\x0D\\x0A&quot;) + &quot;?&quot; + WSP$$ + &quot;+&quot;);</span>
<span class="s0">//const QUOTED_PAIR$ = subexp(subexp(&quot;\\\\&quot; + subexp(VCHAR$$ + &quot;|&quot; + WSP$$)) + &quot;|&quot; + OBS_QP$);</span>
<span class="s0">//const QUOTED_STRING$ = subexp('\\&quot;' + subexp(FWS$ + &quot;?&quot; + QCONTENT$) + &quot;*&quot; + FWS$ + &quot;?&quot; + '\\&quot;');</span>
<span class="s2">var </span><span class="s1">ATEXT$$ = </span><span class="s3">&quot;[A-Za-z0-9</span><span class="s5">\\</span><span class="s3">!</span><span class="s5">\\</span><span class="s3">$</span><span class="s5">\\</span><span class="s3">%</span><span class="s5">\\</span><span class="s3">'</span><span class="s5">\\</span><span class="s3">*</span><span class="s5">\\</span><span class="s3">+</span><span class="s5">\\</span><span class="s3">-</span><span class="s5">\\</span><span class="s3">^</span><span class="s5">\\</span><span class="s3">_</span><span class="s5">\\</span><span class="s3">`</span><span class="s5">\\</span><span class="s3">{</span><span class="s5">\\</span><span class="s3">|</span><span class="s5">\\</span><span class="s3">}</span><span class="s5">\\</span><span class="s3">~]&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">QTEXT$$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">!</span><span class="s5">\\</span><span class="s3">$</span><span class="s5">\\</span><span class="s3">%</span><span class="s5">\\</span><span class="s3">'</span><span class="s5">\\</span><span class="s3">(</span><span class="s5">\\</span><span class="s3">)</span><span class="s5">\\</span><span class="s3">*</span><span class="s5">\\</span><span class="s3">+</span><span class="s5">\\</span><span class="s3">,</span><span class="s5">\\</span><span class="s3">-</span><span class="s5">\\</span><span class="s3">.0-9</span><span class="s5">\\</span><span class="s3">&lt;</span><span class="s5">\\</span><span class="s3">&gt;A-Z</span><span class="s5">\\</span><span class="s3">x5E-</span><span class="s5">\\</span><span class="s3">x7E]&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">VCHAR$$ = merge(QTEXT$$, </span><span class="s3">&quot;[</span><span class="s5">\\\&quot;\\\\</span><span class="s3">]&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">SOME_DELIMS$$ = </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">!</span><span class="s5">\\</span><span class="s3">$</span><span class="s5">\\</span><span class="s3">'</span><span class="s5">\\</span><span class="s3">(</span><span class="s5">\\</span><span class="s3">)</span><span class="s5">\\</span><span class="s3">*</span><span class="s5">\\</span><span class="s3">+</span><span class="s5">\\</span><span class="s3">,</span><span class="s5">\\</span><span class="s3">;</span><span class="s5">\\</span><span class="s3">:</span><span class="s5">\\</span><span class="s3">@]&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">UNRESERVED = </span><span class="s2">new </span><span class="s1">RegExp(UNRESERVED$$, </span><span class="s3">&quot;g&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">PCT_ENCODED = </span><span class="s2">new </span><span class="s1">RegExp(PCT_ENCODED$, </span><span class="s3">&quot;g&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">NOT_LOCAL_PART = </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^]&quot;</span><span class="s1">, ATEXT$$, </span><span class="s3">&quot;[</span><span class="s5">\\</span><span class="s3">.]&quot;</span><span class="s1">, </span><span class="s3">'[</span><span class="s5">\\</span><span class="s3">&quot;]'</span><span class="s1">, VCHAR$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">NOT_HFNAME = </span><span class="s2">new </span><span class="s1">RegExp(merge(</span><span class="s3">&quot;[^]&quot;</span><span class="s1">, UNRESERVED$$, SOME_DELIMS$$), </span><span class="s3">&quot;g&quot;</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">NOT_HFVALUE = NOT_HFNAME;</span>
<span class="s2">function </span><span class="s1">decodeUnreserved(str) {</span>
    <span class="s2">var </span><span class="s1">decStr = pctDecChars(str);</span>
    <span class="s2">return </span><span class="s1">!decStr.match(UNRESERVED) ? str : decStr;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">handler$4 = {</span>
    <span class="s1">scheme: </span><span class="s3">&quot;mailto&quot;</span><span class="s1">,</span>
    <span class="s1">parse: </span><span class="s2">function </span><span class="s1">parse$$1(components, options) {</span>
        <span class="s2">var </span><span class="s1">mailtoComponents = components;</span>
        <span class="s2">var </span><span class="s1">to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">) : [];</span>
        <span class="s1">mailtoComponents.path = undefined;</span>
        <span class="s2">if </span><span class="s1">(mailtoComponents.query) {</span>
            <span class="s2">var </span><span class="s1">unknownHeaders = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">headers = {};</span>
            <span class="s2">var </span><span class="s1">hfields = mailtoComponents.query.split(</span><span class="s3">&quot;&amp;&quot;</span><span class="s1">);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">x = </span><span class="s4">0</span><span class="s1">, xl = hfields.length; x &lt; xl; ++x) {</span>
                <span class="s2">var </span><span class="s1">hfield = hfields[x].split(</span><span class="s3">&quot;=&quot;</span><span class="s1">);</span>
                <span class="s2">switch </span><span class="s1">(hfield[</span><span class="s4">0</span><span class="s1">]) {</span>
                    <span class="s2">case </span><span class="s3">&quot;to&quot;</span><span class="s1">:</span>
                        <span class="s2">var </span><span class="s1">toAddrs = hfield[</span><span class="s4">1</span><span class="s1">].split(</span><span class="s3">&quot;,&quot;</span><span class="s1">);</span>
                        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_x = </span><span class="s4">0</span><span class="s1">, _xl = toAddrs.length; _x &lt; _xl; ++_x) {</span>
                            <span class="s1">to.push(toAddrs[_x]);</span>
                        <span class="s1">}</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">&quot;subject&quot;</span><span class="s1">:</span>
                        <span class="s1">mailtoComponents.subject = unescapeComponent(hfield[</span><span class="s4">1</span><span class="s1">], options);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s3">&quot;body&quot;</span><span class="s1">:</span>
                        <span class="s1">mailtoComponents.body = unescapeComponent(hfield[</span><span class="s4">1</span><span class="s1">], options);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                    <span class="s2">default</span><span class="s1">:</span>
                        <span class="s1">unknownHeaders = </span><span class="s2">true</span><span class="s1">;</span>
                        <span class="s1">headers[unescapeComponent(hfield[</span><span class="s4">0</span><span class="s1">], options)] = unescapeComponent(hfield[</span><span class="s4">1</span><span class="s1">], options);</span>
                        <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(unknownHeaders) mailtoComponents.headers = headers;</span>
        <span class="s1">}</span>
        <span class="s1">mailtoComponents.query = undefined;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">_x2 = </span><span class="s4">0</span><span class="s1">, _xl2 = to.length; _x2 &lt; _xl2; ++_x2) {</span>
            <span class="s2">var </span><span class="s1">addr = to[_x2].split(</span><span class="s3">&quot;@&quot;</span><span class="s1">);</span>
            <span class="s1">addr[</span><span class="s4">0</span><span class="s1">] = unescapeComponent(addr[</span><span class="s4">0</span><span class="s1">]);</span>
            <span class="s2">if </span><span class="s1">(!options.unicodeSupport) {</span>
                <span class="s0">//convert Unicode IDN -&gt; ASCII IDN</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">addr[</span><span class="s4">1</span><span class="s1">] = punycode.toASCII(unescapeComponent(addr[</span><span class="s4">1</span><span class="s1">], options).toLowerCase());</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                    <span class="s1">mailtoComponents.error = mailtoComponents.error || </span><span class="s3">&quot;Email address's domain name can not be converted to ASCII via punycode: &quot; </span><span class="s1">+ e;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">addr[</span><span class="s4">1</span><span class="s1">] = unescapeComponent(addr[</span><span class="s4">1</span><span class="s1">], options).toLowerCase();</span>
            <span class="s1">}</span>
            <span class="s1">to[_x2] = addr.join(</span><span class="s3">&quot;@&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">mailtoComponents;</span>
    <span class="s1">},</span>
    <span class="s1">serialize: </span><span class="s2">function </span><span class="s1">serialize$$1(mailtoComponents, options) {</span>
        <span class="s2">var </span><span class="s1">components = mailtoComponents;</span>
        <span class="s2">var </span><span class="s1">to = toArray(mailtoComponents.to);</span>
        <span class="s2">if </span><span class="s1">(to) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">x = </span><span class="s4">0</span><span class="s1">, xl = to.length; x &lt; xl; ++x) {</span>
                <span class="s2">var </span><span class="s1">toAddr = String(to[x]);</span>
                <span class="s2">var </span><span class="s1">atIdx = toAddr.lastIndexOf(</span><span class="s3">&quot;@&quot;</span><span class="s1">);</span>
                <span class="s2">var </span><span class="s1">localPart = toAddr.slice(</span><span class="s4">0</span><span class="s1">, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);</span>
                <span class="s2">var </span><span class="s1">domain = toAddr.slice(atIdx + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s0">//convert IDN via punycode</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
                    <span class="s1">components.error = components.error || </span><span class="s3">&quot;Email address's domain name can not be converted to &quot; </span><span class="s1">+ (!options.iri ? </span><span class="s3">&quot;ASCII&quot; </span><span class="s1">: </span><span class="s3">&quot;Unicode&quot;</span><span class="s1">) + </span><span class="s3">&quot; via punycode: &quot; </span><span class="s1">+ e;</span>
                <span class="s1">}</span>
                <span class="s1">to[x] = localPart + </span><span class="s3">&quot;@&quot; </span><span class="s1">+ domain;</span>
            <span class="s1">}</span>
            <span class="s1">components.path = to.join(</span><span class="s3">&quot;,&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">headers = mailtoComponents.headers = mailtoComponents.headers || {};</span>
        <span class="s2">if </span><span class="s1">(mailtoComponents.subject) headers[</span><span class="s3">&quot;subject&quot;</span><span class="s1">] = mailtoComponents.subject;</span>
        <span class="s2">if </span><span class="s1">(mailtoComponents.body) headers[</span><span class="s3">&quot;body&quot;</span><span class="s1">] = mailtoComponents.body;</span>
        <span class="s2">var </span><span class="s1">fields = [];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">headers) {</span>
            <span class="s2">if </span><span class="s1">(headers[name] !== O[name]) {</span>
                <span class="s1">fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + </span><span class="s3">&quot;=&quot; </span><span class="s1">+ headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(fields.length) {</span>
            <span class="s1">components.query = fields.join(</span><span class="s3">&quot;&amp;&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">components;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">var </span><span class="s1">URN_PARSE = /^([^\:]+)\:(.*)/;</span>
<span class="s0">//RFC 2141</span>
<span class="s2">var </span><span class="s1">handler$5 = {</span>
    <span class="s1">scheme: </span><span class="s3">&quot;urn&quot;</span><span class="s1">,</span>
    <span class="s1">parse: </span><span class="s2">function </span><span class="s1">parse$$1(components, options) {</span>
        <span class="s2">var </span><span class="s1">matches = components.path &amp;&amp; components.path.match(URN_PARSE);</span>
        <span class="s2">var </span><span class="s1">urnComponents = components;</span>
        <span class="s2">if </span><span class="s1">(matches) {</span>
            <span class="s2">var </span><span class="s1">scheme = options.scheme || urnComponents.scheme || </span><span class="s3">&quot;urn&quot;</span><span class="s1">;</span>
            <span class="s2">var </span><span class="s1">nid = matches[</span><span class="s4">1</span><span class="s1">].toLowerCase();</span>
            <span class="s2">var </span><span class="s1">nss = matches[</span><span class="s4">2</span><span class="s1">];</span>
            <span class="s2">var </span><span class="s1">urnScheme = scheme + </span><span class="s3">&quot;:&quot; </span><span class="s1">+ (options.nid || nid);</span>
            <span class="s2">var </span><span class="s1">schemeHandler = SCHEMES[urnScheme];</span>
            <span class="s1">urnComponents.nid = nid;</span>
            <span class="s1">urnComponents.nss = nss;</span>
            <span class="s1">urnComponents.path = undefined;</span>
            <span class="s2">if </span><span class="s1">(schemeHandler) {</span>
                <span class="s1">urnComponents = schemeHandler.parse(urnComponents, options);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">urnComponents.error = urnComponents.error || </span><span class="s3">&quot;URN can not be parsed.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">urnComponents;</span>
    <span class="s1">},</span>
    <span class="s1">serialize: </span><span class="s2">function </span><span class="s1">serialize$$1(urnComponents, options) {</span>
        <span class="s2">var </span><span class="s1">scheme = options.scheme || urnComponents.scheme || </span><span class="s3">&quot;urn&quot;</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">nid = urnComponents.nid;</span>
        <span class="s2">var </span><span class="s1">urnScheme = scheme + </span><span class="s3">&quot;:&quot; </span><span class="s1">+ (options.nid || nid);</span>
        <span class="s2">var </span><span class="s1">schemeHandler = SCHEMES[urnScheme];</span>
        <span class="s2">if </span><span class="s1">(schemeHandler) {</span>
            <span class="s1">urnComponents = schemeHandler.serialize(urnComponents, options);</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">uriComponents = urnComponents;</span>
        <span class="s2">var </span><span class="s1">nss = urnComponents.nss;</span>
        <span class="s1">uriComponents.path = (nid || options.nid) + </span><span class="s3">&quot;:&quot; </span><span class="s1">+ nss;</span>
        <span class="s2">return </span><span class="s1">uriComponents;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">var </span><span class="s1">UUID = /^[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">A-Fa-f]{</span><span class="s4">8</span><span class="s1">}(?:\-[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">A-Fa-f]{</span><span class="s4">4</span><span class="s1">}){</span><span class="s4">3</span><span class="s1">}\-[</span><span class="s4">0</span><span class="s1">-</span><span class="s4">9</span><span class="s1">A-Fa-f]{</span><span class="s4">12</span><span class="s1">}$/;</span>
<span class="s0">//RFC 4122</span>
<span class="s2">var </span><span class="s1">handler$6 = {</span>
    <span class="s1">scheme: </span><span class="s3">&quot;urn:uuid&quot;</span><span class="s1">,</span>
    <span class="s1">parse: </span><span class="s2">function </span><span class="s1">parse(urnComponents, options) {</span>
        <span class="s2">var </span><span class="s1">uuidComponents = urnComponents;</span>
        <span class="s1">uuidComponents.uuid = uuidComponents.nss;</span>
        <span class="s1">uuidComponents.nss = undefined;</span>
        <span class="s2">if </span><span class="s1">(!options.tolerant &amp;&amp; (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {</span>
            <span class="s1">uuidComponents.error = uuidComponents.error || </span><span class="s3">&quot;UUID is not valid.&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">uuidComponents;</span>
    <span class="s1">},</span>
    <span class="s1">serialize: </span><span class="s2">function </span><span class="s1">serialize(uuidComponents, options) {</span>
        <span class="s2">var </span><span class="s1">urnComponents = uuidComponents;</span>
        <span class="s0">//normalize UUID</span>
        <span class="s1">urnComponents.nss = (uuidComponents.uuid || </span><span class="s3">&quot;&quot;</span><span class="s1">).toLowerCase();</span>
        <span class="s2">return </span><span class="s1">urnComponents;</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s1">SCHEMES[handler.scheme] = handler;</span>
<span class="s1">SCHEMES[handler$1.scheme] = handler$1;</span>
<span class="s1">SCHEMES[handler$2.scheme] = handler$2;</span>
<span class="s1">SCHEMES[handler$3.scheme] = handler$3;</span>
<span class="s1">SCHEMES[handler$4.scheme] = handler$4;</span>
<span class="s1">SCHEMES[handler$5.scheme] = handler$5;</span>
<span class="s1">SCHEMES[handler$6.scheme] = handler$6;</span>

<span class="s1">exports.SCHEMES = SCHEMES;</span>
<span class="s1">exports.pctEncChar = pctEncChar;</span>
<span class="s1">exports.pctDecChars = pctDecChars;</span>
<span class="s1">exports.parse = parse;</span>
<span class="s1">exports.removeDotSegments = removeDotSegments;</span>
<span class="s1">exports.serialize = serialize;</span>
<span class="s1">exports.resolveComponents = resolveComponents;</span>
<span class="s1">exports.resolve = resolve;</span>
<span class="s1">exports.normalize = normalize;</span>
<span class="s1">exports.equal = equal;</span>
<span class="s1">exports.escapeComponent = escapeComponent;</span>
<span class="s1">exports.unescapeComponent = unescapeComponent;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s3">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>

<span class="s1">})));</span>
<span class="s0">//# sourceMappingURL=uri.all.js.map</span>
</pre>
</body>
</html>
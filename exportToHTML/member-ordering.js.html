<html>
<head>
<title>member-ordering.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
member-ordering.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">__importDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importDefault) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">return </span><span class="s1">(mod &amp;&amp; mod.__esModule) ? mod : { </span><span class="s0">&quot;default&quot;</span><span class="s1">: mod };</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.defaultOrder = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">const utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s1">const natural_compare_lite_1 = __importDefault(require(</span><span class="s0">&quot;natural-compare-lite&quot;</span><span class="s1">));</span>
<span class="s1">const util = __importStar(require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">));</span>
<span class="s1">const neverConfig = {</span>
    <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
    <span class="s1">enum: [</span><span class="s0">'never'</span><span class="s1">],</span>
<span class="s1">};</span>
<span class="s1">const arrayConfig = (memberTypes) =&gt; ({</span>
    <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
    <span class="s1">items: {</span>
        <span class="s1">oneOf: [</span>
            <span class="s1">{</span>
                <span class="s1">enum: memberTypes,</span>
            <span class="s1">},</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'array'</span><span class="s1">,</span>
                <span class="s1">items: {</span>
                    <span class="s1">enum: memberTypes,</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s1">const objectConfig = (memberTypes) =&gt; ({</span>
    <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
    <span class="s1">properties: {</span>
        <span class="s1">memberTypes: {</span>
            <span class="s1">oneOf: [arrayConfig(memberTypes), neverConfig],</span>
        <span class="s1">},</span>
        <span class="s1">order: {</span>
            <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
            <span class="s1">enum: [</span>
                <span class="s0">'alphabetically'</span><span class="s1">,</span>
                <span class="s0">'alphabetically-case-insensitive'</span><span class="s1">,</span>
                <span class="s0">'as-written'</span><span class="s1">,</span>
                <span class="s0">'natural'</span><span class="s1">,</span>
                <span class="s0">'natural-case-insensitive'</span><span class="s1">,</span>
            <span class="s1">],</span>
        <span class="s1">},</span>
        <span class="s1">optionalityOrder: {</span>
            <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
            <span class="s1">enum: [</span><span class="s0">'optional-first'</span><span class="s1">, </span><span class="s0">'required-first'</span><span class="s1">],</span>
        <span class="s1">},</span>
    <span class="s1">},</span>
    <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
<span class="s1">});</span>
<span class="s1">exports.defaultOrder = [</span>
    <span class="s4">// Index signature</span>
    <span class="s0">'signature'</span><span class="s1">,</span>
    <span class="s0">'call-signature'</span><span class="s1">,</span>
    <span class="s4">// Fields</span>
    <span class="s0">'public-static-field'</span><span class="s1">,</span>
    <span class="s0">'protected-static-field'</span><span class="s1">,</span>
    <span class="s0">'private-static-field'</span><span class="s1">,</span>
    <span class="s0">'#private-static-field'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-field'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-field'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-field'</span><span class="s1">,</span>
    <span class="s0">'public-instance-field'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-field'</span><span class="s1">,</span>
    <span class="s0">'private-instance-field'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-field'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-field'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-field'</span><span class="s1">,</span>
    <span class="s0">'public-field'</span><span class="s1">,</span>
    <span class="s0">'protected-field'</span><span class="s1">,</span>
    <span class="s0">'private-field'</span><span class="s1">,</span>
    <span class="s0">'#private-field'</span><span class="s1">,</span>
    <span class="s0">'static-field'</span><span class="s1">,</span>
    <span class="s0">'instance-field'</span><span class="s1">,</span>
    <span class="s0">'abstract-field'</span><span class="s1">,</span>
    <span class="s0">'decorated-field'</span><span class="s1">,</span>
    <span class="s0">'field'</span><span class="s1">,</span>
    <span class="s4">// Static initialization</span>
    <span class="s0">'static-initialization'</span><span class="s1">,</span>
    <span class="s4">// Constructors</span>
    <span class="s0">'public-constructor'</span><span class="s1">,</span>
    <span class="s0">'protected-constructor'</span><span class="s1">,</span>
    <span class="s0">'private-constructor'</span><span class="s1">,</span>
    <span class="s0">'constructor'</span><span class="s1">,</span>
    <span class="s4">// Getters</span>
    <span class="s0">'public-static-get'</span><span class="s1">,</span>
    <span class="s0">'protected-static-get'</span><span class="s1">,</span>
    <span class="s0">'private-static-get'</span><span class="s1">,</span>
    <span class="s0">'#private-static-get'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-get'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-get'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-get'</span><span class="s1">,</span>
    <span class="s0">'public-instance-get'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-get'</span><span class="s1">,</span>
    <span class="s0">'private-instance-get'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-get'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-get'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-get'</span><span class="s1">,</span>
    <span class="s0">'public-get'</span><span class="s1">,</span>
    <span class="s0">'protected-get'</span><span class="s1">,</span>
    <span class="s0">'private-get'</span><span class="s1">,</span>
    <span class="s0">'#private-get'</span><span class="s1">,</span>
    <span class="s0">'static-get'</span><span class="s1">,</span>
    <span class="s0">'instance-get'</span><span class="s1">,</span>
    <span class="s0">'abstract-get'</span><span class="s1">,</span>
    <span class="s0">'decorated-get'</span><span class="s1">,</span>
    <span class="s0">'get'</span><span class="s1">,</span>
    <span class="s4">// Setters</span>
    <span class="s0">'public-static-set'</span><span class="s1">,</span>
    <span class="s0">'protected-static-set'</span><span class="s1">,</span>
    <span class="s0">'private-static-set'</span><span class="s1">,</span>
    <span class="s0">'#private-static-set'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-set'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-set'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-set'</span><span class="s1">,</span>
    <span class="s0">'public-instance-set'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-set'</span><span class="s1">,</span>
    <span class="s0">'private-instance-set'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-set'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-set'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-set'</span><span class="s1">,</span>
    <span class="s0">'public-set'</span><span class="s1">,</span>
    <span class="s0">'protected-set'</span><span class="s1">,</span>
    <span class="s0">'private-set'</span><span class="s1">,</span>
    <span class="s0">'#private-set'</span><span class="s1">,</span>
    <span class="s0">'static-set'</span><span class="s1">,</span>
    <span class="s0">'instance-set'</span><span class="s1">,</span>
    <span class="s0">'abstract-set'</span><span class="s1">,</span>
    <span class="s0">'decorated-set'</span><span class="s1">,</span>
    <span class="s0">'set'</span><span class="s1">,</span>
    <span class="s4">// Methods</span>
    <span class="s0">'public-static-method'</span><span class="s1">,</span>
    <span class="s0">'protected-static-method'</span><span class="s1">,</span>
    <span class="s0">'private-static-method'</span><span class="s1">,</span>
    <span class="s0">'#private-static-method'</span><span class="s1">,</span>
    <span class="s0">'public-decorated-method'</span><span class="s1">,</span>
    <span class="s0">'protected-decorated-method'</span><span class="s1">,</span>
    <span class="s0">'private-decorated-method'</span><span class="s1">,</span>
    <span class="s0">'public-instance-method'</span><span class="s1">,</span>
    <span class="s0">'protected-instance-method'</span><span class="s1">,</span>
    <span class="s0">'private-instance-method'</span><span class="s1">,</span>
    <span class="s0">'#private-instance-method'</span><span class="s1">,</span>
    <span class="s0">'public-abstract-method'</span><span class="s1">,</span>
    <span class="s0">'protected-abstract-method'</span><span class="s1">,</span>
    <span class="s0">'public-method'</span><span class="s1">,</span>
    <span class="s0">'protected-method'</span><span class="s1">,</span>
    <span class="s0">'private-method'</span><span class="s1">,</span>
    <span class="s0">'#private-method'</span><span class="s1">,</span>
    <span class="s0">'static-method'</span><span class="s1">,</span>
    <span class="s0">'instance-method'</span><span class="s1">,</span>
    <span class="s0">'abstract-method'</span><span class="s1">,</span>
    <span class="s0">'decorated-method'</span><span class="s1">,</span>
    <span class="s0">'method'</span><span class="s1">,</span>
<span class="s1">];</span>
<span class="s1">const allMemberTypes = Array.from([</span>
    <span class="s0">'readonly-signature'</span><span class="s1">,</span>
    <span class="s0">'signature'</span><span class="s1">,</span>
    <span class="s0">'readonly-field'</span><span class="s1">,</span>
    <span class="s0">'field'</span><span class="s1">,</span>
    <span class="s0">'method'</span><span class="s1">,</span>
    <span class="s0">'call-signature'</span><span class="s1">,</span>
    <span class="s0">'constructor'</span><span class="s1">,</span>
    <span class="s0">'get'</span><span class="s1">,</span>
    <span class="s0">'set'</span><span class="s1">,</span>
    <span class="s0">'static-initialization'</span><span class="s1">,</span>
<span class="s1">].reduce((all, type) =&gt; {</span>
    <span class="s1">all.add(type);</span>
    <span class="s1">[</span><span class="s0">'public'</span><span class="s1">, </span><span class="s0">'protected'</span><span class="s1">, </span><span class="s0">'private'</span><span class="s1">, </span><span class="s0">'#private'</span><span class="s1">].forEach(accessibility =&gt; {</span>
        <span class="s2">if </span><span class="s1">(type !== </span><span class="s0">'readonly-signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'static-initialization' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'call-signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">!(type === </span><span class="s0">'constructor' </span><span class="s1">&amp;&amp; accessibility === </span><span class="s0">'#private'</span><span class="s1">)) {</span>
            <span class="s1">all.add(`${accessibility}-${type}`); </span><span class="s4">// e.g. `public-field`</span>
        <span class="s1">}</span>
        <span class="s4">// Only class instance fields, methods, get and set can have decorators attached to them</span>
        <span class="s2">if </span><span class="s1">(accessibility !== </span><span class="s0">'#private' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">(type === </span><span class="s0">'readonly-field' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'field' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'method' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'get' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'set'</span><span class="s1">)) {</span>
            <span class="s1">all.add(`${accessibility}-decorated-${type}`);</span>
            <span class="s1">all.add(`decorated-${type}`);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type !== </span><span class="s0">'constructor' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'readonly-signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'call-signature'</span><span class="s1">) {</span>
            <span class="s4">// There is no `static-constructor` or `instance-constructor` or `abstract-constructor`</span>
            <span class="s2">if </span><span class="s1">(accessibility === </span><span class="s0">'#private' </span><span class="s1">|| accessibility === </span><span class="s0">'private'</span><span class="s1">) {</span>
                <span class="s1">[</span><span class="s0">'static'</span><span class="s1">, </span><span class="s0">'instance'</span><span class="s1">].forEach(scope =&gt; {</span>
                    <span class="s1">all.add(`${scope}-${type}`);</span>
                    <span class="s1">all.add(`${accessibility}-${scope}-${type}`);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">[</span><span class="s0">'static'</span><span class="s1">, </span><span class="s0">'instance'</span><span class="s1">, </span><span class="s0">'abstract'</span><span class="s1">].forEach(scope =&gt; {</span>
                    <span class="s1">all.add(`${scope}-${type}`);</span>
                    <span class="s1">all.add(`${accessibility}-${scope}-${type}`);</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">all;</span>
<span class="s1">}, </span><span class="s2">new </span><span class="s1">Set()));</span>
<span class="s1">const functionExpressions = [</span>
    <span class="s1">utils_1.AST_NODE_TYPES.FunctionExpression,</span>
    <span class="s1">utils_1.AST_NODE_TYPES.ArrowFunctionExpression,</span>
<span class="s1">];</span>
<span class="s4">/** 
 * Gets the node type. 
 * 
 * @param node the node to be evaluated. 
 */</span>
<span class="s2">function </span><span class="s1">getNodeType(node) {</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
            <span class="s2">return </span><span class="s1">node.kind;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSMethodSignature:</span>
            <span class="s2">return </span><span class="s0">'method'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:</span>
            <span class="s2">return </span><span class="s0">'call-signature'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:</span>
            <span class="s2">return </span><span class="s0">'constructor'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:</span>
            <span class="s2">return </span><span class="s1">node.readonly ? </span><span class="s0">'readonly-field' </span><span class="s1">: </span><span class="s0">'field'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
            <span class="s2">return </span><span class="s1">node.value &amp;&amp; functionExpressions.includes(node.value.type)</span>
                <span class="s1">? </span><span class="s0">'method'</span>
                <span class="s1">: node.readonly</span>
                    <span class="s1">? </span><span class="s0">'readonly-field'</span>
                    <span class="s1">: </span><span class="s0">'field'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
            <span class="s2">return </span><span class="s1">node.readonly ? </span><span class="s0">'readonly-field' </span><span class="s1">: </span><span class="s0">'field'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSIndexSignature:</span>
            <span class="s2">return </span><span class="s1">node.readonly ? </span><span class="s0">'readonly-signature' </span><span class="s1">: </span><span class="s0">'signature'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.StaticBlock:</span>
            <span class="s2">return </span><span class="s0">'static-initialization'</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Gets the raw string value of a member's name 
 */</span>
<span class="s2">function </span><span class="s1">getMemberRawName(member, sourceCode) {</span>
    <span class="s1">const { name, type } = util.getNameFromMember(member, sourceCode);</span>
    <span class="s2">if </span><span class="s1">(type === util.MemberNameType.Quoted) {</span>
        <span class="s2">return </span><span class="s1">name.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type === util.MemberNameType.Private) {</span>
        <span class="s2">return </span><span class="s1">name.slice(</span><span class="s3">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">name;</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Gets the member name based on the member type. 
 * 
 * @param node the node to be evaluated. 
 * @param sourceCode 
 */</span>
<span class="s2">function </span><span class="s1">getMemberName(node, sourceCode) {</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSMethodSignature:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
            <span class="s2">return </span><span class="s1">getMemberRawName(node, sourceCode);</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
            <span class="s2">return </span><span class="s1">node.kind === </span><span class="s0">'constructor'</span>
                <span class="s1">? </span><span class="s0">'constructor'</span>
                <span class="s1">: getMemberRawName(node, sourceCode);</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:</span>
            <span class="s2">return </span><span class="s0">'new'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:</span>
            <span class="s2">return </span><span class="s0">'call'</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSIndexSignature:</span>
            <span class="s2">return </span><span class="s1">util.getNameFromIndexSignature(node);</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.StaticBlock:</span>
            <span class="s2">return </span><span class="s0">'static block'</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Returns true if the member is optional based on the member type. 
 * 
 * @param node the node to be evaluated. 
 * 
 * @returns Whether the member is optional, or false if it cannot be optional at all. 
 */</span>
<span class="s2">function </span><span class="s1">isMemberOptional(node) {</span>
    <span class="s2">switch </span><span class="s1">(node.type) {</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSPropertySignature:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSMethodSignature:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.PropertyDefinition:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:</span>
        <span class="s2">case </span><span class="s1">utils_1.AST_NODE_TYPES.MethodDefinition:</span>
            <span class="s2">return </span><span class="s1">!!node.optional;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Gets the calculated rank using the provided method definition. 
 * The algorithm is as follows: 
 * - Get the rank based on the accessibility-scope-type name, e.g. public-instance-field 
 * - If there is no order for accessibility-scope-type, then strip out the accessibility. 
 * - If there is no order for scope-type, then strip out the scope. 
 * - If there is no order for type, then return -1 
 * @param memberGroups the valid names to be validated. 
 * @param orderConfig the current order to be validated. 
 * 
 * @return Index of the matching member type in the order configuration. 
 */</span>
<span class="s2">function </span><span class="s1">getRankOrder(memberGroups, orderConfig) {</span>
    <span class="s1">let rank = -</span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">const stack = memberGroups.slice(); </span><span class="s4">// Get a copy of the member groups</span>
    <span class="s2">while </span><span class="s1">(stack.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; rank === -</span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s1">const memberGroup = stack.shift();</span>
        <span class="s1">rank = orderConfig.findIndex(memberType =&gt; Array.isArray(memberType)</span>
            <span class="s1">? memberType.includes(memberGroup)</span>
            <span class="s1">: memberType === memberGroup);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">rank;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getAccessibility(node) {</span>
    <span class="s2">var </span><span class="s1">_a;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">'accessibility' </span><span class="s2">in </span><span class="s1">node &amp;&amp; node.accessibility) {</span>
        <span class="s2">return </span><span class="s1">node.accessibility;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s0">'key' </span><span class="s2">in </span><span class="s1">node &amp;&amp; ((_a = node.key) === </span><span class="s2">null </span><span class="s1">|| _a === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _a.type) === utils_1.AST_NODE_TYPES.PrivateIdentifier) {</span>
        <span class="s2">return </span><span class="s0">'#private'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s0">'public'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Gets the rank of the node given the order. 
 * @param node the node to be evaluated. 
 * @param orderConfig the current order to be validated. 
 * @param supportsModifiers a flag indicating whether the type supports modifiers (scope or accessibility) or not. 
 */</span>
<span class="s2">function </span><span class="s1">getRank(node, orderConfig, supportsModifiers) {</span>
    <span class="s1">const type = getNodeType(node);</span>
    <span class="s2">if </span><span class="s1">(type == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s4">// shouldn't happen but just in case, put it on the end</span>
        <span class="s2">return </span><span class="s1">orderConfig.length - </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const abstract = node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||</span>
        <span class="s1">node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition;</span>
    <span class="s1">const scope = </span><span class="s0">'static' </span><span class="s2">in </span><span class="s1">node &amp;&amp; node.static</span>
        <span class="s1">? </span><span class="s0">'static'</span>
        <span class="s1">: abstract</span>
            <span class="s1">? </span><span class="s0">'abstract'</span>
            <span class="s1">: </span><span class="s0">'instance'</span><span class="s1">;</span>
    <span class="s1">const accessibility = getAccessibility(node);</span>
    <span class="s4">// Collect all existing member groups that apply to this node...</span>
    <span class="s4">// (e.g. 'public-instance-field', 'instance-field', 'public-field', 'constructor' etc.)</span>
    <span class="s1">const memberGroups = [];</span>
    <span class="s2">if </span><span class="s1">(supportsModifiers) {</span>
        <span class="s1">const decorated = </span><span class="s0">'decorators' </span><span class="s2">in </span><span class="s1">node &amp;&amp; node.decorators.length &gt; </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(decorated &amp;&amp;</span>
            <span class="s1">(type === </span><span class="s0">'readonly-field' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'field' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'method' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'get' </span><span class="s1">||</span>
                <span class="s1">type === </span><span class="s0">'set'</span><span class="s1">)) {</span>
            <span class="s1">memberGroups.push(`${accessibility}-decorated-${type}`);</span>
            <span class="s1">memberGroups.push(`decorated-${type}`);</span>
            <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
                <span class="s1">memberGroups.push(`${accessibility}-decorated-field`);</span>
                <span class="s1">memberGroups.push(`decorated-field`);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(type !== </span><span class="s0">'readonly-signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'signature' </span><span class="s1">&amp;&amp;</span>
            <span class="s1">type !== </span><span class="s0">'static-initialization'</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(type !== </span><span class="s0">'constructor'</span><span class="s1">) {</span>
                <span class="s4">// Constructors have no scope</span>
                <span class="s1">memberGroups.push(`${accessibility}-${scope}-${type}`);</span>
                <span class="s1">memberGroups.push(`${scope}-${type}`);</span>
                <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
                    <span class="s1">memberGroups.push(`${accessibility}-${scope}-field`);</span>
                    <span class="s1">memberGroups.push(`${scope}-field`);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">memberGroups.push(`${accessibility}-${type}`);</span>
            <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
                <span class="s1">memberGroups.push(`${accessibility}-field`);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">memberGroups.push(type);</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'readonly-signature'</span><span class="s1">) {</span>
        <span class="s1">memberGroups.push(</span><span class="s0">'signature'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(type === </span><span class="s0">'readonly-field'</span><span class="s1">) {</span>
        <span class="s1">memberGroups.push(</span><span class="s0">'field'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">// ...then get the rank order for those member groups based on the node</span>
    <span class="s2">return </span><span class="s1">getRankOrder(memberGroups, orderConfig);</span>
<span class="s1">}</span>
<span class="s4">/** 
 * Gets the lowest possible rank(s) higher than target. 
 * e.g. given the following order: 
 *   ... 
 *   public-static-method 
 *   protected-static-method 
 *   private-static-method 
 *   public-instance-method 
 *   protected-instance-method 
 *   private-instance-method 
 *   ... 
 * and considering that a public-instance-method has already been declared, so ranks contains 
 * public-instance-method, then the lowest possible rank for public-static-method is 
 * public-instance-method. 
 * If a lowest possible rank is a member group, a comma separated list of ranks is returned. 
 * @param ranks the existing ranks in the object. 
 * @param target the target rank. 
 * @param order the current order to be validated. 
 * @returns the name(s) of the lowest possible rank without dashes (-). 
 */</span>
<span class="s2">function </span><span class="s1">getLowestRank(ranks, target, order) {</span>
    <span class="s1">let lowest = ranks[ranks.length - </span><span class="s3">1</span><span class="s1">];</span>
    <span class="s1">ranks.forEach(rank =&gt; {</span>
        <span class="s2">if </span><span class="s1">(rank &gt; target) {</span>
            <span class="s1">lowest = Math.min(lowest, rank);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">const lowestRank = order[lowest];</span>
    <span class="s1">const lowestRanks = Array.isArray(lowestRank) ? lowestRank : [lowestRank];</span>
    <span class="s2">return </span><span class="s1">lowestRanks.map(rank =&gt; rank.replace(/-/g, </span><span class="s0">' '</span><span class="s1">)).join(</span><span class="s0">', '</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s1">exports.</span><span class="s2">default </span><span class="s1">= util.createRule({</span>
    <span class="s1">name: </span><span class="s0">'member-ordering'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Require a consistent member declaration order'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">messages: {</span>
            <span class="s1">incorrectOrder: </span><span class="s0">'Member {{member}} should be declared before member {{beforeMember}}.'</span><span class="s1">,</span>
            <span class="s1">incorrectGroupOrder: </span><span class="s0">'Member {{name}} should be declared before all {{rank}} definitions.'</span><span class="s1">,</span>
            <span class="s1">incorrectRequiredMembersOrder: `Member {{member}} should be declared after all {{optionalOrRequired}} members.`,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s2">default</span><span class="s1">: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">neverConfig,</span>
                            <span class="s1">arrayConfig(allMemberTypes),</span>
                            <span class="s1">objectConfig(allMemberTypes),</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">classes: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">neverConfig,</span>
                            <span class="s1">arrayConfig(allMemberTypes),</span>
                            <span class="s1">objectConfig(allMemberTypes),</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">classExpressions: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">neverConfig,</span>
                            <span class="s1">arrayConfig(allMemberTypes),</span>
                            <span class="s1">objectConfig(allMemberTypes),</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">interfaces: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">neverConfig,</span>
                            <span class="s1">arrayConfig([</span>
                                <span class="s0">'readonly-signature'</span><span class="s1">,</span>
                                <span class="s0">'signature'</span><span class="s1">,</span>
                                <span class="s0">'readonly-field'</span><span class="s1">,</span>
                                <span class="s0">'field'</span><span class="s1">,</span>
                                <span class="s0">'method'</span><span class="s1">,</span>
                                <span class="s0">'constructor'</span><span class="s1">,</span>
                            <span class="s1">]),</span>
                            <span class="s1">objectConfig([</span>
                                <span class="s0">'readonly-signature'</span><span class="s1">,</span>
                                <span class="s0">'signature'</span><span class="s1">,</span>
                                <span class="s0">'readonly-field'</span><span class="s1">,</span>
                                <span class="s0">'field'</span><span class="s1">,</span>
                                <span class="s0">'method'</span><span class="s1">,</span>
                                <span class="s0">'constructor'</span><span class="s1">,</span>
                            <span class="s1">]),</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                    <span class="s1">typeLiterals: {</span>
                        <span class="s1">oneOf: [</span>
                            <span class="s1">neverConfig,</span>
                            <span class="s1">arrayConfig([</span>
                                <span class="s0">'readonly-signature'</span><span class="s1">,</span>
                                <span class="s0">'signature'</span><span class="s1">,</span>
                                <span class="s0">'readonly-field'</span><span class="s1">,</span>
                                <span class="s0">'field'</span><span class="s1">,</span>
                                <span class="s0">'method'</span><span class="s1">,</span>
                                <span class="s0">'constructor'</span><span class="s1">,</span>
                            <span class="s1">]),</span>
                            <span class="s1">objectConfig([</span>
                                <span class="s0">'readonly-signature'</span><span class="s1">,</span>
                                <span class="s0">'signature'</span><span class="s1">,</span>
                                <span class="s0">'readonly-field'</span><span class="s1">,</span>
                                <span class="s0">'field'</span><span class="s1">,</span>
                                <span class="s0">'method'</span><span class="s1">,</span>
                                <span class="s0">'constructor'</span><span class="s1">,</span>
                            <span class="s1">]),</span>
                        <span class="s1">],</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [</span>
        <span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: exports.defaultOrder,</span>
        <span class="s1">},</span>
    <span class="s1">],</span>
    <span class="s1">create(context, [options]) {</span>
        <span class="s4">/** 
         * Checks if the member groups are correctly sorted. 
         * 
         * @param members Members to be validated. 
         * @param groupOrder Group order to be validated. 
         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not. 
         * 
         * @return Array of member groups or null if one of the groups is not correctly sorted. 
         */</span>
        <span class="s2">function </span><span class="s1">checkGroupSort(members, groupOrder, supportsModifiers) {</span>
            <span class="s1">const previousRanks = [];</span>
            <span class="s1">const memberGroups = [];</span>
            <span class="s1">let isCorrectlySorted = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s4">// Find first member which isn't correctly sorted</span>
            <span class="s1">members.forEach(member =&gt; {</span>
                <span class="s1">const rank = getRank(member, groupOrder, supportsModifiers);</span>
                <span class="s1">const name = getMemberName(member, context.getSourceCode());</span>
                <span class="s1">const rankLastMember = previousRanks[previousRanks.length - </span><span class="s3">1</span><span class="s1">];</span>
                <span class="s2">if </span><span class="s1">(rank === -</span><span class="s3">1</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s4">// Works for 1st item because x &lt; undefined === false for any x (typeof string)</span>
                <span class="s2">if </span><span class="s1">(rank &lt; rankLastMember) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node: member,</span>
                        <span class="s1">messageId: </span><span class="s0">'incorrectGroupOrder'</span><span class="s1">,</span>
                        <span class="s1">data: {</span>
                            <span class="s1">name,</span>
                            <span class="s1">rank: getLowestRank(previousRanks, rank, groupOrder),</span>
                        <span class="s1">},</span>
                    <span class="s1">});</span>
                    <span class="s1">isCorrectlySorted = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(rank === rankLastMember) {</span>
                    <span class="s4">// Same member group --&gt; Push to existing member group array</span>
                    <span class="s1">memberGroups[memberGroups.length - </span><span class="s3">1</span><span class="s1">].push(member);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// New member group --&gt; Create new member group array</span>
                    <span class="s1">previousRanks.push(rank);</span>
                    <span class="s1">memberGroups.push([member]);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">return </span><span class="s1">isCorrectlySorted ? memberGroups : </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Checks if the members are alphabetically sorted. 
         * 
         * @param members Members to be validated. 
         * @param caseSensitive indicates if the alpha ordering is case sensitive or not. 
         * 
         * @return True if all members are correctly sorted. 
         */</span>
        <span class="s2">function </span><span class="s1">checkAlphaSort(members, order) {</span>
            <span class="s1">let previousName = </span><span class="s0">''</span><span class="s1">;</span>
            <span class="s1">let isCorrectlySorted = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s4">// Find first member which isn't correctly sorted</span>
            <span class="s1">members.forEach(member =&gt; {</span>
                <span class="s1">const name = getMemberName(member, context.getSourceCode());</span>
                <span class="s4">// Note: Not all members have names</span>
                <span class="s2">if </span><span class="s1">(name) {</span>
                    <span class="s2">if </span><span class="s1">(naturalOutOfOrder(name, previousName, order)) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: member,</span>
                            <span class="s1">messageId: </span><span class="s0">'incorrectOrder'</span><span class="s1">,</span>
                            <span class="s1">data: {</span>
                                <span class="s1">member: name,</span>
                                <span class="s1">beforeMember: previousName,</span>
                            <span class="s1">},</span>
                        <span class="s1">});</span>
                        <span class="s1">isCorrectlySorted = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">previousName = name;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">return </span><span class="s1">isCorrectlySorted;</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">naturalOutOfOrder(name, previousName, order) {</span>
            <span class="s2">switch </span><span class="s1">(order) {</span>
                <span class="s2">case </span><span class="s0">'alphabetically'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">name &lt; previousName;</span>
                <span class="s2">case </span><span class="s0">'alphabetically-case-insensitive'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">name.toLowerCase() &lt; previousName.toLowerCase();</span>
                <span class="s2">case </span><span class="s0">'natural'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, natural_compare_lite_1.</span><span class="s2">default</span><span class="s1">)(name, previousName) !== </span><span class="s3">1</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'natural-case-insensitive'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, natural_compare_lite_1.</span><span class="s2">default</span><span class="s1">)(name.toLowerCase(), previousName.toLowerCase()) !== </span><span class="s3">1</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Checks if the order of optional and required members is correct based 
         * on the given 'required' parameter. 
         * 
         * @param members Members to be validated. 
         * @param optionalityOrder Where to place optional members, if not intermixed. 
         * 
         * @return True if all required and optional members are correctly sorted. 
         */</span>
        <span class="s2">function </span><span class="s1">checkRequiredOrder(members, optionalityOrder) {</span>
            <span class="s1">const switchIndex = members.findIndex((member, i) =&gt; i &amp;&amp; isMemberOptional(member) !== isMemberOptional(members[i - </span><span class="s3">1</span><span class="s1">]));</span>
            <span class="s1">const report = (member) =&gt; context.report({</span>
                <span class="s1">messageId: </span><span class="s0">'incorrectRequiredMembersOrder'</span><span class="s1">,</span>
                <span class="s1">loc: member.loc,</span>
                <span class="s1">data: {</span>
                    <span class="s1">member: getMemberName(member, context.getSourceCode()),</span>
                    <span class="s1">optionalOrRequired: optionalityOrder === </span><span class="s0">'required-first' </span><span class="s1">? </span><span class="s0">'required' </span><span class="s1">: </span><span class="s0">'optional'</span><span class="s1">,</span>
                <span class="s1">},</span>
            <span class="s1">});</span>
            <span class="s4">// if the optionality of the first item is correct (based on optionalityOrder)</span>
            <span class="s4">// then the first 0 inclusive to switchIndex exclusive members all</span>
            <span class="s4">// have the correct optionality</span>
            <span class="s2">if </span><span class="s1">(isMemberOptional(members[</span><span class="s3">0</span><span class="s1">]) !==</span>
                <span class="s1">(optionalityOrder === </span><span class="s0">'optional-first'</span><span class="s1">)) {</span>
                <span class="s1">report(members[</span><span class="s3">0</span><span class="s1">]);</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(let i = switchIndex + </span><span class="s3">1</span><span class="s1">; i &lt; members.length; i++) {</span>
                <span class="s2">if </span><span class="s1">(isMemberOptional(members[i]) !==</span>
                    <span class="s1">isMemberOptional(members[switchIndex])) {</span>
                    <span class="s1">report(members[switchIndex]);</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">/** 
         * Validates if all members are correctly sorted. 
         * 
         * @param members Members to be validated. 
         * @param orderConfig Order config to be validated. 
         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not. 
         */</span>
        <span class="s2">function </span><span class="s1">validateMembersOrder(members, orderConfig, supportsModifiers) {</span>
            <span class="s2">if </span><span class="s1">(orderConfig === </span><span class="s0">'never'</span><span class="s1">) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">// Standardize config</span>
            <span class="s1">let order;</span>
            <span class="s1">let memberTypes;</span>
            <span class="s1">let optionalityOrder;</span>
            <span class="s4">// returns true if everything is good and false if an error was reported</span>
            <span class="s1">const checkOrder = (memberSet) =&gt; {</span>
                <span class="s1">const hasAlphaSort = !!(order &amp;&amp; order !== </span><span class="s0">'as-written'</span><span class="s1">);</span>
                <span class="s4">// Check order</span>
                <span class="s2">if </span><span class="s1">(Array.isArray(memberTypes)) {</span>
                    <span class="s1">const grouped = checkGroupSort(memberSet, memberTypes, supportsModifiers);</span>
                    <span class="s2">if </span><span class="s1">(grouped == </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s2">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(hasAlphaSort) {</span>
                        <span class="s2">return </span><span class="s1">!grouped.some(groupMember =&gt; !checkAlphaSort(groupMember, order));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(hasAlphaSort) {</span>
                    <span class="s2">return </span><span class="s1">checkAlphaSort(memberSet, order);</span>
                <span class="s1">}</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">};</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(orderConfig)) {</span>
                <span class="s1">memberTypes = orderConfig;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">order = orderConfig.order;</span>
                <span class="s1">memberTypes = orderConfig.memberTypes;</span>
                <span class="s1">optionalityOrder = orderConfig.optionalityOrder;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!optionalityOrder) {</span>
                <span class="s1">checkOrder(members);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">const switchIndex = members.findIndex((member, i) =&gt; i &amp;&amp; isMemberOptional(member) !== isMemberOptional(members[i - </span><span class="s3">1</span><span class="s1">]));</span>
            <span class="s2">if </span><span class="s1">(switchIndex !== -</span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(!checkRequiredOrder(members, optionalityOrder)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">checkOrder(members.slice(</span><span class="s3">0</span><span class="s1">, switchIndex));</span>
                <span class="s1">checkOrder(members.slice(switchIndex));</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">checkOrder(members);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">ClassDeclaration(node) {</span>
                <span class="s2">var </span><span class="s1">_a;</span>
                <span class="s1">validateMembersOrder(node.body.body, (_a = options.classes) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : options.</span><span class="s2">default</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">},</span>
            <span class="s1">ClassExpression(node) {</span>
                <span class="s2">var </span><span class="s1">_a;</span>
                <span class="s1">validateMembersOrder(node.body.body, (_a = options.classExpressions) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : options.</span><span class="s2">default</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">},</span>
            <span class="s1">TSInterfaceDeclaration(node) {</span>
                <span class="s2">var </span><span class="s1">_a;</span>
                <span class="s1">validateMembersOrder(node.body.body, (_a = options.interfaces) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : options.</span><span class="s2">default</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">},</span>
            <span class="s1">TSTypeLiteral(node) {</span>
                <span class="s2">var </span><span class="s1">_a;</span>
                <span class="s1">validateMembersOrder(node.members, (_a = options.typeLiterals) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : options.</span><span class="s2">default</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
<span class="s1">});</span>
<span class="s4">//# sourceMappingURL=member-ordering.js.map</span></pre>
</body>
</html>
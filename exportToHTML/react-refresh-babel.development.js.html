<html>
<head>
<title>react-refresh-babel.development.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-refresh-babel.development.js</font>
</center></td></tr></table>
<pre><span class="s0">/** @license React vundefined 
 * react-refresh-babel.development.js 
 * 
 * Copyright (c) Facebook, Inc. and its affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">'use strict'</span><span class="s1">;</span>



<span class="s3">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">&quot;production&quot;</span><span class="s1">) {</span>
  <span class="s1">(</span><span class="s3">function</span><span class="s1">() {</span>
<span class="s2">'use strict'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s1">ReactFreshBabelPlugin = </span><span class="s3">function </span><span class="s1">(babel) {</span>
  <span class="s3">var </span><span class="s1">opts = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : {};</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">babel.getEnv === </span><span class="s2">'function'</span><span class="s1">) {</span>
    <span class="s0">// Only available in Babel 7.</span>
    <span class="s3">var </span><span class="s1">env = babel.getEnv();</span>

    <span class="s3">if </span><span class="s1">(env !== </span><span class="s2">'development' </span><span class="s1">&amp;&amp; !opts.skipEnvCheck) {</span>
      <span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'React Refresh Babel transform should only be enabled in development environment. ' </span><span class="s1">+ </span><span class="s2">'Instead, the environment is: &quot;' </span><span class="s1">+ env + </span><span class="s2">'&quot;. If you want to override this check, pass {skipEnvCheck: true} as plugin options.'</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">t = babel.types;</span>
  <span class="s3">var </span><span class="s1">registrationsByProgramPath = </span><span class="s3">new </span><span class="s1">Map();</span>

  <span class="s3">function </span><span class="s1">createRegistration(programPath, persistentID) {</span>
    <span class="s3">var </span><span class="s1">handle = programPath.scope.generateUidIdentifier(</span><span class="s2">'c'</span><span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(!registrationsByProgramPath.has(programPath)) {</span>
      <span class="s1">registrationsByProgramPath.set(programPath, []);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">registrations = registrationsByProgramPath.get(programPath);</span>
    <span class="s1">registrations.push({</span>
      <span class="s1">handle: handle,</span>
      <span class="s1">persistentID: persistentID</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">handle;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isComponentishName(name) {</span>
    <span class="s3">return typeof </span><span class="s1">name === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; name[</span><span class="s4">0</span><span class="s1">] &gt;= </span><span class="s2">'A' </span><span class="s1">&amp;&amp; name[</span><span class="s4">0</span><span class="s1">] &lt;= </span><span class="s2">'Z'</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">findInnerComponents(inferredName, path, callback) {</span>
    <span class="s3">var </span><span class="s1">node = path.node;</span>

    <span class="s3">switch </span><span class="s1">(node.type) {</span>
      <span class="s3">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(!isComponentishName(node.name)) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// export default hoc(Foo)</span>
          <span class="s0">// const X = hoc(Foo)</span>


          <span class="s1">callback(inferredName, node, </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">'FunctionDeclaration'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s0">// function Foo() {}</span>
          <span class="s0">// export function Foo() {}</span>
          <span class="s0">// export default function Foo() {}</span>
          <span class="s1">callback(inferredName, node.id, </span><span class="s3">null</span><span class="s1">);</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">'ArrowFunctionExpression'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s3">if </span><span class="s1">(node.body.type === </span><span class="s2">'ArrowFunctionExpression'</span><span class="s1">) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// let Foo = () =&gt; {}</span>
          <span class="s0">// export default hoc1(hoc2(() =&gt; {}))</span>


          <span class="s1">callback(inferredName, node, path);</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">'FunctionExpression'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s0">// let Foo = function() {}</span>
          <span class="s0">// const Foo = hoc1(forwardRef(function renderFoo() {}))</span>
          <span class="s0">// export default memo(function() {})</span>
          <span class="s1">callback(inferredName, node, path);</span>
          <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">'CallExpression'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">argsPath = path.get(</span><span class="s2">'arguments'</span><span class="s1">);</span>

          <span class="s3">if </span><span class="s1">(argsPath === undefined || argsPath.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">calleePath = path.get(</span><span class="s2">'callee'</span><span class="s1">);</span>

          <span class="s3">switch </span><span class="s1">(calleePath.node.type) {</span>
            <span class="s3">case </span><span class="s2">'MemberExpression'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s3">var </span><span class="s1">calleeSource = calleePath.getSource();</span>
                <span class="s3">var </span><span class="s1">firstArgPath = argsPath[</span><span class="s4">0</span><span class="s1">];</span>
                <span class="s3">var </span><span class="s1">innerName = inferredName + </span><span class="s2">'$' </span><span class="s1">+ calleeSource;</span>
                <span class="s3">var </span><span class="s1">foundInside = findInnerComponents(innerName, firstArgPath, callback);</span>

                <span class="s3">if </span><span class="s1">(!foundInside) {</span>
                  <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s0">// const Foo = hoc1(hoc2(() =&gt; {}))</span>
                <span class="s0">// export default memo(React.forwardRef(function() {}))</span>


                <span class="s1">callback(inferredName, node, path);</span>
                <span class="s3">return true</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s3">default</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s3">return false</span><span class="s1">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

      <span class="s3">case </span><span class="s2">'VariableDeclarator'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s3">var </span><span class="s1">init = node.init;</span>

          <span class="s3">if </span><span class="s1">(init === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">name = node.id.name;</span>

          <span class="s3">if </span><span class="s1">(!isComponentishName(name)) {</span>
            <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">switch </span><span class="s1">(init.type) {</span>
            <span class="s3">case </span><span class="s2">'ArrowFunctionExpression'</span><span class="s1">:</span>
            <span class="s3">case </span><span class="s2">'FunctionExpression'</span><span class="s1">:</span>
              <span class="s0">// Likely component definitions.</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s2">'CallExpression'</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s0">// Maybe a HOC.</span>
                <span class="s0">// Try to determine if this is some form of import.</span>
                <span class="s3">var </span><span class="s1">callee = init.callee;</span>
                <span class="s3">var </span><span class="s1">calleeType = callee.type;</span>

                <span class="s3">if </span><span class="s1">(calleeType === </span><span class="s2">'Import'</span><span class="s1">) {</span>
                  <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(calleeType === </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
                  <span class="s3">if </span><span class="s1">(callee.name.indexOf(</span><span class="s2">'require'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(callee.name.indexOf(</span><span class="s2">'import'</span><span class="s1">) === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                  <span class="s1">} </span><span class="s0">// Neither require nor import. Might be a HOC.</span>
                  <span class="s0">// Pass through.</span>

                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(calleeType === </span><span class="s2">'MemberExpression'</span><span class="s1">) {</span><span class="s0">// Could be something like React.forwardRef(...)</span>
                  <span class="s0">// Pass through.</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                  <span class="s0">// More complicated call.</span>
                  <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

            <span class="s3">case </span><span class="s2">'TaggedTemplateExpression'</span><span class="s1">:</span>
              <span class="s0">// Maybe something like styled.div`...`</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">default</span><span class="s1">:</span>
              <span class="s3">return false</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">initPath = path.get(</span><span class="s2">'init'</span><span class="s1">);</span>

          <span class="s3">var </span><span class="s1">_foundInside = findInnerComponents(inferredName, initPath, callback);</span>

          <span class="s3">if </span><span class="s1">(_foundInside) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// See if this identifier is used in JSX. Then it's a component.</span>


          <span class="s3">var </span><span class="s1">binding = path.scope.getBinding(name);</span>

          <span class="s3">if </span><span class="s1">(binding === undefined) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">isLikelyUsedAsType = </span><span class="s3">false</span><span class="s1">;</span>
          <span class="s3">var </span><span class="s1">referencePaths = binding.referencePaths;</span>

          <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; referencePaths.length; i++) {</span>
            <span class="s3">var </span><span class="s1">ref = referencePaths[i];</span>

            <span class="s3">if </span><span class="s1">(ref.node.type !== </span><span class="s2">'JSXIdentifier' </span><span class="s1">&amp;&amp; ref.node.type !== </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
              <span class="s3">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">var </span><span class="s1">refParent = ref.parent;</span>

            <span class="s3">if </span><span class="s1">(refParent.type === </span><span class="s2">'JSXOpeningElement'</span><span class="s1">) {</span>
              <span class="s1">isLikelyUsedAsType = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(refParent.type === </span><span class="s2">'CallExpression'</span><span class="s1">) {</span>
              <span class="s3">var </span><span class="s1">_callee = refParent.callee;</span>
              <span class="s3">var </span><span class="s1">fnName = </span><span class="s3">void </span><span class="s4">0</span><span class="s1">;</span>

              <span class="s3">switch </span><span class="s1">(_callee.type) {</span>
                <span class="s3">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
                  <span class="s1">fnName = _callee.name;</span>
                  <span class="s3">break</span><span class="s1">;</span>

                <span class="s3">case </span><span class="s2">'MemberExpression'</span><span class="s1">:</span>
                  <span class="s1">fnName = _callee.property.name;</span>
                  <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>

              <span class="s3">switch </span><span class="s1">(fnName) {</span>
                <span class="s3">case </span><span class="s2">'createElement'</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s2">'jsx'</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s2">'jsxDEV'</span><span class="s1">:</span>
                <span class="s3">case </span><span class="s2">'jsxs'</span><span class="s1">:</span>
                  <span class="s1">isLikelyUsedAsType = </span><span class="s3">true</span><span class="s1">;</span>
                  <span class="s3">break</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(isLikelyUsedAsType) {</span>
              <span class="s0">// const X = ... + later &lt;X /&gt;</span>
              <span class="s1">callback(inferredName, init, initPath);</span>
              <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">isBuiltinHook(hookName) {</span>
    <span class="s3">switch </span><span class="s1">(hookName) {</span>
      <span class="s3">case </span><span class="s2">'useState'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useState'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useReducer'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useReducer'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useEffect'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useEffect'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useLayoutEffect'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useLayoutEffect'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useMemo'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useMemo'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useCallback'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useCallback'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useRef'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useRef'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useContext'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useContext'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useImperativeMethods'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useImperativeMethods'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'useDebugValue'</span><span class="s1">:</span>
      <span class="s3">case </span><span class="s2">'React.useDebugValue'</span><span class="s1">:</span>
        <span class="s3">return true</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s1">:</span>
        <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">getHookCallsSignature(functionNode) {</span>
    <span class="s3">var </span><span class="s1">fnHookCalls = hookCalls.get(functionNode);</span>

    <span class="s3">if </span><span class="s1">(fnHookCalls === undefined) {</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">{</span>
      <span class="s1">key: fnHookCalls.map(</span><span class="s3">function </span><span class="s1">(call) {</span>
        <span class="s3">return </span><span class="s1">call.name + </span><span class="s2">'{' </span><span class="s1">+ call.key + </span><span class="s2">'}'</span><span class="s1">;</span>
      <span class="s1">}).join(</span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">),</span>
      <span class="s1">customHooks: fnHookCalls.filter(</span><span class="s3">function </span><span class="s1">(call) {</span>
        <span class="s3">return </span><span class="s1">!isBuiltinHook(call.name);</span>
      <span class="s1">}).map(</span><span class="s3">function </span><span class="s1">(call) {</span>
        <span class="s3">return </span><span class="s1">t.cloneDeep(call.callee);</span>
      <span class="s1">})</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">hasForceResetCommentByFile = </span><span class="s3">new </span><span class="s1">WeakMap(); </span><span class="s0">// We let user do /* @refresh reset */ to reset state in the whole file.</span>

  <span class="s3">function </span><span class="s1">hasForceResetComment(path) {</span>
    <span class="s3">var </span><span class="s1">file = path.hub.file;</span>
    <span class="s3">var </span><span class="s1">hasForceReset = hasForceResetCommentByFile.get(file);</span>

    <span class="s3">if </span><span class="s1">(hasForceReset !== undefined) {</span>
      <span class="s3">return </span><span class="s1">hasForceReset;</span>
    <span class="s1">}</span>

    <span class="s1">hasForceReset = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">comments = file.ast.comments;</span>

    <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; comments.length; i++) {</span>
      <span class="s3">var </span><span class="s1">cmt = comments[i];</span>

      <span class="s3">if </span><span class="s1">(cmt.value.indexOf(</span><span class="s2">'@refresh reset'</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">hasForceReset = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">hasForceResetCommentByFile.set(file, hasForceReset);</span>
    <span class="s3">return </span><span class="s1">hasForceReset;</span>
  <span class="s1">}</span>

  <span class="s3">function </span><span class="s1">createArgumentsForSignature(node, signature, scope) {</span>
    <span class="s3">var </span><span class="s1">key = signature.key,</span>
        <span class="s1">customHooks = signature.customHooks;</span>
    <span class="s3">var </span><span class="s1">forceReset = hasForceResetComment(scope.path);</span>
    <span class="s3">var </span><span class="s1">customHooksInScope = [];</span>
    <span class="s1">customHooks.forEach(</span><span class="s3">function </span><span class="s1">(callee) {</span>
      <span class="s0">// Check if a corresponding binding exists where we emit the signature.</span>
      <span class="s3">var </span><span class="s1">bindingName;</span>

      <span class="s3">switch </span><span class="s1">(callee.type) {</span>
        <span class="s3">case </span><span class="s2">'MemberExpression'</span><span class="s1">:</span>
          <span class="s3">if </span><span class="s1">(callee.object.type === </span><span class="s2">'Identifier'</span><span class="s1">) {</span>
            <span class="s1">bindingName = callee.object.name;</span>
          <span class="s1">}</span>

          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
          <span class="s1">bindingName = callee.name;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(scope.hasBinding(bindingName)) {</span>
        <span class="s1">customHooksInScope.push(callee);</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s0">// We don't have anything to put in the array because Hook is out of scope.</span>
        <span class="s0">// Since it could potentially have been edited, remount the component.</span>
        <span class="s1">forceReset = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">var </span><span class="s1">finalKey = key;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">require === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; !opts.emitFullSignatures) {</span>
      <span class="s0">// Prefer to hash when we can (e.g. outside of ASTExplorer).</span>
      <span class="s0">// This makes it deterministically compact, even if there's</span>
      <span class="s0">// e.g. a useState ininitalizer with some code inside.</span>
      <span class="s0">// We also need it for www that has transforms like cx()</span>
      <span class="s0">// that don't understand if something is part of a string.</span>
      <span class="s1">finalKey = require(</span><span class="s2">'crypto'</span><span class="s1">).createHash(</span><span class="s2">'sha1'</span><span class="s1">).update(key).digest(</span><span class="s2">'base64'</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">var </span><span class="s1">args = [node, t.stringLiteral(finalKey)];</span>

    <span class="s3">if </span><span class="s1">(forceReset || customHooksInScope.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">args.push(t.booleanLiteral(forceReset));</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(customHooksInScope.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">args.push( </span><span class="s0">// TODO: We could use an arrow here to be more compact.</span>
      <span class="s0">// However, don't do it until AMA can run them natively.</span>
      <span class="s1">t.functionExpression(</span><span class="s3">null</span><span class="s1">, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));</span>
    <span class="s1">}</span>

    <span class="s3">return </span><span class="s1">args;</span>
  <span class="s1">}</span>

  <span class="s3">var </span><span class="s1">seenForRegistration = </span><span class="s3">new </span><span class="s1">WeakSet();</span>
  <span class="s3">var </span><span class="s1">seenForSignature = </span><span class="s3">new </span><span class="s1">WeakSet();</span>
  <span class="s3">var </span><span class="s1">seenForOutro = </span><span class="s3">new </span><span class="s1">WeakSet();</span>
  <span class="s3">var </span><span class="s1">hookCalls = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
  <span class="s3">var </span><span class="s1">HookCallsVisitor = {</span>
    <span class="s1">CallExpression: </span><span class="s3">function </span><span class="s1">(path) {</span>
      <span class="s3">var </span><span class="s1">node = path.node;</span>
      <span class="s3">var </span><span class="s1">callee = node.callee; </span><span class="s0">// Note: this visitor MUST NOT mutate the tree in any way.</span>
      <span class="s0">// It runs early in a separate traversal and should be very fast.</span>

      <span class="s3">var </span><span class="s1">name = </span><span class="s3">null</span><span class="s1">;</span>

      <span class="s3">switch </span><span class="s1">(callee.type) {</span>
        <span class="s3">case </span><span class="s2">'Identifier'</span><span class="s1">:</span>
          <span class="s1">name = callee.name;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s2">'MemberExpression'</span><span class="s1">:</span>
          <span class="s1">name = callee.property.name;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">if </span><span class="s1">(name === </span><span class="s3">null </span><span class="s1">|| !/^use[A-Z]/.test(name)) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">fnScope = path.scope.getFunctionParent();</span>

      <span class="s3">if </span><span class="s1">(fnScope === </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s3">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// This is a Hook call. Record it.</span>


      <span class="s3">var </span><span class="s1">fnNode = fnScope.block;</span>

      <span class="s3">if </span><span class="s1">(!hookCalls.has(fnNode)) {</span>
        <span class="s1">hookCalls.set(fnNode, []);</span>
      <span class="s1">}</span>

      <span class="s3">var </span><span class="s1">hookCallsForFn = hookCalls.get(fnNode);</span>
      <span class="s3">var </span><span class="s1">key = </span><span class="s2">''</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s1">(path.parent.type === </span><span class="s2">'VariableDeclarator'</span><span class="s1">) {</span>
        <span class="s0">// TODO: if there is no LHS, consider some other heuristic.</span>
        <span class="s1">key = path.parentPath.get(</span><span class="s2">'id'</span><span class="s1">).getSource();</span>
      <span class="s1">} </span><span class="s0">// Some built-in Hooks reset on edits to arguments.</span>


      <span class="s3">var </span><span class="s1">args = path.get(</span><span class="s2">'arguments'</span><span class="s1">);</span>

      <span class="s3">if </span><span class="s1">(name === </span><span class="s2">'useState' </span><span class="s1">&amp;&amp; args.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">// useState second argument is initial state.</span>
        <span class="s1">key += </span><span class="s2">'(' </span><span class="s1">+ args[</span><span class="s4">0</span><span class="s1">].getSource() + </span><span class="s2">')'</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(name === </span><span class="s2">'useReducer' </span><span class="s1">&amp;&amp; args.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">// useReducer second argument is initial state.</span>
        <span class="s1">key += </span><span class="s2">'(' </span><span class="s1">+ args[</span><span class="s4">1</span><span class="s1">].getSource() + </span><span class="s2">')'</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">hookCallsForFn.push({</span>
        <span class="s1">callee: path.node.callee,</span>
        <span class="s1">name: name,</span>
        <span class="s1">key: key</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s3">return </span><span class="s1">{</span>
    <span class="s1">visitor: {</span>
      <span class="s1">ExportDefaultDeclaration: </span><span class="s3">function </span><span class="s1">(path) {</span>
        <span class="s3">var </span><span class="s1">node = path.node;</span>
        <span class="s3">var </span><span class="s1">decl = node.declaration;</span>
        <span class="s3">var </span><span class="s1">declPath = path.get(</span><span class="s2">'declaration'</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(decl.type !== </span><span class="s2">'CallExpression'</span><span class="s1">) {</span>
          <span class="s0">// For now, we only support possible HOC calls here.</span>
          <span class="s0">// Named function declarations are handled in FunctionDeclaration.</span>
          <span class="s0">// Anonymous direct exports like export default function() {}</span>
          <span class="s0">// are currently ignored.</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
        <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


        <span class="s3">if </span><span class="s1">(seenForRegistration.has(node)) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">seenForRegistration.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>
        <span class="s0">// This code path handles nested cases like:</span>
        <span class="s0">// export default memo(() =&gt; {})</span>
        <span class="s0">// In those cases it is more plausible people will omit names</span>
        <span class="s0">// so they're worth handling despite possible false positives.</span>
        <span class="s0">// More importantly, it handles the named case:</span>
        <span class="s0">// export default memo(function Named() {})</span>

        <span class="s3">var </span><span class="s1">inferredName = </span><span class="s2">'%default%'</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">programPath = path.parentPath;</span>
        <span class="s1">findInnerComponents(inferredName, declPath, </span><span class="s3">function </span><span class="s1">(persistentID, targetExpr, targetPath) {</span>
          <span class="s3">if </span><span class="s1">(targetPath === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// For case like:</span>
            <span class="s0">// export default hoc(Foo)</span>
            <span class="s0">// we don't want to wrap Foo inside the call.</span>
            <span class="s0">// Instead we assume it's registered at definition.</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">handle = createRegistration(programPath, persistentID);</span>
          <span class="s1">targetPath.replaceWith(t.assignmentExpression(</span><span class="s2">'='</span><span class="s1">, handle, targetExpr));</span>
        <span class="s1">});</span>
      <span class="s1">},</span>
      <span class="s1">FunctionDeclaration: {</span>
        <span class="s1">enter: </span><span class="s3">function </span><span class="s1">(path) {</span>
          <span class="s3">var </span><span class="s1">node = path.node;</span>
          <span class="s3">var </span><span class="s1">programPath;</span>
          <span class="s3">var </span><span class="s1">insertAfterPath;</span>

          <span class="s3">switch </span><span class="s1">(path.parent.type) {</span>
            <span class="s3">case </span><span class="s2">'Program'</span><span class="s1">:</span>
              <span class="s1">insertAfterPath = path;</span>
              <span class="s1">programPath = path.parentPath;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s2">'ExportNamedDeclaration'</span><span class="s1">:</span>
              <span class="s1">insertAfterPath = path.parentPath;</span>
              <span class="s1">programPath = insertAfterPath.parentPath;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s2">'ExportDefaultDeclaration'</span><span class="s1">:</span>
              <span class="s1">insertAfterPath = path.parentPath;</span>
              <span class="s1">programPath = insertAfterPath.parentPath;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">default</span><span class="s1">:</span>
              <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">id = node.id;</span>

          <span class="s3">if </span><span class="s1">(id === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// We don't currently handle anonymous default exports.</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">inferredName = id.name;</span>

          <span class="s3">if </span><span class="s1">(!isComponentishName(inferredName)) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s3">if </span><span class="s1">(seenForRegistration.has(node)) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">seenForRegistration.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>
          <span class="s0">// export function Named() {}</span>
          <span class="s0">// function Named() {}</span>

          <span class="s1">findInnerComponents(inferredName, path, </span><span class="s3">function </span><span class="s1">(persistentID, targetExpr) {</span>
            <span class="s3">var </span><span class="s1">handle = createRegistration(programPath, persistentID);</span>
            <span class="s1">insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression(</span><span class="s2">'='</span><span class="s1">, handle, targetExpr)));</span>
          <span class="s1">});</span>
        <span class="s1">},</span>
        <span class="s1">exit: </span><span class="s3">function </span><span class="s1">(path) {</span>
          <span class="s3">var </span><span class="s1">node = path.node;</span>
          <span class="s3">var </span><span class="s1">id = node.id;</span>

          <span class="s3">if </span><span class="s1">(id === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">signature = getHookCallsSignature(node);</span>

          <span class="s3">if </span><span class="s1">(signature === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s3">if </span><span class="s1">(seenForSignature.has(node)) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">seenForSignature.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

          <span class="s3">var </span><span class="s1">sigCallID = path.scope.generateUidIdentifier(</span><span class="s2">'_s'</span><span class="s1">);</span>
          <span class="s1">path.scope.parent.push({</span>
            <span class="s1">id: sigCallID,</span>
            <span class="s1">init: t.callExpression(t.identifier(</span><span class="s2">'$RefreshSig$'</span><span class="s1">), [])</span>
          <span class="s1">}); </span><span class="s0">// The signature call is split in two parts. One part is called inside the function.</span>
          <span class="s0">// This is used to signal when first render happens.</span>

          <span class="s1">path.get(</span><span class="s2">'body'</span><span class="s1">).unshiftContainer(</span><span class="s2">'body'</span><span class="s1">, t.expressionStatement(t.callExpression(sigCallID, []))); </span><span class="s0">// The second call is around the function itself.</span>
          <span class="s0">// This is used to associate a type with a signature.</span>
          <span class="s0">// Unlike with $RefreshReg$, this needs to work for nested</span>
          <span class="s0">// declarations too. So we need to search for a path where</span>
          <span class="s0">// we can insert a statement rather than hardcoding it.</span>

          <span class="s3">var </span><span class="s1">insertAfterPath = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s1">path.find(</span><span class="s3">function </span><span class="s1">(p) {</span>
            <span class="s3">if </span><span class="s1">(p.parentPath.isBlock()) {</span>
              <span class="s1">insertAfterPath = p;</span>
              <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">});</span>

          <span class="s3">if </span><span class="s1">(insertAfterPath === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s2">'ArrowFunctionExpression|FunctionExpression'</span><span class="s1">: {</span>
        <span class="s1">exit: </span><span class="s3">function </span><span class="s1">(path) {</span>
          <span class="s3">var </span><span class="s1">node = path.node;</span>
          <span class="s3">var </span><span class="s1">signature = getHookCallsSignature(node);</span>

          <span class="s3">if </span><span class="s1">(signature === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s3">if </span><span class="s1">(seenForSignature.has(node)) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">seenForSignature.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

          <span class="s3">var </span><span class="s1">sigCallID = path.scope.generateUidIdentifier(</span><span class="s2">'_s'</span><span class="s1">);</span>
          <span class="s1">path.scope.parent.push({</span>
            <span class="s1">id: sigCallID,</span>
            <span class="s1">init: t.callExpression(t.identifier(</span><span class="s2">'$RefreshSig$'</span><span class="s1">), [])</span>
          <span class="s1">}); </span><span class="s0">// The signature call is split in two parts. One part is called inside the function.</span>
          <span class="s0">// This is used to signal when first render happens.</span>

          <span class="s3">if </span><span class="s1">(path.node.body.type !== </span><span class="s2">'BlockStatement'</span><span class="s1">) {</span>
            <span class="s1">path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);</span>
          <span class="s1">}</span>

          <span class="s1">path.get(</span><span class="s2">'body'</span><span class="s1">).unshiftContainer(</span><span class="s2">'body'</span><span class="s1">, t.expressionStatement(t.callExpression(sigCallID, []))); </span><span class="s0">// The second call is around the function itself.</span>
          <span class="s0">// This is used to associate a type with a signature.</span>

          <span class="s3">if </span><span class="s1">(path.parent.type === </span><span class="s2">'VariableDeclarator'</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">insertAfterPath = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">path.find(</span><span class="s3">function </span><span class="s1">(p) {</span>
              <span class="s3">if </span><span class="s1">(p.parentPath.isBlock()) {</span>
                <span class="s1">insertAfterPath = p;</span>
                <span class="s3">return true</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">});</span>

            <span class="s3">if </span><span class="s1">(insertAfterPath === </span><span class="s3">null</span><span class="s1">) {</span>
              <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s0">// Special case when a function would get an inferred name:</span>
            <span class="s0">// let Foo = () =&gt; {}</span>
            <span class="s0">// let Foo = function() {}</span>
            <span class="s0">// We'll add signature it on next line so that</span>
            <span class="s0">// we don't mess up the inferred 'Foo' function name.</span>


            <span class="s1">insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); </span><span class="s0">// Result: let Foo = () =&gt; {}; __signature(Foo, ...);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// let Foo = hoc(() =&gt; {})</span>
            <span class="s1">path.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(node, signature, path.scope))); </span><span class="s0">// Result: let Foo = hoc(__signature(() =&gt; {}, ...))</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">},</span>
      <span class="s1">VariableDeclaration: </span><span class="s3">function </span><span class="s1">(path) {</span>
        <span class="s3">var </span><span class="s1">node = path.node;</span>
        <span class="s3">var </span><span class="s1">programPath;</span>
        <span class="s3">var </span><span class="s1">insertAfterPath;</span>

        <span class="s3">switch </span><span class="s1">(path.parent.type) {</span>
          <span class="s3">case </span><span class="s2">'Program'</span><span class="s1">:</span>
            <span class="s1">insertAfterPath = path;</span>
            <span class="s1">programPath = path.parentPath;</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s2">'ExportNamedDeclaration'</span><span class="s1">:</span>
            <span class="s1">insertAfterPath = path.parentPath;</span>
            <span class="s1">programPath = insertAfterPath.parentPath;</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">case </span><span class="s2">'ExportDefaultDeclaration'</span><span class="s1">:</span>
            <span class="s1">insertAfterPath = path.parentPath;</span>
            <span class="s1">programPath = insertAfterPath.parentPath;</span>
            <span class="s3">break</span><span class="s1">;</span>

          <span class="s3">default</span><span class="s1">:</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
        <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


        <span class="s3">if </span><span class="s1">(seenForRegistration.has(node)) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">seenForRegistration.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

        <span class="s3">var </span><span class="s1">declPaths = path.get(</span><span class="s2">'declarations'</span><span class="s1">);</span>

        <span class="s3">if </span><span class="s1">(declPaths.length !== </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">var </span><span class="s1">declPath = declPaths[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s3">var </span><span class="s1">inferredName = declPath.node.id.name;</span>
        <span class="s1">findInnerComponents(inferredName, declPath, </span><span class="s3">function </span><span class="s1">(persistentID, targetExpr, targetPath) {</span>
          <span class="s3">if </span><span class="s1">(targetPath === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s0">// For case like:</span>
            <span class="s0">// export const Something = hoc(Foo)</span>
            <span class="s0">// we don't want to wrap Foo inside the call.</span>
            <span class="s0">// Instead we assume it's registered at definition.</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s3">var </span><span class="s1">handle = createRegistration(programPath, persistentID);</span>

          <span class="s3">if </span><span class="s1">((targetExpr.type === </span><span class="s2">'ArrowFunctionExpression' </span><span class="s1">|| targetExpr.type === </span><span class="s2">'FunctionExpression'</span><span class="s1">) &amp;&amp; targetPath.parent.type === </span><span class="s2">'VariableDeclarator'</span><span class="s1">) {</span>
            <span class="s0">// Special case when a function would get an inferred name:</span>
            <span class="s0">// let Foo = () =&gt; {}</span>
            <span class="s0">// let Foo = function() {}</span>
            <span class="s0">// We'll register it on next line so that</span>
            <span class="s0">// we don't mess up the inferred 'Foo' function name.</span>
            <span class="s1">insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression(</span><span class="s2">'='</span><span class="s1">, handle, declPath.node.id))); </span><span class="s0">// Result: let Foo = () =&gt; {}; _c1 = Foo;</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s0">// let Foo = hoc(() =&gt; {})</span>
            <span class="s1">targetPath.replaceWith(t.assignmentExpression(</span><span class="s2">'='</span><span class="s1">, handle, targetExpr)); </span><span class="s0">// Result: let Foo = _c1 = hoc(() =&gt; {})</span>
          <span class="s1">}</span>
        <span class="s1">});</span>
      <span class="s1">},</span>
      <span class="s1">Program: {</span>
        <span class="s1">enter: </span><span class="s3">function </span><span class="s1">(path) {</span>
          <span class="s0">// This is a separate early visitor because we need to collect Hook calls</span>
          <span class="s0">// and &quot;const [foo, setFoo] = ...&quot; signatures before the destructuring</span>
          <span class="s0">// transform mangles them. This extra traversal is not ideal for perf,</span>
          <span class="s0">// but it's the best we can do until we stop transpiling destructuring.</span>
          <span class="s1">path.traverse(HookCallsVisitor);</span>
        <span class="s1">},</span>
        <span class="s1">exit: </span><span class="s3">function </span><span class="s1">(path) {</span>
          <span class="s3">var </span><span class="s1">registrations = registrationsByProgramPath.get(path);</span>

          <span class="s3">if </span><span class="s1">(registrations === undefined) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// Make sure we're not mutating the same tree twice.</span>
          <span class="s0">// This can happen if another Babel plugin replaces parents.</span>


          <span class="s3">var </span><span class="s1">node = path.node;</span>

          <span class="s3">if </span><span class="s1">(seenForOutro.has(node)) {</span>
            <span class="s3">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">seenForOutro.add(node); </span><span class="s0">// Don't mutate the tree above this point.</span>

          <span class="s1">registrationsByProgramPath.</span><span class="s3">delete</span><span class="s1">(path);</span>
          <span class="s3">var </span><span class="s1">declarators = [];</span>
          <span class="s1">path.pushContainer(</span><span class="s2">'body'</span><span class="s1">, t.variableDeclaration(</span><span class="s2">'var'</span><span class="s1">, declarators));</span>
          <span class="s1">registrations.forEach(</span><span class="s3">function </span><span class="s1">(_ref) {</span>
            <span class="s3">var </span><span class="s1">handle = _ref.handle,</span>
                <span class="s1">persistentID = _ref.persistentID;</span>
            <span class="s1">path.pushContainer(</span><span class="s2">'body'</span><span class="s1">, t.expressionStatement(t.callExpression(t.identifier(</span><span class="s2">'$RefreshReg$'</span><span class="s1">), [handle, t.stringLiteral(persistentID)])));</span>
            <span class="s1">declarators.push(t.variableDeclarator(handle));</span>
          <span class="s1">});</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
<span class="s1">};</span>

<span class="s3">var </span><span class="s1">ReactFreshBabelPlugin$1 = Object.freeze({</span>
	<span class="s3">default</span><span class="s1">: ReactFreshBabelPlugin</span>
<span class="s1">});</span>

<span class="s3">var </span><span class="s1">ReactFreshBabelPlugin$2 = ( ReactFreshBabelPlugin$1 &amp;&amp; ReactFreshBabelPlugin ) || ReactFreshBabelPlugin$1;</span>

<span class="s0">// This is hacky but makes it work with both Rollup and Jest.</span>


<span class="s3">var </span><span class="s1">babel = ReactFreshBabelPlugin$2.</span><span class="s3">default </span><span class="s1">|| ReactFreshBabelPlugin$2;</span>

<span class="s1">module.exports = babel;</span>
  <span class="s1">})();</span>
<span class="s1">}</span>
</pre>
</body>
</html>
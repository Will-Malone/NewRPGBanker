<html>
<head>
<title>bundle.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bundle.min.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
<span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports, require(</span><span class="s2">'@jridgewell/source-map'</span><span class="s0">)) :</span>
<span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">, </span><span class="s2">'@jridgewell/source-map'</span><span class="s0">], factory) :</span>
<span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.Terser = {}, global.sourceMap));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports, sourceMap) { </span><span class="s2">'use strict'</span><span class="s0">;</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">function </span><span class="s0">characters(str) {</span>
    <span class="s1">return </span><span class="s0">str.split(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">member(name, array) {</span>
    <span class="s1">return </span><span class="s0">array.includes(name);</span>
<span class="s0">}</span>

<span class="s0">class DefaultsError extends Error {</span>
    <span class="s0">constructor(msg, defs) {</span>
        <span class="s0">super();</span>

        <span class="s1">this</span><span class="s0">.name = </span><span class="s2">&quot;DefaultsError&quot;</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.message = msg;</span>
        <span class="s1">this</span><span class="s0">.defs = defs;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">defaults(args, defs, croak) {</span>
    <span class="s1">if </span><span class="s0">(args === </span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s0">args = {};</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(args != </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">args === </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
        <span class="s0">args = {...args};</span>
    <span class="s0">}</span>

    <span class="s0">const ret = args || {};</span>

    <span class="s1">if </span><span class="s0">(croak) </span><span class="s1">for </span><span class="s0">(const i </span><span class="s1">in </span><span class="s0">ret) </span><span class="s1">if </span><span class="s0">(HOP(ret, i) &amp;&amp; !HOP(defs, i)) {</span>
        <span class="s1">throw new </span><span class="s0">DefaultsError(</span><span class="s2">&quot;`&quot; </span><span class="s0">+ i + </span><span class="s2">&quot;` is not a supported option&quot;</span><span class="s0">, defs);</span>
    <span class="s0">}</span>

    <span class="s1">for </span><span class="s0">(const i </span><span class="s1">in </span><span class="s0">defs) </span><span class="s1">if </span><span class="s0">(HOP(defs, i)) {</span>
        <span class="s1">if </span><span class="s0">(!args || !HOP(args, i)) {</span>
            <span class="s0">ret[i] = defs[i];</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(i === </span><span class="s2">&quot;ecma&quot;</span><span class="s0">) {</span>
            <span class="s0">let ecma = args[i] | </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(ecma &gt; </span><span class="s4">5 </span><span class="s0">&amp;&amp; ecma &lt; </span><span class="s4">2015</span><span class="s0">) ecma += </span><span class="s4">2009</span><span class="s0">;</span>
            <span class="s0">ret[i] = ecma;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">ret[i] = (args &amp;&amp; HOP(args, i)) ? args[i] : defs[i];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">ret;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">noop() {}</span>
<span class="s1">function </span><span class="s0">return_false() { </span><span class="s1">return false</span><span class="s0">; }</span>
<span class="s1">function </span><span class="s0">return_true() { </span><span class="s1">return true</span><span class="s0">; }</span>
<span class="s1">function </span><span class="s0">return_this() { </span><span class="s1">return this</span><span class="s0">; }</span>
<span class="s1">function </span><span class="s0">return_null() { </span><span class="s1">return null</span><span class="s0">; }</span>

<span class="s1">var </span><span class="s0">MAP = (</span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">function </span><span class="s0">MAP(a, tw, allow_splicing = </span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s0">const new_a = [];</span>

        <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; a.length; ++i) {</span>
            <span class="s0">let item = a[i];</span>
            <span class="s0">let ret = item.transform(tw, allow_splicing);</span>

            <span class="s1">if </span><span class="s0">(ret </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
                <span class="s0">new_a.push(ret);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ret </span><span class="s1">instanceof </span><span class="s0">Splice) {</span>
                <span class="s0">new_a.push(...ret.v);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">new_a;</span>
    <span class="s0">}</span>

    <span class="s0">MAP.splice = </span><span class="s1">function</span><span class="s0">(val) { </span><span class="s1">return new </span><span class="s0">Splice(val); };</span>
    <span class="s0">MAP.skip = {};</span>
    <span class="s1">function </span><span class="s0">Splice(val) { </span><span class="s1">this</span><span class="s0">.v = val; }</span>
    <span class="s1">return </span><span class="s0">MAP;</span>
<span class="s0">})();</span>

<span class="s1">function </span><span class="s0">make_node(ctor, orig, props) {</span>
    <span class="s1">if </span><span class="s0">(!props) props = {};</span>
    <span class="s1">if </span><span class="s0">(orig) {</span>
        <span class="s1">if </span><span class="s0">(!props.start) props.start = orig.start;</span>
        <span class="s1">if </span><span class="s0">(!props.end) props.end = orig.end;</span>
    <span class="s0">}</span>
    <span class="s1">return new </span><span class="s0">ctor(props);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">push_uniq(array, el) {</span>
    <span class="s1">if </span><span class="s0">(!array.includes(el))</span>
        <span class="s0">array.push(el);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">string_template(text, props) {</span>
    <span class="s1">return </span><span class="s0">text.replace(/{(.+?)}/g, </span><span class="s1">function</span><span class="s0">(str, p) {</span>
        <span class="s1">return </span><span class="s0">props &amp;&amp; props[p];</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">remove(array, el) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = array.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
        <span class="s1">if </span><span class="s0">(array[i] === el) array.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">mergeSort(array, cmp) {</span>
    <span class="s1">if </span><span class="s0">(array.length &lt; </span><span class="s4">2</span><span class="s0">) </span><span class="s1">return </span><span class="s0">array.slice();</span>
    <span class="s1">function </span><span class="s0">merge(a, b) {</span>
        <span class="s1">var </span><span class="s0">r = [], ai = </span><span class="s4">0</span><span class="s0">, bi = </span><span class="s4">0</span><span class="s0">, i = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">(ai &lt; a.length &amp;&amp; bi &lt; b.length) {</span>
            <span class="s0">cmp(a[ai], b[bi]) &lt;= </span><span class="s4">0</span>
                <span class="s0">? r[i++] = a[ai++]</span>
                <span class="s0">: r[i++] = b[bi++];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(ai &lt; a.length) r.push.apply(r, a.slice(ai));</span>
        <span class="s1">if </span><span class="s0">(bi &lt; b.length) r.push.apply(r, b.slice(bi));</span>
        <span class="s1">return </span><span class="s0">r;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">_ms(a) {</span>
        <span class="s1">if </span><span class="s0">(a.length &lt;= </span><span class="s4">1</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">a;</span>
        <span class="s1">var </span><span class="s0">m = Math.floor(a.length / </span><span class="s4">2</span><span class="s0">), left = a.slice(</span><span class="s4">0</span><span class="s0">, m), right = a.slice(m);</span>
        <span class="s0">left = _ms(left);</span>
        <span class="s0">right = _ms(right);</span>
        <span class="s1">return </span><span class="s0">merge(left, right);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">_ms(array);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">makePredicate(words) {</span>
    <span class="s1">if </span><span class="s0">(!Array.isArray(words)) words = words.split(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>

    <span class="s1">return new </span><span class="s0">Set(words.sort());</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">map_add(map, key, value) {</span>
    <span class="s1">if </span><span class="s0">(map.has(key)) {</span>
        <span class="s0">map.get(key).push(value);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">map.set(key, [ value ]);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">map_from_object(obj) {</span>
    <span class="s1">var </span><span class="s0">map = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">key </span><span class="s1">in </span><span class="s0">obj) {</span>
        <span class="s1">if </span><span class="s0">(HOP(obj, key) &amp;&amp; key.charAt(</span><span class="s4">0</span><span class="s0">) === </span><span class="s2">&quot;$&quot;</span><span class="s0">) {</span>
            <span class="s0">map.set(key.substr(</span><span class="s4">1</span><span class="s0">), obj[key]);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">map;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">map_to_object(map) {</span>
    <span class="s1">var </span><span class="s0">obj = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">map.forEach(</span><span class="s1">function </span><span class="s0">(value, key) {</span>
        <span class="s0">obj[</span><span class="s2">&quot;$&quot; </span><span class="s0">+ key] = value;</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">obj;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">HOP(obj, prop) {</span>
    <span class="s1">return </span><span class="s0">Object.prototype.hasOwnProperty.call(obj, prop);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">keep_name(keep_setting, name) {</span>
    <span class="s1">return </span><span class="s0">keep_setting === </span><span class="s1">true</span>
        <span class="s0">|| (keep_setting </span><span class="s1">instanceof </span><span class="s0">RegExp &amp;&amp; keep_setting.test(name));</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">lineTerminatorEscape = {</span>
    <span class="s2">&quot;</span><span class="s5">\0</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s2">&quot;0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s2">&quot;n&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;</span><span class="s5">\r</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s2">&quot;r&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;</span><span class="s5">\u2028</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s2">&quot;u2028&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;</span><span class="s5">\u2029</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s2">&quot;u2029&quot;</span><span class="s0">,</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">regexp_source_fix(source) {</span>
    <span class="s3">// V8 does not escape line terminators in regexp patterns in node 12</span>
    <span class="s3">// We'll also remove literal \0</span>
    <span class="s1">return </span><span class="s0">source.replace(/[\</span><span class="s4">0</span><span class="s0">\n\r\u2028\u2029]/g, </span><span class="s1">function </span><span class="s0">(match, offset) {</span>
        <span class="s1">var </span><span class="s0">escaped = source[offset - </span><span class="s4">1</span><span class="s0">] == </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span>
            <span class="s0">&amp;&amp; (source[offset - </span><span class="s4">2</span><span class="s0">] != </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span>
            <span class="s0">|| /(?:^|[^\\])(?:\\{</span><span class="s4">2</span><span class="s0">})*$/.test(source.slice(</span><span class="s4">0</span><span class="s0">, offset - </span><span class="s4">1</span><span class="s0">)));</span>
        <span class="s1">return </span><span class="s0">(escaped ? </span><span class="s2">&quot;&quot; </span><span class="s0">: </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">) + lineTerminatorEscape[match];</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s3">// Subset of regexps that is not going to cause regexp based DDOS</span>
<span class="s3">// https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS</span>
<span class="s0">const re_safe_regexp = /^[\\/|\</span><span class="s4">0</span><span class="s0">\s\w^$.[\]()]*$/;</span>

<span class="s3">/** Check if the regexp is safe for Terser to create without risking a RegExp DOS */</span>
<span class="s0">const regexp_is_safe = (source) =&gt; re_safe_regexp.test(source);</span>

<span class="s0">const all_flags = </span><span class="s2">&quot;dgimsuyv&quot;</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">sort_regexp_flags(flags) {</span>
    <span class="s0">const existing_flags = </span><span class="s1">new </span><span class="s0">Set(flags.split(</span><span class="s2">&quot;&quot;</span><span class="s0">));</span>
    <span class="s0">let out = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(const flag of all_flags) {</span>
        <span class="s1">if </span><span class="s0">(existing_flags.has(flag)) {</span>
            <span class="s0">out += flag;</span>
            <span class="s0">existing_flags.</span><span class="s1">delete</span><span class="s0">(flag);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(existing_flags.size) {</span>
        <span class="s3">// Flags Terser doesn't know about</span>
        <span class="s0">existing_flags.forEach(flag =&gt; { out += flag; });</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">out;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">has_annotation(node, annotation) {</span>
    <span class="s1">return </span><span class="s0">node._annotations &amp; annotation;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">set_annotation(node, annotation) {</span>
    <span class="s0">node._annotations |= annotation;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">clear_annotation(node, annotation) {</span>
    <span class="s0">node._annotations &amp;= ~annotation;</span>
<span class="s0">}</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/). 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">var </span><span class="s0">LATEST_RAW = </span><span class="s2">&quot;&quot;</span><span class="s0">;  </span><span class="s3">// Only used for numbers and template strings</span>
<span class="s1">var </span><span class="s0">TEMPLATE_RAWS = </span><span class="s1">new </span><span class="s0">Map();  </span><span class="s3">// Raw template strings</span>

<span class="s1">var </span><span class="s0">KEYWORDS = </span><span class="s2">&quot;break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">KEYWORDS_ATOM = </span><span class="s2">&quot;false null true&quot;</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">RESERVED_WORDS = </span><span class="s2">&quot;enum import super this &quot; </span><span class="s0">+ KEYWORDS_ATOM + </span><span class="s2">&quot; &quot; </span><span class="s0">+ KEYWORDS;</span>
<span class="s1">var </span><span class="s0">ALL_RESERVED_WORDS = </span><span class="s2">&quot;implements interface package private protected public static &quot; </span><span class="s0">+ RESERVED_WORDS;</span>
<span class="s1">var </span><span class="s0">KEYWORDS_BEFORE_EXPRESSION = </span><span class="s2">&quot;return new delete throw else case yield await&quot;</span><span class="s0">;</span>

<span class="s0">KEYWORDS = makePredicate(KEYWORDS);</span>
<span class="s0">RESERVED_WORDS = makePredicate(RESERVED_WORDS);</span>
<span class="s0">KEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);</span>
<span class="s0">KEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);</span>
<span class="s0">ALL_RESERVED_WORDS = makePredicate(ALL_RESERVED_WORDS);</span>

<span class="s1">var </span><span class="s0">OPERATOR_CHARS = makePredicate(characters(</span><span class="s2">&quot;+-*&amp;%=&lt;&gt;!?|~^&quot;</span><span class="s0">));</span>

<span class="s1">var </span><span class="s0">RE_NUM_LITERAL = /[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">a-f]/i;</span>
<span class="s1">var </span><span class="s0">RE_HEX_NUMBER = /^</span><span class="s4">0</span><span class="s0">x[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">a-f]+$/i;</span>
<span class="s1">var </span><span class="s0">RE_OCT_NUMBER = /^</span><span class="s4">0</span><span class="s0">[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">7</span><span class="s0">]+$/;</span>
<span class="s1">var </span><span class="s0">RE_ES6_OCT_NUMBER = /^</span><span class="s4">0</span><span class="s0">o[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">7</span><span class="s0">]+$/i;</span>
<span class="s1">var </span><span class="s0">RE_BIN_NUMBER = /^</span><span class="s4">0</span><span class="s0">b[</span><span class="s4">01</span><span class="s0">]+$/i;</span>
<span class="s1">var </span><span class="s0">RE_DEC_NUMBER = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i;</span>
<span class="s1">var </span><span class="s0">RE_BIG_INT = /^(</span><span class="s4">0</span><span class="s0">[xob])?[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">a-f]+n$/i;</span>

<span class="s1">var </span><span class="s0">OPERATORS = makePredicate([</span>
    <span class="s2">&quot;in&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;instanceof&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;typeof&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;new&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;void&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;++&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;--&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;+&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;!&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;~&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&amp;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;|&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;^&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;*&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;**&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;/&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;%&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&gt;&gt;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&lt;&lt;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&gt;&gt;&gt;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&lt;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&gt;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&lt;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&gt;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;==&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;===&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;!=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;!==&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;?&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;+=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;||=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&amp;&amp;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;??=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;/=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;*=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;**=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;%=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&gt;&gt;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&lt;&lt;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&gt;&gt;&gt;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;|=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;^=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&amp;=&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;??&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;||&quot;</span><span class="s0">,</span>
<span class="s0">]);</span>

<span class="s1">var </span><span class="s0">WHITESPACE_CHARS = makePredicate(characters(</span><span class="s2">&quot; </span><span class="s5">\u00a0\n\r\t\f\u000b\u200b\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\uFEFF</span><span class="s2">&quot;</span><span class="s0">));</span>

<span class="s1">var </span><span class="s0">NEWLINE_CHARS = makePredicate(characters(</span><span class="s2">&quot;</span><span class="s5">\n\r\u2028\u2029</span><span class="s2">&quot;</span><span class="s0">));</span>

<span class="s1">var </span><span class="s0">PUNC_AFTER_EXPRESSION = makePredicate(characters(</span><span class="s2">&quot;;]),:&quot;</span><span class="s0">));</span>

<span class="s1">var </span><span class="s0">PUNC_BEFORE_EXPRESSION = makePredicate(characters(</span><span class="s2">&quot;[{(,;:&quot;</span><span class="s0">));</span>

<span class="s1">var </span><span class="s0">PUNC_CHARS = makePredicate(characters(</span><span class="s2">&quot;[]{}(),;:&quot;</span><span class="s0">));</span>

<span class="s3">/* -----[ Tokenizer ]----- */</span>

<span class="s3">// surrogate safe regexps adapted from https://github.com/mathiasbynens/unicode-8.0.0/tree/89b412d8a71ecca9ed593d9e9fa073ab64acfebe/Binary_Property</span>
<span class="s1">var </span><span class="s0">UNICODE = {</span>
    <span class="s0">ID_Start: /[$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,</span>
    <span class="s0">ID_Continue: /(?:[$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])+/,</span>
<span class="s0">};</span>

<span class="s1">try </span><span class="s0">{</span>
    <span class="s0">UNICODE = {</span>
        <span class="s3">// https://262.ecma-international.org/13.0/#prod-IdentifierStartChar</span>
        <span class="s3">// $, _, ID_Start</span>
        <span class="s0">ID_Start: </span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">&quot;[_$</span><span class="s5">\\</span><span class="s2">p{ID_Start}]&quot;</span><span class="s0">, </span><span class="s2">&quot;u&quot;</span><span class="s0">),</span>
        <span class="s3">// https://262.ecma-international.org/13.0/#prod-IdentifierPartChar</span>
        <span class="s3">// $, zero-width-joiner, zero-width-non-joiner, ID_Continue</span>
        <span class="s0">ID_Continue: </span><span class="s1">new </span><span class="s0">RegExp(</span><span class="s2">&quot;[$</span><span class="s5">\\</span><span class="s2">u200C</span><span class="s5">\\</span><span class="s2">u200D</span><span class="s5">\\</span><span class="s2">p{ID_Continue}]+&quot;</span><span class="s0">, </span><span class="s2">&quot;u&quot;</span><span class="s0">),</span>
    <span class="s0">};</span>
<span class="s0">} </span><span class="s1">catch</span><span class="s0">(e) {</span>
    <span class="s3">// Could not use modern JS \p{...}. UNICODE is already defined above so let's continue</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">get_full_char(str, pos) {</span>
    <span class="s1">if </span><span class="s0">(is_surrogate_pair_head(str.charCodeAt(pos))) {</span>
        <span class="s1">if </span><span class="s0">(is_surrogate_pair_tail(str.charCodeAt(pos + </span><span class="s4">1</span><span class="s0">))) {</span>
            <span class="s1">return </span><span class="s0">str.charAt(pos) + str.charAt(pos + </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_surrogate_pair_tail(str.charCodeAt(pos))) {</span>
        <span class="s1">if </span><span class="s0">(is_surrogate_pair_head(str.charCodeAt(pos - </span><span class="s4">1</span><span class="s0">))) {</span>
            <span class="s1">return </span><span class="s0">str.charAt(pos - </span><span class="s4">1</span><span class="s0">) + str.charAt(pos);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">str.charAt(pos);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">get_full_char_code(str, pos) {</span>
    <span class="s3">// https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates</span>
    <span class="s1">if </span><span class="s0">(is_surrogate_pair_head(str.charCodeAt(pos))) {</span>
        <span class="s1">return </span><span class="s4">0</span><span class="s0">x10000 + (str.charCodeAt(pos) - </span><span class="s4">0</span><span class="s0">xd800 &lt;&lt; </span><span class="s4">10</span><span class="s0">) + str.charCodeAt(pos + </span><span class="s4">1</span><span class="s0">) - </span><span class="s4">0</span><span class="s0">xdc00;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">str.charCodeAt(pos);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">get_full_char_length(str) {</span>
    <span class="s1">var </span><span class="s0">surrogates = </span><span class="s4">0</span><span class="s0">;</span>

    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; str.length; i++) {</span>
        <span class="s1">if </span><span class="s0">(is_surrogate_pair_head(str.charCodeAt(i)) &amp;&amp; is_surrogate_pair_tail(str.charCodeAt(i + </span><span class="s4">1</span><span class="s0">))) {</span>
            <span class="s0">surrogates++;</span>
            <span class="s0">i++;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">str.length - surrogates;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">from_char_code(code) {</span>
    <span class="s3">// Based on https://github.com/mathiasbynens/String.fromCodePoint/blob/master/fromcodepoint.js</span>
    <span class="s1">if </span><span class="s0">(code &gt; </span><span class="s4">0</span><span class="s0">xFFFF) {</span>
        <span class="s0">code -= </span><span class="s4">0</span><span class="s0">x10000;</span>
        <span class="s1">return </span><span class="s0">(String.fromCharCode((code &gt;&gt; </span><span class="s4">10</span><span class="s0">) + </span><span class="s4">0</span><span class="s0">xD800) +</span>
            <span class="s0">String.fromCharCode((code % </span><span class="s4">0</span><span class="s0">x400) + </span><span class="s4">0</span><span class="s0">xDC00));</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">String.fromCharCode(code);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_surrogate_pair_head(code) {</span>
    <span class="s1">return </span><span class="s0">code &gt;= </span><span class="s4">0</span><span class="s0">xd800 &amp;&amp; code &lt;= </span><span class="s4">0</span><span class="s0">xdbff;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_surrogate_pair_tail(code) {</span>
    <span class="s1">return </span><span class="s0">code &gt;= </span><span class="s4">0</span><span class="s0">xdc00 &amp;&amp; code &lt;= </span><span class="s4">0</span><span class="s0">xdfff;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_digit(code) {</span>
    <span class="s1">return </span><span class="s0">code &gt;= </span><span class="s4">48 </span><span class="s0">&amp;&amp; code &lt;= </span><span class="s4">57</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_identifier_start(ch) {</span>
    <span class="s1">return </span><span class="s0">UNICODE.ID_Start.test(ch);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_identifier_char(ch) {</span>
    <span class="s1">return </span><span class="s0">UNICODE.ID_Continue.test(ch);</span>
<span class="s0">}</span>

<span class="s0">const BASIC_IDENT = /^[a-z_$][a-z0-9_$]*$/i;</span>

<span class="s1">function </span><span class="s0">is_basic_identifier_string(str) {</span>
    <span class="s1">return </span><span class="s0">BASIC_IDENT.test(str);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_identifier_string(str, allow_surrogates) {</span>
    <span class="s1">if </span><span class="s0">(BASIC_IDENT.test(str)) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!allow_surrogates &amp;&amp; /[\ud800-\udfff]/.test(str)) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">match = UNICODE.ID_Start.exec(str);</span>
    <span class="s1">if </span><span class="s0">(!match || match.index !== </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">str = str.slice(match[</span><span class="s4">0</span><span class="s0">].length);</span>
    <span class="s1">if </span><span class="s0">(!str) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">match = UNICODE.ID_Continue.exec(str);</span>
    <span class="s1">return </span><span class="s0">!!match &amp;&amp; match[</span><span class="s4">0</span><span class="s0">].length === str.length;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">parse_js_number(num, allow_e = </span><span class="s1">true</span><span class="s0">) {</span>
    <span class="s1">if </span><span class="s0">(!allow_e &amp;&amp; num.includes(</span><span class="s2">&quot;e&quot;</span><span class="s0">)) {</span>
        <span class="s1">return </span><span class="s0">NaN;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(RE_HEX_NUMBER.test(num)) {</span>
        <span class="s1">return </span><span class="s0">parseInt(num.substr(</span><span class="s4">2</span><span class="s0">), </span><span class="s4">16</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(RE_OCT_NUMBER.test(num)) {</span>
        <span class="s1">return </span><span class="s0">parseInt(num.substr(</span><span class="s4">1</span><span class="s0">), </span><span class="s4">8</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(RE_ES6_OCT_NUMBER.test(num)) {</span>
        <span class="s1">return </span><span class="s0">parseInt(num.substr(</span><span class="s4">2</span><span class="s0">), </span><span class="s4">8</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(RE_BIN_NUMBER.test(num)) {</span>
        <span class="s1">return </span><span class="s0">parseInt(num.substr(</span><span class="s4">2</span><span class="s0">), </span><span class="s4">2</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(RE_DEC_NUMBER.test(num)) {</span>
        <span class="s1">return </span><span class="s0">parseFloat(num);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">val = parseFloat(num);</span>
        <span class="s1">if </span><span class="s0">(val == num) </span><span class="s1">return </span><span class="s0">val;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">class JS_Parse_Error extends Error {</span>
    <span class="s0">constructor(message, filename, line, col, pos) {</span>
        <span class="s0">super();</span>

        <span class="s1">this</span><span class="s0">.name = </span><span class="s2">&quot;SyntaxError&quot;</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.message = message;</span>
        <span class="s1">this</span><span class="s0">.filename = filename;</span>
        <span class="s1">this</span><span class="s0">.line = line;</span>
        <span class="s1">this</span><span class="s0">.col = col;</span>
        <span class="s1">this</span><span class="s0">.pos = pos;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">js_error(message, filename, line, col, pos) {</span>
    <span class="s1">throw new </span><span class="s0">JS_Parse_Error(message, filename, line, col, pos);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_token(token, type, val) {</span>
    <span class="s1">return </span><span class="s0">token.type == type &amp;&amp; (val == </span><span class="s1">null </span><span class="s0">|| token.value == val);</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">EX_EOF = {};</span>

<span class="s1">function </span><span class="s0">tokenizer($TEXT, filename, html5_comments, shebang) {</span>
    <span class="s1">var </span><span class="s0">S = {</span>
        <span class="s0">text            : $TEXT,</span>
        <span class="s0">filename        : filename,</span>
        <span class="s0">pos             : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">tokpos          : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">line            : </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">tokline         : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">col             : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">tokcol          : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">newline_before  : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">regex_allowed   : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">brace_counter   : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">template_braces : [],</span>
        <span class="s0">comments_before : [],</span>
        <span class="s0">directives      : {},</span>
        <span class="s0">directive_stack : []</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">peek() { </span><span class="s1">return </span><span class="s0">get_full_char(S.text, S.pos); }</span>

    <span class="s3">// Used because parsing ?. involves a lookahead for a digit</span>
    <span class="s1">function </span><span class="s0">is_option_chain_op() {</span>
        <span class="s0">const must_be_dot = S.text.charCodeAt(S.pos + </span><span class="s4">1</span><span class="s0">) === </span><span class="s4">46</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!must_be_dot) </span><span class="s1">return false</span><span class="s0">;</span>

        <span class="s0">const cannot_be_digit = S.text.charCodeAt(S.pos + </span><span class="s4">2</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">cannot_be_digit &lt; </span><span class="s4">48 </span><span class="s0">|| cannot_be_digit &gt; </span><span class="s4">57</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">next(signal_eof, in_string) {</span>
        <span class="s1">var </span><span class="s0">ch = get_full_char(S.text, S.pos++);</span>
        <span class="s1">if </span><span class="s0">(signal_eof &amp;&amp; !ch)</span>
            <span class="s1">throw </span><span class="s0">EX_EOF;</span>
        <span class="s1">if </span><span class="s0">(NEWLINE_CHARS.has(ch)) {</span>
            <span class="s0">S.newline_before = S.newline_before || !in_string;</span>
            <span class="s0">++S.line;</span>
            <span class="s0">S.col = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(ch == </span><span class="s2">&quot;</span><span class="s5">\r</span><span class="s2">&quot; </span><span class="s0">&amp;&amp; peek() == </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">) {</span>
                <span class="s3">// treat a \r\n sequence as a single \n</span>
                <span class="s0">++S.pos;</span>
                <span class="s0">ch = </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(ch.length &gt; </span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s0">++S.pos;</span>
                <span class="s0">++S.col;</span>
            <span class="s0">}</span>
            <span class="s0">++S.col;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ch;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">forward(i) {</span>
        <span class="s1">while </span><span class="s0">(i--) next();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">looking_at(str) {</span>
        <span class="s1">return </span><span class="s0">S.text.substr(S.pos, str.length) == str;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">find_eol() {</span>
        <span class="s1">var </span><span class="s0">text = S.text;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = S.pos, n = S.text.length; i &lt; n; ++i) {</span>
            <span class="s1">var </span><span class="s0">ch = text[i];</span>
            <span class="s1">if </span><span class="s0">(NEWLINE_CHARS.has(ch))</span>
                <span class="s1">return </span><span class="s0">i;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">find(what, signal_eof) {</span>
        <span class="s1">var </span><span class="s0">pos = S.text.indexOf(what, S.pos);</span>
        <span class="s1">if </span><span class="s0">(signal_eof &amp;&amp; pos == -</span><span class="s4">1</span><span class="s0">) </span><span class="s1">throw </span><span class="s0">EX_EOF;</span>
        <span class="s1">return </span><span class="s0">pos;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">start_token() {</span>
        <span class="s0">S.tokline = S.line;</span>
        <span class="s0">S.tokcol = S.col;</span>
        <span class="s0">S.tokpos = S.pos;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">prev_was_dot = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">previous_token = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">token(type, value, is_comment) {</span>
        <span class="s0">S.regex_allowed = ((type == </span><span class="s2">&quot;operator&quot; </span><span class="s0">&amp;&amp; !UNARY_POSTFIX.has(value)) ||</span>
                           <span class="s0">(type == </span><span class="s2">&quot;keyword&quot; </span><span class="s0">&amp;&amp; KEYWORDS_BEFORE_EXPRESSION.has(value)) ||</span>
                           <span class="s0">(type == </span><span class="s2">&quot;punc&quot; </span><span class="s0">&amp;&amp; PUNC_BEFORE_EXPRESSION.has(value))) ||</span>
                           <span class="s0">(type == </span><span class="s2">&quot;arrow&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(type == </span><span class="s2">&quot;punc&quot; </span><span class="s0">&amp;&amp; (value == </span><span class="s2">&quot;.&quot; </span><span class="s0">|| value == </span><span class="s2">&quot;?.&quot;</span><span class="s0">)) {</span>
            <span class="s0">prev_was_dot = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!is_comment) {</span>
            <span class="s0">prev_was_dot = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">const line     = S.tokline;</span>
        <span class="s0">const col      = S.tokcol;</span>
        <span class="s0">const pos      = S.tokpos;</span>
        <span class="s0">const nlb      = S.newline_before;</span>
        <span class="s0">const file     = filename;</span>
        <span class="s0">let comments_before = [];</span>
        <span class="s0">let comments_after  = [];</span>

        <span class="s1">if </span><span class="s0">(!is_comment) {</span>
            <span class="s0">comments_before = S.comments_before;</span>
            <span class="s0">comments_after = S.comments_before = [];</span>
        <span class="s0">}</span>
        <span class="s0">S.newline_before = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">const tok = </span><span class="s1">new </span><span class="s0">AST_Token(type, value, line, col, pos, nlb, comments_before, comments_after, file);</span>

        <span class="s1">if </span><span class="s0">(!is_comment) previous_token = tok;</span>
        <span class="s1">return </span><span class="s0">tok;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">skip_whitespace() {</span>
        <span class="s1">while </span><span class="s0">(WHITESPACE_CHARS.has(peek()))</span>
            <span class="s0">next();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">read_while(pred) {</span>
        <span class="s1">var </span><span class="s0">ret = </span><span class="s2">&quot;&quot;</span><span class="s0">, ch, i = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">((ch = peek()) &amp;&amp; pred(ch, i++))</span>
            <span class="s0">ret += next();</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">parse_error(err) {</span>
        <span class="s0">js_error(err, filename, S.tokline, S.tokcol, S.tokpos);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">read_num(prefix) {</span>
        <span class="s1">var </span><span class="s0">has_e = </span><span class="s1">false</span><span class="s0">, after_e = </span><span class="s1">false</span><span class="s0">, has_x = </span><span class="s1">false</span><span class="s0">, has_dot = prefix == </span><span class="s2">&quot;.&quot;</span><span class="s0">, is_big_int = </span><span class="s1">false</span><span class="s0">, numeric_separator = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">num = read_while(</span><span class="s1">function</span><span class="s0">(ch, i) {</span>
            <span class="s1">if </span><span class="s0">(is_big_int) </span><span class="s1">return false</span><span class="s0">;</span>

            <span class="s1">var </span><span class="s0">code = ch.charCodeAt(</span><span class="s4">0</span><span class="s0">);</span>
            <span class="s1">switch </span><span class="s0">(code) {</span>
              <span class="s1">case </span><span class="s4">95</span><span class="s0">: </span><span class="s3">// _</span>
                <span class="s1">return </span><span class="s0">(numeric_separator = </span><span class="s1">true</span><span class="s0">);</span>
              <span class="s1">case </span><span class="s4">98</span><span class="s0">: </span><span class="s1">case </span><span class="s4">66</span><span class="s0">: </span><span class="s3">// bB</span>
                <span class="s1">return </span><span class="s0">(has_x = </span><span class="s1">true</span><span class="s0">); </span><span class="s3">// Can occur in hex sequence, don't return false yet</span>
              <span class="s1">case </span><span class="s4">111</span><span class="s0">: </span><span class="s1">case </span><span class="s4">79</span><span class="s0">: </span><span class="s3">// oO</span>
              <span class="s1">case </span><span class="s4">120</span><span class="s0">: </span><span class="s1">case </span><span class="s4">88</span><span class="s0">: </span><span class="s3">// xX</span>
                <span class="s1">return </span><span class="s0">has_x ? </span><span class="s1">false </span><span class="s0">: (has_x = </span><span class="s1">true</span><span class="s0">);</span>
              <span class="s1">case </span><span class="s4">101</span><span class="s0">: </span><span class="s1">case </span><span class="s4">69</span><span class="s0">: </span><span class="s3">// eE</span>
                <span class="s1">return </span><span class="s0">has_x ? </span><span class="s1">true </span><span class="s0">: has_e ? </span><span class="s1">false </span><span class="s0">: (has_e = after_e = </span><span class="s1">true</span><span class="s0">);</span>
              <span class="s1">case </span><span class="s4">45</span><span class="s0">: </span><span class="s3">// -</span>
                <span class="s1">return </span><span class="s0">after_e || (i == </span><span class="s4">0 </span><span class="s0">&amp;&amp; !prefix);</span>
              <span class="s1">case </span><span class="s4">43</span><span class="s0">: </span><span class="s3">// +</span>
                <span class="s1">return </span><span class="s0">after_e;</span>
              <span class="s1">case </span><span class="s0">(after_e = </span><span class="s1">false</span><span class="s0">, </span><span class="s4">46</span><span class="s0">): </span><span class="s3">// .</span>
                <span class="s1">return </span><span class="s0">(!has_dot &amp;&amp; !has_x &amp;&amp; !has_e) ? (has_dot = </span><span class="s1">true</span><span class="s0">) : </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(ch === </span><span class="s2">&quot;n&quot;</span><span class="s0">) {</span>
                <span class="s0">is_big_int = </span><span class="s1">true</span><span class="s0">;</span>

                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">return </span><span class="s0">RE_NUM_LITERAL.test(ch);</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(prefix) num = prefix + num;</span>

        <span class="s0">LATEST_RAW = num;</span>

        <span class="s1">if </span><span class="s0">(RE_OCT_NUMBER.test(num) &amp;&amp; next_token.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)) {</span>
            <span class="s0">parse_error(</span><span class="s2">&quot;Legacy octal literals are not allowed in strict mode&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(numeric_separator) {</span>
            <span class="s1">if </span><span class="s0">(num.endsWith(</span><span class="s2">&quot;_&quot;</span><span class="s0">)) {</span>
                <span class="s0">parse_error(</span><span class="s2">&quot;Numeric separators are not allowed at the end of numeric literals&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(num.includes(</span><span class="s2">&quot;__&quot;</span><span class="s0">)) {</span>
                <span class="s0">parse_error(</span><span class="s2">&quot;Only one underscore is allowed as numeric separator&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">num = num.replace(/_/g, </span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(num.endsWith(</span><span class="s2">&quot;n&quot;</span><span class="s0">)) {</span>
            <span class="s0">const without_n = num.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">const allow_e = RE_HEX_NUMBER.test(without_n);</span>
            <span class="s0">const valid = parse_js_number(without_n, allow_e);</span>
            <span class="s1">if </span><span class="s0">(!has_dot &amp;&amp; RE_BIG_INT.test(num) &amp;&amp; !isNaN(valid))</span>
                <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;big_int&quot;</span><span class="s0">, without_n);</span>
            <span class="s0">parse_error(</span><span class="s2">&quot;Invalid or unexpected token&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">valid = parse_js_number(num);</span>
        <span class="s1">if </span><span class="s0">(!isNaN(valid)) {</span>
            <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;num&quot;</span><span class="s0">, valid);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">parse_error(</span><span class="s2">&quot;Invalid syntax: &quot; </span><span class="s0">+ num);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">is_octal(ch) {</span>
        <span class="s1">return </span><span class="s0">ch &gt;= </span><span class="s2">&quot;0&quot; </span><span class="s0">&amp;&amp; ch &lt;= </span><span class="s2">&quot;7&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">read_escaped_char(in_string, strict_hex, template_string) {</span>
        <span class="s1">var </span><span class="s0">ch = next(</span><span class="s1">true</span><span class="s0">, in_string);</span>
        <span class="s1">switch </span><span class="s0">(ch.charCodeAt(</span><span class="s4">0</span><span class="s0">)) {</span>
          <span class="s1">case </span><span class="s4">110 </span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s4">114 </span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\r</span><span class="s2">&quot;</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s4">116 </span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\t</span><span class="s2">&quot;</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s4">98  </span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\b</span><span class="s2">&quot;</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s4">118 </span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\u000b</span><span class="s2">&quot;</span><span class="s0">; </span><span class="s3">// \v</span>
          <span class="s1">case </span><span class="s4">102 </span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\f</span><span class="s2">&quot;</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s4">120 </span><span class="s0">: </span><span class="s1">return </span><span class="s0">String.fromCharCode(hex_bytes(</span><span class="s4">2</span><span class="s0">, strict_hex)); </span><span class="s3">// \x</span>
          <span class="s1">case </span><span class="s4">117 </span><span class="s0">: </span><span class="s3">// \u</span>
            <span class="s1">if </span><span class="s0">(peek() == </span><span class="s2">&quot;{&quot;</span><span class="s0">) {</span>
                <span class="s0">next(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(peek() === </span><span class="s2">&quot;}&quot;</span><span class="s0">)</span>
                    <span class="s0">parse_error(</span><span class="s2">&quot;Expecting hex-character between {}&quot;</span><span class="s0">);</span>
                <span class="s1">while </span><span class="s0">(peek() == </span><span class="s2">&quot;0&quot;</span><span class="s0">) next(</span><span class="s1">true</span><span class="s0">); </span><span class="s3">// No significance</span>
                <span class="s1">var </span><span class="s0">result, length = find(</span><span class="s2">&quot;}&quot;</span><span class="s0">, </span><span class="s1">true</span><span class="s0">) - S.pos;</span>
                <span class="s3">// Avoid 32 bit integer overflow (1 &lt;&lt; 32 === 1)</span>
                <span class="s3">// We know first character isn't 0 and thus out of range anyway</span>
                <span class="s1">if </span><span class="s0">(length &gt; </span><span class="s4">6 </span><span class="s0">|| (result = hex_bytes(length, strict_hex)) &gt; </span><span class="s4">0</span><span class="s0">x10FFFF) {</span>
                    <span class="s0">parse_error(</span><span class="s2">&quot;Unicode reference out of bounds&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">next(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">from_char_code(result);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">String.fromCharCode(hex_bytes(</span><span class="s4">4</span><span class="s0">, strict_hex));</span>
          <span class="s1">case </span><span class="s4">10  </span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">; </span><span class="s3">// newline</span>
          <span class="s1">case </span><span class="s4">13  </span><span class="s0">:            </span><span class="s3">// \r</span>
            <span class="s1">if </span><span class="s0">(peek() == </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">) { </span><span class="s3">// DOS newline</span>
                <span class="s0">next(</span><span class="s1">true</span><span class="s0">, in_string);</span>
                <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is_octal(ch)) {</span>
            <span class="s1">if </span><span class="s0">(template_string &amp;&amp; strict_hex) {</span>
                <span class="s0">const represents_null_character = ch === </span><span class="s2">&quot;0&quot; </span><span class="s0">&amp;&amp; !is_octal(peek());</span>
                <span class="s1">if </span><span class="s0">(!represents_null_character) {</span>
                    <span class="s0">parse_error(</span><span class="s2">&quot;Octal escape sequences are not allowed in template strings&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">read_octal_escape_sequence(ch, strict_hex);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ch;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">read_octal_escape_sequence(ch, strict_octal) {</span>
        <span class="s3">// Read</span>
        <span class="s1">var </span><span class="s0">p = peek();</span>
        <span class="s1">if </span><span class="s0">(p &gt;= </span><span class="s2">&quot;0&quot; </span><span class="s0">&amp;&amp; p &lt;= </span><span class="s2">&quot;7&quot;</span><span class="s0">) {</span>
            <span class="s0">ch += next(</span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(ch[</span><span class="s4">0</span><span class="s0">] &lt;= </span><span class="s2">&quot;3&quot; </span><span class="s0">&amp;&amp; (p = peek()) &gt;= </span><span class="s2">&quot;0&quot; </span><span class="s0">&amp;&amp; p &lt;= </span><span class="s2">&quot;7&quot;</span><span class="s0">)</span>
                <span class="s0">ch += next(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s3">// Parse</span>
        <span class="s1">if </span><span class="s0">(ch === </span><span class="s2">&quot;0&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\0</span><span class="s2">&quot;</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(ch.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; next_token.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">) &amp;&amp; strict_octal)</span>
            <span class="s0">parse_error(</span><span class="s2">&quot;Legacy octal escape sequences are not allowed in strict mode&quot;</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">String.fromCharCode(parseInt(ch, </span><span class="s4">8</span><span class="s0">));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">hex_bytes(n, strict_hex) {</span>
        <span class="s1">var </span><span class="s0">num = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(; n &gt; </span><span class="s4">0</span><span class="s0">; --n) {</span>
            <span class="s1">if </span><span class="s0">(!strict_hex &amp;&amp; isNaN(parseInt(peek(), </span><span class="s4">16</span><span class="s0">))) {</span>
                <span class="s1">return </span><span class="s0">parseInt(num, </span><span class="s4">16</span><span class="s0">) || </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">digit = next(</span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(isNaN(parseInt(digit, </span><span class="s4">16</span><span class="s0">)))</span>
                <span class="s0">parse_error(</span><span class="s2">&quot;Invalid hex-character pattern in string&quot;</span><span class="s0">);</span>
            <span class="s0">num += digit;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">parseInt(num, </span><span class="s4">16</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">read_string = with_eof_error(</span><span class="s2">&quot;Unterminated string constant&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">const start_pos = S.pos;</span>
        <span class="s1">var </span><span class="s0">quote = next(), ret = [];</span>
        <span class="s1">for </span><span class="s0">(;;) {</span>
            <span class="s1">var </span><span class="s0">ch = next(</span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(ch == </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">) ch = read_escaped_char(</span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">else if </span><span class="s0">(ch == </span><span class="s2">&quot;</span><span class="s5">\r</span><span class="s2">&quot; </span><span class="s0">|| ch == </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">) parse_error(</span><span class="s2">&quot;Unterminated string constant&quot;</span><span class="s0">);</span>
            <span class="s1">else if </span><span class="s0">(ch == quote) </span><span class="s1">break</span><span class="s0">;</span>
            <span class="s0">ret.push(ch);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">tok = token(</span><span class="s2">&quot;string&quot;</span><span class="s0">, ret.join(</span><span class="s2">&quot;&quot;</span><span class="s0">));</span>
        <span class="s0">LATEST_RAW = S.text.slice(start_pos, S.pos);</span>
        <span class="s0">tok.quote = quote;</span>
        <span class="s1">return </span><span class="s0">tok;</span>
    <span class="s0">});</span>

    <span class="s1">var </span><span class="s0">read_template_characters = with_eof_error(</span><span class="s2">&quot;Unterminated template&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(begin) {</span>
        <span class="s1">if </span><span class="s0">(begin) {</span>
            <span class="s0">S.template_braces.push(S.brace_counter);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">content = </span><span class="s2">&quot;&quot;</span><span class="s0">, raw = </span><span class="s2">&quot;&quot;</span><span class="s0">, ch, tok;</span>
        <span class="s0">next(</span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">while </span><span class="s0">((ch = next(</span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">)) != </span><span class="s2">&quot;`&quot;</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(ch == </span><span class="s2">&quot;</span><span class="s5">\r</span><span class="s2">&quot;</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(peek() == </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">) ++S.pos;</span>
                <span class="s0">ch = </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ch == </span><span class="s2">&quot;$&quot; </span><span class="s0">&amp;&amp; peek() == </span><span class="s2">&quot;{&quot;</span><span class="s0">) {</span>
                <span class="s0">next(</span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">S.brace_counter++;</span>
                <span class="s0">tok = token(begin ? </span><span class="s2">&quot;template_head&quot; </span><span class="s0">: </span><span class="s2">&quot;template_substitution&quot;</span><span class="s0">, content);</span>
                <span class="s0">TEMPLATE_RAWS.set(tok, raw);</span>
                <span class="s0">tok.template_end = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">tok;</span>
            <span class="s0">}</span>

            <span class="s0">raw += ch;</span>
            <span class="s1">if </span><span class="s0">(ch == </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">tmp = S.pos;</span>
                <span class="s1">var </span><span class="s0">prev_is_tag = previous_token &amp;&amp; (previous_token.type === </span><span class="s2">&quot;name&quot; </span><span class="s0">|| previous_token.type === </span><span class="s2">&quot;punc&quot; </span><span class="s0">&amp;&amp; (previous_token.value === </span><span class="s2">&quot;)&quot; </span><span class="s0">|| previous_token.value === </span><span class="s2">&quot;]&quot;</span><span class="s0">));</span>
                <span class="s0">ch = read_escaped_char(</span><span class="s1">true</span><span class="s0">, !prev_is_tag, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">raw += S.text.substr(tmp, S.pos - tmp);</span>
            <span class="s0">}</span>

            <span class="s0">content += ch;</span>
        <span class="s0">}</span>
        <span class="s0">S.template_braces.pop();</span>
        <span class="s0">tok = token(begin ? </span><span class="s2">&quot;template_head&quot; </span><span class="s0">: </span><span class="s2">&quot;template_substitution&quot;</span><span class="s0">, content);</span>
        <span class="s0">TEMPLATE_RAWS.set(tok, raw);</span>
        <span class="s0">tok.template_end = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">tok;</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">skip_line_comment(type) {</span>
        <span class="s1">var </span><span class="s0">regex_allowed = S.regex_allowed;</span>
        <span class="s1">var </span><span class="s0">i = find_eol(), ret;</span>
        <span class="s1">if </span><span class="s0">(i == -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s0">ret = S.text.substr(S.pos);</span>
            <span class="s0">S.pos = S.text.length;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">ret = S.text.substring(S.pos, i);</span>
            <span class="s0">S.pos = i;</span>
        <span class="s0">}</span>
        <span class="s0">S.col = S.tokcol + (S.pos - S.tokpos);</span>
        <span class="s0">S.comments_before.push(token(type, ret, </span><span class="s1">true</span><span class="s0">));</span>
        <span class="s0">S.regex_allowed = regex_allowed;</span>
        <span class="s1">return </span><span class="s0">next_token;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">skip_multiline_comment = with_eof_error(</span><span class="s2">&quot;Unterminated multiline comment&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">var </span><span class="s0">regex_allowed = S.regex_allowed;</span>
        <span class="s1">var </span><span class="s0">i = find(</span><span class="s2">&quot;*/&quot;</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">text = S.text.substring(S.pos, i).replace(/\r\n|\r|\u2028|\u2029/g, </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
        <span class="s3">// update stream position</span>
        <span class="s0">forward(get_full_char_length(text) </span><span class="s3">/* text length doesn't count \r\n as 2 char while S.pos - i does */ </span><span class="s0">+ </span><span class="s4">2</span><span class="s0">);</span>
        <span class="s0">S.comments_before.push(token(</span><span class="s2">&quot;comment2&quot;</span><span class="s0">, text, </span><span class="s1">true</span><span class="s0">));</span>
        <span class="s0">S.newline_before = S.newline_before || text.includes(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
        <span class="s0">S.regex_allowed = regex_allowed;</span>
        <span class="s1">return </span><span class="s0">next_token;</span>
    <span class="s0">});</span>

    <span class="s1">var </span><span class="s0">read_name = with_eof_error(</span><span class="s2">&quot;Unterminated identifier name&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">var </span><span class="s0">name = [], ch, escaped = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">read_escaped_identifier_char = </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">escaped = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">next();</span>
            <span class="s1">if </span><span class="s0">(peek() !== </span><span class="s2">&quot;u&quot;</span><span class="s0">) {</span>
                <span class="s0">parse_error(</span><span class="s2">&quot;Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">read_escaped_char(</span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">};</span>

        <span class="s3">// Read first character (ID_Start)</span>
        <span class="s1">if </span><span class="s0">((ch = peek()) === </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">) {</span>
            <span class="s0">ch = read_escaped_identifier_char();</span>
            <span class="s1">if </span><span class="s0">(!is_identifier_start(ch)) {</span>
                <span class="s0">parse_error(</span><span class="s2">&quot;First identifier char is an invalid identifier char&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_identifier_start(ch)) {</span>
            <span class="s0">next();</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">name.push(ch);</span>

        <span class="s3">// Read ID_Continue</span>
        <span class="s1">while </span><span class="s0">((ch = peek()) != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">((ch = peek()) === </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">) {</span>
                <span class="s0">ch = read_escaped_identifier_char();</span>
                <span class="s1">if </span><span class="s0">(!is_identifier_char(ch)) {</span>
                    <span class="s0">parse_error(</span><span class="s2">&quot;Invalid escaped identifier char&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(!is_identifier_char(ch)) {</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">next();</span>
            <span class="s0">}</span>
            <span class="s0">name.push(ch);</span>
        <span class="s0">}</span>
        <span class="s0">const name_str = name.join(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(RESERVED_WORDS.has(name_str) &amp;&amp; escaped) {</span>
            <span class="s0">parse_error(</span><span class="s2">&quot;Escaped characters are not allowed in keywords&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">name_str;</span>
    <span class="s0">});</span>

    <span class="s1">var </span><span class="s0">read_regexp = with_eof_error(</span><span class="s2">&quot;Unterminated regular expression&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(source) {</span>
        <span class="s1">var </span><span class="s0">prev_backslash = </span><span class="s1">false</span><span class="s0">, ch, in_class = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">((ch = next(</span><span class="s1">true</span><span class="s0">))) </span><span class="s1">if </span><span class="s0">(NEWLINE_CHARS.has(ch)) {</span>
            <span class="s0">parse_error(</span><span class="s2">&quot;Unexpected line terminator&quot;</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prev_backslash) {</span>
            <span class="s0">source += </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot; </span><span class="s0">+ ch;</span>
            <span class="s0">prev_backslash = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ch == </span><span class="s2">&quot;[&quot;</span><span class="s0">) {</span>
            <span class="s0">in_class = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">source += ch;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ch == </span><span class="s2">&quot;]&quot; </span><span class="s0">&amp;&amp; in_class) {</span>
            <span class="s0">in_class = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">source += ch;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ch == </span><span class="s2">&quot;/&quot; </span><span class="s0">&amp;&amp; !in_class) {</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ch == </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">) {</span>
            <span class="s0">prev_backslash = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">source += ch;</span>
        <span class="s0">}</span>
        <span class="s0">const flags = read_name();</span>
        <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;regexp&quot;</span><span class="s0">, </span><span class="s2">&quot;/&quot; </span><span class="s0">+ source + </span><span class="s2">&quot;/&quot; </span><span class="s0">+ flags);</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">read_operator(prefix) {</span>
        <span class="s1">function </span><span class="s0">grow(op) {</span>
            <span class="s1">if </span><span class="s0">(!peek()) </span><span class="s1">return </span><span class="s0">op;</span>
            <span class="s1">var </span><span class="s0">bigger = op + peek();</span>
            <span class="s1">if </span><span class="s0">(OPERATORS.has(bigger)) {</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">grow(bigger);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">op;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, grow(prefix || next()));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">handle_slash() {</span>
        <span class="s0">next();</span>
        <span class="s1">switch </span><span class="s0">(peek()) {</span>
          <span class="s1">case </span><span class="s2">&quot;/&quot;</span><span class="s0">:</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">skip_line_comment(</span><span class="s2">&quot;comment1&quot;</span><span class="s0">);</span>
          <span class="s1">case </span><span class="s2">&quot;*&quot;</span><span class="s0">:</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">skip_multiline_comment();</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">S.regex_allowed ? read_regexp(</span><span class="s2">&quot;&quot;</span><span class="s0">) : read_operator(</span><span class="s2">&quot;/&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">handle_eq_sign() {</span>
        <span class="s0">next();</span>
        <span class="s1">if </span><span class="s0">(peek() === </span><span class="s2">&quot;&gt;&quot;</span><span class="s0">) {</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;arrow&quot;</span><span class="s0">, </span><span class="s2">&quot;=&gt;&quot;</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">read_operator(</span><span class="s2">&quot;=&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">handle_dot() {</span>
        <span class="s0">next();</span>
        <span class="s1">if </span><span class="s0">(is_digit(peek().charCodeAt(</span><span class="s4">0</span><span class="s0">))) {</span>
            <span class="s1">return </span><span class="s0">read_num(</span><span class="s2">&quot;.&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(peek() === </span><span class="s2">&quot;.&quot;</span><span class="s0">) {</span>
            <span class="s0">next();  </span><span class="s3">// Consume second dot</span>
            <span class="s0">next();  </span><span class="s3">// Consume third dot</span>
            <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;expand&quot;</span><span class="s0">, </span><span class="s2">&quot;...&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">read_word() {</span>
        <span class="s1">var </span><span class="s0">word = read_name();</span>
        <span class="s1">if </span><span class="s0">(prev_was_dot) </span><span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;name&quot;</span><span class="s0">, word);</span>
        <span class="s1">return </span><span class="s0">KEYWORDS_ATOM.has(word) ? token(</span><span class="s2">&quot;atom&quot;</span><span class="s0">, word)</span>
            <span class="s0">: !KEYWORDS.has(word) ? token(</span><span class="s2">&quot;name&quot;</span><span class="s0">, word)</span>
            <span class="s0">: OPERATORS.has(word) ? token(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, word)</span>
            <span class="s0">: token(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, word);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">read_private_word() {</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">, read_name());</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">with_eof_error(eof_error, cont) {</span>
        <span class="s1">return function</span><span class="s0">(x) {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">cont(x);</span>
            <span class="s0">} </span><span class="s1">catch</span><span class="s0">(ex) {</span>
                <span class="s1">if </span><span class="s0">(ex === EX_EOF) parse_error(eof_error);</span>
                <span class="s1">else throw </span><span class="s0">ex;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">next_token(force_regexp) {</span>
        <span class="s1">if </span><span class="s0">(force_regexp != </span><span class="s1">null</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">read_regexp(force_regexp);</span>
        <span class="s1">if </span><span class="s0">(shebang &amp;&amp; S.pos == </span><span class="s4">0 </span><span class="s0">&amp;&amp; looking_at(</span><span class="s2">&quot;#!&quot;</span><span class="s0">)) {</span>
            <span class="s0">start_token();</span>
            <span class="s0">forward(</span><span class="s4">2</span><span class="s0">);</span>
            <span class="s0">skip_line_comment(</span><span class="s2">&quot;comment5&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(;;) {</span>
            <span class="s0">skip_whitespace();</span>
            <span class="s0">start_token();</span>
            <span class="s1">if </span><span class="s0">(html5_comments) {</span>
                <span class="s1">if </span><span class="s0">(looking_at(</span><span class="s2">&quot;&lt;!--&quot;</span><span class="s0">)) {</span>
                    <span class="s0">forward(</span><span class="s4">4</span><span class="s0">);</span>
                    <span class="s0">skip_line_comment(</span><span class="s2">&quot;comment3&quot;</span><span class="s0">);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(looking_at(</span><span class="s2">&quot;--&gt;&quot;</span><span class="s0">) &amp;&amp; S.newline_before) {</span>
                    <span class="s0">forward(</span><span class="s4">3</span><span class="s0">);</span>
                    <span class="s0">skip_line_comment(</span><span class="s2">&quot;comment4&quot;</span><span class="s0">);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">ch = peek();</span>
            <span class="s1">if </span><span class="s0">(!ch) </span><span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;eof&quot;</span><span class="s0">);</span>
            <span class="s1">var </span><span class="s0">code = ch.charCodeAt(</span><span class="s4">0</span><span class="s0">);</span>
            <span class="s1">switch </span><span class="s0">(code) {</span>
              <span class="s1">case </span><span class="s4">34</span><span class="s0">: </span><span class="s1">case </span><span class="s4">39</span><span class="s0">: </span><span class="s1">return </span><span class="s0">read_string();</span>
              <span class="s1">case </span><span class="s4">46</span><span class="s0">: </span><span class="s1">return </span><span class="s0">handle_dot();</span>
              <span class="s1">case </span><span class="s4">47</span><span class="s0">: {</span>
                  <span class="s1">var </span><span class="s0">tok = handle_slash();</span>
                  <span class="s1">if </span><span class="s0">(tok === next_token) </span><span class="s1">continue</span><span class="s0">;</span>
                  <span class="s1">return </span><span class="s0">tok;</span>
              <span class="s0">}</span>
              <span class="s1">case </span><span class="s4">61</span><span class="s0">: </span><span class="s1">return </span><span class="s0">handle_eq_sign();</span>
              <span class="s1">case </span><span class="s4">63</span><span class="s0">: {</span>
                  <span class="s1">if </span><span class="s0">(!is_option_chain_op()) </span><span class="s1">break</span><span class="s0">;  </span><span class="s3">// Handled below</span>

                  <span class="s0">next(); </span><span class="s3">// ?</span>
                  <span class="s0">next(); </span><span class="s3">// .</span>

                  <span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;?.&quot;</span><span class="s0">);</span>
              <span class="s0">}</span>
              <span class="s1">case </span><span class="s4">96</span><span class="s0">: </span><span class="s1">return </span><span class="s0">read_template_characters(</span><span class="s1">true</span><span class="s0">);</span>
              <span class="s1">case </span><span class="s4">123</span><span class="s0">:</span>
                <span class="s0">S.brace_counter++;</span>
                <span class="s1">break</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s4">125</span><span class="s0">:</span>
                <span class="s0">S.brace_counter--;</span>
                <span class="s1">if </span><span class="s0">(S.template_braces.length &gt; </span><span class="s4">0</span>
                    <span class="s0">&amp;&amp; S.template_braces[S.template_braces.length - </span><span class="s4">1</span><span class="s0">] === S.brace_counter)</span>
                    <span class="s1">return </span><span class="s0">read_template_characters(</span><span class="s1">false</span><span class="s0">);</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(is_digit(code)) </span><span class="s1">return </span><span class="s0">read_num();</span>
            <span class="s1">if </span><span class="s0">(PUNC_CHARS.has(ch)) </span><span class="s1">return </span><span class="s0">token(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, next());</span>
            <span class="s1">if </span><span class="s0">(OPERATOR_CHARS.has(ch)) </span><span class="s1">return </span><span class="s0">read_operator();</span>
            <span class="s1">if </span><span class="s0">(code == </span><span class="s4">92 </span><span class="s0">|| is_identifier_start(ch)) </span><span class="s1">return </span><span class="s0">read_word();</span>
            <span class="s1">if </span><span class="s0">(code == </span><span class="s4">35</span><span class="s0">) </span><span class="s1">return </span><span class="s0">read_private_word();</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">parse_error(</span><span class="s2">&quot;Unexpected character '&quot; </span><span class="s0">+ ch + </span><span class="s2">&quot;'&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">next_token.next = next;</span>
    <span class="s0">next_token.peek = peek;</span>

    <span class="s0">next_token.context = </span><span class="s1">function</span><span class="s0">(nc) {</span>
        <span class="s1">if </span><span class="s0">(nc) S = nc;</span>
        <span class="s1">return </span><span class="s0">S;</span>
    <span class="s0">};</span>

    <span class="s0">next_token.add_directive = </span><span class="s1">function</span><span class="s0">(directive) {</span>
        <span class="s0">S.directive_stack[S.directive_stack.length - </span><span class="s4">1</span><span class="s0">].push(directive);</span>

        <span class="s1">if </span><span class="s0">(S.directives[directive] === undefined) {</span>
            <span class="s0">S.directives[directive] = </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">S.directives[directive]++;</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s0">next_token.push_directives_stack = </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">S.directive_stack.push([]);</span>
    <span class="s0">};</span>

    <span class="s0">next_token.pop_directives_stack = </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">var </span><span class="s0">directives = S.directive_stack[S.directive_stack.length - </span><span class="s4">1</span><span class="s0">];</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; directives.length; i++) {</span>
            <span class="s0">S.directives[directives[i]]--;</span>
        <span class="s0">}</span>

        <span class="s0">S.directive_stack.pop();</span>
    <span class="s0">};</span>

    <span class="s0">next_token.has_directive = </span><span class="s1">function</span><span class="s0">(directive) {</span>
        <span class="s1">return </span><span class="s0">S.directives[directive] &gt; </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">return </span><span class="s0">next_token;</span>

<span class="s0">}</span>

<span class="s3">/* -----[ Parser (constants) ]----- */</span>

<span class="s1">var </span><span class="s0">UNARY_PREFIX = makePredicate([</span>
    <span class="s2">&quot;typeof&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;void&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;--&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;++&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;!&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;~&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;+&quot;</span>
<span class="s0">]);</span>

<span class="s1">var </span><span class="s0">UNARY_POSTFIX = makePredicate([ </span><span class="s2">&quot;--&quot;</span><span class="s0">, </span><span class="s2">&quot;++&quot; </span><span class="s0">]);</span>

<span class="s1">var </span><span class="s0">ASSIGNMENT = makePredicate([ </span><span class="s2">&quot;=&quot;</span><span class="s0">, </span><span class="s2">&quot;+=&quot;</span><span class="s0">, </span><span class="s2">&quot;-=&quot;</span><span class="s0">, </span><span class="s2">&quot;??=&quot;</span><span class="s0">, </span><span class="s2">&quot;&amp;&amp;=&quot;</span><span class="s0">, </span><span class="s2">&quot;||=&quot;</span><span class="s0">, </span><span class="s2">&quot;/=&quot;</span><span class="s0">, </span><span class="s2">&quot;*=&quot;</span><span class="s0">, </span><span class="s2">&quot;**=&quot;</span><span class="s0">, </span><span class="s2">&quot;%=&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&gt;=&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;&lt;=&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&gt;&gt;=&quot;</span><span class="s0">, </span><span class="s2">&quot;|=&quot;</span><span class="s0">, </span><span class="s2">&quot;^=&quot;</span><span class="s0">, </span><span class="s2">&quot;&amp;=&quot; </span><span class="s0">]);</span>

<span class="s1">var </span><span class="s0">LOGICAL_ASSIGNMENT = makePredicate([ </span><span class="s2">&quot;??=&quot;</span><span class="s0">, </span><span class="s2">&quot;&amp;&amp;=&quot;</span><span class="s0">, </span><span class="s2">&quot;||=&quot; </span><span class="s0">]);</span>

<span class="s1">var </span><span class="s0">PRECEDENCE = (</span><span class="s1">function</span><span class="s0">(a, ret) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; a.length; ++i) {</span>
        <span class="s1">var </span><span class="s0">b = a[i];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">; j &lt; b.length; ++j) {</span>
            <span class="s0">ret[b[j]] = i + </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">ret;</span>
<span class="s0">})(</span>
    <span class="s0">[</span>
        <span class="s0">[</span><span class="s2">&quot;||&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;??&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;|&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;^&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;&amp;&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;==&quot;</span><span class="s0">, </span><span class="s2">&quot;===&quot;</span><span class="s0">, </span><span class="s2">&quot;!=&quot;</span><span class="s0">, </span><span class="s2">&quot;!==&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">, </span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;instanceof&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;&gt;&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&gt;&gt;&gt;&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;+&quot;</span><span class="s0">, </span><span class="s2">&quot;-&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;*&quot;</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s2">&quot;%&quot;</span><span class="s0">],</span>
        <span class="s0">[</span><span class="s2">&quot;**&quot;</span><span class="s0">]</span>
    <span class="s0">],</span>
    <span class="s0">{}</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">ATOMIC_START_TOKEN = makePredicate([ </span><span class="s2">&quot;atom&quot;</span><span class="s0">, </span><span class="s2">&quot;num&quot;</span><span class="s0">, </span><span class="s2">&quot;big_int&quot;</span><span class="s0">, </span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;regexp&quot;</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">]);</span>

<span class="s3">/* -----[ Parser ]----- */</span>

<span class="s1">function </span><span class="s0">parse($TEXT, options) {</span>
    <span class="s3">// maps start tokens to count of comments found outside of their parens</span>
    <span class="s3">// Example: /* I count */ ( /* I don't */ foo() )</span>
    <span class="s3">// Useful because comments_before property of call with parens outside</span>
    <span class="s3">// contains both comments inside and outside these parens. Used to find the</span>
    
    <span class="s0">const outer_comments_before_counts = </span><span class="s1">new </span><span class="s0">WeakMap();</span>

    <span class="s0">options = defaults(options, {</span>
        <span class="s0">bare_returns   : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">ecma           : </span><span class="s1">null</span><span class="s0">,  </span><span class="s3">// Legacy</span>
        <span class="s0">expression     : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">filename       : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">html5_comments : </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">module         : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">shebang        : </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">strict         : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">toplevel       : </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s1">var </span><span class="s0">S = {</span>
        <span class="s0">input         : (</span><span class="s1">typeof </span><span class="s0">$TEXT == </span><span class="s2">&quot;string&quot;</span>
                         <span class="s0">? tokenizer($TEXT, options.filename,</span>
                                     <span class="s0">options.html5_comments, options.shebang)</span>
                         <span class="s0">: $TEXT),</span>
        <span class="s0">token         : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">prev          : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">peeked        : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">in_function   : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">in_async      : -</span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">in_generator  : -</span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">in_directives : </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">in_loop       : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">labels        : []</span>
    <span class="s0">};</span>

    <span class="s0">S.token = next();</span>

    <span class="s1">function </span><span class="s0">is(type, value) {</span>
        <span class="s1">return </span><span class="s0">is_token(S.token, type, value);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">peek() { </span><span class="s1">return </span><span class="s0">S.peeked || (S.peeked = S.input()); }</span>

    <span class="s1">function </span><span class="s0">next() {</span>
        <span class="s0">S.prev = S.token;</span>

        <span class="s1">if </span><span class="s0">(!S.peeked) peek();</span>
        <span class="s0">S.token = S.peeked;</span>
        <span class="s0">S.peeked = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">S.in_directives = S.in_directives &amp;&amp; (</span>
            <span class="s0">S.token.type == </span><span class="s2">&quot;string&quot; </span><span class="s0">|| is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)</span>
        <span class="s0">);</span>
        <span class="s1">return </span><span class="s0">S.token;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">prev() {</span>
        <span class="s1">return </span><span class="s0">S.prev;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">croak(msg, line, col, pos) {</span>
        <span class="s1">var </span><span class="s0">ctx = S.input.context();</span>
        <span class="s0">js_error(msg,</span>
                 <span class="s0">ctx.filename,</span>
                 <span class="s0">line != </span><span class="s1">null </span><span class="s0">? line : ctx.tokline,</span>
                 <span class="s0">col != </span><span class="s1">null </span><span class="s0">? col : ctx.tokcol,</span>
                 <span class="s0">pos != </span><span class="s1">null </span><span class="s0">? pos : ctx.tokpos);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">token_error(token, msg) {</span>
        <span class="s0">croak(msg, token.line, token.col);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">unexpected(token) {</span>
        <span class="s1">if </span><span class="s0">(token == </span><span class="s1">null</span><span class="s0">)</span>
            <span class="s0">token = S.token;</span>
        <span class="s0">token_error(token, </span><span class="s2">&quot;Unexpected token: &quot; </span><span class="s0">+ token.type + </span><span class="s2">&quot; (&quot; </span><span class="s0">+ token.value + </span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">expect_token(type, val) {</span>
        <span class="s1">if </span><span class="s0">(is(type, val)) {</span>
            <span class="s1">return </span><span class="s0">next();</span>
        <span class="s0">}</span>
        <span class="s0">token_error(S.token, </span><span class="s2">&quot;Unexpected token &quot; </span><span class="s0">+ S.token.type + </span><span class="s2">&quot; «&quot; </span><span class="s0">+ S.token.value + </span><span class="s2">&quot;»&quot; </span><span class="s0">+ </span><span class="s2">&quot;, expected &quot; </span><span class="s0">+ type + </span><span class="s2">&quot; «&quot; </span><span class="s0">+ val + </span><span class="s2">&quot;»&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">expect(punc) { </span><span class="s1">return </span><span class="s0">expect_token(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, punc); }</span>

    <span class="s1">function </span><span class="s0">has_newline_before(token) {</span>
        <span class="s1">return </span><span class="s0">token.nlb || !token.comments_before.every((comment) =&gt; !comment.nlb);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">can_insert_semicolon() {</span>
        <span class="s1">return </span><span class="s0">!options.strict</span>
            <span class="s0">&amp;&amp; (is(</span><span class="s2">&quot;eof&quot;</span><span class="s0">) || is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">) || has_newline_before(S.token));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">is_in_generator() {</span>
        <span class="s1">return </span><span class="s0">S.in_generator === S.in_function;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">is_in_async() {</span>
        <span class="s1">return </span><span class="s0">S.in_async === S.in_function;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">can_await() {</span>
        <span class="s1">return </span><span class="s0">(</span>
            <span class="s0">S.in_async === S.in_function</span>
            <span class="s0">|| S.in_function === </span><span class="s4">0 </span><span class="s0">&amp;&amp; S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)</span>
        <span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">semicolon(optional) {</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)) next();</span>
        <span class="s1">else if </span><span class="s0">(!optional &amp;&amp; !can_insert_semicolon()) unexpected();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">parenthesised() {</span>
        <span class="s0">expect(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">exp = expression(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">expect(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">exp;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">embed_tokens(parser) {</span>
        <span class="s1">return function </span><span class="s0">_embed_tokens_wrapper(...args) {</span>
            <span class="s0">const start = S.token;</span>
            <span class="s0">const expr = parser(...args);</span>
            <span class="s0">expr.start = start;</span>
            <span class="s0">expr.end = prev();</span>
            <span class="s1">return </span><span class="s0">expr;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">handle_regexp() {</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s0">) || is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;/=&quot;</span><span class="s0">)) {</span>
            <span class="s0">S.peeked = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">S.token = S.input(S.token.value.substr(</span><span class="s4">1</span><span class="s0">)); </span><span class="s3">// force regexp</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">statement = embed_tokens(</span><span class="s1">function </span><span class="s0">statement(is_export_default, is_for_body, is_if_body) {</span>
        <span class="s0">handle_regexp();</span>
        <span class="s1">switch </span><span class="s0">(S.token.type) {</span>
          <span class="s1">case </span><span class="s2">&quot;string&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(S.in_directives) {</span>
                <span class="s1">var </span><span class="s0">token = peek();</span>
                <span class="s1">if </span><span class="s0">(!LATEST_RAW.includes(</span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">)</span>
                    <span class="s0">&amp;&amp; (is_token(token, </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)</span>
                        <span class="s0">|| is_token(token, </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)</span>
                        <span class="s0">|| has_newline_before(token)</span>
                        <span class="s0">|| is_token(token, </span><span class="s2">&quot;eof&quot;</span><span class="s0">))) {</span>
                    <span class="s0">S.input.add_directive(S.token.value);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">S.in_directives = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">dir = S.in_directives, stat = simple_statement();</span>
            <span class="s1">return </span><span class="s0">dir &amp;&amp; stat.body </span><span class="s1">instanceof </span><span class="s0">AST_String ? </span><span class="s1">new </span><span class="s0">AST_Directive(stat.body) : stat;</span>
          <span class="s1">case </span><span class="s2">&quot;template_head&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;num&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;big_int&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;regexp&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;operator&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;atom&quot;</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">simple_statement();</span>

          <span class="s1">case </span><span class="s2">&quot;name&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;privatename&quot;</span><span class="s0">:</span>
            <span class="s1">if</span><span class="s0">(is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">) &amp;&amp; !S.in_class)</span>
                <span class="s0">croak(</span><span class="s2">&quot;Private field must be used in an enclosing class&quot;</span><span class="s0">);</span>

            <span class="s1">if </span><span class="s0">(S.token.value == </span><span class="s2">&quot;async&quot; </span><span class="s0">&amp;&amp; is_token(peek(), </span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;function&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>
                <span class="s0">next();</span>
                <span class="s1">if </span><span class="s0">(is_for_body) {</span>
                    <span class="s0">croak(</span><span class="s2">&quot;functions are not allowed as the body of a loop&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">function_(AST_Defun, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">, is_export_default);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(S.token.value == </span><span class="s2">&quot;import&quot; </span><span class="s0">&amp;&amp; !is_token(peek(), </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">) &amp;&amp; !is_token(peek(), </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>
                <span class="s1">var </span><span class="s0">node = import_statement();</span>
                <span class="s0">semicolon();</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">is_token(peek(), </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;:&quot;</span><span class="s0">)</span>
                <span class="s0">? labeled_statement()</span>
                <span class="s0">: simple_statement();</span>

          <span class="s1">case </span><span class="s2">&quot;punc&quot;</span><span class="s0">:</span>
            <span class="s1">switch </span><span class="s0">(S.token.value) {</span>
              <span class="s1">case </span><span class="s2">&quot;{&quot;</span><span class="s0">:</span>
                <span class="s1">return new </span><span class="s0">AST_BlockStatement({</span>
                    <span class="s0">start : S.token,</span>
                    <span class="s0">body  : block_(),</span>
                    <span class="s0">end   : prev()</span>
                <span class="s0">});</span>
              <span class="s1">case </span><span class="s2">&quot;[&quot;</span><span class="s0">:</span>
              <span class="s1">case </span><span class="s2">&quot;(&quot;</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">simple_statement();</span>
              <span class="s1">case </span><span class="s2">&quot;;&quot;</span><span class="s0">:</span>
                <span class="s0">S.in_directives = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">next();</span>
                <span class="s1">return new </span><span class="s0">AST_EmptyStatement();</span>
              <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">unexpected();</span>
            <span class="s0">}</span>

          <span class="s1">case </span><span class="s2">&quot;keyword&quot;</span><span class="s0">:</span>
            <span class="s1">switch </span><span class="s0">(S.token.value) {</span>
              <span class="s1">case </span><span class="s2">&quot;break&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">break_cont(AST_Break);</span>

              <span class="s1">case </span><span class="s2">&quot;continue&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">break_cont(AST_Continue);</span>

              <span class="s1">case </span><span class="s2">&quot;debugger&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s0">semicolon();</span>
                <span class="s1">return new </span><span class="s0">AST_Debugger();</span>

              <span class="s1">case </span><span class="s2">&quot;do&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">var </span><span class="s0">body = in_loop(statement);</span>
                <span class="s0">expect_token(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;while&quot;</span><span class="s0">);</span>
                <span class="s1">var </span><span class="s0">condition = parenthesised();</span>
                <span class="s0">semicolon(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return new </span><span class="s0">AST_Do({</span>
                    <span class="s0">body      : body,</span>
                    <span class="s0">condition : condition</span>
                <span class="s0">});</span>

              <span class="s1">case </span><span class="s2">&quot;while&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">return new </span><span class="s0">AST_While({</span>
                    <span class="s0">condition : parenthesised(),</span>
                    <span class="s0">body      : in_loop(</span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">statement(</span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">); })</span>
                <span class="s0">});</span>

              <span class="s1">case </span><span class="s2">&quot;for&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">for_();</span>

              <span class="s1">case </span><span class="s2">&quot;class&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">if </span><span class="s0">(is_for_body) {</span>
                    <span class="s0">croak(</span><span class="s2">&quot;classes are not allowed as the body of a loop&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is_if_body) {</span>
                    <span class="s0">croak(</span><span class="s2">&quot;classes are not allowed as the body of an if&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">class_(AST_DefClass, is_export_default);</span>

              <span class="s1">case </span><span class="s2">&quot;function&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">if </span><span class="s0">(is_for_body) {</span>
                    <span class="s0">croak(</span><span class="s2">&quot;functions are not allowed as the body of a loop&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">function_(AST_Defun, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, is_export_default);</span>

              <span class="s1">case </span><span class="s2">&quot;if&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">if_();</span>

              <span class="s1">case </span><span class="s2">&quot;return&quot;</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(S.in_function == </span><span class="s4">0 </span><span class="s0">&amp;&amp; !options.bare_returns)</span>
                    <span class="s0">croak(</span><span class="s2">&quot;'return' outside of function&quot;</span><span class="s0">);</span>
                <span class="s0">next();</span>
                <span class="s1">var </span><span class="s0">value = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)) {</span>
                    <span class="s0">next();</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!can_insert_semicolon()) {</span>
                    <span class="s0">value = expression(</span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">semicolon();</span>
                <span class="s0">}</span>
                <span class="s1">return new </span><span class="s0">AST_Return({</span>
                    <span class="s0">value: value</span>
                <span class="s0">});</span>

              <span class="s1">case </span><span class="s2">&quot;switch&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">return new </span><span class="s0">AST_Switch({</span>
                    <span class="s0">expression : parenthesised(),</span>
                    <span class="s0">body       : in_loop(switch_body_)</span>
                <span class="s0">});</span>

              <span class="s1">case </span><span class="s2">&quot;throw&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">if </span><span class="s0">(has_newline_before(S.token))</span>
                    <span class="s0">croak(</span><span class="s2">&quot;Illegal newline after 'throw'&quot;</span><span class="s0">);</span>
                <span class="s1">var </span><span class="s0">value = expression(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">semicolon();</span>
                <span class="s1">return new </span><span class="s0">AST_Throw({</span>
                    <span class="s0">value: value</span>
                <span class="s0">});</span>

              <span class="s1">case </span><span class="s2">&quot;try&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">try_();</span>

              <span class="s1">case </span><span class="s2">&quot;var&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">var </span><span class="s0">node = var_();</span>
                <span class="s0">semicolon();</span>
                <span class="s1">return </span><span class="s0">node;</span>

              <span class="s1">case </span><span class="s2">&quot;let&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">var </span><span class="s0">node = let_();</span>
                <span class="s0">semicolon();</span>
                <span class="s1">return </span><span class="s0">node;</span>

              <span class="s1">case </span><span class="s2">&quot;const&quot;</span><span class="s0">:</span>
                <span class="s0">next();</span>
                <span class="s1">var </span><span class="s0">node = const_();</span>
                <span class="s0">semicolon();</span>
                <span class="s1">return </span><span class="s0">node;</span>

              <span class="s1">case </span><span class="s2">&quot;with&quot;</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)) {</span>
                    <span class="s0">croak(</span><span class="s2">&quot;Strict mode may not include a with statement&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">next();</span>
                <span class="s1">return new </span><span class="s0">AST_With({</span>
                    <span class="s0">expression : parenthesised(),</span>
                    <span class="s0">body       : statement()</span>
                <span class="s0">});</span>

              <span class="s1">case </span><span class="s2">&quot;export&quot;</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(!is_token(peek(), </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">)) {</span>
                    <span class="s0">next();</span>
                    <span class="s1">var </span><span class="s0">node = export_statement();</span>
                    <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)) semicolon();</span>
                    <span class="s1">return </span><span class="s0">node;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">unexpected();</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">labeled_statement() {</span>
        <span class="s1">var </span><span class="s0">label = as_symbol(AST_Label);</span>
        <span class="s1">if </span><span class="s0">(label.name === </span><span class="s2">&quot;await&quot; </span><span class="s0">&amp;&amp; is_in_async()) {</span>
            <span class="s0">token_error(S.prev, </span><span class="s2">&quot;await cannot be used as label inside async function&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(S.labels.some((l) =&gt; l.name === label.name)) {</span>
            <span class="s3">// ECMA-262, 12.12: An ECMAScript program is considered</span>
            <span class="s3">// syntactically incorrect if it contains a</span>
            <span class="s3">// LabelledStatement that is enclosed by a</span>
            <span class="s3">// LabelledStatement with the same Identifier as label.</span>
            <span class="s0">croak(</span><span class="s2">&quot;Label &quot; </span><span class="s0">+ label.name + </span><span class="s2">&quot; defined twice&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">expect(</span><span class="s2">&quot;:&quot;</span><span class="s0">);</span>
        <span class="s0">S.labels.push(label);</span>
        <span class="s1">var </span><span class="s0">stat = statement();</span>
        <span class="s0">S.labels.pop();</span>
        <span class="s1">if </span><span class="s0">(!(stat </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement)) {</span>
            <span class="s3">// check for `continue` that refers to this label.</span>
            <span class="s3">// those should be reported as syntax errors.</span>
            <span class="s3">// https://github.com/mishoo/UglifyJS2/issues/287</span>
            <span class="s0">label.references.forEach(</span><span class="s1">function</span><span class="s0">(ref) {</span>
                <span class="s1">if </span><span class="s0">(ref </span><span class="s1">instanceof </span><span class="s0">AST_Continue) {</span>
                    <span class="s0">ref = ref.label.start;</span>
                    <span class="s0">croak(</span><span class="s2">&quot;Continue label `&quot; </span><span class="s0">+ label.name + </span><span class="s2">&quot;` refers to non-IterationStatement.&quot;</span><span class="s0">,</span>
                          <span class="s0">ref.line, ref.col, ref.pos);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return new </span><span class="s0">AST_LabeledStatement({ body: stat, label: label });</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">simple_statement(tmp) {</span>
        <span class="s1">return new </span><span class="s0">AST_SimpleStatement({ body: (tmp = expression(</span><span class="s1">true</span><span class="s0">), semicolon(), tmp) });</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">break_cont(type) {</span>
        <span class="s1">var </span><span class="s0">label = </span><span class="s1">null</span><span class="s0">, ldef;</span>
        <span class="s1">if </span><span class="s0">(!can_insert_semicolon()) {</span>
            <span class="s0">label = as_symbol(AST_LabelRef, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(label != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">ldef = S.labels.find((l) =&gt; l.name === label.name);</span>
            <span class="s1">if </span><span class="s0">(!ldef)</span>
                <span class="s0">croak(</span><span class="s2">&quot;Undefined label &quot; </span><span class="s0">+ label.name);</span>
            <span class="s0">label.thedef = ldef;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(S.in_loop == </span><span class="s4">0</span><span class="s0">)</span>
            <span class="s0">croak(type.TYPE + </span><span class="s2">&quot; not inside a loop or switch&quot;</span><span class="s0">);</span>
        <span class="s0">semicolon();</span>
        <span class="s1">var </span><span class="s0">stat = </span><span class="s1">new </span><span class="s0">type({ label: label });</span>
        <span class="s1">if </span><span class="s0">(ldef) ldef.references.push(stat);</span>
        <span class="s1">return </span><span class="s0">stat;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">for_() {</span>
        <span class="s1">var </span><span class="s0">for_await_error = </span><span class="s2">&quot;`for await` invalid in this context&quot;</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">await_tok = S.token;</span>
        <span class="s1">if </span><span class="s0">(await_tok.type == </span><span class="s2">&quot;name&quot; </span><span class="s0">&amp;&amp; await_tok.value == </span><span class="s2">&quot;await&quot;</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(!can_await()) {</span>
                <span class="s0">token_error(await_tok, for_await_error);</span>
            <span class="s0">}</span>
            <span class="s0">next();</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">await_tok = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">expect(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">init = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)) {</span>
            <span class="s0">init =</span>
                <span class="s0">is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;var&quot;</span><span class="s0">) ? (next(), var_(</span><span class="s1">true</span><span class="s0">)) :</span>
                <span class="s0">is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;let&quot;</span><span class="s0">) ? (next(), let_(</span><span class="s1">true</span><span class="s0">)) :</span>
                <span class="s0">is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;const&quot;</span><span class="s0">) ? (next(), const_(</span><span class="s1">true</span><span class="s0">)) :</span>
                                       <span class="s0">expression(</span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">var </span><span class="s0">is_in = is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;in&quot;</span><span class="s0">);</span>
            <span class="s1">var </span><span class="s0">is_of = is(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;of&quot;</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(await_tok &amp;&amp; !is_of) {</span>
                <span class="s0">token_error(await_tok, for_await_error);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(is_in || is_of) {</span>
                <span class="s1">if </span><span class="s0">(init </span><span class="s1">instanceof </span><span class="s0">AST_Definitions) {</span>
                    <span class="s1">if </span><span class="s0">(init.definitions.length &gt; </span><span class="s4">1</span><span class="s0">)</span>
                        <span class="s0">token_error(init.start, </span><span class="s2">&quot;Only one variable declaration allowed in for..in loop&quot;</span><span class="s0">);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(is_assignable(init) || (init = to_destructuring(init)) </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring)) {</span>
                    <span class="s0">token_error(init.start, </span><span class="s2">&quot;Invalid left-hand side in for..in loop&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">next();</span>
                <span class="s1">if </span><span class="s0">(is_in) {</span>
                    <span class="s1">return </span><span class="s0">for_in(init);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">return </span><span class="s0">for_of(init, !!await_tok);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(await_tok) {</span>
            <span class="s0">token_error(await_tok, for_await_error);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">regular_for(init);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">regular_for(init) {</span>
        <span class="s0">expect(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">test = is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">) ? </span><span class="s1">null </span><span class="s0">: expression(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">expect(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">step = is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">) ? </span><span class="s1">null </span><span class="s0">: expression(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">expect(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s1">return new </span><span class="s0">AST_For({</span>
            <span class="s0">init      : init,</span>
            <span class="s0">condition : test,</span>
            <span class="s0">step      : step,</span>
            <span class="s0">body      : in_loop(</span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">statement(</span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">); })</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">for_of(init, is_await) {</span>
        <span class="s1">var </span><span class="s0">lhs = init </span><span class="s1">instanceof </span><span class="s0">AST_Definitions ? init.definitions[</span><span class="s4">0</span><span class="s0">].name : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">obj = expression(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">expect(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s1">return new </span><span class="s0">AST_ForOf({</span>
            <span class="s0">await  : is_await,</span>
            <span class="s0">init   : init,</span>
            <span class="s0">name   : lhs,</span>
            <span class="s0">object : obj,</span>
            <span class="s0">body   : in_loop(</span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">statement(</span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">); })</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">for_in(init) {</span>
        <span class="s1">var </span><span class="s0">obj = expression(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">expect(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s1">return new </span><span class="s0">AST_ForIn({</span>
            <span class="s0">init   : init,</span>
            <span class="s0">object : obj,</span>
            <span class="s0">body   : in_loop(</span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">statement(</span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">); })</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">arrow_function = </span><span class="s1">function</span><span class="s0">(start, argnames, is_async) {</span>
        <span class="s1">if </span><span class="s0">(has_newline_before(S.token)) {</span>
            <span class="s0">croak(</span><span class="s2">&quot;Unexpected newline before arrow (=&gt;)&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s0">expect_token(</span><span class="s2">&quot;arrow&quot;</span><span class="s0">, </span><span class="s2">&quot;=&gt;&quot;</span><span class="s0">);</span>

        <span class="s1">var </span><span class="s0">body = _function_body(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s0">), </span><span class="s1">false</span><span class="s0">, is_async);</span>

        <span class="s1">var </span><span class="s0">end =</span>
            <span class="s0">body </span><span class="s1">instanceof </span><span class="s0">Array &amp;&amp; body.length ? body[body.length - </span><span class="s4">1</span><span class="s0">].end :</span>
            <span class="s0">body </span><span class="s1">instanceof </span><span class="s0">Array ? start :</span>
                <span class="s0">body.end;</span>

        <span class="s1">return new </span><span class="s0">AST_Arrow({</span>
            <span class="s0">start    : start,</span>
            <span class="s0">end      : end,</span>
            <span class="s0">async    : is_async,</span>
            <span class="s0">argnames : argnames,</span>
            <span class="s0">body     : body</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">function_ = </span><span class="s1">function</span><span class="s0">(ctor, is_generator_property, is_async, is_export_default) {</span>
        <span class="s1">var </span><span class="s0">in_statement = ctor === AST_Defun;</span>
        <span class="s1">var </span><span class="s0">is_generator = is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(is_generator) {</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">name = is(</span><span class="s2">&quot;name&quot;</span><span class="s0">) ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(in_statement &amp;&amp; !name) {</span>
            <span class="s1">if </span><span class="s0">(is_export_default) {</span>
                <span class="s0">ctor = AST_Function;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">unexpected();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(name &amp;&amp; ctor !== AST_Accessor &amp;&amp; !(name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration))</span>
            <span class="s0">unexpected(prev());</span>

        <span class="s1">var </span><span class="s0">args = [];</span>
        <span class="s1">var </span><span class="s0">body = _function_body(</span><span class="s1">true</span><span class="s0">, is_generator || is_generator_property, is_async, name, args);</span>
        <span class="s1">return new </span><span class="s0">ctor({</span>
            <span class="s0">start : args.start,</span>
            <span class="s0">end   : body.end,</span>
            <span class="s0">is_generator: is_generator,</span>
            <span class="s0">async : is_async,</span>
            <span class="s0">name  : name,</span>
            <span class="s0">argnames: args,</span>
            <span class="s0">body  : body</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s0">class UsedParametersTracker {</span>
        <span class="s0">constructor(is_parameter, strict, duplicates_ok = </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.is_parameter = is_parameter;</span>
            <span class="s1">this</span><span class="s0">.duplicates_ok = duplicates_ok;</span>
            <span class="s1">this</span><span class="s0">.parameters = </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s1">this</span><span class="s0">.duplicate = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.default_assignment = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.spread = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.strict_mode = !!strict;</span>
        <span class="s0">}</span>
        <span class="s0">add_parameter(token) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parameters.has(token.value)) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.duplicate === </span><span class="s1">null</span><span class="s0">) {</span>
                    <span class="s1">this</span><span class="s0">.duplicate = token;</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.check_strict();</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.parameters.add(token.value);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.is_parameter) {</span>
                    <span class="s1">switch </span><span class="s0">(token.value) {</span>
                      <span class="s1">case </span><span class="s2">&quot;arguments&quot;</span><span class="s0">:</span>
                      <span class="s1">case </span><span class="s2">&quot;eval&quot;</span><span class="s0">:</span>
                      <span class="s1">case </span><span class="s2">&quot;yield&quot;</span><span class="s0">:</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.strict_mode) {</span>
                            <span class="s0">token_error(token, </span><span class="s2">&quot;Unexpected &quot; </span><span class="s0">+ token.value + </span><span class="s2">&quot; identifier as parameter inside strict mode&quot;</span><span class="s0">);</span>
                        <span class="s0">}</span>
                        <span class="s1">break</span><span class="s0">;</span>
                      <span class="s1">default</span><span class="s0">:</span>
                        <span class="s1">if </span><span class="s0">(RESERVED_WORDS.has(token.value)) {</span>
                            <span class="s0">unexpected();</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">mark_default_assignment(token) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.default_assignment === </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.default_assignment = token;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">mark_spread(token) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.spread === </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.spread = token;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">mark_strict_mode() {</span>
            <span class="s1">this</span><span class="s0">.strict_mode = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">is_strict() {</span>
            <span class="s1">return this</span><span class="s0">.default_assignment !== </span><span class="s1">false </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.spread !== </span><span class="s1">false </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.strict_mode;</span>
        <span class="s0">}</span>
        <span class="s0">check_strict() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.is_strict() &amp;&amp; </span><span class="s1">this</span><span class="s0">.duplicate !== </span><span class="s1">null </span><span class="s0">&amp;&amp; !</span><span class="s1">this</span><span class="s0">.duplicates_ok) {</span>
                <span class="s0">token_error(</span><span class="s1">this</span><span class="s0">.duplicate, </span><span class="s2">&quot;Parameter &quot; </span><span class="s0">+ </span><span class="s1">this</span><span class="s0">.duplicate.value + </span><span class="s2">&quot; was used already&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">parameters(params) {</span>
        <span class="s1">var </span><span class="s0">used_parameters = </span><span class="s1">new </span><span class="s0">UsedParametersTracker(</span><span class="s1">true</span><span class="s0">, S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">));</span>

        <span class="s0">expect(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>

        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">param = parameter(used_parameters);</span>
            <span class="s0">params.push(param);</span>

            <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
                <span class="s0">expect(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(param </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s0">next();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">parameter(used_parameters, symbol_type) {</span>
        <span class="s1">var </span><span class="s0">param;</span>
        <span class="s1">var </span><span class="s0">expand = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(used_parameters === undefined) {</span>
            <span class="s0">used_parameters = </span><span class="s1">new </span><span class="s0">UsedParametersTracker(</span><span class="s1">true</span><span class="s0">, S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;expand&quot;</span><span class="s0">, </span><span class="s2">&quot;...&quot;</span><span class="s0">)) {</span>
            <span class="s0">expand = S.token;</span>
            <span class="s0">used_parameters.mark_spread(S.token);</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>
        <span class="s0">param = binding_element(used_parameters, symbol_type);</span>

        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">) &amp;&amp; expand === </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s0">used_parameters.mark_default_assignment(S.token);</span>
            <span class="s0">next();</span>
            <span class="s0">param = </span><span class="s1">new </span><span class="s0">AST_DefaultAssign({</span>
                <span class="s0">start: param.start,</span>
                <span class="s0">left: param,</span>
                <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                <span class="s0">right: expression(</span><span class="s1">false</span><span class="s0">),</span>
                <span class="s0">end: S.token</span>
            <span class="s0">});</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(expand !== </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
                <span class="s0">unexpected();</span>
            <span class="s0">}</span>
            <span class="s0">param = </span><span class="s1">new </span><span class="s0">AST_Expansion({</span>
                <span class="s0">start: expand,</span>
                <span class="s0">expression: param,</span>
                <span class="s0">end: expand</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">used_parameters.check_strict();</span>

        <span class="s1">return </span><span class="s0">param;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">binding_element(used_parameters, symbol_type) {</span>
        <span class="s1">var </span><span class="s0">elements = [];</span>
        <span class="s1">var </span><span class="s0">first = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">is_expand = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">expand_token;</span>
        <span class="s1">var </span><span class="s0">first_token = S.token;</span>
        <span class="s1">if </span><span class="s0">(used_parameters === undefined) {</span>
            <span class="s0">const strict = S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">);</span>
            <span class="s0">const duplicates_ok = symbol_type === AST_SymbolVar;</span>
            <span class="s0">used_parameters = </span><span class="s1">new </span><span class="s0">UsedParametersTracker(</span><span class="s1">false</span><span class="s0">, strict, duplicates_ok);</span>
        <span class="s0">}</span>
        <span class="s0">symbol_type = symbol_type === undefined ? AST_SymbolFunarg : symbol_type;</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;[&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;]&quot;</span><span class="s0">)) {</span>
                <span class="s1">if </span><span class="s0">(first) {</span>
                    <span class="s0">first = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">expect(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>

                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;expand&quot;</span><span class="s0">, </span><span class="s2">&quot;...&quot;</span><span class="s0">)) {</span>
                    <span class="s0">is_expand = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">expand_token = S.token;</span>
                    <span class="s0">used_parameters.mark_spread(S.token);</span>
                    <span class="s0">next();</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">)) {</span>
                    <span class="s1">switch </span><span class="s0">(S.token.value) {</span>
                      <span class="s1">case </span><span class="s2">&quot;,&quot;</span><span class="s0">:</span>
                        <span class="s0">elements.push(</span><span class="s1">new </span><span class="s0">AST_Hole({</span>
                            <span class="s0">start: S.token,</span>
                            <span class="s0">end: S.token</span>
                        <span class="s0">}));</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                      <span class="s1">case </span><span class="s2">&quot;]&quot;</span><span class="s0">: </span><span class="s3">// Trailing comma after last element</span>
                        <span class="s1">break</span><span class="s0">;</span>
                      <span class="s1">case </span><span class="s2">&quot;[&quot;</span><span class="s0">:</span>
                      <span class="s1">case </span><span class="s2">&quot;{&quot;</span><span class="s0">:</span>
                        <span class="s0">elements.push(binding_element(used_parameters, symbol_type));</span>
                        <span class="s1">break</span><span class="s0">;</span>
                      <span class="s1">default</span><span class="s0">:</span>
                        <span class="s0">unexpected();</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">)) {</span>
                    <span class="s0">used_parameters.add_parameter(S.token);</span>
                    <span class="s0">elements.push(as_symbol(symbol_type));</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">croak(</span><span class="s2">&quot;Invalid function parameter&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">) &amp;&amp; is_expand === </span><span class="s1">false</span><span class="s0">) {</span>
                    <span class="s0">used_parameters.mark_default_assignment(S.token);</span>
                    <span class="s0">next();</span>
                    <span class="s0">elements[elements.length - </span><span class="s4">1</span><span class="s0">] = </span><span class="s1">new </span><span class="s0">AST_DefaultAssign({</span>
                        <span class="s0">start: elements[elements.length - </span><span class="s4">1</span><span class="s0">].start,</span>
                        <span class="s0">left: elements[elements.length - </span><span class="s4">1</span><span class="s0">],</span>
                        <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                        <span class="s0">right: expression(</span><span class="s1">false</span><span class="s0">),</span>
                        <span class="s0">end: S.token</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is_expand) {</span>
                    <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;]&quot;</span><span class="s0">)) {</span>
                        <span class="s0">croak(</span><span class="s2">&quot;Rest element must be last element&quot;</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s0">elements[elements.length - </span><span class="s4">1</span><span class="s0">] = </span><span class="s1">new </span><span class="s0">AST_Expansion({</span>
                        <span class="s0">start: expand_token,</span>
                        <span class="s0">expression: elements[elements.length - </span><span class="s4">1</span><span class="s0">],</span>
                        <span class="s0">end: expand_token</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">expect(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
            <span class="s0">used_parameters.check_strict();</span>
            <span class="s1">return new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: first_token,</span>
                <span class="s0">names: elements,</span>
                <span class="s0">is_array: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">end: prev()</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
                <span class="s1">if </span><span class="s0">(first) {</span>
                    <span class="s0">first = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">expect(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;expand&quot;</span><span class="s0">, </span><span class="s2">&quot;...&quot;</span><span class="s0">)) {</span>
                    <span class="s0">is_expand = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">expand_token = S.token;</span>
                    <span class="s0">used_parameters.mark_spread(S.token);</span>
                    <span class="s0">next();</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">) &amp;&amp; (is_token(peek(), </span><span class="s2">&quot;punc&quot;</span><span class="s0">) || is_token(peek(), </span><span class="s2">&quot;operator&quot;</span><span class="s0">)) &amp;&amp; [</span><span class="s2">&quot;,&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">].includes(peek().value)) {</span>
                    <span class="s0">used_parameters.add_parameter(S.token);</span>
                    <span class="s1">var </span><span class="s0">start = prev();</span>
                    <span class="s1">var </span><span class="s0">value = as_symbol(symbol_type);</span>
                    <span class="s1">if </span><span class="s0">(is_expand) {</span>
                        <span class="s0">elements.push(</span><span class="s1">new </span><span class="s0">AST_Expansion({</span>
                            <span class="s0">start: expand_token,</span>
                            <span class="s0">expression: value,</span>
                            <span class="s0">end: value.end,</span>
                        <span class="s0">}));</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">elements.push(</span><span class="s1">new </span><span class="s0">AST_ObjectKeyVal({</span>
                            <span class="s0">start: start,</span>
                            <span class="s0">key: value.name,</span>
                            <span class="s0">value: value,</span>
                            <span class="s0">end: value.end,</span>
                        <span class="s0">}));</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
                    <span class="s1">continue</span><span class="s0">; </span><span class="s3">// Allow trailing hole</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">var </span><span class="s0">property_token = S.token;</span>
                    <span class="s1">var </span><span class="s0">property = as_property_name();</span>
                    <span class="s1">if </span><span class="s0">(property === </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s0">unexpected(prev());</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prev().type === </span><span class="s2">&quot;name&quot; </span><span class="s0">&amp;&amp; !is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;:&quot;</span><span class="s0">)) {</span>
                        <span class="s0">elements.push(</span><span class="s1">new </span><span class="s0">AST_ObjectKeyVal({</span>
                            <span class="s0">start: prev(),</span>
                            <span class="s0">key: property,</span>
                            <span class="s0">value: </span><span class="s1">new </span><span class="s0">symbol_type({</span>
                                <span class="s0">start: prev(),</span>
                                <span class="s0">name: property,</span>
                                <span class="s0">end: prev()</span>
                            <span class="s0">}),</span>
                            <span class="s0">end: prev()</span>
                        <span class="s0">}));</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">expect(</span><span class="s2">&quot;:&quot;</span><span class="s0">);</span>
                        <span class="s0">elements.push(</span><span class="s1">new </span><span class="s0">AST_ObjectKeyVal({</span>
                            <span class="s0">start: property_token,</span>
                            <span class="s0">quote: property_token.quote,</span>
                            <span class="s0">key: property,</span>
                            <span class="s0">value: binding_element(used_parameters, symbol_type),</span>
                            <span class="s0">end: prev()</span>
                        <span class="s0">}));</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is_expand) {</span>
                    <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
                        <span class="s0">croak(</span><span class="s2">&quot;Rest element must be last element&quot;</span><span class="s0">);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">)) {</span>
                    <span class="s0">used_parameters.mark_default_assignment(S.token);</span>
                    <span class="s0">next();</span>
                    <span class="s0">elements[elements.length - </span><span class="s4">1</span><span class="s0">].value = </span><span class="s1">new </span><span class="s0">AST_DefaultAssign({</span>
                        <span class="s0">start: elements[elements.length - </span><span class="s4">1</span><span class="s0">].value.start,</span>
                        <span class="s0">left: elements[elements.length - </span><span class="s4">1</span><span class="s0">].value,</span>
                        <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                        <span class="s0">right: expression(</span><span class="s1">false</span><span class="s0">),</span>
                        <span class="s0">end: S.token</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">expect(</span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
            <span class="s0">used_parameters.check_strict();</span>
            <span class="s1">return new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: first_token,</span>
                <span class="s0">names: elements,</span>
                <span class="s0">is_array: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">end: prev()</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">)) {</span>
            <span class="s0">used_parameters.add_parameter(S.token);</span>
            <span class="s1">return </span><span class="s0">as_symbol(symbol_type);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">croak(</span><span class="s2">&quot;Invalid function parameter&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">params_or_seq_(allow_arrows, maybe_sequence) {</span>
        <span class="s1">var </span><span class="s0">spread_token;</span>
        <span class="s1">var </span><span class="s0">invalid_sequence;</span>
        <span class="s1">var </span><span class="s0">trailing_comma;</span>
        <span class="s1">var </span><span class="s0">a = [];</span>
        <span class="s0">expect(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(spread_token) unexpected(spread_token);</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;expand&quot;</span><span class="s0">, </span><span class="s2">&quot;...&quot;</span><span class="s0">)) {</span>
                <span class="s0">spread_token = S.token;</span>
                <span class="s1">if </span><span class="s0">(maybe_sequence) invalid_sequence = S.token;</span>
                <span class="s0">next();</span>
                <span class="s0">a.push(</span><span class="s1">new </span><span class="s0">AST_Expansion({</span>
                    <span class="s0">start: prev(),</span>
                    <span class="s0">expression: expression(),</span>
                    <span class="s0">end: S.token,</span>
                <span class="s0">}));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">a.push(expression());</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
                <span class="s0">expect(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
                    <span class="s0">trailing_comma = prev();</span>
                    <span class="s1">if </span><span class="s0">(maybe_sequence) invalid_sequence = trailing_comma;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">expect(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(allow_arrows &amp;&amp; is(</span><span class="s2">&quot;arrow&quot;</span><span class="s0">, </span><span class="s2">&quot;=&gt;&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(spread_token &amp;&amp; trailing_comma) unexpected(trailing_comma);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(invalid_sequence) {</span>
            <span class="s0">unexpected(invalid_sequence);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">a;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">_function_body(block, generator, is_async, name, args) {</span>
        <span class="s1">var </span><span class="s0">loop = S.in_loop;</span>
        <span class="s1">var </span><span class="s0">labels = S.labels;</span>
        <span class="s1">var </span><span class="s0">current_generator = S.in_generator;</span>
        <span class="s1">var </span><span class="s0">current_async = S.in_async;</span>
        <span class="s0">++S.in_function;</span>
        <span class="s1">if </span><span class="s0">(generator)</span>
            <span class="s0">S.in_generator = S.in_function;</span>
        <span class="s1">if </span><span class="s0">(is_async)</span>
            <span class="s0">S.in_async = S.in_function;</span>
        <span class="s1">if </span><span class="s0">(args) parameters(args);</span>
        <span class="s1">if </span><span class="s0">(block)</span>
            <span class="s0">S.in_directives = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">S.in_loop = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">S.labels = [];</span>
        <span class="s1">if </span><span class="s0">(block) {</span>
            <span class="s0">S.input.push_directives_stack();</span>
            <span class="s1">var </span><span class="s0">a = block_();</span>
            <span class="s1">if </span><span class="s0">(name) _verify_symbol(name);</span>
            <span class="s1">if </span><span class="s0">(args) args.forEach(_verify_symbol);</span>
            <span class="s0">S.input.pop_directives_stack();</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">var </span><span class="s0">a = [</span><span class="s1">new </span><span class="s0">AST_Return({</span>
                <span class="s0">start: S.token,</span>
                <span class="s0">value: expression(</span><span class="s1">false</span><span class="s0">),</span>
                <span class="s0">end: S.token</span>
            <span class="s0">})];</span>
        <span class="s0">}</span>
        <span class="s0">--S.in_function;</span>
        <span class="s0">S.in_loop = loop;</span>
        <span class="s0">S.labels = labels;</span>
        <span class="s0">S.in_generator = current_generator;</span>
        <span class="s0">S.in_async = current_async;</span>
        <span class="s1">return </span><span class="s0">a;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">_await_expression() {</span>
        <span class="s3">// Previous token must be &quot;await&quot; and not be interpreted as an identifier</span>
        <span class="s1">if </span><span class="s0">(!can_await()) {</span>
            <span class="s0">croak(</span><span class="s2">&quot;Unexpected await expression outside async function&quot;</span><span class="s0">,</span>
                <span class="s0">S.prev.line, S.prev.col, S.prev.pos);</span>
        <span class="s0">}</span>
        <span class="s3">// the await expression is parsed as a unary expression in Babel</span>
        <span class="s1">return new </span><span class="s0">AST_Await({</span>
            <span class="s0">start: prev(),</span>
            <span class="s0">end: S.token,</span>
            <span class="s0">expression : maybe_unary(</span><span class="s1">true</span><span class="s0">),</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">_yield_expression() {</span>
        <span class="s3">// Previous token must be keyword yield and not be interpret as an identifier</span>
        <span class="s1">if </span><span class="s0">(!is_in_generator()) {</span>
            <span class="s0">croak(</span><span class="s2">&quot;Unexpected yield expression outside generator function&quot;</span><span class="s0">,</span>
                <span class="s0">S.prev.line, S.prev.col, S.prev.pos);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">star = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">has_expression = </span><span class="s1">true</span><span class="s0">;</span>

        <span class="s3">// Attempt to get expression or star (and then the mandatory expression)</span>
        <span class="s3">// behind yield on the same line.</span>
        <span class="s3">//</span>
        <span class="s3">// If nothing follows on the same line of the yieldExpression,</span>
        <span class="s3">// it should default to the value `undefined` for yield to return.</span>
        <span class="s3">// In that case, the `undefined` stored as `null` in ast.</span>
        <span class="s3">//</span>
        <span class="s3">// Note 1: It isn't allowed for yield* to close without an expression</span>
        <span class="s3">// Note 2: If there is a nlb between yield and star, it is interpret as</span>
        <span class="s3">//         yield &lt;explicit undefined&gt; &lt;inserted automatic semicolon&gt; *</span>
        <span class="s1">if </span><span class="s0">(can_insert_semicolon() ||</span>
            <span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">) &amp;&amp; PUNC_AFTER_EXPRESSION.has(S.token.value))) {</span>
            <span class="s0">has_expression = </span><span class="s1">false</span><span class="s0">;</span>

        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">)) {</span>
            <span class="s0">star = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>

        <span class="s1">return new </span><span class="s0">AST_Yield({</span>
            <span class="s0">start      : start,</span>
            <span class="s0">is_star    : star,</span>
            <span class="s0">expression : has_expression ? expression() : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">end        : prev()</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">if_() {</span>
        <span class="s1">var </span><span class="s0">cond = parenthesised(), body = statement(</span><span class="s1">false</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">), belse = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;else&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s0">belse = statement(</span><span class="s1">false</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return new </span><span class="s0">AST_If({</span>
            <span class="s0">condition   : cond,</span>
            <span class="s0">body        : body,</span>
            <span class="s0">alternative : belse</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">block_() {</span>
        <span class="s0">expect(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">a = [];</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;eof&quot;</span><span class="s0">)) unexpected();</span>
            <span class="s0">a.push(statement());</span>
        <span class="s0">}</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">a;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">switch_body_() {</span>
        <span class="s0">expect(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">a = [], cur = </span><span class="s1">null</span><span class="s0">, branch = </span><span class="s1">null</span><span class="s0">, tmp;</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;eof&quot;</span><span class="s0">)) unexpected();</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;case&quot;</span><span class="s0">)) {</span>
                <span class="s1">if </span><span class="s0">(branch) branch.end = prev();</span>
                <span class="s0">cur = [];</span>
                <span class="s0">branch = </span><span class="s1">new </span><span class="s0">AST_Case({</span>
                    <span class="s0">start      : (tmp = S.token, next(), tmp),</span>
                    <span class="s0">expression : expression(</span><span class="s1">true</span><span class="s0">),</span>
                    <span class="s0">body       : cur</span>
                <span class="s0">});</span>
                <span class="s0">a.push(branch);</span>
                <span class="s0">expect(</span><span class="s2">&quot;:&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;default&quot;</span><span class="s0">)) {</span>
                <span class="s1">if </span><span class="s0">(branch) branch.end = prev();</span>
                <span class="s0">cur = [];</span>
                <span class="s0">branch = </span><span class="s1">new </span><span class="s0">AST_Default({</span>
                    <span class="s0">start : (tmp = S.token, next(), expect(</span><span class="s2">&quot;:&quot;</span><span class="s0">), tmp),</span>
                    <span class="s0">body  : cur</span>
                <span class="s0">});</span>
                <span class="s0">a.push(branch);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(!cur) unexpected();</span>
                <span class="s0">cur.push(statement());</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(branch) branch.end = prev();</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">a;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">try_() {</span>
        <span class="s1">var </span><span class="s0">body, bcatch = </span><span class="s1">null</span><span class="s0">, bfinally = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">body = </span><span class="s1">new </span><span class="s0">AST_TryBlock({</span>
            <span class="s0">start : S.token,</span>
            <span class="s0">body  : block_(),</span>
            <span class="s0">end   : prev(),</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;catch&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">start = S.token;</span>
            <span class="s0">next();</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s0">)) {</span>
                <span class="s1">var </span><span class="s0">name = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">expect(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
                <span class="s1">var </span><span class="s0">name = parameter(undefined, AST_SymbolCatch);</span>
                <span class="s0">expect(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">bcatch = </span><span class="s1">new </span><span class="s0">AST_Catch({</span>
                <span class="s0">start   : start,</span>
                <span class="s0">argname : name,</span>
                <span class="s0">body    : block_(),</span>
                <span class="s0">end     : prev()</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;finally&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">start = S.token;</span>
            <span class="s0">next();</span>
            <span class="s0">bfinally = </span><span class="s1">new </span><span class="s0">AST_Finally({</span>
                <span class="s0">start : start,</span>
                <span class="s0">body  : block_(),</span>
                <span class="s0">end   : prev()</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!bcatch &amp;&amp; !bfinally)</span>
            <span class="s0">croak(</span><span class="s2">&quot;Missing catch/finally blocks&quot;</span><span class="s0">);</span>
        <span class="s1">return new </span><span class="s0">AST_Try({</span>
            <span class="s0">body     : body,</span>
            <span class="s0">bcatch   : bcatch,</span>
            <span class="s0">bfinally : bfinally</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">/** 
     * var 
     *   vardef1 = 2, 
     *   vardef2 = 3; 
     */</span>
    <span class="s1">function </span><span class="s0">vardefs(no_in, kind) {</span>
        <span class="s1">var </span><span class="s0">var_defs = [];</span>
        <span class="s1">var </span><span class="s0">def;</span>
        <span class="s1">for </span><span class="s0">(;;) {</span>
            <span class="s1">var </span><span class="s0">sym_type =</span>
                <span class="s0">kind === </span><span class="s2">&quot;var&quot; </span><span class="s0">? AST_SymbolVar :</span>
                <span class="s0">kind === </span><span class="s2">&quot;const&quot; </span><span class="s0">? AST_SymbolConst :</span>
                <span class="s0">kind === </span><span class="s2">&quot;let&quot; </span><span class="s0">? AST_SymbolLet : </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">// var { a } = b</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s0">) || is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;[&quot;</span><span class="s0">)) {</span>
                <span class="s0">def = </span><span class="s1">new </span><span class="s0">AST_VarDef({</span>
                    <span class="s0">start: S.token,</span>
                    <span class="s0">name: binding_element(undefined, sym_type),</span>
                    <span class="s0">value: is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">) ? (expect_token(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">), expression(</span><span class="s1">false</span><span class="s0">, no_in)) : </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">def = </span><span class="s1">new </span><span class="s0">AST_VarDef({</span>
                    <span class="s0">start : S.token,</span>
                    <span class="s0">name  : as_symbol(sym_type),</span>
                    <span class="s0">value : is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">)</span>
                        <span class="s0">? (next(), expression(</span><span class="s1">false</span><span class="s0">, no_in))</span>
                        <span class="s0">: !no_in &amp;&amp; kind === </span><span class="s2">&quot;const&quot;</span>
                            <span class="s0">? croak(</span><span class="s2">&quot;Missing initializer in const declaration&quot;</span><span class="s0">) : </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">end   : prev()</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(def.name.name == </span><span class="s2">&quot;import&quot;</span><span class="s0">) croak(</span><span class="s2">&quot;Unexpected token: import&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">var_defs.push(def);</span>
            <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;,&quot;</span><span class="s0">))</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">var_defs;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">var_ = </span><span class="s1">function</span><span class="s0">(no_in) {</span>
        <span class="s1">return new </span><span class="s0">AST_Var({</span>
            <span class="s0">start       : prev(),</span>
            <span class="s0">definitions : vardefs(no_in, </span><span class="s2">&quot;var&quot;</span><span class="s0">),</span>
            <span class="s0">end         : prev()</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">let_ = </span><span class="s1">function</span><span class="s0">(no_in) {</span>
        <span class="s1">return new </span><span class="s0">AST_Let({</span>
            <span class="s0">start       : prev(),</span>
            <span class="s0">definitions : vardefs(no_in, </span><span class="s2">&quot;let&quot;</span><span class="s0">),</span>
            <span class="s0">end         : prev()</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">const_ = </span><span class="s1">function</span><span class="s0">(no_in) {</span>
        <span class="s1">return new </span><span class="s0">AST_Const({</span>
            <span class="s0">start       : prev(),</span>
            <span class="s0">definitions : vardefs(no_in, </span><span class="s2">&quot;const&quot;</span><span class="s0">),</span>
            <span class="s0">end         : prev()</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">new_ = </span><span class="s1">function</span><span class="s0">(allow_calls) {</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s0">expect_token(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;new&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s0">expect_token(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;target&quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">subscripts(</span><span class="s1">new </span><span class="s0">AST_NewTarget({</span>
                <span class="s0">start : start,</span>
                <span class="s0">end   : prev()</span>
            <span class="s0">}), allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">newexp = expr_atom(</span><span class="s1">false</span><span class="s0">), args;</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s0">args = expr_list(</span><span class="s2">&quot;)&quot;</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">args = [];</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">call = </span><span class="s1">new </span><span class="s0">AST_New({</span>
            <span class="s0">start      : start,</span>
            <span class="s0">expression : newexp,</span>
            <span class="s0">args       : args,</span>
            <span class="s0">end        : prev()</span>
        <span class="s0">});</span>
        <span class="s0">annotate(call);</span>
        <span class="s1">return </span><span class="s0">subscripts(call, allow_calls);</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">as_atom_node() {</span>
        <span class="s1">var </span><span class="s0">tok = S.token, ret;</span>
        <span class="s1">switch </span><span class="s0">(tok.type) {</span>
          <span class="s1">case </span><span class="s2">&quot;name&quot;</span><span class="s0">:</span>
            <span class="s0">ret = _make_symbol(AST_SymbolRef);</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;num&quot;</span><span class="s0">:</span>
            <span class="s0">ret = </span><span class="s1">new </span><span class="s0">AST_Number({</span>
                <span class="s0">start: tok,</span>
                <span class="s0">end: tok,</span>
                <span class="s0">value: tok.value,</span>
                <span class="s0">raw: LATEST_RAW</span>
            <span class="s0">});</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;big_int&quot;</span><span class="s0">:</span>
            <span class="s0">ret = </span><span class="s1">new </span><span class="s0">AST_BigInt({ start: tok, end: tok, value: tok.value });</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;string&quot;</span><span class="s0">:</span>
            <span class="s0">ret = </span><span class="s1">new </span><span class="s0">AST_String({</span>
                <span class="s0">start : tok,</span>
                <span class="s0">end   : tok,</span>
                <span class="s0">value : tok.value,</span>
                <span class="s0">quote : tok.quote</span>
            <span class="s0">});</span>
            <span class="s0">annotate(ret);</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;regexp&quot;</span><span class="s0">:</span>
            <span class="s0">const [_, source, flags] = tok.value.match(/^\/(.*)\/(\w*)$/);</span>

            <span class="s0">ret = </span><span class="s1">new </span><span class="s0">AST_RegExp({ start: tok, end: tok, value: { source, flags } });</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;atom&quot;</span><span class="s0">:</span>
            <span class="s1">switch </span><span class="s0">(tok.value) {</span>
              <span class="s1">case </span><span class="s2">&quot;false&quot;</span><span class="s0">:</span>
                <span class="s0">ret = </span><span class="s1">new </span><span class="s0">AST_False({ start: tok, end: tok });</span>
                <span class="s1">break</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;true&quot;</span><span class="s0">:</span>
                <span class="s0">ret = </span><span class="s1">new </span><span class="s0">AST_True({ start: tok, end: tok });</span>
                <span class="s1">break</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;null&quot;</span><span class="s0">:</span>
                <span class="s0">ret = </span><span class="s1">new </span><span class="s0">AST_Null({ start: tok, end: tok });</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">to_fun_args(ex, default_seen_above) {</span>
        <span class="s1">var </span><span class="s0">insert_default = </span><span class="s1">function</span><span class="s0">(ex, default_value) {</span>
            <span class="s1">if </span><span class="s0">(default_value) {</span>
                <span class="s1">return new </span><span class="s0">AST_DefaultAssign({</span>
                    <span class="s0">start: ex.start,</span>
                    <span class="s0">left: ex,</span>
                    <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                    <span class="s0">right: default_value,</span>
                    <span class="s0">end: default_value.end</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">ex;</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_Object) {</span>
            <span class="s1">return </span><span class="s0">insert_default(</span><span class="s1">new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: ex.start,</span>
                <span class="s0">end: ex.end,</span>
                <span class="s0">is_array: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">names: ex.properties.map(prop =&gt; to_fun_args(prop))</span>
            <span class="s0">}), default_seen_above);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal) {</span>
            <span class="s0">ex.value = to_fun_args(ex.value);</span>
            <span class="s1">return </span><span class="s0">insert_default(ex, default_seen_above);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_Hole) {</span>
            <span class="s1">return </span><span class="s0">ex;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
            <span class="s0">ex.names = ex.names.map(name =&gt; to_fun_args(name));</span>
            <span class="s1">return </span><span class="s0">insert_default(ex, default_seen_above);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
            <span class="s1">return </span><span class="s0">insert_default(</span><span class="s1">new </span><span class="s0">AST_SymbolFunarg({</span>
                <span class="s0">name: ex.name,</span>
                <span class="s0">start: ex.start,</span>
                <span class="s0">end: ex.end</span>
            <span class="s0">}), default_seen_above);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
            <span class="s0">ex.expression = to_fun_args(ex.expression);</span>
            <span class="s1">return </span><span class="s0">insert_default(ex, default_seen_above);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
            <span class="s1">return </span><span class="s0">insert_default(</span><span class="s1">new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: ex.start,</span>
                <span class="s0">end: ex.end,</span>
                <span class="s0">is_array: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">names: ex.elements.map(elm =&gt; to_fun_args(elm))</span>
            <span class="s0">}), default_seen_above);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
            <span class="s1">return </span><span class="s0">insert_default(to_fun_args(ex.left, ex.right), default_seen_above);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_DefaultAssign) {</span>
            <span class="s0">ex.left = to_fun_args(ex.left);</span>
            <span class="s1">return </span><span class="s0">ex;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">croak(</span><span class="s2">&quot;Invalid function parameter&quot;</span><span class="s0">, ex.start.line, ex.start.col);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">expr_atom = </span><span class="s1">function</span><span class="s0">(allow_calls, allow_arrows) {</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;new&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">new_(allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;import&quot;</span><span class="s0">) &amp;&amp; is_token(peek(), </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">import_meta(allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">peeked;</span>
        <span class="s1">var </span><span class="s0">async = is(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;async&quot;</span><span class="s0">)</span>
            <span class="s0">&amp;&amp; (peeked = peek()).value != </span><span class="s2">&quot;[&quot;</span>
            <span class="s0">&amp;&amp; peeked.type != </span><span class="s2">&quot;arrow&quot;</span>
            <span class="s0">&amp;&amp; as_atom_node();</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">)) {</span>
            <span class="s1">switch </span><span class="s0">(S.token.value) {</span>
              <span class="s1">case </span><span class="s2">&quot;(&quot;</span><span class="s0">:</span>
                <span class="s1">if </span><span class="s0">(async &amp;&amp; !allow_calls) </span><span class="s1">break</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">exprs = params_or_seq_(allow_arrows, !async);</span>
                <span class="s1">if </span><span class="s0">(allow_arrows &amp;&amp; is(</span><span class="s2">&quot;arrow&quot;</span><span class="s0">, </span><span class="s2">&quot;=&gt;&quot;</span><span class="s0">)) {</span>
                    <span class="s1">return </span><span class="s0">arrow_function(start, exprs.map(e =&gt; to_fun_args(e)), !!async);</span>
                <span class="s0">}</span>
                <span class="s1">var </span><span class="s0">ex = async ? </span><span class="s1">new </span><span class="s0">AST_Call({</span>
                    <span class="s0">expression: async,</span>
                    <span class="s0">args: exprs</span>
                <span class="s0">}) : exprs.length == </span><span class="s4">1 </span><span class="s0">? exprs[</span><span class="s4">0</span><span class="s0">] : </span><span class="s1">new </span><span class="s0">AST_Sequence({</span>
                    <span class="s0">expressions: exprs</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(ex.start) {</span>
                    <span class="s0">const outer_comments_before = start.comments_before.length;</span>
                    <span class="s0">outer_comments_before_counts.set(start, outer_comments_before);</span>
                    <span class="s0">ex.start.comments_before.unshift(...start.comments_before);</span>
                    <span class="s0">start.comments_before = ex.start.comments_before;</span>
                    <span class="s1">if </span><span class="s0">(outer_comments_before == </span><span class="s4">0 </span><span class="s0">&amp;&amp; start.comments_before.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                        <span class="s1">var </span><span class="s0">comment = start.comments_before[</span><span class="s4">0</span><span class="s0">];</span>
                        <span class="s1">if </span><span class="s0">(!comment.nlb) {</span>
                            <span class="s0">comment.nlb = start.nlb;</span>
                            <span class="s0">start.nlb = </span><span class="s1">false</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s0">start.comments_after = ex.start.comments_after;</span>
                <span class="s0">}</span>
                <span class="s0">ex.start = start;</span>
                <span class="s1">var </span><span class="s0">end = prev();</span>
                <span class="s1">if </span><span class="s0">(ex.end) {</span>
                    <span class="s0">end.comments_before = ex.end.comments_before;</span>
                    <span class="s0">ex.end.comments_after.push(...end.comments_after);</span>
                    <span class="s0">end.comments_after = ex.end.comments_after;</span>
                <span class="s0">}</span>
                <span class="s0">ex.end = end;</span>
                <span class="s1">if </span><span class="s0">(ex </span><span class="s1">instanceof </span><span class="s0">AST_Call) annotate(ex);</span>
                <span class="s1">return </span><span class="s0">subscripts(ex, allow_calls);</span>
              <span class="s1">case </span><span class="s2">&quot;[&quot;</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">subscripts(array_(), allow_calls);</span>
              <span class="s1">case </span><span class="s2">&quot;{&quot;</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">subscripts(object_or_destructuring_(), allow_calls);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!async) unexpected();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(allow_arrows &amp;&amp; is(</span><span class="s2">&quot;name&quot;</span><span class="s0">) &amp;&amp; is_token(peek(), </span><span class="s2">&quot;arrow&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">param = </span><span class="s1">new </span><span class="s0">AST_SymbolFunarg({</span>
                <span class="s0">name: S.token.value,</span>
                <span class="s0">start: start,</span>
                <span class="s0">end: start,</span>
            <span class="s0">});</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">arrow_function(start, [param], !!async);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;function&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">var </span><span class="s0">func = function_(AST_Function, </span><span class="s1">false</span><span class="s0">, !!async);</span>
            <span class="s0">func.start = start;</span>
            <span class="s0">func.end = prev();</span>
            <span class="s1">return </span><span class="s0">subscripts(func, allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(async) </span><span class="s1">return </span><span class="s0">subscripts(async, allow_calls);</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;class&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">var </span><span class="s0">cls = class_(AST_ClassExpression);</span>
            <span class="s0">cls.start = start;</span>
            <span class="s0">cls.end = prev();</span>
            <span class="s1">return </span><span class="s0">subscripts(cls, allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;template_head&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">subscripts(template_string(), allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">)) {</span>
            <span class="s1">if</span><span class="s0">(!S.in_class) {</span>
                <span class="s0">croak(</span><span class="s2">&quot;Private field must be used in an enclosing class&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s0">const start = S.token;</span>
            <span class="s0">const key = </span><span class="s1">new </span><span class="s0">AST_SymbolPrivateProperty({</span>
                <span class="s0">start,</span>
                <span class="s0">name: start.value,</span>
                <span class="s0">end: start</span>
            <span class="s0">});</span>
            <span class="s0">next();</span>
            <span class="s0">expect_token(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;in&quot;</span><span class="s0">);</span>

            <span class="s0">const private_in = </span><span class="s1">new </span><span class="s0">AST_PrivateIn({</span>
                <span class="s0">start,</span>
                <span class="s0">key,</span>
                <span class="s0">value: subscripts(as_atom_node(), allow_calls),</span>
                <span class="s0">end: prev()</span>
            <span class="s0">});</span>

            <span class="s1">return </span><span class="s0">subscripts(private_in, allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(ATOMIC_START_TOKEN.has(S.token.type)) {</span>
            <span class="s1">return </span><span class="s0">subscripts(as_atom_node(), allow_calls);</span>
        <span class="s0">}</span>
        <span class="s0">unexpected();</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">template_string() {</span>
        <span class="s1">var </span><span class="s0">segments = [], start = S.token;</span>

        <span class="s0">segments.push(</span><span class="s1">new </span><span class="s0">AST_TemplateSegment({</span>
            <span class="s0">start: S.token,</span>
            <span class="s0">raw: TEMPLATE_RAWS.get(S.token),</span>
            <span class="s0">value: S.token.value,</span>
            <span class="s0">end: S.token</span>
        <span class="s0">}));</span>

        <span class="s1">while </span><span class="s0">(!S.token.template_end) {</span>
            <span class="s0">next();</span>
            <span class="s0">handle_regexp();</span>
            <span class="s0">segments.push(expression(</span><span class="s1">true</span><span class="s0">));</span>

            <span class="s0">segments.push(</span><span class="s1">new </span><span class="s0">AST_TemplateSegment({</span>
                <span class="s0">start: S.token,</span>
                <span class="s0">raw: TEMPLATE_RAWS.get(S.token),</span>
                <span class="s0">value: S.token.value,</span>
                <span class="s0">end: S.token</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>
        <span class="s0">next();</span>

        <span class="s1">return new </span><span class="s0">AST_TemplateString({</span>
            <span class="s0">start: start,</span>
            <span class="s0">segments: segments,</span>
            <span class="s0">end: S.token</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">expr_list(closing, allow_trailing_comma, allow_empty) {</span>
        <span class="s1">var </span><span class="s0">first = </span><span class="s1">true</span><span class="s0">, a = [];</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, closing)) {</span>
            <span class="s1">if </span><span class="s0">(first) first = </span><span class="s1">false</span><span class="s0">; </span><span class="s1">else </span><span class="s0">expect(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(allow_trailing_comma &amp;&amp; is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, closing)) </span><span class="s1">break</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;,&quot;</span><span class="s0">) &amp;&amp; allow_empty) {</span>
                <span class="s0">a.push(</span><span class="s1">new </span><span class="s0">AST_Hole({ start: S.token, end: S.token }));</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;expand&quot;</span><span class="s0">, </span><span class="s2">&quot;...&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>
                <span class="s0">a.push(</span><span class="s1">new </span><span class="s0">AST_Expansion({start: prev(), expression: expression(),end: S.token}));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">a.push(expression(</span><span class="s1">false</span><span class="s0">));</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">a;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">array_ = embed_tokens(</span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">expect(</span><span class="s2">&quot;[&quot;</span><span class="s0">);</span>
        <span class="s1">return new </span><span class="s0">AST_Array({</span>
            <span class="s0">elements: expr_list(</span><span class="s2">&quot;]&quot;</span><span class="s0">, !options.strict, </span><span class="s1">true</span><span class="s0">)</span>
        <span class="s0">});</span>
    <span class="s0">});</span>

    <span class="s1">var </span><span class="s0">create_accessor = embed_tokens((is_generator, is_async) =&gt; {</span>
        <span class="s1">return </span><span class="s0">function_(AST_Accessor, is_generator, is_async);</span>
    <span class="s0">});</span>

    <span class="s1">var </span><span class="s0">object_or_destructuring_ = embed_tokens(</span><span class="s1">function </span><span class="s0">object_or_destructuring_() {</span>
        <span class="s1">var </span><span class="s0">start = S.token, first = </span><span class="s1">true</span><span class="s0">, a = [];</span>
        <span class="s0">expect(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(first) first = </span><span class="s1">false</span><span class="s0">; </span><span class="s1">else </span><span class="s0">expect(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(!options.strict &amp;&amp; is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">))</span>
                <span class="s3">// allow trailing comma</span>
                <span class="s1">break</span><span class="s0">;</span>

            <span class="s0">start = S.token;</span>
            <span class="s1">if </span><span class="s0">(start.type == </span><span class="s2">&quot;expand&quot;</span><span class="s0">) {</span>
                <span class="s0">next();</span>
                <span class="s0">a.push(</span><span class="s1">new </span><span class="s0">AST_Expansion({</span>
                    <span class="s0">start: start,</span>
                    <span class="s0">expression: expression(</span><span class="s1">false</span><span class="s0">),</span>
                    <span class="s0">end: prev(),</span>
                <span class="s0">}));</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if</span><span class="s0">(is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">)) {</span>
                <span class="s0">croak(</span><span class="s2">&quot;private fields are not allowed in an object&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">name = as_property_name();</span>
            <span class="s1">var </span><span class="s0">value;</span>

            <span class="s3">// Check property and fetch value</span>
            <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;:&quot;</span><span class="s0">)) {</span>
                <span class="s1">var </span><span class="s0">concise = concise_method_or_getset(name, start);</span>
                <span class="s1">if </span><span class="s0">(concise) {</span>
                    <span class="s0">a.push(concise);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>

                <span class="s0">value = </span><span class="s1">new </span><span class="s0">AST_SymbolRef({</span>
                    <span class="s0">start: prev(),</span>
                    <span class="s0">name: name,</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(name === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">unexpected(prev());</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">next(); </span><span class="s3">// `:` - see first condition</span>
                <span class="s0">value = expression(</span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">}</span>

            <span class="s3">// Check for default value and alter value accordingly if necessary</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>
                <span class="s0">value = </span><span class="s1">new </span><span class="s0">AST_Assign({</span>
                    <span class="s0">start: start,</span>
                    <span class="s0">left: value,</span>
                    <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                    <span class="s0">right: expression(</span><span class="s1">false</span><span class="s0">),</span>
                    <span class="s0">logical: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">});</span>
            <span class="s0">}</span>

            <span class="s3">// Create property</span>
            <span class="s0">const kv = </span><span class="s1">new </span><span class="s0">AST_ObjectKeyVal({</span>
                <span class="s0">start: start,</span>
                <span class="s0">quote: start.quote,</span>
                <span class="s0">key: name </span><span class="s1">instanceof </span><span class="s0">AST_Node ? name : </span><span class="s2">&quot;&quot; </span><span class="s0">+ name,</span>
                <span class="s0">value: value,</span>
                <span class="s0">end: prev()</span>
            <span class="s0">});</span>
            <span class="s0">a.push(annotate(kv));</span>
        <span class="s0">}</span>
        <span class="s0">next();</span>
        <span class="s1">return new </span><span class="s0">AST_Object({ properties: a });</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">class_(KindOfClass, is_export_default) {</span>
        <span class="s1">var </span><span class="s0">start, method, class_name, extends_, a = [];</span>

        <span class="s0">S.input.push_directives_stack(); </span><span class="s3">// Push directive stack, but not scope stack</span>
        <span class="s0">S.input.add_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">);</span>

        <span class="s1">if </span><span class="s0">(S.token.type == </span><span class="s2">&quot;name&quot; </span><span class="s0">&amp;&amp; S.token.value != </span><span class="s2">&quot;extends&quot;</span><span class="s0">) {</span>
            <span class="s0">class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(KindOfClass === AST_DefClass &amp;&amp; !class_name) {</span>
            <span class="s1">if </span><span class="s0">(is_export_default) {</span>
                <span class="s0">KindOfClass = AST_ClassExpression;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">unexpected();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(S.token.value == </span><span class="s2">&quot;extends&quot;</span><span class="s0">) {</span>
            <span class="s0">next();</span>
            <span class="s0">extends_ = expression(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s0">expect(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
        <span class="s3">// mark in class feild,</span>
        <span class="s0">const save_in_class = S.in_class;</span>
        <span class="s0">S.in_class = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)) { next(); }  </span><span class="s3">// Leading semicolons are okay in class bodies.</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
            <span class="s0">start = S.token;</span>
            <span class="s0">method = concise_method_or_getset(as_property_name(), start, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(!method) { unexpected(); }</span>
            <span class="s0">a.push(method);</span>
            <span class="s1">while </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)) { next(); }</span>
        <span class="s0">}</span>
        <span class="s3">// mark in class feild,</span>
        <span class="s0">S.in_class = save_in_class;</span>

        <span class="s0">S.input.pop_directives_stack();</span>

        <span class="s0">next();</span>

        <span class="s1">return new </span><span class="s0">KindOfClass({</span>
            <span class="s0">start: start,</span>
            <span class="s0">name: class_name,</span>
            <span class="s0">extends: extends_,</span>
            <span class="s0">properties: a,</span>
            <span class="s0">end: prev(),</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">concise_method_or_getset(name, start, is_class) {</span>
        <span class="s0">const get_symbol_ast = (name, SymbolClass = AST_SymbolMethod) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">name === </span><span class="s2">&quot;string&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">name === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">SymbolClass({</span>
                    <span class="s0">start,</span>
                    <span class="s0">name: </span><span class="s2">&quot;&quot; </span><span class="s0">+ name,</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(name === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">unexpected();</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">name;</span>
        <span class="s0">};</span>

        <span class="s0">const is_not_method_start = () =&gt;</span>
            <span class="s0">!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">) &amp;&amp; !is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;,&quot;</span><span class="s0">) &amp;&amp; !is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">) &amp;&amp; !is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">) &amp;&amp; !is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">);</span>

        <span class="s1">var </span><span class="s0">is_async = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">is_static = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">is_generator = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">is_private = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">accessor_type = </span><span class="s1">null</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(is_class &amp;&amp; name === </span><span class="s2">&quot;static&quot; </span><span class="s0">&amp;&amp; is_not_method_start()) {</span>
            <span class="s0">const static_block = class_static_block();</span>
            <span class="s1">if </span><span class="s0">(static_block != </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">static_block;</span>
            <span class="s0">}</span>
            <span class="s0">is_static = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">name = as_property_name();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;async&quot; </span><span class="s0">&amp;&amp; is_not_method_start()) {</span>
            <span class="s0">is_async = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">name = as_property_name();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(prev().type === </span><span class="s2">&quot;operator&quot; </span><span class="s0">&amp;&amp; prev().value === </span><span class="s2">&quot;*&quot;</span><span class="s0">) {</span>
            <span class="s0">is_generator = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">name = as_property_name();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">((name === </span><span class="s2">&quot;get&quot; </span><span class="s0">|| name === </span><span class="s2">&quot;set&quot;</span><span class="s0">) &amp;&amp; is_not_method_start()) {</span>
            <span class="s0">accessor_type = name;</span>
            <span class="s0">name = as_property_name();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(prev().type === </span><span class="s2">&quot;privatename&quot;</span><span class="s0">) {</span>
            <span class="s0">is_private = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">const property_token = prev();</span>

        <span class="s1">if </span><span class="s0">(accessor_type != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(!is_private) {</span>
                <span class="s0">const AccessorClass = accessor_type === </span><span class="s2">&quot;get&quot;</span>
                    <span class="s0">? AST_ObjectGetter</span>
                    <span class="s0">: AST_ObjectSetter;</span>

                <span class="s0">name = get_symbol_ast(name);</span>
                <span class="s1">return </span><span class="s0">annotate(</span><span class="s1">new </span><span class="s0">AccessorClass({</span>
                    <span class="s0">start,</span>
                    <span class="s0">static: is_static,</span>
                    <span class="s0">key: name,</span>
                    <span class="s0">quote: name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod ? property_token.quote : undefined,</span>
                    <span class="s0">value: create_accessor(),</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">}));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">const AccessorClass = accessor_type === </span><span class="s2">&quot;get&quot;</span>
                    <span class="s0">? AST_PrivateGetter</span>
                    <span class="s0">: AST_PrivateSetter;</span>

                <span class="s1">return </span><span class="s0">annotate(</span><span class="s1">new </span><span class="s0">AccessorClass({</span>
                    <span class="s0">start,</span>
                    <span class="s0">static: is_static,</span>
                    <span class="s0">key: get_symbol_ast(name),</span>
                    <span class="s0">value: create_accessor(),</span>
                    <span class="s0">end: prev(),</span>
                <span class="s0">}));</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">)) {</span>
            <span class="s0">name = get_symbol_ast(name);</span>
            <span class="s0">const AST_MethodVariant = is_private</span>
                <span class="s0">? AST_PrivateMethod</span>
                <span class="s0">: AST_ConciseMethod;</span>
            <span class="s1">var </span><span class="s0">node = </span><span class="s1">new </span><span class="s0">AST_MethodVariant({</span>
                <span class="s0">start       : start,</span>
                <span class="s0">static      : is_static,</span>
                <span class="s0">is_generator: is_generator,</span>
                <span class="s0">async       : is_async,</span>
                <span class="s0">key         : name,</span>
                <span class="s0">quote       : name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod ?</span>
                              <span class="s0">property_token.quote : undefined,</span>
                <span class="s0">value       : create_accessor(is_generator, is_async),</span>
                <span class="s0">end         : prev()</span>
            <span class="s0">});</span>
            <span class="s1">return </span><span class="s0">annotate(node);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(is_class) {</span>
            <span class="s0">const key = get_symbol_ast(name, AST_SymbolClassProperty);</span>
            <span class="s0">const quote = key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolClassProperty</span>
                <span class="s0">? property_token.quote</span>
                <span class="s0">: undefined;</span>
            <span class="s0">const AST_ClassPropertyVariant = is_private</span>
                <span class="s0">? AST_ClassPrivateProperty</span>
                <span class="s0">: AST_ClassProperty;</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;=&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">annotate(</span>
                    <span class="s1">new </span><span class="s0">AST_ClassPropertyVariant({</span>
                        <span class="s0">start,</span>
                        <span class="s0">static: is_static,</span>
                        <span class="s0">quote,</span>
                        <span class="s0">key,</span>
                        <span class="s0">value: expression(</span><span class="s1">false</span><span class="s0">),</span>
                        <span class="s0">end: prev()</span>
                    <span class="s0">})</span>
                <span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
                <span class="s0">is(</span><span class="s2">&quot;name&quot;</span><span class="s0">)</span>
                <span class="s0">|| is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">)</span>
                <span class="s0">|| is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">)</span>
                <span class="s0">|| is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;;&quot;</span><span class="s0">)</span>
                <span class="s0">|| is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)</span>
            <span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">annotate(</span>
                    <span class="s1">new </span><span class="s0">AST_ClassPropertyVariant({</span>
                        <span class="s0">start,</span>
                        <span class="s0">static: is_static,</span>
                        <span class="s0">quote,</span>
                        <span class="s0">key,</span>
                        <span class="s0">end: prev()</span>
                    <span class="s0">})</span>
                <span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">class_static_block() {</span>
        <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s0">)) {</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">const start = S.token;</span>
        <span class="s0">const body = [];</span>

        <span class="s0">next();</span>

        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
            <span class="s0">body.push(statement());</span>
        <span class="s0">}</span>

        <span class="s0">next();</span>

        <span class="s1">return new </span><span class="s0">AST_ClassStaticBlock({ start, body, end: prev() });</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">maybe_import_assertion() {</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;assert&quot;</span><span class="s0">) &amp;&amp; !has_newline_before(S.token)) {</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">object_or_destructuring_();</span>
        <span class="s0">}</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">import_statement() {</span>
        <span class="s1">var </span><span class="s0">start = prev();</span>

        <span class="s1">var </span><span class="s0">imported_name;</span>
        <span class="s1">var </span><span class="s0">imported_names;</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">)) {</span>
            <span class="s0">imported_name = as_symbol(AST_SymbolImport);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;,&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>

        <span class="s0">imported_names = map_names(</span><span class="s1">true</span><span class="s0">);</span>

        <span class="s1">if </span><span class="s0">(imported_names || imported_name) {</span>
            <span class="s0">expect_token(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;from&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">mod_str = S.token;</span>
        <span class="s1">if </span><span class="s0">(mod_str.type !== </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s0">unexpected();</span>
        <span class="s0">}</span>
        <span class="s0">next();</span>

        <span class="s0">const assert_clause = maybe_import_assertion();</span>

        <span class="s1">return new </span><span class="s0">AST_Import({</span>
            <span class="s0">start,</span>
            <span class="s0">imported_name,</span>
            <span class="s0">imported_names,</span>
            <span class="s0">module_name: </span><span class="s1">new </span><span class="s0">AST_String({</span>
                <span class="s0">start: mod_str,</span>
                <span class="s0">value: mod_str.value,</span>
                <span class="s0">quote: mod_str.quote,</span>
                <span class="s0">end: mod_str,</span>
            <span class="s0">}),</span>
            <span class="s0">assert_clause,</span>
            <span class="s0">end: S.token,</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">import_meta(allow_calls) {</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s0">expect_token(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;import&quot;</span><span class="s0">);</span>
        <span class="s0">expect_token(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s0">);</span>
        <span class="s0">expect_token(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;meta&quot;</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">subscripts(</span><span class="s1">new </span><span class="s0">AST_ImportMeta({</span>
            <span class="s0">start: start,</span>
            <span class="s0">end: prev()</span>
        <span class="s0">}), allow_calls);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">map_name(is_import) {</span>
        <span class="s1">function </span><span class="s0">make_symbol(type, quote) {</span>
            <span class="s1">return new </span><span class="s0">type({</span>
                <span class="s0">name: as_property_name(),</span>
                <span class="s0">quote: quote || undefined,</span>
                <span class="s0">start: prev(),</span>
                <span class="s0">end: prev()</span>
            <span class="s0">});</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;</span>
        <span class="s1">var </span><span class="s0">type = is_import ? AST_SymbolImport : AST_SymbolExport;</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">foreign_name;</span>
        <span class="s1">var </span><span class="s0">name;</span>

        <span class="s1">if </span><span class="s0">(is_import) {</span>
            <span class="s0">foreign_name = make_symbol(foreign_type, start.quote);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">name = make_symbol(type, start.quote);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;as&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();  </span><span class="s3">// The &quot;as&quot; word</span>
            <span class="s1">if </span><span class="s0">(is_import) {</span>
                <span class="s0">name = make_symbol(type);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">foreign_name = make_symbol(foreign_type, S.token.quote);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_import) {</span>
            <span class="s0">name = </span><span class="s1">new </span><span class="s0">type(foreign_name);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">foreign_name = </span><span class="s1">new </span><span class="s0">foreign_type(name);</span>
        <span class="s0">}</span>

        <span class="s1">return new </span><span class="s0">AST_NameMapping({</span>
            <span class="s0">start: start,</span>
            <span class="s0">foreign_name: foreign_name,</span>
            <span class="s0">name: name,</span>
            <span class="s0">end: prev(),</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">map_nameAsterisk(is_import, import_or_export_foreign_name) {</span>
        <span class="s1">var </span><span class="s0">foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;</span>
        <span class="s1">var </span><span class="s0">type = is_import ? AST_SymbolImport : AST_SymbolExport;</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">name, foreign_name;</span>
        <span class="s1">var </span><span class="s0">end = prev();</span>

        <span class="s1">if </span><span class="s0">(is_import) {</span>
            <span class="s0">name = import_or_export_foreign_name;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">foreign_name = import_or_export_foreign_name;</span>
        <span class="s0">}</span>

        <span class="s0">name = name || </span><span class="s1">new </span><span class="s0">type({</span>
            <span class="s0">start: start,</span>
            <span class="s0">name: </span><span class="s2">&quot;*&quot;</span><span class="s0">,</span>
            <span class="s0">end: end,</span>
        <span class="s0">});</span>

        <span class="s0">foreign_name = foreign_name || </span><span class="s1">new </span><span class="s0">foreign_type({</span>
            <span class="s0">start: start,</span>
            <span class="s0">name: </span><span class="s2">&quot;*&quot;</span><span class="s0">,</span>
            <span class="s0">end: end,</span>
        <span class="s0">});</span>

        <span class="s1">return new </span><span class="s0">AST_NameMapping({</span>
            <span class="s0">start: start,</span>
            <span class="s0">foreign_name: foreign_name,</span>
            <span class="s0">name: name,</span>
            <span class="s0">end: end,</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">map_names(is_import) {</span>
        <span class="s1">var </span><span class="s0">names;</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s0">names = [];</span>
            <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;}&quot;</span><span class="s0">)) {</span>
                <span class="s0">names.push(map_name(is_import));</span>
                <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;,&quot;</span><span class="s0">)) {</span>
                    <span class="s0">next();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">next();</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">name;</span>
            <span class="s0">next();</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;as&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();  </span><span class="s3">// The &quot;as&quot; word</span>
                <span class="s0">name = is_import ? as_symbol(AST_SymbolImport) : as_symbol_or_string(AST_SymbolExportForeign);</span>
            <span class="s0">}</span>
            <span class="s0">names = [map_nameAsterisk(is_import, name)];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">names;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">export_statement() {</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">is_default;</span>
        <span class="s1">var </span><span class="s0">exported_names;</span>

        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;default&quot;</span><span class="s0">)) {</span>
            <span class="s0">is_default = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">next();</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(exported_names = map_names(</span><span class="s1">false</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s2">&quot;from&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>

                <span class="s1">var </span><span class="s0">mod_str = S.token;</span>
                <span class="s1">if </span><span class="s0">(mod_str.type !== </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                    <span class="s0">unexpected();</span>
                <span class="s0">}</span>
                <span class="s0">next();</span>

                <span class="s0">const assert_clause = maybe_import_assertion();</span>

                <span class="s1">return new </span><span class="s0">AST_Export({</span>
                    <span class="s0">start: start,</span>
                    <span class="s0">is_default: is_default,</span>
                    <span class="s0">exported_names: exported_names,</span>
                    <span class="s0">module_name: </span><span class="s1">new </span><span class="s0">AST_String({</span>
                        <span class="s0">start: mod_str,</span>
                        <span class="s0">value: mod_str.value,</span>
                        <span class="s0">quote: mod_str.quote,</span>
                        <span class="s0">end: mod_str,</span>
                    <span class="s0">}),</span>
                    <span class="s0">end: prev(),</span>
                    <span class="s0">assert_clause</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return new </span><span class="s0">AST_Export({</span>
                    <span class="s0">start: start,</span>
                    <span class="s0">is_default: is_default,</span>
                    <span class="s0">exported_names: exported_names,</span>
                    <span class="s0">end: prev(),</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">node;</span>
        <span class="s1">var </span><span class="s0">exported_value;</span>
        <span class="s1">var </span><span class="s0">exported_definition;</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;{&quot;</span><span class="s0">)</span>
            <span class="s0">|| is_default</span>
                <span class="s0">&amp;&amp; (is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;class&quot;</span><span class="s0">) || is(</span><span class="s2">&quot;keyword&quot;</span><span class="s0">, </span><span class="s2">&quot;function&quot;</span><span class="s0">))</span>
                <span class="s0">&amp;&amp; is_token(peek(), </span><span class="s2">&quot;punc&quot;</span><span class="s0">)) {</span>
            <span class="s0">exported_value = expression(</span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">semicolon();</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">((node = statement(is_default)) </span><span class="s1">instanceof </span><span class="s0">AST_Definitions &amp;&amp; is_default) {</span>
            <span class="s0">unexpected(node.start);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Definitions</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Defun</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_DefClass</span>
        <span class="s0">) {</span>
            <span class="s0">exported_definition = node;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_ClassExpression</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Function</span>
        <span class="s0">) {</span>
            <span class="s0">exported_value = node;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
            <span class="s0">exported_value = node.body;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">unexpected(node.start);</span>
        <span class="s0">}</span>

        <span class="s1">return new </span><span class="s0">AST_Export({</span>
            <span class="s0">start: start,</span>
            <span class="s0">is_default: is_default,</span>
            <span class="s0">exported_value: exported_value,</span>
            <span class="s0">exported_definition: exported_definition,</span>
            <span class="s0">end: prev(),</span>
            <span class="s0">assert_clause: </span><span class="s1">null</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">as_property_name() {</span>
        <span class="s1">var </span><span class="s0">tmp = S.token;</span>
        <span class="s1">switch </span><span class="s0">(tmp.type) {</span>
          <span class="s1">case </span><span class="s2">&quot;punc&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(tmp.value === </span><span class="s2">&quot;[&quot;</span><span class="s0">) {</span>
                <span class="s0">next();</span>
                <span class="s1">var </span><span class="s0">ex = expression(</span><span class="s1">false</span><span class="s0">);</span>
                <span class="s0">expect(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">ex;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">unexpected(tmp);</span>
          <span class="s1">case </span><span class="s2">&quot;operator&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(tmp.value === </span><span class="s2">&quot;*&quot;</span><span class="s0">) {</span>
                <span class="s0">next();</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(![</span><span class="s2">&quot;delete&quot;</span><span class="s0">, </span><span class="s2">&quot;in&quot;</span><span class="s0">, </span><span class="s2">&quot;instanceof&quot;</span><span class="s0">, </span><span class="s2">&quot;new&quot;</span><span class="s0">, </span><span class="s2">&quot;typeof&quot;</span><span class="s0">, </span><span class="s2">&quot;void&quot;</span><span class="s0">].includes(tmp.value)) {</span>
                <span class="s0">unexpected(tmp);</span>
            <span class="s0">}</span>
            <span class="s3">/* falls through */</span>
          <span class="s1">case </span><span class="s2">&quot;name&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;privatename&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;string&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;num&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;big_int&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;keyword&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;atom&quot;</span><span class="s0">:</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">tmp.value;</span>
          <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">unexpected(tmp);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">as_name() {</span>
        <span class="s1">var </span><span class="s0">tmp = S.token;</span>
        <span class="s1">if </span><span class="s0">(tmp.type != </span><span class="s2">&quot;name&quot; </span><span class="s0">&amp;&amp; tmp.type != </span><span class="s2">&quot;privatename&quot;</span><span class="s0">) unexpected();</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">tmp.value;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">_make_symbol(type) {</span>
        <span class="s1">var </span><span class="s0">name = S.token.value;</span>
        <span class="s1">return new </span><span class="s0">(name == </span><span class="s2">&quot;this&quot; </span><span class="s0">? AST_This :</span>
                    <span class="s0">name == </span><span class="s2">&quot;super&quot; </span><span class="s0">? AST_Super :</span>
                    <span class="s0">type)({</span>
            <span class="s0">name  : String(name),</span>
            <span class="s0">start : S.token,</span>
            <span class="s0">end   : S.token</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">_verify_symbol(sym) {</span>
        <span class="s1">var </span><span class="s0">name = sym.name;</span>
        <span class="s1">if </span><span class="s0">(is_in_generator() &amp;&amp; name == </span><span class="s2">&quot;yield&quot;</span><span class="s0">) {</span>
            <span class="s0">token_error(sym.start, </span><span class="s2">&quot;Yield cannot be used as identifier inside generators&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(name == </span><span class="s2">&quot;yield&quot;</span><span class="s0">) {</span>
                <span class="s0">token_error(sym.start, </span><span class="s2">&quot;Unexpected yield identifier inside strict mode&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration &amp;&amp; (name == </span><span class="s2">&quot;arguments&quot; </span><span class="s0">|| name == </span><span class="s2">&quot;eval&quot;</span><span class="s0">)) {</span>
                <span class="s0">token_error(sym.start, </span><span class="s2">&quot;Unexpected &quot; </span><span class="s0">+ name + </span><span class="s2">&quot; in strict mode&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">as_symbol(type, noerror) {</span>
        <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;name&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(!noerror) croak(</span><span class="s2">&quot;Name expected&quot;</span><span class="s0">);</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">sym = _make_symbol(type);</span>
        <span class="s0">_verify_symbol(sym);</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">sym;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">as_symbol_or_string(type) {</span>
        <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;name&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;string&quot;</span><span class="s0">)) {</span>
                <span class="s0">croak(</span><span class="s2">&quot;Name or string expected&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">tok = S.token;</span>
            <span class="s1">var </span><span class="s0">ret = </span><span class="s1">new </span><span class="s0">type({</span>
                <span class="s0">start : tok,</span>
                <span class="s0">end   : tok,</span>
                <span class="s0">name : tok.value,</span>
                <span class="s0">quote : tok.quote</span>
            <span class="s0">});</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">ret;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">sym = _make_symbol(type);</span>
        <span class="s0">_verify_symbol(sym);</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">sym;</span>
    <span class="s0">}</span>

    <span class="s3">// Annotate AST_Call, AST_Lambda or AST_New with the special comments</span>
    <span class="s1">function </span><span class="s0">annotate(node, before_token = node.start) {</span>
        <span class="s1">var </span><span class="s0">comments = before_token.comments_before;</span>
        <span class="s0">const comments_outside_parens = outer_comments_before_counts.get(before_token);</span>
        <span class="s1">var </span><span class="s0">i = comments_outside_parens != </span><span class="s1">null </span><span class="s0">? comments_outside_parens : comments.length;</span>
        <span class="s1">while </span><span class="s0">(--i &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">comment = comments[i];</span>
            <span class="s1">if </span><span class="s0">(/[@#]__/.test(comment.value)) {</span>
                <span class="s1">if </span><span class="s0">(/[@#]__PURE__/.test(comment.value)) {</span>
                    <span class="s0">set_annotation(node, _PURE);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(/[@#]__INLINE__/.test(comment.value)) {</span>
                    <span class="s0">set_annotation(node, _INLINE);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(/[@#]__NOINLINE__/.test(comment.value)) {</span>
                    <span class="s0">set_annotation(node, _NOINLINE);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(/[@#]__KEY__/.test(comment.value)) {</span>
                    <span class="s0">set_annotation(node, _KEY);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(/[@#]__MANGLE_PROP__/.test(comment.value)) {</span>
                    <span class="s0">set_annotation(node, _MANGLEPROP);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">node;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">subscripts = </span><span class="s1">function</span><span class="s0">(expr, allow_calls, is_chain) {</span>
        <span class="s1">var </span><span class="s0">start = expr.start;</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;.&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">if</span><span class="s0">(is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">) &amp;&amp; !S.in_class) </span>
                <span class="s0">croak(</span><span class="s2">&quot;Private field must be used in an enclosing class&quot;</span><span class="s0">);</span>
            <span class="s0">const AST_DotVariant = is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">) ? AST_DotHash : AST_Dot;</span>
            <span class="s1">return </span><span class="s0">annotate(subscripts(</span><span class="s1">new </span><span class="s0">AST_DotVariant({</span>
                <span class="s0">start      : start,</span>
                <span class="s0">expression : expr,</span>
                <span class="s0">optional   : </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">property   : as_name(),</span>
                <span class="s0">end        : prev()</span>
            <span class="s0">}), allow_calls, is_chain));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;[&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">var </span><span class="s0">prop = expression(</span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">expect(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">annotate(subscripts(</span><span class="s1">new </span><span class="s0">AST_Sub({</span>
                <span class="s0">start      : start,</span>
                <span class="s0">expression : expr,</span>
                <span class="s0">optional   : </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">property   : prop,</span>
                <span class="s0">end        : prev()</span>
            <span class="s0">}), allow_calls, is_chain));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(allow_calls &amp;&amp; is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">var </span><span class="s0">call = </span><span class="s1">new </span><span class="s0">AST_Call({</span>
                <span class="s0">start      : start,</span>
                <span class="s0">expression : expr,</span>
                <span class="s0">optional   : </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">args       : call_args(),</span>
                <span class="s0">end        : prev()</span>
            <span class="s0">});</span>
            <span class="s0">annotate(call);</span>
            <span class="s1">return </span><span class="s0">subscripts(call, </span><span class="s1">true</span><span class="s0">, is_chain);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;?.&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>

            <span class="s0">let chain_contents;</span>

            <span class="s1">if </span><span class="s0">(allow_calls &amp;&amp; is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>

                <span class="s0">const call = </span><span class="s1">new </span><span class="s0">AST_Call({</span>
                    <span class="s0">start,</span>
                    <span class="s0">optional: </span><span class="s1">true</span><span class="s0">,</span>
                    <span class="s0">expression: expr,</span>
                    <span class="s0">args: call_args(),</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">});</span>
                <span class="s0">annotate(call);</span>

                <span class="s0">chain_contents = subscripts(call, </span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;name&quot;</span><span class="s0">) || is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">)) {</span>
                <span class="s1">if</span><span class="s0">(is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">) &amp;&amp; !S.in_class) </span>
                    <span class="s0">croak(</span><span class="s2">&quot;Private field must be used in an enclosing class&quot;</span><span class="s0">);</span>
                <span class="s0">const AST_DotVariant = is(</span><span class="s2">&quot;privatename&quot;</span><span class="s0">) ? AST_DotHash : AST_Dot;</span>
                <span class="s0">chain_contents = annotate(subscripts(</span><span class="s1">new </span><span class="s0">AST_DotVariant({</span>
                    <span class="s0">start,</span>
                    <span class="s0">expression: expr,</span>
                    <span class="s0">optional: </span><span class="s1">true</span><span class="s0">,</span>
                    <span class="s0">property: as_name(),</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">}), allow_calls, </span><span class="s1">true</span><span class="s0">));</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;[&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>
                <span class="s0">const property = expression(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">expect(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
                <span class="s0">chain_contents = annotate(subscripts(</span><span class="s1">new </span><span class="s0">AST_Sub({</span>
                    <span class="s0">start,</span>
                    <span class="s0">expression: expr,</span>
                    <span class="s0">optional: </span><span class="s1">true</span><span class="s0">,</span>
                    <span class="s0">property,</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">}), allow_calls, </span><span class="s1">true</span><span class="s0">));</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(!chain_contents) unexpected();</span>

            <span class="s1">if </span><span class="s0">(chain_contents </span><span class="s1">instanceof </span><span class="s0">AST_Chain) </span><span class="s1">return </span><span class="s0">chain_contents;</span>

            <span class="s1">return new </span><span class="s0">AST_Chain({</span>
                <span class="s0">start,</span>
                <span class="s0">expression: chain_contents,</span>
                <span class="s0">end: prev()</span>
            <span class="s0">});</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;template_head&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(is_chain) {</span>
                <span class="s3">// a?.b`c` is a syntax error</span>
                <span class="s0">unexpected();</span>
            <span class="s0">}</span>

            <span class="s1">return </span><span class="s0">subscripts(</span><span class="s1">new </span><span class="s0">AST_PrefixedTemplateString({</span>
                <span class="s0">start: start,</span>
                <span class="s0">prefix: expr,</span>
                <span class="s0">template_string: template_string(),</span>
                <span class="s0">end: prev()</span>
            <span class="s0">}), allow_calls);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">expr;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">call_args() {</span>
        <span class="s1">var </span><span class="s0">args = [];</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;expand&quot;</span><span class="s0">, </span><span class="s2">&quot;...&quot;</span><span class="s0">)) {</span>
                <span class="s0">next();</span>
                <span class="s0">args.push(</span><span class="s1">new </span><span class="s0">AST_Expansion({</span>
                    <span class="s0">start: prev(),</span>
                    <span class="s0">expression: expression(</span><span class="s1">false</span><span class="s0">),</span>
                    <span class="s0">end: prev()</span>
                <span class="s0">}));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">args.push(expression(</span><span class="s1">false</span><span class="s0">));</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;)&quot;</span><span class="s0">)) {</span>
                <span class="s0">expect(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">next();</span>
        <span class="s1">return </span><span class="s0">args;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">maybe_unary = </span><span class="s1">function</span><span class="s0">(allow_calls, allow_arrows) {</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">if </span><span class="s0">(start.type == </span><span class="s2">&quot;name&quot; </span><span class="s0">&amp;&amp; start.value == </span><span class="s2">&quot;await&quot; </span><span class="s0">&amp;&amp; can_await()) {</span>
            <span class="s0">next();</span>
            <span class="s1">return </span><span class="s0">_await_expression();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">) &amp;&amp; UNARY_PREFIX.has(start.value)) {</span>
            <span class="s0">next();</span>
            <span class="s0">handle_regexp();</span>
            <span class="s1">var </span><span class="s0">ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));</span>
            <span class="s0">ex.start = start;</span>
            <span class="s0">ex.end = prev();</span>
            <span class="s1">return </span><span class="s0">ex;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">val = expr_atom(allow_calls, allow_arrows);</span>
        <span class="s1">while </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">) &amp;&amp; UNARY_POSTFIX.has(S.token.value) &amp;&amp; !has_newline_before(S.token)) {</span>
            <span class="s1">if </span><span class="s0">(val </span><span class="s1">instanceof </span><span class="s0">AST_Arrow) unexpected();</span>
            <span class="s0">val = make_unary(AST_UnaryPostfix, S.token, val);</span>
            <span class="s0">val.start = start;</span>
            <span class="s0">val.end = S.token;</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">val;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">make_unary(ctor, token, expr) {</span>
        <span class="s1">var </span><span class="s0">op = token.value;</span>
        <span class="s1">switch </span><span class="s0">(op) {</span>
          <span class="s1">case </span><span class="s2">&quot;++&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;--&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(!is_assignable(expr))</span>
                <span class="s0">croak(</span><span class="s2">&quot;Invalid use of &quot; </span><span class="s0">+ op + </span><span class="s2">&quot; operator&quot;</span><span class="s0">, token.line, token.col, token.pos);</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;delete&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">))</span>
                <span class="s0">croak(</span><span class="s2">&quot;Calling delete on expression not allowed in strict mode&quot;</span><span class="s0">, expr.start.line, expr.start.col, expr.start.pos);</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return new </span><span class="s0">ctor({ operator: op, expression: expr });</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">expr_op = </span><span class="s1">function</span><span class="s0">(left, min_prec, no_in) {</span>
        <span class="s1">var </span><span class="s0">op = is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">) ? S.token.value : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(op == </span><span class="s2">&quot;in&quot; </span><span class="s0">&amp;&amp; no_in) op = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(op == </span><span class="s2">&quot;**&quot; </span><span class="s0">&amp;&amp; left </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
            <span class="s3">/* unary token in front not allowed - parenthesis required */</span>
            <span class="s0">&amp;&amp; !is_token(left.start, </span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;(&quot;</span><span class="s0">)</span>
            <span class="s0">&amp;&amp; left.operator !== </span><span class="s2">&quot;--&quot; </span><span class="s0">&amp;&amp; left.operator !== </span><span class="s2">&quot;++&quot;</span><span class="s0">)</span>
                <span class="s0">unexpected(left.start);</span>
        <span class="s1">var </span><span class="s0">prec = op != </span><span class="s1">null </span><span class="s0">? PRECEDENCE[op] : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(prec != </span><span class="s1">null </span><span class="s0">&amp;&amp; (prec &gt; min_prec || (op === </span><span class="s2">&quot;**&quot; </span><span class="s0">&amp;&amp; min_prec === prec))) {</span>
            <span class="s0">next();</span>
            <span class="s1">var </span><span class="s0">right = expr_op(maybe_unary(</span><span class="s1">true</span><span class="s0">), prec, no_in);</span>
            <span class="s1">return </span><span class="s0">expr_op(</span><span class="s1">new </span><span class="s0">AST_Binary({</span>
                <span class="s0">start    : left.start,</span>
                <span class="s0">left     : left,</span>
                <span class="s0">operator : op,</span>
                <span class="s0">right    : right,</span>
                <span class="s0">end      : right.end</span>
            <span class="s0">}), min_prec, no_in);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">left;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">expr_ops(no_in) {</span>
        <span class="s1">return </span><span class="s0">expr_op(maybe_unary(</span><span class="s1">true</span><span class="s0">, </span><span class="s1">true</span><span class="s0">), </span><span class="s4">0</span><span class="s0">, no_in);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">maybe_conditional = </span><span class="s1">function</span><span class="s0">(no_in) {</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">expr = expr_ops(no_in);</span>
        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">, </span><span class="s2">&quot;?&quot;</span><span class="s0">)) {</span>
            <span class="s0">next();</span>
            <span class="s1">var </span><span class="s0">yes = expression(</span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">expect(</span><span class="s2">&quot;:&quot;</span><span class="s0">);</span>
            <span class="s1">return new </span><span class="s0">AST_Conditional({</span>
                <span class="s0">start       : start,</span>
                <span class="s0">condition   : expr,</span>
                <span class="s0">consequent  : yes,</span>
                <span class="s0">alternative : expression(</span><span class="s1">false</span><span class="s0">, no_in),</span>
                <span class="s0">end         : prev()</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">expr;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">is_assignable(expr) {</span>
        <span class="s1">return </span><span class="s0">expr </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess || expr </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">to_destructuring(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Object) {</span>
            <span class="s0">node = </span><span class="s1">new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: node.start,</span>
                <span class="s0">names: node.properties.map(to_destructuring),</span>
                <span class="s0">is_array: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">end: node.end</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
            <span class="s1">var </span><span class="s0">names = [];</span>

            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; node.elements.length; i++) {</span>
                <span class="s3">// Only allow expansion as last element</span>
                <span class="s1">if </span><span class="s0">(node.elements[i] </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
                    <span class="s1">if </span><span class="s0">(i + </span><span class="s4">1 </span><span class="s0">!== node.elements.length) {</span>
                        <span class="s0">token_error(node.elements[i].start, </span><span class="s2">&quot;Spread must the be last element in destructuring array&quot;</span><span class="s0">);</span>
                    <span class="s0">}</span>
                    <span class="s0">node.elements[i].expression = to_destructuring(node.elements[i].expression);</span>
                <span class="s0">}</span>

                <span class="s0">names.push(to_destructuring(node.elements[i]));</span>
            <span class="s0">}</span>

            <span class="s0">node = </span><span class="s1">new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: node.start,</span>
                <span class="s0">names: names,</span>
                <span class="s0">is_array: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">end: node.end</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectProperty) {</span>
            <span class="s0">node.value = to_destructuring(node.value);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
            <span class="s0">node = </span><span class="s1">new </span><span class="s0">AST_DefaultAssign({</span>
                <span class="s0">start: node.start,</span>
                <span class="s0">left: node.left,</span>
                <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                <span class="s0">right: node.right,</span>
                <span class="s0">end: node.end</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">node;</span>
    <span class="s0">}</span>

    <span class="s3">// In ES6, AssignmentExpression can also be an ArrowFunction</span>
    <span class="s1">var </span><span class="s0">maybe_assign = </span><span class="s1">function</span><span class="s0">(no_in) {</span>
        <span class="s0">handle_regexp();</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>

        <span class="s1">if </span><span class="s0">(start.type == </span><span class="s2">&quot;name&quot; </span><span class="s0">&amp;&amp; start.value == </span><span class="s2">&quot;yield&quot;</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(is_in_generator()) {</span>
                <span class="s0">next();</span>
                <span class="s1">return </span><span class="s0">_yield_expression();</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(S.input.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)) {</span>
                <span class="s0">token_error(S.token, </span><span class="s2">&quot;Unexpected yield identifier inside strict mode&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">left = maybe_conditional(no_in);</span>
        <span class="s1">var </span><span class="s0">val = S.token.value;</span>

        <span class="s1">if </span><span class="s0">(is(</span><span class="s2">&quot;operator&quot;</span><span class="s0">) &amp;&amp; ASSIGNMENT.has(val)) {</span>
            <span class="s1">if </span><span class="s0">(is_assignable(left) || (left = to_destructuring(left)) </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
                <span class="s0">next();</span>

                <span class="s1">return new </span><span class="s0">AST_Assign({</span>
                    <span class="s0">start    : start,</span>
                    <span class="s0">left     : left,</span>
                    <span class="s0">operator : val,</span>
                    <span class="s0">right    : maybe_assign(no_in),</span>
                    <span class="s0">logical  : LOGICAL_ASSIGNMENT.has(val),</span>
                    <span class="s0">end      : prev()</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">croak(</span><span class="s2">&quot;Invalid assignment&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">left;</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">expression = </span><span class="s1">function</span><span class="s0">(commas, no_in) {</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">exprs = [];</span>
        <span class="s1">while </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
            <span class="s0">exprs.push(maybe_assign(no_in));</span>
            <span class="s1">if </span><span class="s0">(!commas || !is(</span><span class="s2">&quot;punc&quot;</span><span class="s0">, </span><span class="s2">&quot;,&quot;</span><span class="s0">)) </span><span class="s1">break</span><span class="s0">;</span>
            <span class="s0">next();</span>
            <span class="s0">commas = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">exprs.length == </span><span class="s4">1 </span><span class="s0">? exprs[</span><span class="s4">0</span><span class="s0">] : </span><span class="s1">new </span><span class="s0">AST_Sequence({</span>
            <span class="s0">start       : start,</span>
            <span class="s0">expressions : exprs,</span>
            <span class="s0">end         : peek()</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">in_loop(cont) {</span>
        <span class="s0">++S.in_loop;</span>
        <span class="s1">var </span><span class="s0">ret = cont();</span>
        <span class="s0">--S.in_loop;</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(options.expression) {</span>
        <span class="s1">return </span><span class="s0">expression(</span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">(</span><span class="s1">function </span><span class="s0">parse_toplevel() {</span>
        <span class="s1">var </span><span class="s0">start = S.token;</span>
        <span class="s1">var </span><span class="s0">body = [];</span>
        <span class="s0">S.input.push_directives_stack();</span>
        <span class="s1">if </span><span class="s0">(options.module) S.input.add_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">);</span>
        <span class="s1">while </span><span class="s0">(!is(</span><span class="s2">&quot;eof&quot;</span><span class="s0">)) {</span>
            <span class="s0">body.push(statement());</span>
        <span class="s0">}</span>
        <span class="s0">S.input.pop_directives_stack();</span>
        <span class="s1">var </span><span class="s0">end = prev();</span>
        <span class="s1">var </span><span class="s0">toplevel = options.toplevel;</span>
        <span class="s1">if </span><span class="s0">(toplevel) {</span>
            <span class="s0">toplevel.body = toplevel.body.concat(body);</span>
            <span class="s0">toplevel.end = end;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">toplevel = </span><span class="s1">new </span><span class="s0">AST_Toplevel({ start: start, body: body, end: end });</span>
        <span class="s0">}</span>
        <span class="s0">TEMPLATE_RAWS = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s1">return </span><span class="s0">toplevel;</span>
    <span class="s0">})();</span>

<span class="s0">}</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">function </span><span class="s0">DEFNODE(type, props, ctor, methods, base = AST_Node) {</span>
    <span class="s1">if </span><span class="s0">(!props) props = [];</span>
    <span class="s1">else </span><span class="s0">props = props.split(/\s+/);</span>
    <span class="s1">var </span><span class="s0">self_props = props;</span>
    <span class="s1">if </span><span class="s0">(base &amp;&amp; base.PROPS)</span>
        <span class="s0">props = props.concat(base.PROPS);</span>
    <span class="s0">const proto = base &amp;&amp; Object.create(base.prototype);</span>
    <span class="s1">if </span><span class="s0">(proto) {</span>
        <span class="s0">ctor.prototype = proto;</span>
        <span class="s0">ctor.BASE = base;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(base) base.SUBCLASSES.push(ctor);</span>
    <span class="s0">ctor.prototype.CTOR = ctor;</span>
    <span class="s0">ctor.prototype.constructor = ctor;</span>
    <span class="s0">ctor.PROPS = props || </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">ctor.SELF_PROPS = self_props;</span>
    <span class="s0">ctor.SUBCLASSES = [];</span>
    <span class="s1">if </span><span class="s0">(type) {</span>
        <span class="s0">ctor.prototype.TYPE = ctor.TYPE = type;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(methods) </span><span class="s1">for </span><span class="s0">(let i </span><span class="s1">in </span><span class="s0">methods) </span><span class="s1">if </span><span class="s0">(HOP(methods, i)) {</span>
        <span class="s1">if </span><span class="s0">(i[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">&quot;$&quot;</span><span class="s0">) {</span>
            <span class="s0">ctor[i.substr(</span><span class="s4">1</span><span class="s0">)] = methods[i];</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">ctor.prototype[i] = methods[i];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">ctor.DEFMETHOD = </span><span class="s1">function</span><span class="s0">(name, method) {</span>
        <span class="s1">this</span><span class="s0">.prototype[name] = method;</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">ctor;</span>
<span class="s0">}</span>

<span class="s0">const has_tok_flag = (tok, flag) =&gt; Boolean(tok.flags &amp; flag);</span>
<span class="s0">const set_tok_flag = (tok, flag, truth) =&gt; {</span>
    <span class="s1">if </span><span class="s0">(truth) {</span>
        <span class="s0">tok.flags |= flag;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">tok.flags &amp;= ~flag;</span>
    <span class="s0">}</span>
<span class="s0">};</span>

<span class="s0">const TOK_FLAG_NLB          = </span><span class="s4">0</span><span class="s0">b0001;</span>
<span class="s0">const TOK_FLAG_QUOTE_SINGLE = </span><span class="s4">0</span><span class="s0">b0010;</span>
<span class="s0">const TOK_FLAG_QUOTE_EXISTS = </span><span class="s4">0</span><span class="s0">b0100;</span>
<span class="s0">const TOK_FLAG_TEMPLATE_END = </span><span class="s4">0</span><span class="s0">b1000;</span>

<span class="s0">class AST_Token {</span>
    <span class="s0">constructor(type, value, line, col, pos, nlb, comments_before, comments_after, file) {</span>
        <span class="s1">this</span><span class="s0">.flags = (nlb ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>

        <span class="s1">this</span><span class="s0">.type = type;</span>
        <span class="s1">this</span><span class="s0">.value = value;</span>
        <span class="s1">this</span><span class="s0">.line = line;</span>
        <span class="s1">this</span><span class="s0">.col = col;</span>
        <span class="s1">this</span><span class="s0">.pos = pos;</span>
        <span class="s1">this</span><span class="s0">.comments_before = comments_before;</span>
        <span class="s1">this</span><span class="s0">.comments_after = comments_after;</span>
        <span class="s1">this</span><span class="s0">.file = file;</span>

        <span class="s0">Object.seal(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">// Return a string summary of the token for node.js console.log</span>
    <span class="s0">[Symbol.</span><span class="s1">for</span><span class="s0">(</span><span class="s2">&quot;nodejs.util.inspect.custom&quot;</span><span class="s0">)](_depth, options) {</span>
        <span class="s0">const special = str =&gt; options.stylize(str, </span><span class="s2">&quot;special&quot;</span><span class="s0">);</span>
        <span class="s0">const quote = </span><span class="s1">typeof this</span><span class="s0">.value === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.value.includes(</span><span class="s2">&quot;`&quot;</span><span class="s0">) ? </span><span class="s2">&quot;'&quot; </span><span class="s0">: </span><span class="s2">&quot;`&quot;</span><span class="s0">;</span>
        <span class="s0">const value = `${quote}${</span><span class="s1">this</span><span class="s0">.value}${quote}`;</span>
        <span class="s1">return </span><span class="s0">`${special(</span><span class="s2">&quot;[AST_Token&quot;</span><span class="s0">)} ${value} at ${</span><span class="s1">this</span><span class="s0">.line}:${</span><span class="s1">this</span><span class="s0">.col}${special(</span><span class="s2">&quot;]&quot;</span><span class="s0">)}`;</span>
    <span class="s0">}</span>

    <span class="s0">get nlb() {</span>
        <span class="s1">return </span><span class="s0">has_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_NLB);</span>
    <span class="s0">}</span>

    <span class="s0">set nlb(new_nlb) {</span>
        <span class="s0">set_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_NLB, new_nlb);</span>
    <span class="s0">}</span>

    <span class="s0">get quote() {</span>
        <span class="s1">return </span><span class="s0">!has_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_QUOTE_EXISTS)</span>
            <span class="s0">? </span><span class="s2">&quot;&quot;</span>
            <span class="s0">: (has_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_QUOTE_SINGLE) ? </span><span class="s2">&quot;'&quot; </span><span class="s0">: </span><span class="s2">'&quot;'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">set quote(quote_type) {</span>
        <span class="s0">set_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_QUOTE_SINGLE, quote_type === </span><span class="s2">&quot;'&quot;</span><span class="s0">);</span>
        <span class="s0">set_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_QUOTE_EXISTS, !!quote_type);</span>
    <span class="s0">}</span>

    <span class="s0">get template_end() {</span>
        <span class="s1">return </span><span class="s0">has_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_TEMPLATE_END);</span>
    <span class="s0">}</span>

    <span class="s0">set template_end(new_template_end) {</span>
        <span class="s0">set_tok_flag(</span><span class="s1">this</span><span class="s0">, TOK_FLAG_TEMPLATE_END, new_template_end);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">AST_Node = DEFNODE(</span><span class="s2">&quot;Node&quot;</span><span class="s0">, </span><span class="s2">&quot;start end&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Node(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">_clone: </span><span class="s1">function</span><span class="s0">(deep) {</span>
        <span class="s1">if </span><span class="s0">(deep) {</span>
            <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">.clone();</span>
            <span class="s1">return </span><span class="s0">self.transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
                <span class="s1">if </span><span class="s0">(node !== self) {</span>
                    <span class="s1">return </span><span class="s0">node.clone(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>
        <span class="s1">return new this</span><span class="s0">.CTOR(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">},</span>
    <span class="s0">clone: </span><span class="s1">function</span><span class="s0">(deep) {</span>
        <span class="s1">return this</span><span class="s0">._clone(deep);</span>
    <span class="s0">},</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class of all AST nodes&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">start: </span><span class="s2">&quot;[AST_Token] The first token of this node&quot;</span><span class="s0">,</span>
        <span class="s0">end: </span><span class="s2">&quot;[AST_Token] The last token of this node&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">},</span>
    <span class="s0">walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return this</span><span class="s0">._walk(visitor); </span><span class="s3">// not sure the indirection will be any help</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards: () =&gt; {}</span>
<span class="s0">}, </span><span class="s1">null</span><span class="s0">);</span>

<span class="s3">/* -----[ statements ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Statement = DEFNODE(</span><span class="s2">&quot;Statement&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Statement(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class of all statements&quot;</span><span class="s0">,</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Debugger = DEFNODE(</span><span class="s2">&quot;Debugger&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Debugger(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Represents a debugger statement&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">var </span><span class="s0">AST_Directive = DEFNODE(</span><span class="s2">&quot;Directive&quot;</span><span class="s0">, </span><span class="s2">&quot;value quote&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Directive(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Represents a directive, like </span><span class="s5">\&quot;</span><span class="s2">use strict</span><span class="s5">\&quot;</span><span class="s2">;&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">value: </span><span class="s2">&quot;[string] The value of this directive as a plain string (it's not an AST_String!)&quot;</span><span class="s0">,</span>
        <span class="s0">quote: </span><span class="s2">&quot;[string] the original quote character&quot;</span>
    <span class="s0">},</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">var </span><span class="s0">AST_SimpleStatement = DEFNODE(</span><span class="s2">&quot;SimpleStatement&quot;</span><span class="s0">, </span><span class="s2">&quot;body&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SimpleStatement(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A statement consisting of an expression, i.e. a = 1 + 2&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">body: </span><span class="s2">&quot;[AST_Node] an expression node (should not be instanceof AST_Statement)&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">function </span><span class="s0">walk_body(node, visitor) {</span>
    <span class="s0">const body = node.body;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = body.length; i &lt; len; i++) {</span>
        <span class="s0">body[i]._walk(visitor);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">clone_block_scope(deep) {</span>
    <span class="s1">var </span><span class="s0">clone = </span><span class="s1">this</span><span class="s0">._clone(deep);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.block_scope) {</span>
        <span class="s0">clone.block_scope = </span><span class="s1">this</span><span class="s0">.block_scope.clone();</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">clone;</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">AST_Block = DEFNODE(</span><span class="s2">&quot;Block&quot;</span><span class="s0">, </span><span class="s2">&quot;body block_scope&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Block(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A body of statements (usually braced)&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">body: </span><span class="s2">&quot;[AST_Statement*] an array of statements&quot;</span><span class="s0">,</span>
        <span class="s0">block_scope: </span><span class="s2">&quot;[AST_Scope] the block scope&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">walk_body(</span><span class="s1">this</span><span class="s0">, visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.body.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.body[i]);</span>
    <span class="s0">},</span>
    <span class="s0">clone: clone_block_scope</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">var </span><span class="s0">AST_BlockStatement = DEFNODE(</span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_BlockStatement(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A block statement&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Block);</span>

<span class="s1">var </span><span class="s0">AST_EmptyStatement = DEFNODE(</span><span class="s2">&quot;EmptyStatement&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_EmptyStatement(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The empty statement (empty block or simply a semicolon)&quot;</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">var </span><span class="s0">AST_StatementWithBody = DEFNODE(</span><span class="s2">&quot;StatementWithBody&quot;</span><span class="s0">, </span><span class="s2">&quot;body&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_StatementWithBody(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">body: </span><span class="s2">&quot;[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement&quot;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">var </span><span class="s0">AST_LabeledStatement = DEFNODE(</span><span class="s2">&quot;LabeledStatement&quot;</span><span class="s0">, </span><span class="s2">&quot;label&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_LabeledStatement(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.label = props.label;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Statement with a label&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">label: </span><span class="s2">&quot;[AST_Label] a label definition&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.label._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.label);</span>
    <span class="s0">},</span>
    <span class="s0">clone: </span><span class="s1">function</span><span class="s0">(deep) {</span>
        <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">._clone(deep);</span>
        <span class="s1">if </span><span class="s0">(deep) {</span>
            <span class="s1">var </span><span class="s0">label = node.label;</span>
            <span class="s1">var </span><span class="s0">def = </span><span class="s1">this</span><span class="s0">.label;</span>
            <span class="s0">node.walk(</span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_LoopControl</span>
                    <span class="s0">&amp;&amp; node.label &amp;&amp; node.label.thedef === def) {</span>
                    <span class="s0">node.label.thedef = label;</span>
                    <span class="s0">label.references.push(node);</span>
                <span class="s0">}</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">node;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_StatementWithBody);</span>

<span class="s1">var </span><span class="s0">AST_IterationStatement = DEFNODE(</span>
    <span class="s2">&quot;IterationStatement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;block_scope&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_IterationStatement(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
            <span class="s1">this</span><span class="s0">.body = props.body;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;Internal class.  All loops inherit from it.&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">block_scope: </span><span class="s2">&quot;[AST_Scope] the block scope for this iteration statement.&quot;</span>
        <span class="s0">},</span>
        <span class="s0">clone: clone_block_scope</span>
    <span class="s0">},</span>
    <span class="s0">AST_StatementWithBody</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_DWLoop = DEFNODE(</span><span class="s2">&quot;DWLoop&quot;</span><span class="s0">, </span><span class="s2">&quot;condition&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_DWLoop(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.condition = props.condition;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for do/while statements&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">condition: </span><span class="s2">&quot;[AST_Node] the loop condition.  Should not be instanceof AST_Statement&quot;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_IterationStatement);</span>

<span class="s1">var </span><span class="s0">AST_Do = DEFNODE(</span><span class="s2">&quot;Do&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Do(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.condition = props.condition;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `do` statement&quot;</span><span class="s0">,</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.condition._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.condition);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
    <span class="s0">}</span>
<span class="s0">}, AST_DWLoop);</span>

<span class="s1">var </span><span class="s0">AST_While = DEFNODE(</span><span class="s2">&quot;While&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_While(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.condition = props.condition;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `while` statement&quot;</span><span class="s0">,</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.condition._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.condition);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_DWLoop);</span>

<span class="s1">var </span><span class="s0">AST_For = DEFNODE(</span><span class="s2">&quot;For&quot;</span><span class="s0">, </span><span class="s2">&quot;init condition step&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_For(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.condition = props.condition;</span>
        <span class="s1">this</span><span class="s0">.step = props.step;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `for` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">init: </span><span class="s2">&quot;[AST_Node?] the `for` initialization code, or null if empty&quot;</span><span class="s0">,</span>
        <span class="s0">condition: </span><span class="s2">&quot;[AST_Node?] the `for` termination clause, or null if empty&quot;</span><span class="s0">,</span>
        <span class="s0">step: </span><span class="s2">&quot;[AST_Node?] the `for` update clause, or null if empty&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.init) </span><span class="s1">this</span><span class="s0">.init._walk(visitor);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.condition) </span><span class="s1">this</span><span class="s0">.condition._walk(visitor);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.step) </span><span class="s1">this</span><span class="s0">.step._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.step) push(</span><span class="s1">this</span><span class="s0">.step);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.condition) push(</span><span class="s1">this</span><span class="s0">.condition);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.init) push(</span><span class="s1">this</span><span class="s0">.init);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_IterationStatement);</span>

<span class="s1">var </span><span class="s0">AST_ForIn = DEFNODE(</span><span class="s2">&quot;ForIn&quot;</span><span class="s0">, </span><span class="s2">&quot;init object&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ForIn(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.object = props.object;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `for ... in` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">init: </span><span class="s2">&quot;[AST_Node] the `for/in` initialization code&quot;</span><span class="s0">,</span>
        <span class="s0">object: </span><span class="s2">&quot;[AST_Node] the object that we're looping through&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.init._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.object._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.object) push(</span><span class="s1">this</span><span class="s0">.object);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.init) push(</span><span class="s1">this</span><span class="s0">.init);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_IterationStatement);</span>

<span class="s1">var </span><span class="s0">AST_ForOf = DEFNODE(</span><span class="s2">&quot;ForOf&quot;</span><span class="s0">, </span><span class="s2">&quot;await&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ForOf(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.await = props.await;</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.object = props.object;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `for ... of` statement&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_ForIn);</span>

<span class="s1">var </span><span class="s0">AST_With = DEFNODE(</span><span class="s2">&quot;With&quot;</span><span class="s0">, </span><span class="s2">&quot;expression&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_With(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `with` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] the `with` expression&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_StatementWithBody);</span>

<span class="s3">/* -----[ scope and functions ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Scope = DEFNODE(</span>
    <span class="s2">&quot;Scope&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;variables uses_with uses_eval parent_scope enclosed cname&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_Scope(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
            <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
            <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
            <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
            <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
            <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
            <span class="s1">this</span><span class="s0">.body = props.body;</span>
            <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;Base class for all statements introducing a lexical scope&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">variables: </span><span class="s2">&quot;[Map/S] a map of name -&gt; SymbolDef for all variables/functions defined in this scope&quot;</span><span class="s0">,</span>
            <span class="s0">uses_with: </span><span class="s2">&quot;[boolean/S] tells whether this scope uses the `with` statement&quot;</span><span class="s0">,</span>
            <span class="s0">uses_eval: </span><span class="s2">&quot;[boolean/S] tells whether this scope contains a direct call to the global `eval`&quot;</span><span class="s0">,</span>
            <span class="s0">parent_scope: </span><span class="s2">&quot;[AST_Scope?/S] link to the parent scope&quot;</span><span class="s0">,</span>
            <span class="s0">enclosed: </span><span class="s2">&quot;[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes&quot;</span><span class="s0">,</span>
            <span class="s0">cname: </span><span class="s2">&quot;[integer/S] current index for mangling variables (used internally by the mangler)&quot;</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s0">get_defun_scope: </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">while </span><span class="s0">(self.is_block_scope()) {</span>
                <span class="s0">self = self.parent_scope;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">self;</span>
        <span class="s0">},</span>
        <span class="s0">clone: </span><span class="s1">function</span><span class="s0">(deep, toplevel) {</span>
            <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">._clone(deep);</span>
            <span class="s1">if </span><span class="s0">(deep &amp;&amp; </span><span class="s1">this</span><span class="s0">.variables &amp;&amp; toplevel &amp;&amp; !</span><span class="s1">this</span><span class="s0">._block_scope) {</span>
                <span class="s0">node.figure_out_scope({}, {</span>
                    <span class="s0">toplevel: toplevel,</span>
                    <span class="s0">parent_scope: </span><span class="s1">this</span><span class="s0">.parent_scope</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.variables) node.variables = </span><span class="s1">new </span><span class="s0">Map(</span><span class="s1">this</span><span class="s0">.variables);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.enclosed) node.enclosed = </span><span class="s1">this</span><span class="s0">.enclosed.slice();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._block_scope) node._block_scope = </span><span class="s1">this</span><span class="s0">._block_scope;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">node;</span>
        <span class="s0">},</span>
        <span class="s0">pinned: </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">return this</span><span class="s0">.uses_eval || </span><span class="s1">this</span><span class="s0">.uses_with;</span>
        <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">AST_Block</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_Toplevel = DEFNODE(</span><span class="s2">&quot;Toplevel&quot;</span><span class="s0">, </span><span class="s2">&quot;globals&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Toplevel(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.globals = props.globals;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The toplevel scope&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">globals: </span><span class="s2">&quot;[Map/S] a map of name -&gt; SymbolDef for all undeclared names&quot;</span><span class="s0">,</span>
    <span class="s0">},</span>
    <span class="s0">wrap_commonjs: </span><span class="s1">function</span><span class="s0">(name) {</span>
        <span class="s1">var </span><span class="s0">body = </span><span class="s1">this</span><span class="s0">.body;</span>
        <span class="s1">var </span><span class="s0">wrapped_tl = </span><span class="s2">&quot;(function(exports){'$ORIG';})(typeof &quot; </span><span class="s0">+ name + </span><span class="s2">&quot;=='undefined'?(&quot; </span><span class="s0">+ name + </span><span class="s2">&quot;={}):&quot; </span><span class="s0">+ name + </span><span class="s2">&quot;);&quot;</span><span class="s0">;</span>
        <span class="s0">wrapped_tl = parse(wrapped_tl);</span>
        <span class="s0">wrapped_tl = wrapped_tl.transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Directive &amp;&amp; node.value == </span><span class="s2">&quot;$ORIG&quot;</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">MAP.splice(body);</span>
            <span class="s0">}</span>
        <span class="s0">}));</span>
        <span class="s1">return </span><span class="s0">wrapped_tl;</span>
    <span class="s0">},</span>
    <span class="s0">wrap_enclose: </span><span class="s1">function</span><span class="s0">(args_values) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">args_values != </span><span class="s2">&quot;string&quot;</span><span class="s0">) args_values = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">index = args_values.indexOf(</span><span class="s2">&quot;:&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s4">0</span><span class="s0">) index = args_values.length;</span>
        <span class="s1">var </span><span class="s0">body = </span><span class="s1">this</span><span class="s0">.body;</span>
        <span class="s1">return </span><span class="s0">parse([</span>
            <span class="s2">&quot;(function(&quot;</span><span class="s0">,</span>
            <span class="s0">args_values.slice(</span><span class="s4">0</span><span class="s0">, index),</span>
            <span class="s2">'){&quot;$ORIG&quot;})('</span><span class="s0">,</span>
            <span class="s0">args_values.slice(index + </span><span class="s4">1</span><span class="s0">),</span>
            <span class="s2">&quot;)&quot;</span>
        <span class="s0">].join(</span><span class="s2">&quot;&quot;</span><span class="s0">)).transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Directive &amp;&amp; node.value == </span><span class="s2">&quot;$ORIG&quot;</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">MAP.splice(body);</span>
            <span class="s0">}</span>
        <span class="s0">}));</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Scope);</span>

<span class="s1">var </span><span class="s0">AST_Expansion = DEFNODE(</span><span class="s2">&quot;Expansion&quot;</span><span class="s0">, </span><span class="s2">&quot;expression&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Expansion(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] the thing to be expanded&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression.walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Lambda = DEFNODE(</span>
    <span class="s2">&quot;Lambda&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;name argnames uses_arguments is_generator async&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_Lambda(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.name = props.name;</span>
            <span class="s1">this</span><span class="s0">.argnames = props.argnames;</span>
            <span class="s1">this</span><span class="s0">.uses_arguments = props.uses_arguments;</span>
            <span class="s1">this</span><span class="s0">.is_generator = props.is_generator;</span>
            <span class="s1">this</span><span class="s0">.async = props.async;</span>
            <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
            <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
            <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
            <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
            <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
            <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
            <span class="s1">this</span><span class="s0">.body = props.body;</span>
            <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;Base class for functions&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">name: </span><span class="s2">&quot;[AST_SymbolDeclaration?] the name of this function&quot;</span><span class="s0">,</span>
            <span class="s0">argnames: </span><span class="s2">&quot;[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments&quot;</span><span class="s0">,</span>
            <span class="s0">uses_arguments: </span><span class="s2">&quot;[boolean/S] tells whether this function accesses the arguments array&quot;</span><span class="s0">,</span>
            <span class="s0">is_generator: </span><span class="s2">&quot;[boolean] is this a generator method&quot;</span><span class="s0">,</span>
            <span class="s0">async: </span><span class="s2">&quot;[boolean] is this method async&quot;</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s0">args_as_names: </span><span class="s1">function </span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">out = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.argnames.length; i++) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.argnames[i] </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
                    <span class="s0">out.push(...</span><span class="s1">this</span><span class="s0">.argnames[i].all_symbols());</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">out.push(</span><span class="s1">this</span><span class="s0">.argnames[i]);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">out;</span>
        <span class="s0">},</span>
        <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
            <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name) </span><span class="s1">this</span><span class="s0">.name._walk(visitor);</span>
                <span class="s1">var </span><span class="s0">argnames = </span><span class="s1">this</span><span class="s0">.argnames;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = argnames.length; i &lt; len; i++) {</span>
                    <span class="s0">argnames[i]._walk(visitor);</span>
                <span class="s0">}</span>
                <span class="s0">walk_body(</span><span class="s1">this</span><span class="s0">, visitor);</span>
            <span class="s0">});</span>
        <span class="s0">},</span>
        <span class="s0">_children_backwards(push) {</span>
            <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.body.length;</span>
            <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.body[i]);</span>

            <span class="s0">i = </span><span class="s1">this</span><span class="s0">.argnames.length;</span>
            <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.argnames[i]);</span>

            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name) push(</span><span class="s1">this</span><span class="s0">.name);</span>
        <span class="s0">},</span>
        <span class="s0">is_braceless() {</span>
            <span class="s1">return this</span><span class="s0">.body[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Return &amp;&amp; </span><span class="s1">this</span><span class="s0">.body[</span><span class="s4">0</span><span class="s0">].value;</span>
        <span class="s0">},</span>
        <span class="s3">// Default args and expansion don't count, so .argnames.length doesn't cut it</span>
        <span class="s0">length_property() {</span>
            <span class="s0">let length = </span><span class="s4">0</span><span class="s0">;</span>

            <span class="s1">for </span><span class="s0">(const arg of </span><span class="s1">this</span><span class="s0">.argnames) {</span>
                <span class="s1">if </span><span class="s0">(arg </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg || arg </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
                    <span class="s0">length++;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s1">return </span><span class="s0">length;</span>
        <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">AST_Scope</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_Accessor = DEFNODE(</span><span class="s2">&quot;Accessor&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Accessor(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.argnames = props.argnames;</span>
        <span class="s1">this</span><span class="s0">.uses_arguments = props.uses_arguments;</span>
        <span class="s1">this</span><span class="s0">.is_generator = props.is_generator;</span>
        <span class="s1">this</span><span class="s0">.async = props.async;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A setter/getter function.  The `name` property is always null.&quot;</span>
<span class="s0">}, AST_Lambda);</span>

<span class="s1">var </span><span class="s0">AST_Function = DEFNODE(</span><span class="s2">&quot;Function&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Function(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.argnames = props.argnames;</span>
        <span class="s1">this</span><span class="s0">.uses_arguments = props.uses_arguments;</span>
        <span class="s1">this</span><span class="s0">.is_generator = props.is_generator;</span>
        <span class="s1">this</span><span class="s0">.async = props.async;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A function expression&quot;</span>
<span class="s0">}, AST_Lambda);</span>

<span class="s1">var </span><span class="s0">AST_Arrow = DEFNODE(</span><span class="s2">&quot;Arrow&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Arrow(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.argnames = props.argnames;</span>
        <span class="s1">this</span><span class="s0">.uses_arguments = props.uses_arguments;</span>
        <span class="s1">this</span><span class="s0">.is_generator = props.is_generator;</span>
        <span class="s1">this</span><span class="s0">.async = props.async;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An ES6 Arrow function ((a) =&gt; b)&quot;</span>
<span class="s0">}, AST_Lambda);</span>

<span class="s1">var </span><span class="s0">AST_Defun = DEFNODE(</span><span class="s2">&quot;Defun&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Defun(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.argnames = props.argnames;</span>
        <span class="s1">this</span><span class="s0">.uses_arguments = props.uses_arguments;</span>
        <span class="s1">this</span><span class="s0">.is_generator = props.is_generator;</span>
        <span class="s1">this</span><span class="s0">.async = props.async;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A function definition&quot;</span>
<span class="s0">}, AST_Lambda);</span>

<span class="s3">/* -----[ DESTRUCTURING ]----- */</span>
<span class="s1">var </span><span class="s0">AST_Destructuring = DEFNODE(</span><span class="s2">&quot;Destructuring&quot;</span><span class="s0">, </span><span class="s2">&quot;names is_array&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Destructuring(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.names = props.names;</span>
        <span class="s1">this</span><span class="s0">.is_array = props.is_array;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A destructuring of several names. Used in destructuring assignment and with destructuring function argument names&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s2">&quot;names&quot;</span><span class="s0">: </span><span class="s2">&quot;[AST_Node*] Array of properties or elements&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;is_array&quot;</span><span class="s0">: </span><span class="s2">&quot;[Boolean] Whether the destructuring represents an object or array&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.names.forEach(</span><span class="s1">function</span><span class="s0">(name) {</span>
                <span class="s0">name._walk(visitor);</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.names.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.names[i]);</span>
    <span class="s0">},</span>
    <span class="s0">all_symbols: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">var </span><span class="s0">out = [];</span>
        <span class="s0">walk(</span><span class="s1">this</span><span class="s0">, node =&gt; {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration) {</span>
                <span class="s0">out.push(node);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">out;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_PrefixedTemplateString = DEFNODE(</span>
    <span class="s2">&quot;PrefixedTemplateString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;template_string prefix&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_PrefixedTemplateString(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.template_string = props.template_string;</span>
            <span class="s1">this</span><span class="s0">.prefix = props.prefix;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;A templatestring with a prefix, such as String.raw`foobarbaz`&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">template_string: </span><span class="s2">&quot;[AST_TemplateString] The template string&quot;</span><span class="s0">,</span>
            <span class="s0">prefix: </span><span class="s2">&quot;[AST_Node] The prefix, which will get called.&quot;</span>
        <span class="s0">},</span>
        <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
            <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">this</span><span class="s0">.prefix._walk(visitor);</span>
                <span class="s1">this</span><span class="s0">.template_string._walk(visitor);</span>
            <span class="s0">});</span>
        <span class="s0">},</span>
        <span class="s0">_children_backwards(push) {</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.template_string);</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.prefix);</span>
        <span class="s0">},</span>
    <span class="s0">}</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_TemplateString = DEFNODE(</span><span class="s2">&quot;TemplateString&quot;</span><span class="s0">, </span><span class="s2">&quot;segments&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_TemplateString(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.segments = props.segments;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A template string literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">segments: </span><span class="s2">&quot;[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment.&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.segments.forEach(</span><span class="s1">function</span><span class="s0">(seg) {</span>
                <span class="s0">seg._walk(visitor);</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.segments.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.segments[i]);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_TemplateSegment = DEFNODE(</span><span class="s2">&quot;TemplateSegment&quot;</span><span class="s0">, </span><span class="s2">&quot;value raw&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_TemplateSegment(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.raw = props.raw;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A segment of a template string literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">value: </span><span class="s2">&quot;Content of the segment&quot;</span><span class="s0">,</span>
        <span class="s0">raw: </span><span class="s2">&quot;Raw source of the segment&quot;</span><span class="s0">,</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s3">/* -----[ JUMPS ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Jump = DEFNODE(</span><span class="s2">&quot;Jump&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Jump(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)&quot;</span>
<span class="s0">}, AST_Statement);</span>

<span class="s3">/** Base class for “exits” (`return` and `throw`) */</span>
<span class="s1">var </span><span class="s0">AST_Exit = DEFNODE(</span><span class="s2">&quot;Exit&quot;</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Exit(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for “exits” (`return` and `throw`)&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">value: </span><span class="s2">&quot;[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.value &amp;&amp; </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.value._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.value) push(</span><span class="s1">this</span><span class="s0">.value);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_Jump);</span>

<span class="s1">var </span><span class="s0">AST_Return = DEFNODE(</span><span class="s2">&quot;Return&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Return(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `return` statement&quot;</span>
<span class="s0">}, AST_Exit);</span>

<span class="s1">var </span><span class="s0">AST_Throw = DEFNODE(</span><span class="s2">&quot;Throw&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Throw(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `throw` statement&quot;</span>
<span class="s0">}, AST_Exit);</span>

<span class="s1">var </span><span class="s0">AST_LoopControl = DEFNODE(</span><span class="s2">&quot;LoopControl&quot;</span><span class="s0">, </span><span class="s2">&quot;label&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_LoopControl(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.label = props.label;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for loop control statements (`break` and `continue`)&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">label: </span><span class="s2">&quot;[AST_LabelRef?] the label, or null if none&quot;</span><span class="s0">,</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.label &amp;&amp; </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.label._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.label) push(</span><span class="s1">this</span><span class="s0">.label);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_Jump);</span>

<span class="s1">var </span><span class="s0">AST_Break = DEFNODE(</span><span class="s2">&quot;Break&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Break(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.label = props.label;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `break` statement&quot;</span>
<span class="s0">}, AST_LoopControl);</span>

<span class="s1">var </span><span class="s0">AST_Continue = DEFNODE(</span><span class="s2">&quot;Continue&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Continue(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.label = props.label;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `continue` statement&quot;</span>
<span class="s0">}, AST_LoopControl);</span>

<span class="s1">var </span><span class="s0">AST_Await = DEFNODE(</span><span class="s2">&quot;Await&quot;</span><span class="s0">, </span><span class="s2">&quot;expression&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Await(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An `await` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] the mandatory expression being awaited&quot;</span><span class="s0">,</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Yield = DEFNODE(</span><span class="s2">&quot;Yield&quot;</span><span class="s0">, </span><span class="s2">&quot;expression is_star&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Yield(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.is_star = props.is_star;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `yield` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false&quot;</span><span class="s0">,</span>
        <span class="s0">is_star: </span><span class="s2">&quot;[Boolean] Whether this is a yield or yield* statement&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.expression &amp;&amp; </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expression) push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s3">/* -----[ IF ]----- */</span>

<span class="s1">var </span><span class="s0">AST_If = DEFNODE(</span><span class="s2">&quot;If&quot;</span><span class="s0">, </span><span class="s2">&quot;condition alternative&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_If(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.condition = props.condition;</span>
        <span class="s1">this</span><span class="s0">.alternative = props.alternative;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `if` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">condition: </span><span class="s2">&quot;[AST_Node] the `if` condition&quot;</span><span class="s0">,</span>
        <span class="s0">alternative: </span><span class="s2">&quot;[AST_Statement?] the `else` part, or null if not present&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.condition._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.alternative) </span><span class="s1">this</span><span class="s0">.alternative._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.alternative) {</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.alternative);</span>
        <span class="s0">}</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.condition);</span>
    <span class="s0">}</span>
<span class="s0">}, AST_StatementWithBody);</span>

<span class="s3">/* -----[ SWITCH ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Switch = DEFNODE(</span><span class="s2">&quot;Switch&quot;</span><span class="s0">, </span><span class="s2">&quot;expression&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Switch(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `switch` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] the `switch` “discriminant”&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
            <span class="s0">walk_body(</span><span class="s1">this</span><span class="s0">, visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.body.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.body[i]);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Block);</span>

<span class="s1">var </span><span class="s0">AST_SwitchBranch = DEFNODE(</span><span class="s2">&quot;SwitchBranch&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SwitchBranch(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for `switch` branches&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Block);</span>

<span class="s1">var </span><span class="s0">AST_Default = DEFNODE(</span><span class="s2">&quot;Default&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Default(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `default` switch branch&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SwitchBranch);</span>

<span class="s1">var </span><span class="s0">AST_Case = DEFNODE(</span><span class="s2">&quot;Case&quot;</span><span class="s0">, </span><span class="s2">&quot;expression&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Case(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `case` switch branch&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] the `case` expression&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
            <span class="s0">walk_body(</span><span class="s1">this</span><span class="s0">, visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.body.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.body[i]);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_SwitchBranch);</span>

<span class="s3">/* -----[ EXCEPTIONS ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Try = DEFNODE(</span><span class="s2">&quot;Try&quot;</span><span class="s0">, </span><span class="s2">&quot;body bcatch bfinally&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Try(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.bcatch = props.bcatch;</span>
        <span class="s1">this</span><span class="s0">.bfinally = props.bfinally;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `try` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">body: </span><span class="s2">&quot;[AST_TryBlock] the try block&quot;</span><span class="s0">,</span>
        <span class="s0">bcatch: </span><span class="s2">&quot;[AST_Catch?] the catch block, or null if not present&quot;</span><span class="s0">,</span>
        <span class="s0">bfinally: </span><span class="s2">&quot;[AST_Finally?] the finally block, or null if not present&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.body._walk(visitor);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.bcatch) </span><span class="s1">this</span><span class="s0">.bcatch._walk(visitor);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.bfinally) </span><span class="s1">this</span><span class="s0">.bfinally._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.bfinally) push(</span><span class="s1">this</span><span class="s0">.bfinally);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.bcatch) push(</span><span class="s1">this</span><span class="s0">.bcatch);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.body);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">var </span><span class="s0">AST_TryBlock = DEFNODE(</span><span class="s2">&quot;TryBlock&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_TryBlock(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `try` block of a try statement&quot;</span>
<span class="s0">}, AST_Block);</span>

<span class="s1">var </span><span class="s0">AST_Catch = DEFNODE(</span><span class="s2">&quot;Catch&quot;</span><span class="s0">, </span><span class="s2">&quot;argname&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Catch(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.argname = props.argname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `catch` node; only makes sense as part of a `try` statement&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">argname: </span><span class="s2">&quot;[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.argname) </span><span class="s1">this</span><span class="s0">.argname._walk(visitor);</span>
            <span class="s0">walk_body(</span><span class="s1">this</span><span class="s0">, visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.body.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.body[i]);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.argname) push(</span><span class="s1">this</span><span class="s0">.argname);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_Block);</span>

<span class="s1">var </span><span class="s0">AST_Finally = DEFNODE(</span><span class="s2">&quot;Finally&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Finally(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `finally` node; only makes sense as part of a `try` statement&quot;</span>
<span class="s0">}, AST_Block);</span>

<span class="s3">/* -----[ VAR/CONST ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Definitions = DEFNODE(</span><span class="s2">&quot;Definitions&quot;</span><span class="s0">, </span><span class="s2">&quot;definitions&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Definitions(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.definitions = props.definitions;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for `var` or `const` nodes (variable declarations/initializations)&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">definitions: </span><span class="s2">&quot;[AST_VarDef*] array of variable definitions&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">definitions = </span><span class="s1">this</span><span class="s0">.definitions;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = definitions.length; i &lt; len; i++) {</span>
                <span class="s0">definitions[i]._walk(visitor);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.definitions.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.definitions[i]);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_Statement);</span>

<span class="s1">var </span><span class="s0">AST_Var = DEFNODE(</span><span class="s2">&quot;Var&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Var(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.definitions = props.definitions;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `var` statement&quot;</span>
<span class="s0">}, AST_Definitions);</span>

<span class="s1">var </span><span class="s0">AST_Let = DEFNODE(</span><span class="s2">&quot;Let&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Let(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.definitions = props.definitions;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `let` statement&quot;</span>
<span class="s0">}, AST_Definitions);</span>

<span class="s1">var </span><span class="s0">AST_Const = DEFNODE(</span><span class="s2">&quot;Const&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Const(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.definitions = props.definitions;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A `const` statement&quot;</span>
<span class="s0">}, AST_Definitions);</span>

<span class="s1">var </span><span class="s0">AST_VarDef = DEFNODE(</span><span class="s2">&quot;VarDef&quot;</span><span class="s0">, </span><span class="s2">&quot;name value&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_VarDef(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A variable declaration; only appears in a AST_Definitions node&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">name: </span><span class="s2">&quot;[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable&quot;</span><span class="s0">,</span>
        <span class="s0">value: </span><span class="s2">&quot;[AST_Node?] initializer, or null of there's no initializer&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.name._walk(visitor);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.value) </span><span class="s1">this</span><span class="s0">.value._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.value) push(</span><span class="s1">this</span><span class="s0">.value);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.name);</span>
    <span class="s0">},</span>
    <span class="s0">declarations_as_names() {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration) {</span>
            <span class="s1">return </span><span class="s0">[</span><span class="s1">this</span><span class="s0">];</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return this</span><span class="s0">.name.all_symbols();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_NameMapping = DEFNODE(</span><span class="s2">&quot;NameMapping&quot;</span><span class="s0">, </span><span class="s2">&quot;foreign_name name&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_NameMapping(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.foreign_name = props.foreign_name;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The part of the export/import statement that declare names from a module.&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">foreign_name: </span><span class="s2">&quot;[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)&quot;</span><span class="s0">,</span>
        <span class="s0">name: </span><span class="s2">&quot;[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module.&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function </span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.foreign_name._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.name._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.name);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.foreign_name);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Import = DEFNODE(</span>
    <span class="s2">&quot;Import&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imported_name imported_names module_name assert_clause&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_Import(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.imported_name = props.imported_name;</span>
            <span class="s1">this</span><span class="s0">.imported_names = props.imported_names;</span>
            <span class="s1">this</span><span class="s0">.module_name = props.module_name;</span>
            <span class="s1">this</span><span class="s0">.assert_clause = props.assert_clause;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;An `import` statement&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">imported_name: </span><span class="s2">&quot;[AST_SymbolImport] The name of the variable holding the module's default export.&quot;</span><span class="s0">,</span>
            <span class="s0">imported_names: </span><span class="s2">&quot;[AST_NameMapping*] The names of non-default imported variables&quot;</span><span class="s0">,</span>
            <span class="s0">module_name: </span><span class="s2">&quot;[AST_String] String literal describing where this module came from&quot;</span><span class="s0">,</span>
            <span class="s0">assert_clause: </span><span class="s2">&quot;[AST_Object?] The import assertion&quot;</span>
        <span class="s0">},</span>
        <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
            <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_name) {</span>
                    <span class="s1">this</span><span class="s0">.imported_name._walk(visitor);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_names) {</span>
                    <span class="s1">this</span><span class="s0">.imported_names.forEach(</span><span class="s1">function</span><span class="s0">(name_import) {</span>
                        <span class="s0">name_import._walk(visitor);</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.module_name._walk(visitor);</span>
            <span class="s0">});</span>
        <span class="s0">},</span>
        <span class="s0">_children_backwards(push) {</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.module_name);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_names) {</span>
                <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.imported_names.length;</span>
                <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.imported_names[i]);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_name) push(</span><span class="s1">this</span><span class="s0">.imported_name);</span>
        <span class="s0">},</span>
    <span class="s0">}</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_ImportMeta = DEFNODE(</span><span class="s2">&quot;ImportMeta&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ImportMeta(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A reference to import.meta&quot;</span><span class="s0">,</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Export = DEFNODE(</span>
    <span class="s2">&quot;Export&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exported_definition exported_value is_default exported_names module_name assert_clause&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_Export(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.exported_definition = props.exported_definition;</span>
            <span class="s1">this</span><span class="s0">.exported_value = props.exported_value;</span>
            <span class="s1">this</span><span class="s0">.is_default = props.is_default;</span>
            <span class="s1">this</span><span class="s0">.exported_names = props.exported_names;</span>
            <span class="s1">this</span><span class="s0">.module_name = props.module_name;</span>
            <span class="s1">this</span><span class="s0">.assert_clause = props.assert_clause;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;An `export` statement&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">exported_definition: </span><span class="s2">&quot;[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition&quot;</span><span class="s0">,</span>
            <span class="s0">exported_value: </span><span class="s2">&quot;[AST_Node?] An exported value&quot;</span><span class="s0">,</span>
            <span class="s0">exported_names: </span><span class="s2">&quot;[AST_NameMapping*?] List of exported names&quot;</span><span class="s0">,</span>
            <span class="s0">module_name: </span><span class="s2">&quot;[AST_String?] Name of the file to load exports from&quot;</span><span class="s0">,</span>
            <span class="s0">is_default: </span><span class="s2">&quot;[Boolean] Whether this is the default exported value of this module&quot;</span><span class="s0">,</span>
            <span class="s0">assert_clause: </span><span class="s2">&quot;[AST_Object?] The import assertion&quot;</span>
        <span class="s0">},</span>
        <span class="s0">_walk: </span><span class="s1">function </span><span class="s0">(visitor) {</span>
            <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_definition) {</span>
                    <span class="s1">this</span><span class="s0">.exported_definition._walk(visitor);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_value) {</span>
                    <span class="s1">this</span><span class="s0">.exported_value._walk(visitor);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_names) {</span>
                    <span class="s1">this</span><span class="s0">.exported_names.forEach(</span><span class="s1">function</span><span class="s0">(name_export) {</span>
                        <span class="s0">name_export._walk(visitor);</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.module_name) {</span>
                    <span class="s1">this</span><span class="s0">.module_name._walk(visitor);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">},</span>
        <span class="s0">_children_backwards(push) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.module_name) push(</span><span class="s1">this</span><span class="s0">.module_name);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_names) {</span>
                <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.exported_names.length;</span>
                <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.exported_names[i]);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_value) push(</span><span class="s1">this</span><span class="s0">.exported_value);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_definition) push(</span><span class="s1">this</span><span class="s0">.exported_definition);</span>
        <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">AST_Statement</span>
<span class="s0">);</span>

<span class="s3">/* -----[ OTHER ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Call = DEFNODE(</span>
    <span class="s2">&quot;Call&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expression args optional _annotations&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_Call(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
            <span class="s1">this</span><span class="s0">.args = props.args;</span>
            <span class="s1">this</span><span class="s0">.optional = props.optional;</span>
            <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
            <span class="s1">this</span><span class="s0">.initialize();</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;A function call expression&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] expression to invoke as function&quot;</span><span class="s0">,</span>
            <span class="s0">args: </span><span class="s2">&quot;[AST_Node*] array of arguments&quot;</span><span class="s0">,</span>
            <span class="s0">optional: </span><span class="s2">&quot;[boolean] whether this is an optional call (IE ?.() )&quot;</span><span class="s0">,</span>
            <span class="s0">_annotations: </span><span class="s2">&quot;[number] bitfield containing information about the call&quot;</span>
        <span class="s0">},</span>
        <span class="s0">initialize() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._annotations == </span><span class="s1">null</span><span class="s0">) </span><span class="s1">this</span><span class="s0">._annotations = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">},</span>
        <span class="s0">_walk(visitor) {</span>
            <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s1">var </span><span class="s0">args = </span><span class="s1">this</span><span class="s0">.args;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = args.length; i &lt; len; i++) {</span>
                    <span class="s0">args[i]._walk(visitor);</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.expression._walk(visitor);  </span><span class="s3">// TODO why do we need to crawl this last?</span>
            <span class="s0">});</span>
        <span class="s0">},</span>
        <span class="s0">_children_backwards(push) {</span>
            <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.args.length;</span>
            <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.args[i]);</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
        <span class="s0">},</span>
    <span class="s0">}</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_New = DEFNODE(</span><span class="s2">&quot;New&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_New(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.args = props.args;</span>
        <span class="s1">this</span><span class="s0">.optional = props.optional;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">.initialize();</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An object instantiation.  Derives from a function call since it has exactly the same properties&quot;</span>
<span class="s0">}, AST_Call);</span>

<span class="s1">var </span><span class="s0">AST_Sequence = DEFNODE(</span><span class="s2">&quot;Sequence&quot;</span><span class="s0">, </span><span class="s2">&quot;expressions&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Sequence(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expressions = props.expressions;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A sequence expression (comma-separated expressions)&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expressions: </span><span class="s2">&quot;[AST_Node*] array of expressions (at least two)&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expressions.forEach(</span><span class="s1">function</span><span class="s0">(node) {</span>
                <span class="s0">node._walk(visitor);</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.expressions.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.expressions[i]);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_PropAccess = DEFNODE(</span>
    <span class="s2">&quot;PropAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expression property optional&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_PropAccess(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
            <span class="s1">this</span><span class="s0">.property = props.property;</span>
            <span class="s1">this</span><span class="s0">.optional = props.optional;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;Base class for property access expressions, i.e. `a.foo` or `a[</span><span class="s5">\&quot;</span><span class="s2">foo</span><span class="s5">\&quot;</span><span class="s2">]`&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] the “container” expression&quot;</span><span class="s0">,</span>
            <span class="s0">property: </span><span class="s2">&quot;[AST_Node|string] the property to access.  For AST_Dot &amp; AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node&quot;</span><span class="s0">,</span>

            <span class="s0">optional: </span><span class="s2">&quot;[boolean] whether this is an optional property access (IE ?.)&quot;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_Dot = DEFNODE(</span><span class="s2">&quot;Dot&quot;</span><span class="s0">, </span><span class="s2">&quot;quote&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Dot(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.property = props.property;</span>
        <span class="s1">this</span><span class="s0">.optional = props.optional;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A dotted property access expression&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">quote: </span><span class="s2">&quot;[string] the original quote character when transformed from AST_Sub&quot;</span><span class="s0">,</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_PropAccess);</span>

<span class="s1">var </span><span class="s0">AST_DotHash = DEFNODE(</span><span class="s2">&quot;DotHash&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_DotHash(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.property = props.property;</span>
        <span class="s1">this</span><span class="s0">.optional = props.optional;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A dotted property access to a private property&quot;</span><span class="s0">,</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_PropAccess);</span>

<span class="s1">var </span><span class="s0">AST_Sub = DEFNODE(</span><span class="s2">&quot;Sub&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Sub(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.property = props.property;</span>
        <span class="s1">this</span><span class="s0">.optional = props.optional;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Index-style property access, i.e. `a[</span><span class="s5">\&quot;</span><span class="s2">foo</span><span class="s5">\&quot;</span><span class="s2">]`&quot;</span><span class="s0">,</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.property._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.property);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">}, AST_PropAccess);</span>

<span class="s1">var </span><span class="s0">AST_Chain = DEFNODE(</span><span class="s2">&quot;Chain&quot;</span><span class="s0">, </span><span class="s2">&quot;expression&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Chain(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A chain expression like a?.b?.(c)?.[d]&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element.&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function </span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Unary = DEFNODE(</span><span class="s2">&quot;Unary&quot;</span><span class="s0">, </span><span class="s2">&quot;operator expression&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Unary(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.operator = props.operator;</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for unary expressions&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">operator: </span><span class="s2">&quot;[string] the operator&quot;</span><span class="s0">,</span>
        <span class="s0">expression: </span><span class="s2">&quot;[AST_Node] expression that this unary operator applies to&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.expression._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.expression);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_UnaryPrefix = DEFNODE(</span><span class="s2">&quot;UnaryPrefix&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_UnaryPrefix(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.operator = props.operator;</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Unary prefix expression, i.e. `typeof i` or `++i`&quot;</span>
<span class="s0">}, AST_Unary);</span>

<span class="s1">var </span><span class="s0">AST_UnaryPostfix = DEFNODE(</span><span class="s2">&quot;UnaryPostfix&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_UnaryPostfix(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.operator = props.operator;</span>
        <span class="s1">this</span><span class="s0">.expression = props.expression;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Unary postfix expression, i.e. `i++`&quot;</span>
<span class="s0">}, AST_Unary);</span>

<span class="s1">var </span><span class="s0">AST_Binary = DEFNODE(</span><span class="s2">&quot;Binary&quot;</span><span class="s0">, </span><span class="s2">&quot;operator left right&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Binary(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.operator = props.operator;</span>
        <span class="s1">this</span><span class="s0">.left = props.left;</span>
        <span class="s1">this</span><span class="s0">.right = props.right;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Binary expression, i.e. `a + b`&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">left: </span><span class="s2">&quot;[AST_Node] left-hand side expression&quot;</span><span class="s0">,</span>
        <span class="s0">operator: </span><span class="s2">&quot;[string] the operator&quot;</span><span class="s0">,</span>
        <span class="s0">right: </span><span class="s2">&quot;[AST_Node] right-hand side expression&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.left._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.right._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.right);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.left);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Conditional = DEFNODE(</span>
    <span class="s2">&quot;Conditional&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;condition consequent alternative&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_Conditional(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.condition = props.condition;</span>
            <span class="s1">this</span><span class="s0">.consequent = props.consequent;</span>
            <span class="s1">this</span><span class="s0">.alternative = props.alternative;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;Conditional expression using the ternary operator, i.e. `a ? b : c`&quot;</span><span class="s0">,</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">condition: </span><span class="s2">&quot;[AST_Node]&quot;</span><span class="s0">,</span>
            <span class="s0">consequent: </span><span class="s2">&quot;[AST_Node]&quot;</span><span class="s0">,</span>
            <span class="s0">alternative: </span><span class="s2">&quot;[AST_Node]&quot;</span>
        <span class="s0">},</span>
        <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
            <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s1">this</span><span class="s0">.condition._walk(visitor);</span>
                <span class="s1">this</span><span class="s0">.consequent._walk(visitor);</span>
                <span class="s1">this</span><span class="s0">.alternative._walk(visitor);</span>
            <span class="s0">});</span>
        <span class="s0">},</span>
        <span class="s0">_children_backwards(push) {</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.alternative);</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.consequent);</span>
            <span class="s0">push(</span><span class="s1">this</span><span class="s0">.condition);</span>
        <span class="s0">},</span>
    <span class="s0">}</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_Assign = DEFNODE(</span><span class="s2">&quot;Assign&quot;</span><span class="s0">, </span><span class="s2">&quot;logical&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Assign(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.logical = props.logical;</span>
        <span class="s1">this</span><span class="s0">.operator = props.operator;</span>
        <span class="s1">this</span><span class="s0">.left = props.left;</span>
        <span class="s1">this</span><span class="s0">.right = props.right;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An assignment expression — `a = b + 5`&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">logical: </span><span class="s2">&quot;Whether it's a logical assignment&quot;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Binary);</span>

<span class="s1">var </span><span class="s0">AST_DefaultAssign = DEFNODE(</span><span class="s2">&quot;DefaultAssign&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_DefaultAssign(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.operator = props.operator;</span>
        <span class="s1">this</span><span class="s0">.left = props.left;</span>
        <span class="s1">this</span><span class="s0">.right = props.right;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A default assignment expression like in `(a = 3) =&gt; a`&quot;</span>
<span class="s0">}, AST_Binary);</span>

<span class="s3">/* -----[ LITERALS ]----- */</span>

<span class="s1">var </span><span class="s0">AST_Array = DEFNODE(</span><span class="s2">&quot;Array&quot;</span><span class="s0">, </span><span class="s2">&quot;elements&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Array(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.elements = props.elements;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An array literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">elements: </span><span class="s2">&quot;[AST_Node*] array of elements&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">elements = </span><span class="s1">this</span><span class="s0">.elements;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = elements.length; i &lt; len; i++) {</span>
                <span class="s0">elements[i]._walk(visitor);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.elements.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.elements[i]);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_Object = DEFNODE(</span><span class="s2">&quot;Object&quot;</span><span class="s0">, </span><span class="s2">&quot;properties&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Object(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.properties = props.properties;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An object literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">properties: </span><span class="s2">&quot;[AST_ObjectProperty*] array of properties&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">properties = </span><span class="s1">this</span><span class="s0">.properties;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = properties.length; i &lt; len; i++) {</span>
                <span class="s0">properties[i]._walk(visitor);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.properties.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.properties[i]);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_ObjectProperty = DEFNODE(</span><span class="s2">&quot;ObjectProperty&quot;</span><span class="s0">, </span><span class="s2">&quot;key value&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ObjectProperty(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for literal object properties&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">key: </span><span class="s2">&quot;[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.&quot;</span><span class="s0">,</span>
        <span class="s0">value: </span><span class="s2">&quot;[AST_Node] property value.  For getters and setters this is an AST_Accessor.&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_Node)</span>
                <span class="s1">this</span><span class="s0">.key._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.value._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.value);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_Node) push(</span><span class="s1">this</span><span class="s0">.key);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_ObjectKeyVal = DEFNODE(</span><span class="s2">&quot;ObjectKeyVal&quot;</span><span class="s0">, </span><span class="s2">&quot;quote&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ObjectKeyVal(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A key: value object property&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">quote: </span><span class="s2">&quot;[string] the original quote character&quot;</span>
    <span class="s0">},</span>
    <span class="s0">computed_key() {</span>
        <span class="s1">return this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_Node;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_ObjectProperty);</span>

<span class="s1">var </span><span class="s0">AST_PrivateSetter = DEFNODE(</span><span class="s2">&quot;PrivateSetter&quot;</span><span class="s0">, </span><span class="s2">&quot;static&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_PrivateSetter(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.static = props.static;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">static: </span><span class="s2">&quot;[boolean] whether this is a static private setter&quot;</span>
    <span class="s0">},</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A private setter property&quot;</span><span class="s0">,</span>
    <span class="s0">computed_key() {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_ObjectProperty);</span>

<span class="s1">var </span><span class="s0">AST_PrivateGetter = DEFNODE(</span><span class="s2">&quot;PrivateGetter&quot;</span><span class="s0">, </span><span class="s2">&quot;static&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_PrivateGetter(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.static = props.static;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">static: </span><span class="s2">&quot;[boolean] whether this is a static private getter&quot;</span>
    <span class="s0">},</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A private getter property&quot;</span><span class="s0">,</span>
    <span class="s0">computed_key() {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_ObjectProperty);</span>

<span class="s1">var </span><span class="s0">AST_ObjectSetter = DEFNODE(</span><span class="s2">&quot;ObjectSetter&quot;</span><span class="s0">, </span><span class="s2">&quot;quote static&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ObjectSetter(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.static = props.static;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">quote: </span><span class="s2">&quot;[string|undefined] the original quote character, if any&quot;</span><span class="s0">,</span>
        <span class="s0">static: </span><span class="s2">&quot;[boolean] whether this is a static setter (classes only)&quot;</span>
    <span class="s0">},</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An object setter property&quot;</span><span class="s0">,</span>
    <span class="s0">computed_key() {</span>
        <span class="s1">return </span><span class="s0">!(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod);</span>
    <span class="s0">}</span>
<span class="s0">}, AST_ObjectProperty);</span>

<span class="s1">var </span><span class="s0">AST_ObjectGetter = DEFNODE(</span><span class="s2">&quot;ObjectGetter&quot;</span><span class="s0">, </span><span class="s2">&quot;quote static&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ObjectGetter(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.static = props.static;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">quote: </span><span class="s2">&quot;[string|undefined] the original quote character, if any&quot;</span><span class="s0">,</span>
        <span class="s0">static: </span><span class="s2">&quot;[boolean] whether this is a static getter (classes only)&quot;</span>
    <span class="s0">},</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An object getter property&quot;</span><span class="s0">,</span>
    <span class="s0">computed_key() {</span>
        <span class="s1">return </span><span class="s0">!(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod);</span>
    <span class="s0">}</span>
<span class="s0">}, AST_ObjectProperty);</span>

<span class="s1">var </span><span class="s0">AST_ConciseMethod = DEFNODE(</span>
    <span class="s2">&quot;ConciseMethod&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;quote static is_generator async&quot;</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_ConciseMethod(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
            <span class="s1">this</span><span class="s0">.static = props.static;</span>
            <span class="s1">this</span><span class="s0">.is_generator = props.is_generator;</span>
            <span class="s1">this</span><span class="s0">.async = props.async;</span>
            <span class="s1">this</span><span class="s0">.key = props.key;</span>
            <span class="s1">this</span><span class="s0">.value = props.value;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
            <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$propdoc: {</span>
            <span class="s0">quote: </span><span class="s2">&quot;[string|undefined] the original quote character, if any&quot;</span><span class="s0">,</span>
            <span class="s0">static: </span><span class="s2">&quot;[boolean] is this method static (classes only)&quot;</span><span class="s0">,</span>
            <span class="s0">is_generator: </span><span class="s2">&quot;[boolean] is this a generator method&quot;</span><span class="s0">,</span>
            <span class="s0">async: </span><span class="s2">&quot;[boolean] is this method async&quot;</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;An ES6 concise method inside an object or class&quot;</span><span class="s0">,</span>
        <span class="s0">computed_key() {</span>
            <span class="s1">return </span><span class="s0">!(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod);</span>
        <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">AST_ObjectProperty</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_PrivateMethod = DEFNODE(</span><span class="s2">&quot;PrivateMethod&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_PrivateMethod(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.static = props.static;</span>
        <span class="s1">this</span><span class="s0">.is_generator = props.is_generator;</span>
        <span class="s1">this</span><span class="s0">.async = props.async;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A private class method inside a class&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_ConciseMethod);</span>

<span class="s1">var </span><span class="s0">AST_Class = DEFNODE(</span><span class="s2">&quot;Class&quot;</span><span class="s0">, </span><span class="s2">&quot;name extends properties&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Class(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.extends = props.extends;</span>
        <span class="s1">this</span><span class="s0">.properties = props.properties;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">name: </span><span class="s2">&quot;[AST_SymbolClass|AST_SymbolDefClass?] optional class name.&quot;</span><span class="s0">,</span>
        <span class="s0">extends: </span><span class="s2">&quot;[AST_Node]? optional parent class&quot;</span><span class="s0">,</span>
        <span class="s0">properties: </span><span class="s2">&quot;[AST_ObjectProperty*] array of properties&quot;</span>
    <span class="s0">},</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An ES6 class&quot;</span><span class="s0">,</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name) {</span>
                <span class="s1">this</span><span class="s0">.name._walk(visitor);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.extends) {</span>
                <span class="s1">this</span><span class="s0">.extends._walk(visitor);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.properties.forEach((prop) =&gt; prop._walk(visitor));</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.properties.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.properties[i]);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.extends) push(</span><span class="s1">this</span><span class="s0">.extends);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name) push(</span><span class="s1">this</span><span class="s0">.name);</span>
    <span class="s0">},</span>
    <span class="s3">/** go through the bits that are executed instantly, not when the class is `new`'d. Doesn't walk the name. */</span>
    <span class="s0">visit_nondeferred_class_parts(visitor) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.extends) {</span>
            <span class="s1">this</span><span class="s0">.extends._walk(visitor);</span>
        <span class="s0">}</span>
        <span class="s1">this</span><span class="s0">.properties.forEach((prop) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_ClassStaticBlock) {</span>
                <span class="s0">prop._walk(visitor);</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(prop.computed_key()) {</span>
                <span class="s0">visitor.push(prop);</span>
                <span class="s0">prop.key._walk(visitor);</span>
                <span class="s0">visitor.pop();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">((prop </span><span class="s1">instanceof </span><span class="s0">AST_ClassPrivateProperty || prop </span><span class="s1">instanceof </span><span class="s0">AST_ClassProperty) &amp;&amp; prop.static &amp;&amp; prop.value) {</span>
                <span class="s0">visitor.push(prop);</span>
                <span class="s0">prop.value._walk(visitor);</span>
                <span class="s0">visitor.pop();</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s3">/** go through the bits that are executed later, when the class is `new`'d or a static method is called */</span>
    <span class="s0">visit_deferred_class_parts(visitor) {</span>
        <span class="s1">this</span><span class="s0">.properties.forEach((prop) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_ConciseMethod) {</span>
                <span class="s0">prop.walk(visitor);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_ClassProperty &amp;&amp; !prop.static &amp;&amp; prop.value) {</span>
                <span class="s0">visitor.push(prop);</span>
                <span class="s0">prop.value._walk(visitor);</span>
                <span class="s0">visitor.pop();</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
<span class="s0">}, AST_Scope </span><span class="s3">/* TODO a class might have a scope but it's not a scope */</span><span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_ClassProperty = DEFNODE(</span><span class="s2">&quot;ClassProperty&quot;</span><span class="s0">, </span><span class="s2">&quot;static quote&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ClassProperty(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.static = props.static;</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A class property&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">static: </span><span class="s2">&quot;[boolean] whether this is a static key&quot;</span><span class="s0">,</span>
        <span class="s0">quote: </span><span class="s2">&quot;[string] which quote is being used&quot;</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_Node)</span>
                <span class="s1">this</span><span class="s0">.key._walk(visitor);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.value </span><span class="s1">instanceof </span><span class="s0">AST_Node)</span>
                <span class="s1">this</span><span class="s0">.value._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.value </span><span class="s1">instanceof </span><span class="s0">AST_Node) push(</span><span class="s1">this</span><span class="s0">.value);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_Node) push(</span><span class="s1">this</span><span class="s0">.key);</span>
    <span class="s0">},</span>
    <span class="s0">computed_key() {</span>
        <span class="s1">return </span><span class="s0">!(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolClassProperty);</span>
    <span class="s0">}</span>
<span class="s0">}, AST_ObjectProperty);</span>

<span class="s1">var </span><span class="s0">AST_ClassPrivateProperty = DEFNODE(</span><span class="s2">&quot;ClassPrivateProperty&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ClassPrivateProperty(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.static = props.static;</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A class property for a private property&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_ClassProperty);</span>

<span class="s1">var </span><span class="s0">AST_PrivateIn = DEFNODE(</span><span class="s2">&quot;PrivateIn&quot;</span><span class="s0">, </span><span class="s2">&quot;key value&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_PrivateIn(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.key = props.key;</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;An `in` binop when the key is private, eg #x in this&quot;</span><span class="s0">,</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">this</span><span class="s0">.key._walk(visitor);</span>
            <span class="s1">this</span><span class="s0">.value._walk(visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.value);</span>
        <span class="s0">push(</span><span class="s1">this</span><span class="s0">.key);</span>
    <span class="s0">},</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_DefClass = DEFNODE(</span><span class="s2">&quot;DefClass&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_DefClass(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.extends = props.extends;</span>
        <span class="s1">this</span><span class="s0">.properties = props.properties;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A class definition&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Class);</span>

<span class="s1">var </span><span class="s0">AST_ClassStaticBlock = DEFNODE(</span><span class="s2">&quot;ClassStaticBlock&quot;</span><span class="s0">, </span><span class="s2">&quot;body block_scope&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ClassStaticBlock (props) {</span>
    <span class="s1">this</span><span class="s0">.body = props.body;</span>
    <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
    <span class="s1">this</span><span class="s0">.start = props.start;</span>
    <span class="s1">this</span><span class="s0">.end = props.end;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A block containing statements to be executed in the context of the class&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">body: </span><span class="s2">&quot;[AST_Statement*] an array of statements&quot;</span><span class="s0">,</span>
    <span class="s0">},</span>
    <span class="s0">_walk: </span><span class="s1">function</span><span class="s0">(visitor) {</span>
        <span class="s1">return </span><span class="s0">visitor._visit(</span><span class="s1">this</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">walk_body(</span><span class="s1">this</span><span class="s0">, visitor);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">_children_backwards(push) {</span>
        <span class="s0">let i = </span><span class="s1">this</span><span class="s0">.body.length;</span>
        <span class="s1">while </span><span class="s0">(i--) push(</span><span class="s1">this</span><span class="s0">.body[i]);</span>
    <span class="s0">},</span>
    <span class="s0">clone: clone_block_scope,</span>
    <span class="s0">computed_key: () =&gt; </span><span class="s1">false</span>
<span class="s0">}, AST_Scope);</span>

<span class="s1">var </span><span class="s0">AST_ClassExpression = DEFNODE(</span><span class="s2">&quot;ClassExpression&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_ClassExpression(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.extends = props.extends;</span>
        <span class="s1">this</span><span class="s0">.properties = props.properties;</span>
        <span class="s1">this</span><span class="s0">.variables = props.variables;</span>
        <span class="s1">this</span><span class="s0">.uses_with = props.uses_with;</span>
        <span class="s1">this</span><span class="s0">.uses_eval = props.uses_eval;</span>
        <span class="s1">this</span><span class="s0">.parent_scope = props.parent_scope;</span>
        <span class="s1">this</span><span class="s0">.enclosed = props.enclosed;</span>
        <span class="s1">this</span><span class="s0">.cname = props.cname;</span>
        <span class="s1">this</span><span class="s0">.body = props.body;</span>
        <span class="s1">this</span><span class="s0">.block_scope = props.block_scope;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A class expression.&quot;</span>
<span class="s0">}, AST_Class);</span>

<span class="s1">var </span><span class="s0">AST_Symbol = DEFNODE(</span><span class="s2">&quot;Symbol&quot;</span><span class="s0">, </span><span class="s2">&quot;scope name thedef&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Symbol(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">name: </span><span class="s2">&quot;[string] name of this symbol&quot;</span><span class="s0">,</span>
        <span class="s0">scope: </span><span class="s2">&quot;[AST_Scope/S] the current scope (not necessarily the definition scope)&quot;</span><span class="s0">,</span>
        <span class="s0">thedef: </span><span class="s2">&quot;[SymbolDef/S] the definition of this symbol&quot;</span>
    <span class="s0">},</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for all symbols&quot;</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_NewTarget = DEFNODE(</span><span class="s2">&quot;NewTarget&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_NewTarget(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A reference to new.target&quot;</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_SymbolDeclaration = DEFNODE(</span><span class="s2">&quot;SymbolDeclaration&quot;</span><span class="s0">, </span><span class="s2">&quot;init&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolDeclaration(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A declaration symbol (symbol in var/const, function name or argument, symbol in catch)&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_SymbolVar = DEFNODE(</span><span class="s2">&quot;SymbolVar&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolVar(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol defining a variable&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SymbolDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolBlockDeclaration = DEFNODE(</span>
    <span class="s2">&quot;SymbolBlockDeclaration&quot;</span><span class="s0">,</span>
    <span class="s1">null</span><span class="s0">,</span>
    <span class="s1">function </span><span class="s0">AST_SymbolBlockDeclaration(props) {</span>
        <span class="s1">if </span><span class="s0">(props) {</span>
            <span class="s1">this</span><span class="s0">.init = props.init;</span>
            <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
            <span class="s1">this</span><span class="s0">.name = props.name;</span>
            <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
            <span class="s1">this</span><span class="s0">.start = props.start;</span>
            <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s0">}</span>

        <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">},</span>
    <span class="s0">{</span>
        <span class="s0">$documentation: </span><span class="s2">&quot;Base class for block-scoped declaration symbols&quot;</span>
    <span class="s0">},</span>
    <span class="s0">AST_SymbolDeclaration</span>
<span class="s0">);</span>

<span class="s1">var </span><span class="s0">AST_SymbolConst = DEFNODE(</span><span class="s2">&quot;SymbolConst&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolConst(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A constant declaration&quot;</span>
<span class="s0">}, AST_SymbolBlockDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolLet = DEFNODE(</span><span class="s2">&quot;SymbolLet&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolLet(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A block-scoped `let` declaration&quot;</span>
<span class="s0">}, AST_SymbolBlockDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolFunarg = DEFNODE(</span><span class="s2">&quot;SymbolFunarg&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolFunarg(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol naming a function argument&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SymbolVar);</span>

<span class="s1">var </span><span class="s0">AST_SymbolDefun = DEFNODE(</span><span class="s2">&quot;SymbolDefun&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolDefun(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol defining a function&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SymbolDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolMethod = DEFNODE(</span><span class="s2">&quot;SymbolMethod&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolMethod(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol in an object defining a method&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_SymbolClassProperty = DEFNODE(</span><span class="s2">&quot;SymbolClassProperty&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolClassProperty(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol for a class property&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_SymbolLambda = DEFNODE(</span><span class="s2">&quot;SymbolLambda&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolLambda(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol naming a function expression&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SymbolDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolDefClass = DEFNODE(</span><span class="s2">&quot;SymbolDefClass&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolDefClass(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class.&quot;</span>
<span class="s0">}, AST_SymbolBlockDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolClass = DEFNODE(</span><span class="s2">&quot;SymbolClass&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolClass(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol naming a class's name. Lexically scoped to the class.&quot;</span>
<span class="s0">}, AST_SymbolDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolCatch = DEFNODE(</span><span class="s2">&quot;SymbolCatch&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolCatch(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol naming the exception in catch&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SymbolBlockDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolImport = DEFNODE(</span><span class="s2">&quot;SymbolImport&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolImport(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.init = props.init;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol referring to an imported name&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SymbolBlockDeclaration);</span>

<span class="s1">var </span><span class="s0">AST_SymbolImportForeign = DEFNODE(</span><span class="s2">&quot;SymbolImportForeign&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolImportForeign(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_Label = DEFNODE(</span><span class="s2">&quot;Label&quot;</span><span class="s0">, </span><span class="s2">&quot;references&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Label(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.references = props.references;</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">.initialize();</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol naming a label (declaration)&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">references: </span><span class="s2">&quot;[AST_LoopControl*] a list of nodes referring to this label&quot;</span>
    <span class="s0">},</span>
    <span class="s0">initialize: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">this</span><span class="s0">.references = [];</span>
        <span class="s1">this</span><span class="s0">.thedef = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_SymbolRef = DEFNODE(</span><span class="s2">&quot;SymbolRef&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolRef(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Reference to some symbol (not definition/declaration)&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_SymbolExport = DEFNODE(</span><span class="s2">&quot;SymbolExport&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolExport(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Symbol referring to a name to export&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_SymbolRef);</span>

<span class="s1">var </span><span class="s0">AST_SymbolExportForeign = DEFNODE(</span><span class="s2">&quot;SymbolExportForeign&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolExportForeign(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_LabelRef = DEFNODE(</span><span class="s2">&quot;LabelRef&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_LabelRef(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Reference to a label symbol&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_SymbolPrivateProperty = DEFNODE(</span><span class="s2">&quot;SymbolPrivateProperty&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_SymbolPrivateProperty(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A symbol that refers to a private property&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_This = DEFNODE(</span><span class="s2">&quot;This&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_This(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `this` symbol&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Symbol);</span>

<span class="s1">var </span><span class="s0">AST_Super = DEFNODE(</span><span class="s2">&quot;Super&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Super(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.scope = props.scope;</span>
        <span class="s1">this</span><span class="s0">.name = props.name;</span>
        <span class="s1">this</span><span class="s0">.thedef = props.thedef;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `super` symbol&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_This);</span>

<span class="s1">var </span><span class="s0">AST_Constant = DEFNODE(</span><span class="s2">&quot;Constant&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Constant(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for all constants&quot;</span><span class="s0">,</span>
    <span class="s0">getValue: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.value;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">AST_String = DEFNODE(</span><span class="s2">&quot;String&quot;</span><span class="s0">, </span><span class="s2">&quot;value quote&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_String(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.quote = props.quote;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
        <span class="s1">this</span><span class="s0">._annotations = props._annotations;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A string literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">value: </span><span class="s2">&quot;[string] the contents of this string&quot;</span><span class="s0">,</span>
        <span class="s0">quote: </span><span class="s2">&quot;[string] the original quote character&quot;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Constant);</span>

<span class="s1">var </span><span class="s0">AST_Number = DEFNODE(</span><span class="s2">&quot;Number&quot;</span><span class="s0">, </span><span class="s2">&quot;value raw&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Number(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.raw = props.raw;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A number literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">value: </span><span class="s2">&quot;[number] the numeric value&quot;</span><span class="s0">,</span>
        <span class="s0">raw: </span><span class="s2">&quot;[string] numeric value as string&quot;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Constant);</span>

<span class="s1">var </span><span class="s0">AST_BigInt = DEFNODE(</span><span class="s2">&quot;BigInt&quot;</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_BigInt(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A big int literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">value: </span><span class="s2">&quot;[string] big int value&quot;</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Constant);</span>

<span class="s1">var </span><span class="s0">AST_RegExp = DEFNODE(</span><span class="s2">&quot;RegExp&quot;</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_RegExp(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.value = props.value;</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A regexp literal&quot;</span><span class="s0">,</span>
    <span class="s0">$propdoc: {</span>
        <span class="s0">value: </span><span class="s2">&quot;[RegExp] the actual regexp&quot;</span><span class="s0">,</span>
    <span class="s0">}</span>
<span class="s0">}, AST_Constant);</span>

<span class="s1">var </span><span class="s0">AST_Atom = DEFNODE(</span><span class="s2">&quot;Atom&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Atom(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for atoms&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Constant);</span>

<span class="s1">var </span><span class="s0">AST_Null = DEFNODE(</span><span class="s2">&quot;Null&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Null(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `null` atom&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">null</span>
<span class="s0">}, AST_Atom);</span>

<span class="s1">var </span><span class="s0">AST_NaN = DEFNODE(</span><span class="s2">&quot;NaN&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_NaN(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The impossible value&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s4">0</span><span class="s0">/</span><span class="s4">0</span>
<span class="s0">}, AST_Atom);</span>

<span class="s1">var </span><span class="s0">AST_Undefined = DEFNODE(</span><span class="s2">&quot;Undefined&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Undefined(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `undefined` value&quot;</span><span class="s0">,</span>
    <span class="s0">value: (</span><span class="s1">function</span><span class="s0">() {}())</span>
<span class="s0">}, AST_Atom);</span>

<span class="s1">var </span><span class="s0">AST_Hole = DEFNODE(</span><span class="s2">&quot;Hole&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Hole(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;A hole in an array&quot;</span><span class="s0">,</span>
    <span class="s0">value: (</span><span class="s1">function</span><span class="s0">() {}())</span>
<span class="s0">}, AST_Atom);</span>

<span class="s1">var </span><span class="s0">AST_Infinity = DEFNODE(</span><span class="s2">&quot;Infinity&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Infinity(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `Infinity` value&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s4">1</span><span class="s0">/</span><span class="s4">0</span>
<span class="s0">}, AST_Atom);</span>

<span class="s1">var </span><span class="s0">AST_Boolean = DEFNODE(</span><span class="s2">&quot;Boolean&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_Boolean(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;Base class for booleans&quot;</span><span class="s0">,</span>
<span class="s0">}, AST_Atom);</span>

<span class="s1">var </span><span class="s0">AST_False = DEFNODE(</span><span class="s2">&quot;False&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_False(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `false` atom&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">false</span>
<span class="s0">}, AST_Boolean);</span>

<span class="s1">var </span><span class="s0">AST_True = DEFNODE(</span><span class="s2">&quot;True&quot;</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">function </span><span class="s0">AST_True(props) {</span>
    <span class="s1">if </span><span class="s0">(props) {</span>
        <span class="s1">this</span><span class="s0">.start = props.start;</span>
        <span class="s1">this</span><span class="s0">.end = props.end;</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.flags = </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}, {</span>
    <span class="s0">$documentation: </span><span class="s2">&quot;The `true` atom&quot;</span><span class="s0">,</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">}, AST_Boolean);</span>

<span class="s3">/* -----[ Walk function ]---- */</span>

<span class="s3">/** 
 * Walk nodes in depth-first search fashion. 
 * Callback can return `walk_abort` symbol to stop iteration. 
 * It can also return `true` to stop iteration just for child nodes. 
 * Iteration can be stopped and continued by passing the `to_visit` argument, 
 * which is given to the callback in the second argument. 
 **/</span>
<span class="s1">function </span><span class="s0">walk(node, cb, to_visit = [node]) {</span>
    <span class="s0">const push = to_visit.push.bind(to_visit);</span>
    <span class="s1">while </span><span class="s0">(to_visit.length) {</span>
        <span class="s0">const node = to_visit.pop();</span>
        <span class="s0">const ret = cb(node, to_visit);</span>

        <span class="s1">if </span><span class="s0">(ret) {</span>
            <span class="s1">if </span><span class="s0">(ret === walk_abort) </span><span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">node._children_backwards(push);</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">/** 
 * Walks an AST node and its children. 
 * 
 * {cb} can return `walk_abort` to interrupt the walk. 
 * 
 * @param node 
 * @param cb {(node, info: { parent: (nth) =&gt; any }) =&gt; (boolean | undefined)} 
 * 
 * @returns {boolean} whether the walk was aborted 
 * 
 * @example 
 * const found_some_cond = walk_parent(my_ast_node, (node, { parent }) =&gt; { 
 *   if (some_cond(node, parent())) return walk_abort 
 * }); 
 */</span>
<span class="s1">function </span><span class="s0">walk_parent(node, cb, initial_stack) {</span>
    <span class="s0">const to_visit = [node];</span>
    <span class="s0">const push = to_visit.push.bind(to_visit);</span>
    <span class="s0">const stack = initial_stack ? initial_stack.slice() : [];</span>
    <span class="s0">const parent_pop_indices = [];</span>

    <span class="s0">let current;</span>

    <span class="s0">const info = {</span>
        <span class="s0">parent: (n = </span><span class="s4">0</span><span class="s0">) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(n === -</span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">current;</span>
            <span class="s0">}</span>

            <span class="s3">// [ p1 p0 ] [ 1 0 ]</span>
            <span class="s1">if </span><span class="s0">(initial_stack &amp;&amp; n &gt;= stack.length) {</span>
                <span class="s0">n -= stack.length;</span>
                <span class="s1">return </span><span class="s0">initial_stack[</span>
                    <span class="s0">initial_stack.length - (n + </span><span class="s4">1</span><span class="s0">)</span>
                <span class="s0">];</span>
            <span class="s0">}</span>

            <span class="s1">return </span><span class="s0">stack[stack.length - (</span><span class="s4">1 </span><span class="s0">+ n)];</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">while </span><span class="s0">(to_visit.length) {</span>
        <span class="s0">current = to_visit.pop();</span>

        <span class="s1">while </span><span class="s0">(</span>
            <span class="s0">parent_pop_indices.length &amp;&amp;</span>
            <span class="s0">to_visit.length == parent_pop_indices[parent_pop_indices.length - </span><span class="s4">1</span><span class="s0">]</span>
        <span class="s0">) {</span>
            <span class="s0">stack.pop();</span>
            <span class="s0">parent_pop_indices.pop();</span>
        <span class="s0">}</span>

        <span class="s0">const ret = cb(current, info);</span>

        <span class="s1">if </span><span class="s0">(ret) {</span>
            <span class="s1">if </span><span class="s0">(ret === walk_abort) </span><span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s0">const visit_length = to_visit.length;</span>

        <span class="s0">current._children_backwards(push);</span>

        <span class="s3">// Push only if we're going to traverse the children</span>
        <span class="s1">if </span><span class="s0">(to_visit.length &gt; visit_length) {</span>
            <span class="s0">stack.push(current);</span>
            <span class="s0">parent_pop_indices.push(visit_length - </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">const walk_abort = Symbol(</span><span class="s2">&quot;abort walk&quot;</span><span class="s0">);</span>

<span class="s3">/* -----[ TreeWalker ]----- */</span>

<span class="s0">class TreeWalker {</span>
    <span class="s0">constructor(callback) {</span>
        <span class="s1">this</span><span class="s0">.visit = callback;</span>
        <span class="s1">this</span><span class="s0">.stack = [];</span>
        <span class="s1">this</span><span class="s0">.directives = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">_visit(node, descend) {</span>
        <span class="s1">this</span><span class="s0">.push(node);</span>
        <span class="s1">var </span><span class="s0">ret = </span><span class="s1">this</span><span class="s0">.visit(node, descend ? </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">descend.call(node);</span>
        <span class="s0">} : noop);</span>
        <span class="s1">if </span><span class="s0">(!ret &amp;&amp; descend) {</span>
            <span class="s0">descend.call(node);</span>
        <span class="s0">}</span>
        <span class="s1">this</span><span class="s0">.pop();</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s0">parent(n) {</span>
        <span class="s1">return this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length - </span><span class="s4">2 </span><span class="s0">- (n || </span><span class="s4">0</span><span class="s0">)];</span>
    <span class="s0">}</span>

    <span class="s0">push(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda) {</span>
            <span class="s1">this</span><span class="s0">.directives = Object.create(</span><span class="s1">this</span><span class="s0">.directives);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Directive &amp;&amp; !</span><span class="s1">this</span><span class="s0">.directives[node.value]) {</span>
            <span class="s1">this</span><span class="s0">.directives[node.value] = node;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Class) {</span>
            <span class="s1">this</span><span class="s0">.directives = Object.create(</span><span class="s1">this</span><span class="s0">.directives);</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.directives[</span><span class="s2">&quot;use strict&quot;</span><span class="s0">]) {</span>
                <span class="s1">this</span><span class="s0">.directives[</span><span class="s2">&quot;use strict&quot;</span><span class="s0">] = node;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">this</span><span class="s0">.stack.push(node);</span>
    <span class="s0">}</span>

    <span class="s0">pop() {</span>
        <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.stack.pop();</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda || node </span><span class="s1">instanceof </span><span class="s0">AST_Class) {</span>
            <span class="s1">this</span><span class="s0">.directives = Object.getPrototypeOf(</span><span class="s1">this</span><span class="s0">.directives);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">self() {</span>
        <span class="s1">return this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length - </span><span class="s4">1</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s0">find_parent(type) {</span>
        <span class="s1">var </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.stack;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = stack.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s1">var </span><span class="s0">x = stack[i];</span>
            <span class="s1">if </span><span class="s0">(x </span><span class="s1">instanceof </span><span class="s0">type) </span><span class="s1">return </span><span class="s0">x;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">find_scope() {</span>
        <span class="s1">var </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.stack;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = stack.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s0">const p = stack[i];</span>
            <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) </span><span class="s1">return </span><span class="s0">p;</span>
            <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Lambda) </span><span class="s1">return </span><span class="s0">p;</span>
            <span class="s1">if </span><span class="s0">(p.block_scope) </span><span class="s1">return </span><span class="s0">p.block_scope;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">has_directive(type) {</span>
        <span class="s1">var </span><span class="s0">dir = </span><span class="s1">this</span><span class="s0">.directives[type];</span>
        <span class="s1">if </span><span class="s0">(dir) </span><span class="s1">return </span><span class="s0">dir;</span>
        <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length - </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope &amp;&amp; node.body) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; node.body.length; ++i) {</span>
                <span class="s1">var </span><span class="s0">st = node.body[i];</span>
                <span class="s1">if </span><span class="s0">(!(st </span><span class="s1">instanceof </span><span class="s0">AST_Directive)) </span><span class="s1">break</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(st.value == type) </span><span class="s1">return </span><span class="s0">st;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">loopcontrol_target(node) {</span>
        <span class="s1">var </span><span class="s0">stack = </span><span class="s1">this</span><span class="s0">.stack;</span>
        <span class="s1">if </span><span class="s0">(node.label) </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = stack.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s1">var </span><span class="s0">x = stack[i];</span>
            <span class="s1">if </span><span class="s0">(x </span><span class="s1">instanceof </span><span class="s0">AST_LabeledStatement &amp;&amp; x.label.name == node.label.name)</span>
                <span class="s1">return </span><span class="s0">x.body;</span>
        <span class="s0">} </span><span class="s1">else for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = stack.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s1">var </span><span class="s0">x = stack[i];</span>
            <span class="s1">if </span><span class="s0">(x </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Break &amp;&amp; x </span><span class="s1">instanceof </span><span class="s0">AST_Switch)</span>
                <span class="s1">return </span><span class="s0">x;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">// Tree transformer helpers.</span>
<span class="s0">class TreeTransformer extends TreeWalker {</span>
    <span class="s0">constructor(before, after) {</span>
        <span class="s0">super();</span>
        <span class="s1">this</span><span class="s0">.before = before;</span>
        <span class="s1">this</span><span class="s0">.after = after;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">const _PURE       = </span><span class="s4">0</span><span class="s0">b00000001;</span>
<span class="s0">const _INLINE     = </span><span class="s4">0</span><span class="s0">b00000010;</span>
<span class="s0">const _NOINLINE   = </span><span class="s4">0</span><span class="s0">b00000100;</span>
<span class="s0">const _KEY        = </span><span class="s4">0</span><span class="s0">b00001000;</span>
<span class="s0">const _MANGLEPROP = </span><span class="s4">0</span><span class="s0">b00010000;</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">function </span><span class="s0">def_transform(node, descend) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;transform&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(tw, in_list) {</span>
        <span class="s0">let transformed = undefined;</span>
        <span class="s0">tw.push(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(tw.before) transformed = tw.before(</span><span class="s1">this</span><span class="s0">, descend, in_list);</span>
        <span class="s1">if </span><span class="s0">(transformed === undefined) {</span>
            <span class="s0">transformed = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s0">descend(transformed, tw);</span>
            <span class="s1">if </span><span class="s0">(tw.after) {</span>
                <span class="s0">const after_ret = tw.after(transformed, in_list);</span>
                <span class="s1">if </span><span class="s0">(after_ret !== undefined) transformed = after_ret;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">tw.pop();</span>
        <span class="s1">return </span><span class="s0">transformed;</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s0">def_transform(AST_Node, noop);</span>

<span class="s0">def_transform(AST_LabeledStatement, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.label = self.label.transform(tw);</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_SimpleStatement, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Block, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.body = MAP(self.body, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Do, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
    <span class="s0">self.condition = self.condition.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_While, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.condition = self.condition.transform(tw);</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_For, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.init) self.init = self.init.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.condition) self.condition = self.condition.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.step) self.step = self.step.transform(tw);</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_ForIn, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.init = self.init.transform(tw);</span>
    <span class="s0">self.object = self.object.transform(tw);</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_With, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Exit, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.value) self.value = self.value.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_LoopControl, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.label) self.label = self.label.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_If, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.condition = self.condition.transform(tw);</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.alternative) self.alternative = self.alternative.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Switch, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
    <span class="s0">self.body = MAP(self.body, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Case, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
    <span class="s0">self.body = MAP(self.body, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Try, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.body = self.body.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.bcatch) self.bcatch = self.bcatch.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.bfinally) self.bfinally = self.bfinally.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Catch, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.argname) self.argname = self.argname.transform(tw);</span>
    <span class="s0">self.body = MAP(self.body, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Definitions, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.definitions = MAP(self.definitions, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_VarDef, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.name = self.name.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.value) self.value = self.value.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Destructuring, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.names = MAP(self.names, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Lambda, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.name) self.name = self.name.transform(tw);</span>
    <span class="s0">self.argnames = MAP(self.argnames, tw, </span><span class="s3">/* allow_splicing */ </span><span class="s1">false</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(self.body </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
        <span class="s0">self.body = self.body.transform(tw);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">self.body = MAP(self.body, tw);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Call, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
    <span class="s0">self.args = MAP(self.args, tw, </span><span class="s3">/* allow_splicing */ </span><span class="s1">false</span><span class="s0">);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Sequence, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">const result = MAP(self.expressions, tw);</span>
    <span class="s0">self.expressions = result.length</span>
        <span class="s0">? result</span>
        <span class="s0">: [</span><span class="s1">new </span><span class="s0">AST_Number({ value: </span><span class="s4">0 </span><span class="s0">})];</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_PropAccess, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Sub, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
    <span class="s0">self.property = self.property.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Chain, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Yield, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.expression) self.expression = self.expression.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Await, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Unary, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Binary, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.left = self.left.transform(tw);</span>
    <span class="s0">self.right = self.right.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_PrivateIn, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.key = self.key.transform(tw);</span>
    <span class="s0">self.value = self.value.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Conditional, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.condition = self.condition.transform(tw);</span>
    <span class="s0">self.consequent = self.consequent.transform(tw);</span>
    <span class="s0">self.alternative = self.alternative.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Array, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.elements = MAP(self.elements, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Object, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.properties = MAP(self.properties, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_ObjectProperty, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.key </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
        <span class="s0">self.key = self.key.transform(tw);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.value) self.value = self.value.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Class, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.name) self.name = self.name.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.extends) self.extends = self.extends.transform(tw);</span>
    <span class="s0">self.properties = MAP(self.properties, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_ClassStaticBlock, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.body = MAP(self.body, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Expansion, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.expression = self.expression.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_NameMapping, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.foreign_name = self.foreign_name.transform(tw);</span>
    <span class="s0">self.name = self.name.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Import, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.imported_name) self.imported_name = self.imported_name.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.imported_names) MAP(self.imported_names, tw);</span>
    <span class="s0">self.module_name = self.module_name.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_Export, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s1">if </span><span class="s0">(self.exported_definition) self.exported_definition = self.exported_definition.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.exported_value) self.exported_value = self.exported_value.transform(tw);</span>
    <span class="s1">if </span><span class="s0">(self.exported_names) MAP(self.exported_names, tw);</span>
    <span class="s1">if </span><span class="s0">(self.module_name) self.module_name = self.module_name.transform(tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_TemplateString, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.segments = MAP(self.segments, tw);</span>
<span class="s0">});</span>

<span class="s0">def_transform(AST_PrefixedTemplateString, </span><span class="s1">function</span><span class="s0">(self, tw) {</span>
    <span class="s0">self.prefix = self.prefix.transform(tw);</span>
    <span class="s0">self.template_string = self.template_string.transform(tw);</span>
<span class="s0">});</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s0">(</span><span class="s1">function</span><span class="s0">() {</span>

    <span class="s1">var </span><span class="s0">normalize_directives = </span><span class="s1">function</span><span class="s0">(body) {</span>
        <span class="s1">var </span><span class="s0">in_directive = </span><span class="s1">true</span><span class="s0">;</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; body.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(in_directive &amp;&amp; body[i] </span><span class="s1">instanceof </span><span class="s0">AST_Statement &amp;&amp; body[i].body </span><span class="s1">instanceof </span><span class="s0">AST_String) {</span>
                <span class="s0">body[i] = </span><span class="s1">new </span><span class="s0">AST_Directive({</span>
                    <span class="s0">start: body[i].start,</span>
                    <span class="s0">end: body[i].end,</span>
                    <span class="s0">value: body[i].body.value</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(in_directive &amp;&amp; !(body[i] </span><span class="s1">instanceof </span><span class="s0">AST_Statement &amp;&amp; body[i].body </span><span class="s1">instanceof </span><span class="s0">AST_String)) {</span>
                <span class="s0">in_directive = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">body;</span>
    <span class="s0">};</span>

    <span class="s0">const assert_clause_from_moz = (assertions) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(assertions &amp;&amp; assertions.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">return new </span><span class="s0">AST_Object({</span>
                <span class="s0">start: my_start_token(assertions),</span>
                <span class="s0">end: my_end_token(assertions),</span>
                <span class="s0">properties: assertions.map((assertion_kv) =&gt;</span>
                    <span class="s1">new </span><span class="s0">AST_ObjectKeyVal({</span>
                        <span class="s0">start: my_start_token(assertion_kv),</span>
                        <span class="s0">end: my_end_token(assertion_kv),</span>
                        <span class="s0">key: assertion_kv.key.name || assertion_kv.key.value,</span>
                        <span class="s0">value: from_moz(assertion_kv.value)</span>
                    <span class="s0">})</span>
                <span class="s0">)</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">MOZ_TO_ME = {</span>
        <span class="s0">Program: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Toplevel({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">body: normalize_directives(M.body.map(from_moz))</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ArrayPattern: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">names: M.elements.map(</span><span class="s1">function</span><span class="s0">(elm) {</span>
                    <span class="s1">if </span><span class="s0">(elm === </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s1">return new </span><span class="s0">AST_Hole();</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">from_moz(elm);</span>
                <span class="s0">}),</span>
                <span class="s0">is_array: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ObjectPattern: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Destructuring({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">names: M.properties.map(from_moz),</span>
                <span class="s0">is_array: </span><span class="s1">false</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">AssignmentPattern: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_DefaultAssign({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">left: from_moz(M.left),</span>
                <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                <span class="s0">right: from_moz(M.right)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">SpreadElement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Expansion({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.argument)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">RestElement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Expansion({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.argument)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">TemplateElement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_TemplateSegment({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">value: M.value.cooked,</span>
                <span class="s0">raw: M.value.raw</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">TemplateLiteral: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">var </span><span class="s0">segments = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; M.quasis.length; i++) {</span>
                <span class="s0">segments.push(from_moz(M.quasis[i]));</span>
                <span class="s1">if </span><span class="s0">(M.expressions[i]) {</span>
                    <span class="s0">segments.push(from_moz(M.expressions[i]));</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return new </span><span class="s0">AST_TemplateString({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">segments: segments</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">TaggedTemplateExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_PrefixedTemplateString({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">template_string: from_moz(M.quasi),</span>
                <span class="s0">prefix: from_moz(M.tag)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">FunctionDeclaration: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Defun({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">name: from_moz(M.id),</span>
                <span class="s0">argnames: M.params.map(from_moz),</span>
                <span class="s0">is_generator: M.generator,</span>
                <span class="s0">async: M.async,</span>
                <span class="s0">body: normalize_directives(from_moz(M.body).body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">FunctionExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Function({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">name: from_moz(M.id),</span>
                <span class="s0">argnames: M.params.map(from_moz),</span>
                <span class="s0">is_generator: M.generator,</span>
                <span class="s0">async: M.async,</span>
                <span class="s0">body: normalize_directives(from_moz(M.body).body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ArrowFunctionExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s0">const body = M.body.type === </span><span class="s2">&quot;BlockStatement&quot;</span>
                <span class="s0">? from_moz(M.body).body</span>
                <span class="s0">: [make_node(AST_Return, {}, { value: from_moz(M.body) })];</span>
            <span class="s1">return new </span><span class="s0">AST_Arrow({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">argnames: M.params.map(from_moz),</span>
                <span class="s0">body,</span>
                <span class="s0">async: M.async,</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ExpressionStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_SimpleStatement({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">body: from_moz(M.expression)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">TryStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">var </span><span class="s0">handlers = M.handlers || [M.handler];</span>
            <span class="s1">if </span><span class="s0">(handlers.length &gt; </span><span class="s4">1 </span><span class="s0">|| M.guardedHandlers &amp;&amp; M.guardedHandlers.length) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Multiple catch clauses are not supported.&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return new </span><span class="s0">AST_Try({</span>
                <span class="s0">start    : my_start_token(M),</span>
                <span class="s0">end      : my_end_token(M),</span>
                <span class="s0">body     : </span><span class="s1">new </span><span class="s0">AST_TryBlock(from_moz(M.block)),</span>
                <span class="s0">bcatch   : from_moz(handlers[</span><span class="s4">0</span><span class="s0">]),</span>
                <span class="s0">bfinally : M.finalizer ? </span><span class="s1">new </span><span class="s0">AST_Finally(from_moz(M.finalizer)) : </span><span class="s1">null</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">Property: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">var </span><span class="s0">key = M.key;</span>
            <span class="s1">var </span><span class="s0">args = {</span>
                <span class="s0">start    : my_start_token(key || M.value),</span>
                <span class="s0">end      : my_end_token(M.value),</span>
                <span class="s0">key      : key.type == </span><span class="s2">&quot;Identifier&quot; </span><span class="s0">? key.name : key.value,</span>
                <span class="s0">value    : from_moz(M.value)</span>
            <span class="s0">};</span>
            <span class="s1">if </span><span class="s0">(M.computed) {</span>
                <span class="s0">args.key = from_moz(M.key);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(M.method) {</span>
                <span class="s0">args.is_generator = M.value.generator;</span>
                <span class="s0">args.async = M.value.async;</span>
                <span class="s1">if </span><span class="s0">(!M.computed) {</span>
                    <span class="s0">args.key = </span><span class="s1">new </span><span class="s0">AST_SymbolMethod({ name: args.key });</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">args.key = from_moz(M.key);</span>
                <span class="s0">}</span>
                <span class="s1">return new </span><span class="s0">AST_ConciseMethod(args);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(M.kind == </span><span class="s2">&quot;init&quot;</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(key.type != </span><span class="s2">&quot;Identifier&quot; </span><span class="s0">&amp;&amp; key.type != </span><span class="s2">&quot;Literal&quot;</span><span class="s0">) {</span>
                    <span class="s0">args.key = from_moz(key);</span>
                <span class="s0">}</span>
                <span class="s1">return new </span><span class="s0">AST_ObjectKeyVal(args);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">args.key === </span><span class="s2">&quot;string&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">args.key === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                <span class="s0">args.key = </span><span class="s1">new </span><span class="s0">AST_SymbolMethod({</span>
                    <span class="s0">name: args.key</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">args.value = </span><span class="s1">new </span><span class="s0">AST_Accessor(args.value);</span>
            <span class="s1">if </span><span class="s0">(M.kind == </span><span class="s2">&quot;get&quot;</span><span class="s0">) </span><span class="s1">return new </span><span class="s0">AST_ObjectGetter(args);</span>
            <span class="s1">if </span><span class="s0">(M.kind == </span><span class="s2">&quot;set&quot;</span><span class="s0">) </span><span class="s1">return new </span><span class="s0">AST_ObjectSetter(args);</span>
            <span class="s1">if </span><span class="s0">(M.kind == </span><span class="s2">&quot;method&quot;</span><span class="s0">) {</span>
                <span class="s0">args.async = M.value.async;</span>
                <span class="s0">args.is_generator = M.value.generator;</span>
                <span class="s0">args.quote = M.computed ? </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot; </span><span class="s0">: </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">return new </span><span class="s0">AST_ConciseMethod(args);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>

        <span class="s0">MethodDefinition: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s0">const is_private = M.key.type === </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">;</span>
            <span class="s0">const key = M.computed ? from_moz(M.key) : </span><span class="s1">new </span><span class="s0">AST_SymbolMethod({ name: M.key.name || M.key.value });</span>

            <span class="s1">var </span><span class="s0">args = {</span>
                <span class="s0">start    : my_start_token(M),</span>
                <span class="s0">end      : my_end_token(M),</span>
                <span class="s0">key,</span>
                <span class="s0">value    : from_moz(M.value),</span>
                <span class="s0">static   : M.static,</span>
            <span class="s0">};</span>
            <span class="s1">if </span><span class="s0">(M.kind == </span><span class="s2">&quot;get&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">(is_private ? AST_PrivateGetter : AST_ObjectGetter)(args);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(M.kind == </span><span class="s2">&quot;set&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">(is_private ? AST_PrivateSetter : AST_ObjectSetter)(args);</span>
            <span class="s0">}</span>
            <span class="s0">args.is_generator = M.value.generator;</span>
            <span class="s0">args.async = M.value.async;</span>
            <span class="s1">return new </span><span class="s0">(is_private ? AST_PrivateMethod : AST_ConciseMethod)(args);</span>
        <span class="s0">},</span>

        <span class="s0">FieldDefinition: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s0">let key;</span>
            <span class="s1">if </span><span class="s0">(M.computed) {</span>
                <span class="s0">key = from_moz(M.key);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(M.key.type !== </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">) </span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Non-Identifier key in FieldDefinition&quot;</span><span class="s0">);</span>
                <span class="s0">key = from_moz(M.key);</span>
            <span class="s0">}</span>
            <span class="s1">return new </span><span class="s0">AST_ClassProperty({</span>
                <span class="s0">start    : my_start_token(M),</span>
                <span class="s0">end      : my_end_token(M),</span>
                <span class="s0">key,</span>
                <span class="s0">value    : from_moz(M.value),</span>
                <span class="s0">static   : M.static,</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">PropertyDefinition: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s0">let key;</span>
            <span class="s1">if </span><span class="s0">(M.computed) {</span>
                <span class="s0">key = from_moz(M.key);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(M.key.type === </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">AST_ClassPrivateProperty({</span>
                    <span class="s0">start    : my_start_token(M),</span>
                    <span class="s0">end      : my_end_token(M),</span>
                    <span class="s0">key      : from_moz(M.key),</span>
                    <span class="s0">value    : from_moz(M.value),</span>
                    <span class="s0">static   : M.static,</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(M.key.type !== </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">) {</span>
                    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Non-Identifier key in PropertyDefinition&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">key = from_moz(M.key);</span>
            <span class="s0">}</span>

            <span class="s1">return new </span><span class="s0">AST_ClassProperty({</span>
                <span class="s0">start    : my_start_token(M),</span>
                <span class="s0">end      : my_end_token(M),</span>
                <span class="s0">key,</span>
                <span class="s0">value    : from_moz(M.value),</span>
                <span class="s0">static   : M.static,</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">PrivateIdentifier: </span><span class="s1">function </span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_SymbolPrivateProperty({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">name: M.name</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">StaticBlock: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_ClassStaticBlock({</span>
                <span class="s0">start : my_start_token(M),</span>
                <span class="s0">end   : my_end_token(M),</span>
                <span class="s0">body  : M.body.map(from_moz),</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ArrayExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Array({</span>
                <span class="s0">start    : my_start_token(M),</span>
                <span class="s0">end      : my_end_token(M),</span>
                <span class="s0">elements : M.elements.map(</span><span class="s1">function</span><span class="s0">(elem) {</span>
                    <span class="s1">return </span><span class="s0">elem === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">new </span><span class="s0">AST_Hole() : from_moz(elem);</span>
                <span class="s0">})</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ObjectExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Object({</span>
                <span class="s0">start      : my_start_token(M),</span>
                <span class="s0">end        : my_end_token(M),</span>
                <span class="s0">properties : M.properties.map(</span><span class="s1">function</span><span class="s0">(prop) {</span>
                    <span class="s1">if </span><span class="s0">(prop.type === </span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">) {</span>
                        <span class="s1">return </span><span class="s0">from_moz(prop);</span>
                    <span class="s0">}</span>
                    <span class="s0">prop.type = </span><span class="s2">&quot;Property&quot;</span><span class="s0">;</span>
                    <span class="s1">return </span><span class="s0">from_moz(prop);</span>
                <span class="s0">})</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">SequenceExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Sequence({</span>
                <span class="s0">start      : my_start_token(M),</span>
                <span class="s0">end        : my_end_token(M),</span>
                <span class="s0">expressions: M.expressions.map(from_moz)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">MemberExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">if </span><span class="s0">(M.property.type === </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">AST_DotHash({</span>
                    <span class="s0">start      : my_start_token(M),</span>
                    <span class="s0">end        : my_end_token(M),</span>
                    <span class="s0">property   : M.property.name,</span>
                    <span class="s0">expression : from_moz(M.object),</span>
                    <span class="s0">optional   : M.optional || </span><span class="s1">false</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return new </span><span class="s0">(M.computed ? AST_Sub : AST_Dot)({</span>
                <span class="s0">start      : my_start_token(M),</span>
                <span class="s0">end        : my_end_token(M),</span>
                <span class="s0">property   : M.computed ? from_moz(M.property) : M.property.name,</span>
                <span class="s0">expression : from_moz(M.object),</span>
                <span class="s0">optional   : M.optional || </span><span class="s1">false</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ChainExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Chain({</span>
                <span class="s0">start      : my_start_token(M),</span>
                <span class="s0">end        : my_end_token(M),</span>
                <span class="s0">expression : from_moz(M.expression)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">SwitchCase: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">(M.test ? AST_Case : AST_Default)({</span>
                <span class="s0">start      : my_start_token(M),</span>
                <span class="s0">end        : my_end_token(M),</span>
                <span class="s0">expression : from_moz(M.test),</span>
                <span class="s0">body       : M.consequent.map(from_moz)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">VariableDeclaration: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">(M.kind === </span><span class="s2">&quot;const&quot; </span><span class="s0">? AST_Const :</span>
                        <span class="s0">M.kind === </span><span class="s2">&quot;let&quot; </span><span class="s0">? AST_Let : AST_Var)({</span>
                <span class="s0">start       : my_start_token(M),</span>
                <span class="s0">end         : my_end_token(M),</span>
                <span class="s0">definitions : M.declarations.map(from_moz)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ImportDeclaration: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">var </span><span class="s0">imported_name = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">imported_names = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">M.specifiers.forEach(</span><span class="s1">function </span><span class="s0">(specifier) {</span>
                <span class="s1">if </span><span class="s0">(specifier.type === </span><span class="s2">&quot;ImportSpecifier&quot; </span><span class="s0">|| specifier.type === </span><span class="s2">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(!imported_names) { imported_names = []; }</span>
                    <span class="s0">imported_names.push(from_moz(specifier));</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(specifier.type === </span><span class="s2">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">) {</span>
                    <span class="s0">imported_name = from_moz(specifier);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s1">return new </span><span class="s0">AST_Import({</span>
                <span class="s0">start       : my_start_token(M),</span>
                <span class="s0">end         : my_end_token(M),</span>
                <span class="s0">imported_name: imported_name,</span>
                <span class="s0">imported_names : imported_names,</span>
                <span class="s0">module_name : from_moz(M.source),</span>
                <span class="s0">assert_clause: assert_clause_from_moz(M.assertions)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ImportSpecifier: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_NameMapping({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">foreign_name: from_moz(M.imported),</span>
                <span class="s0">name: from_moz(M.local)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ImportDefaultSpecifier: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return </span><span class="s0">from_moz(M.local);</span>
        <span class="s0">},</span>

        <span class="s0">ImportNamespaceSpecifier: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_NameMapping({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">foreign_name: </span><span class="s1">new </span><span class="s0">AST_SymbolImportForeign({ name: </span><span class="s2">&quot;*&quot; </span><span class="s0">}),</span>
                <span class="s0">name: from_moz(M.local)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ExportAllDeclaration: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">var </span><span class="s0">foreign_name = M.exported == </span><span class="s1">null </span><span class="s0">? </span>
                <span class="s1">new </span><span class="s0">AST_SymbolExportForeign({ name: </span><span class="s2">&quot;*&quot; </span><span class="s0">}) :</span>
                <span class="s0">from_moz(M.exported);</span>
            <span class="s1">return new </span><span class="s0">AST_Export({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">exported_names: [</span>
                    <span class="s1">new </span><span class="s0">AST_NameMapping({</span>
                        <span class="s0">name: </span><span class="s1">new </span><span class="s0">AST_SymbolExportForeign({ name: </span><span class="s2">&quot;*&quot; </span><span class="s0">}),</span>
                        <span class="s0">foreign_name: foreign_name</span>
                    <span class="s0">})</span>
                <span class="s0">],</span>
                <span class="s0">module_name: from_moz(M.source),</span>
                <span class="s0">assert_clause: assert_clause_from_moz(M.assertions)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ExportNamedDeclaration: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Export({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">exported_definition: from_moz(M.declaration),</span>
                <span class="s0">exported_names: M.specifiers &amp;&amp; M.specifiers.length ? M.specifiers.map(</span><span class="s1">function </span><span class="s0">(specifier) {</span>
                    <span class="s1">return </span><span class="s0">from_moz(specifier);</span>
                <span class="s0">}) : </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">module_name: from_moz(M.source),</span>
                <span class="s0">assert_clause: assert_clause_from_moz(M.assertions)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ExportDefaultDeclaration: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Export({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">exported_value: from_moz(M.declaration),</span>
                <span class="s0">is_default: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ExportSpecifier: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_NameMapping({</span>
                <span class="s0">foreign_name: from_moz(M.exported),</span>
                <span class="s0">name: from_moz(M.local)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">Literal: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">var </span><span class="s0">val = M.value, args = {</span>
                <span class="s0">start  : my_start_token(M),</span>
                <span class="s0">end    : my_end_token(M)</span>
            <span class="s0">};</span>
            <span class="s1">var </span><span class="s0">rx = M.regex;</span>
            <span class="s1">if </span><span class="s0">(rx &amp;&amp; rx.pattern) {</span>
                <span class="s3">// RegExpLiteral as per ESTree AST spec</span>
                <span class="s0">args.value = {</span>
                    <span class="s0">source: rx.pattern,</span>
                    <span class="s0">flags: rx.flags</span>
                <span class="s0">};</span>
                <span class="s1">return new </span><span class="s0">AST_RegExp(args);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(rx) {</span>
                <span class="s3">// support legacy RegExp</span>
                <span class="s0">const rx_source = M.raw || val;</span>
                <span class="s0">const match = rx_source.match(/^\/(.*)\/(\w*)$/);</span>
                <span class="s1">if </span><span class="s0">(!match) </span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Invalid regex source &quot; </span><span class="s0">+ rx_source);</span>
                <span class="s0">const [_, source, flags] = match;</span>
                <span class="s0">args.value = { source, flags };</span>
                <span class="s1">return new </span><span class="s0">AST_RegExp(args);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(val === </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return new </span><span class="s0">AST_Null(args);</span>
            <span class="s1">switch </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">val) {</span>
              <span class="s1">case </span><span class="s2">&quot;string&quot;</span><span class="s0">:</span>
                <span class="s0">args.quote = </span><span class="s2">&quot;</span><span class="s5">\&quot;</span><span class="s2">&quot;</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - </span><span class="s4">2</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">(p.type == </span><span class="s2">&quot;ImportSpecifier&quot;</span><span class="s0">) {</span>
                    <span class="s0">args.name = val;</span>
                    <span class="s1">return new </span><span class="s0">AST_SymbolImportForeign(args);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(p.type == </span><span class="s2">&quot;ExportSpecifier&quot;</span><span class="s0">) {</span>
                    <span class="s0">args.name = val;</span>
                    <span class="s1">if </span><span class="s0">(M == p.exported) {</span>
                        <span class="s1">return new </span><span class="s0">AST_SymbolExportForeign(args);</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">return new </span><span class="s0">AST_SymbolExport(args);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(p.type == </span><span class="s2">&quot;ExportAllDeclaration&quot; </span><span class="s0">&amp;&amp; M == p.exported) {</span>
                    <span class="s0">args.name = val;</span>
                    <span class="s1">return new </span><span class="s0">AST_SymbolExportForeign(args);</span>
                <span class="s0">}</span>
                <span class="s0">args.value = val;</span>
                <span class="s1">return new </span><span class="s0">AST_String(args);</span>
              <span class="s1">case </span><span class="s2">&quot;number&quot;</span><span class="s0">:</span>
                <span class="s0">args.value = val;</span>
                <span class="s0">args.raw = M.raw || val.toString();</span>
                <span class="s1">return new </span><span class="s0">AST_Number(args);</span>
              <span class="s1">case </span><span class="s2">&quot;boolean&quot;</span><span class="s0">:</span>
                <span class="s1">return new </span><span class="s0">(val ? AST_True : AST_False)(args);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>

        <span class="s0">MetaProperty: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">if </span><span class="s0">(M.meta.name === </span><span class="s2">&quot;new&quot; </span><span class="s0">&amp;&amp; M.property.name === </span><span class="s2">&quot;target&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">AST_NewTarget({</span>
                    <span class="s0">start: my_start_token(M),</span>
                    <span class="s0">end: my_end_token(M)</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(M.meta.name === </span><span class="s2">&quot;import&quot; </span><span class="s0">&amp;&amp; M.property.name === </span><span class="s2">&quot;meta&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">AST_ImportMeta({</span>
                    <span class="s0">start: my_start_token(M),</span>
                    <span class="s0">end: my_end_token(M)</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">},</span>

        <span class="s0">Identifier: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">var </span><span class="s0">p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - </span><span class="s4">2</span><span class="s0">];</span>
            <span class="s1">return new </span><span class="s0">(  p.type == </span><span class="s2">&quot;LabeledStatement&quot; </span><span class="s0">? AST_Label</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;VariableDeclarator&quot; </span><span class="s0">&amp;&amp; p.id === M ? (p.kind == </span><span class="s2">&quot;const&quot; </span><span class="s0">? AST_SymbolConst : p.kind == </span><span class="s2">&quot;let&quot; </span><span class="s0">? AST_SymbolLet : AST_SymbolVar)</span>
                        <span class="s0">: /Import.*Specifier/.test(p.type) ? (p.local === M ? AST_SymbolImport : AST_SymbolImportForeign)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;ExportSpecifier&quot; </span><span class="s0">? (p.local === M ? AST_SymbolExport : AST_SymbolExportForeign)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;FunctionExpression&quot; </span><span class="s0">? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;FunctionDeclaration&quot; </span><span class="s0">? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;ArrowFunctionExpression&quot; </span><span class="s0">? (p.params.includes(M)) ? AST_SymbolFunarg : AST_SymbolRef</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;ClassExpression&quot; </span><span class="s0">? (p.id === M ? AST_SymbolClass : AST_SymbolRef)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;Property&quot; </span><span class="s0">? (p.key === M &amp;&amp; p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;PropertyDefinition&quot; </span><span class="s0">|| p.type === </span><span class="s2">&quot;FieldDefinition&quot; </span><span class="s0">? (p.key === M &amp;&amp; p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;ClassDeclaration&quot; </span><span class="s0">? (p.id === M ? AST_SymbolDefClass : AST_SymbolRef)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;MethodDefinition&quot; </span><span class="s0">? (p.computed ? AST_SymbolRef : AST_SymbolMethod)</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;CatchClause&quot; </span><span class="s0">? AST_SymbolCatch</span>
                        <span class="s0">: p.type == </span><span class="s2">&quot;BreakStatement&quot; </span><span class="s0">|| p.type == </span><span class="s2">&quot;ContinueStatement&quot; </span><span class="s0">? AST_LabelRef</span>
                        <span class="s0">: AST_SymbolRef)({</span>
                            <span class="s0">start : my_start_token(M),</span>
                            <span class="s0">end   : my_end_token(M),</span>
                            <span class="s0">name  : M.name</span>
                        <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">BigIntLiteral(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_BigInt({</span>
                <span class="s0">start : my_start_token(M),</span>
                <span class="s0">end   : my_end_token(M),</span>
                <span class="s0">value : M.value</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">EmptyStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_EmptyStatement({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">BlockStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_BlockStatement({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">body: M.body.map(from_moz)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">IfStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_If({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">condition: from_moz(M.test),</span>
                <span class="s0">body: from_moz(M.consequent),</span>
                <span class="s0">alternative: from_moz(M.alternate)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">LabeledStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_LabeledStatement({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">label: from_moz(M.label),</span>
                <span class="s0">body: from_moz(M.body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">BreakStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Break({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">label: from_moz(M.label)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ContinueStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Continue({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">label: from_moz(M.label)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">WithStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_With({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.object),</span>
                <span class="s0">body: from_moz(M.body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">SwitchStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Switch({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.discriminant),</span>
                <span class="s0">body: M.cases.map(from_moz)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ReturnStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Return({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">value: from_moz(M.argument)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ThrowStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Throw({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">value: from_moz(M.argument)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">WhileStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_While({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">condition: from_moz(M.test),</span>
                <span class="s0">body: from_moz(M.body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">DoWhileStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Do({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">condition: from_moz(M.test),</span>
                <span class="s0">body: from_moz(M.body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ForStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_For({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">init: from_moz(M.init),</span>
                <span class="s0">condition: from_moz(M.test),</span>
                <span class="s0">step: from_moz(M.update),</span>
                <span class="s0">body: from_moz(M.body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ForInStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_ForIn({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">init: from_moz(M.left),</span>
                <span class="s0">object: from_moz(M.right),</span>
                <span class="s0">body: from_moz(M.body)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ForOfStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_ForOf({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">init: from_moz(M.left),</span>
                <span class="s0">object: from_moz(M.right),</span>
                <span class="s0">body: from_moz(M.body),</span>
                <span class="s0">await: M.await</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">AwaitExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Await({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.argument)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">YieldExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Yield({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.argument),</span>
                <span class="s0">is_star: M.delegate</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">DebuggerStatement: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Debugger({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">VariableDeclarator: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_VarDef({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">name: from_moz(M.id),</span>
                <span class="s0">value: from_moz(M.init)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">CatchClause: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Catch({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">argname: from_moz(M.param),</span>
                <span class="s0">body: from_moz(M.body).body</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ThisExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_This({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">Super: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Super({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">BinaryExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">if </span><span class="s0">(M.left.type === </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">) {</span>
                <span class="s1">return new </span><span class="s0">AST_PrivateIn({</span>
                    <span class="s0">start: my_start_token(M),</span>
                    <span class="s0">end: my_end_token(M),</span>
                    <span class="s0">key: </span><span class="s1">new </span><span class="s0">AST_SymbolPrivateProperty({</span>
                        <span class="s0">start: my_start_token(M.left),</span>
                        <span class="s0">end: my_end_token(M.left),</span>
                        <span class="s0">name: M.left.name</span>
                    <span class="s0">}),</span>
                    <span class="s0">value: from_moz(M.right),</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return new </span><span class="s0">AST_Binary({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">operator: M.operator,</span>
                <span class="s0">left: from_moz(M.left),</span>
                <span class="s0">right: from_moz(M.right)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">LogicalExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Binary({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">operator: M.operator,</span>
                <span class="s0">left: from_moz(M.left),</span>
                <span class="s0">right: from_moz(M.right)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">AssignmentExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Assign({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">operator: M.operator,</span>
                <span class="s0">left: from_moz(M.left),</span>
                <span class="s0">right: from_moz(M.right)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">ConditionalExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Conditional({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">condition: from_moz(M.test),</span>
                <span class="s0">consequent: from_moz(M.consequent),</span>
                <span class="s0">alternative: from_moz(M.alternate)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">NewExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_New({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.callee),</span>
                <span class="s0">args: M.arguments.map(from_moz)</span>
            <span class="s0">});</span>
        <span class="s0">},</span>

        <span class="s0">CallExpression: </span><span class="s1">function</span><span class="s0">(M) {</span>
            <span class="s1">return new </span><span class="s0">AST_Call({</span>
                <span class="s0">start: my_start_token(M),</span>
                <span class="s0">end: my_end_token(M),</span>
                <span class="s0">expression: from_moz(M.callee),</span>
                <span class="s0">optional: M.optional,</span>
                <span class="s0">args: M.arguments.map(from_moz)</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s0">MOZ_TO_ME.UpdateExpression =</span>
    <span class="s0">MOZ_TO_ME.UnaryExpression = </span><span class="s1">function </span><span class="s0">To_Moz_Unary(M) {</span>
        <span class="s1">var </span><span class="s0">prefix = </span><span class="s2">&quot;prefix&quot; </span><span class="s1">in </span><span class="s0">M ? M.prefix</span>
            <span class="s0">: M.type == </span><span class="s2">&quot;UnaryExpression&quot; </span><span class="s0">? </span><span class="s1">true </span><span class="s0">: </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">return new </span><span class="s0">(prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({</span>
            <span class="s0">start      : my_start_token(M),</span>
            <span class="s0">end        : my_end_token(M),</span>
            <span class="s0">operator   : M.operator,</span>
            <span class="s0">expression : from_moz(M.argument)</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s0">MOZ_TO_ME.ClassDeclaration =</span>
    <span class="s0">MOZ_TO_ME.ClassExpression = </span><span class="s1">function </span><span class="s0">From_Moz_Class(M) {</span>
        <span class="s1">return new </span><span class="s0">(M.type === </span><span class="s2">&quot;ClassDeclaration&quot; </span><span class="s0">? AST_DefClass : AST_ClassExpression)({</span>
            <span class="s0">start    : my_start_token(M),</span>
            <span class="s0">end      : my_end_token(M),</span>
            <span class="s0">name     : from_moz(M.id),</span>
            <span class="s0">extends  : from_moz(M.superClass),</span>
            <span class="s0">properties: M.body.body.map(from_moz)</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s0">def_to_moz(AST_EmptyStatement, </span><span class="s1">function </span><span class="s0">To_Moz_EmptyStatement() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;EmptyStatement&quot;</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_BlockStatement, </span><span class="s1">function </span><span class="s0">To_Moz_BlockStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">,</span>
            <span class="s0">body: M.body.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_If, </span><span class="s1">function </span><span class="s0">To_Moz_IfStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;IfStatement&quot;</span><span class="s0">,</span>
            <span class="s0">test: to_moz(M.condition),</span>
            <span class="s0">consequent: to_moz(M.body),</span>
            <span class="s0">alternate: to_moz(M.alternative)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_LabeledStatement, </span><span class="s1">function </span><span class="s0">To_Moz_LabeledStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;LabeledStatement&quot;</span><span class="s0">,</span>
            <span class="s0">label: to_moz(M.label),</span>
            <span class="s0">body: to_moz(M.body)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Break, </span><span class="s1">function </span><span class="s0">To_Moz_BreakStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;BreakStatement&quot;</span><span class="s0">,</span>
            <span class="s0">label: to_moz(M.label)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Continue, </span><span class="s1">function </span><span class="s0">To_Moz_ContinueStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ContinueStatement&quot;</span><span class="s0">,</span>
            <span class="s0">label: to_moz(M.label)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_With, </span><span class="s1">function </span><span class="s0">To_Moz_WithStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;WithStatement&quot;</span><span class="s0">,</span>
            <span class="s0">object: to_moz(M.expression),</span>
            <span class="s0">body: to_moz(M.body)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Switch, </span><span class="s1">function </span><span class="s0">To_Moz_SwitchStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;SwitchStatement&quot;</span><span class="s0">,</span>
            <span class="s0">discriminant: to_moz(M.expression),</span>
            <span class="s0">cases: M.body.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Return, </span><span class="s1">function </span><span class="s0">To_Moz_ReturnStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ReturnStatement&quot;</span><span class="s0">,</span>
            <span class="s0">argument: to_moz(M.value)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Throw, </span><span class="s1">function </span><span class="s0">To_Moz_ThrowStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ThrowStatement&quot;</span><span class="s0">,</span>
            <span class="s0">argument: to_moz(M.value)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_While, </span><span class="s1">function </span><span class="s0">To_Moz_WhileStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;WhileStatement&quot;</span><span class="s0">,</span>
            <span class="s0">test: to_moz(M.condition),</span>
            <span class="s0">body: to_moz(M.body)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Do, </span><span class="s1">function </span><span class="s0">To_Moz_DoWhileStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;DoWhileStatement&quot;</span><span class="s0">,</span>
            <span class="s0">test: to_moz(M.condition),</span>
            <span class="s0">body: to_moz(M.body)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_For, </span><span class="s1">function </span><span class="s0">To_Moz_ForStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ForStatement&quot;</span><span class="s0">,</span>
            <span class="s0">init: to_moz(M.init),</span>
            <span class="s0">test: to_moz(M.condition),</span>
            <span class="s0">update: to_moz(M.step),</span>
            <span class="s0">body: to_moz(M.body)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_ForIn, </span><span class="s1">function </span><span class="s0">To_Moz_ForInStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ForInStatement&quot;</span><span class="s0">,</span>
            <span class="s0">left: to_moz(M.init),</span>
            <span class="s0">right: to_moz(M.object),</span>
            <span class="s0">body: to_moz(M.body)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_ForOf, </span><span class="s1">function </span><span class="s0">To_Moz_ForOfStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ForOfStatement&quot;</span><span class="s0">,</span>
            <span class="s0">left: to_moz(M.init),</span>
            <span class="s0">right: to_moz(M.object),</span>
            <span class="s0">body: to_moz(M.body),</span>
            <span class="s0">await: M.await</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Await, </span><span class="s1">function </span><span class="s0">To_Moz_AwaitExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;AwaitExpression&quot;</span><span class="s0">,</span>
            <span class="s0">argument: to_moz(M.expression)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Yield, </span><span class="s1">function </span><span class="s0">To_Moz_YieldExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;YieldExpression&quot;</span><span class="s0">,</span>
            <span class="s0">argument: to_moz(M.expression),</span>
            <span class="s0">delegate: M.is_star</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Debugger, </span><span class="s1">function </span><span class="s0">To_Moz_DebuggerStatement() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;DebuggerStatement&quot;</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_VarDef, </span><span class="s1">function </span><span class="s0">To_Moz_VariableDeclarator(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;VariableDeclarator&quot;</span><span class="s0">,</span>
            <span class="s0">id: to_moz(M.name),</span>
            <span class="s0">init: to_moz(M.value)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Catch, </span><span class="s1">function </span><span class="s0">To_Moz_CatchClause(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;CatchClause&quot;</span><span class="s0">,</span>
            <span class="s0">param: to_moz(M.argname),</span>
            <span class="s0">body: to_moz_block(M)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_This, </span><span class="s1">function </span><span class="s0">To_Moz_ThisExpression() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ThisExpression&quot;</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Super, </span><span class="s1">function </span><span class="s0">To_Moz_Super() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;Super&quot;</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Binary, </span><span class="s1">function </span><span class="s0">To_Moz_BinaryExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;BinaryExpression&quot;</span><span class="s0">,</span>
            <span class="s0">operator: M.operator,</span>
            <span class="s0">left: to_moz(M.left),</span>
            <span class="s0">right: to_moz(M.right)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Binary, </span><span class="s1">function </span><span class="s0">To_Moz_LogicalExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;LogicalExpression&quot;</span><span class="s0">,</span>
            <span class="s0">operator: M.operator,</span>
            <span class="s0">left: to_moz(M.left),</span>
            <span class="s0">right: to_moz(M.right)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Assign, </span><span class="s1">function </span><span class="s0">To_Moz_AssignmentExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;AssignmentExpression&quot;</span><span class="s0">,</span>
            <span class="s0">operator: M.operator,</span>
            <span class="s0">left: to_moz(M.left),</span>
            <span class="s0">right: to_moz(M.right)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Conditional, </span><span class="s1">function </span><span class="s0">To_Moz_ConditionalExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ConditionalExpression&quot;</span><span class="s0">,</span>
            <span class="s0">test: to_moz(M.condition),</span>
            <span class="s0">consequent: to_moz(M.consequent),</span>
            <span class="s0">alternate: to_moz(M.alternative)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_New, </span><span class="s1">function </span><span class="s0">To_Moz_NewExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;NewExpression&quot;</span><span class="s0">,</span>
            <span class="s0">callee: to_moz(M.expression),</span>
            <span class="s0">arguments: M.args.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
    <span class="s0">def_to_moz(AST_Call, </span><span class="s1">function </span><span class="s0">To_Moz_CallExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;CallExpression&quot;</span><span class="s0">,</span>
            <span class="s0">callee: to_moz(M.expression),</span>
            <span class="s0">optional: M.optional,</span>
            <span class="s0">arguments: M.args.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Toplevel, </span><span class="s1">function </span><span class="s0">To_Moz_Program(M) {</span>
        <span class="s1">return </span><span class="s0">to_moz_scope(</span><span class="s2">&quot;Program&quot;</span><span class="s0">, M);</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Expansion, </span><span class="s1">function </span><span class="s0">To_Moz_Spread(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: to_moz_in_destructuring() ? </span><span class="s2">&quot;RestElement&quot; </span><span class="s0">: </span><span class="s2">&quot;SpreadElement&quot;</span><span class="s0">,</span>
            <span class="s0">argument: to_moz(M.expression)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_PrefixedTemplateString, </span><span class="s1">function </span><span class="s0">To_Moz_TaggedTemplateExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;TaggedTemplateExpression&quot;</span><span class="s0">,</span>
            <span class="s0">tag: to_moz(M.prefix),</span>
            <span class="s0">quasi: to_moz(M.template_string)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_TemplateString, </span><span class="s1">function </span><span class="s0">To_Moz_TemplateLiteral(M) {</span>
        <span class="s1">var </span><span class="s0">quasis = [];</span>
        <span class="s1">var </span><span class="s0">expressions = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; M.segments.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(i % </span><span class="s4">2 </span><span class="s0">!== </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">expressions.push(to_moz(M.segments[i]));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">quasis.push({</span>
                    <span class="s0">type: </span><span class="s2">&quot;TemplateElement&quot;</span><span class="s0">,</span>
                    <span class="s0">value: {</span>
                        <span class="s0">raw: M.segments[i].raw,</span>
                        <span class="s0">cooked: M.segments[i].value</span>
                    <span class="s0">},</span>
                    <span class="s0">tail: i === M.segments.length - </span><span class="s4">1</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;TemplateLiteral&quot;</span><span class="s0">,</span>
            <span class="s0">quasis: quasis,</span>
            <span class="s0">expressions: expressions</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Defun, </span><span class="s1">function </span><span class="s0">To_Moz_FunctionDeclaration(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;FunctionDeclaration&quot;</span><span class="s0">,</span>
            <span class="s0">id: to_moz(M.name),</span>
            <span class="s0">params: M.argnames.map(to_moz),</span>
            <span class="s0">generator: M.is_generator,</span>
            <span class="s0">async: M.async,</span>
            <span class="s0">body: to_moz_scope(</span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">, M)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Function, </span><span class="s1">function </span><span class="s0">To_Moz_FunctionExpression(M, parent) {</span>
        <span class="s1">var </span><span class="s0">is_generator = parent.is_generator !== undefined ?</span>
            <span class="s0">parent.is_generator : M.is_generator;</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;FunctionExpression&quot;</span><span class="s0">,</span>
            <span class="s0">id: to_moz(M.name),</span>
            <span class="s0">params: M.argnames.map(to_moz),</span>
            <span class="s0">generator: is_generator,</span>
            <span class="s0">async: M.async,</span>
            <span class="s0">body: to_moz_scope(</span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">, M)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Arrow, </span><span class="s1">function </span><span class="s0">To_Moz_ArrowFunctionExpression(M) {</span>
        <span class="s1">var </span><span class="s0">body = {</span>
            <span class="s0">type: </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">,</span>
            <span class="s0">body: M.body.map(to_moz)</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ArrowFunctionExpression&quot;</span><span class="s0">,</span>
            <span class="s0">params: M.argnames.map(to_moz),</span>
            <span class="s0">async: M.async,</span>
            <span class="s0">body: body</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Destructuring, </span><span class="s1">function </span><span class="s0">To_Moz_ObjectPattern(M) {</span>
        <span class="s1">if </span><span class="s0">(M.is_array) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;ArrayPattern&quot;</span><span class="s0">,</span>
                <span class="s0">elements: M.names.map(to_moz)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ObjectPattern&quot;</span><span class="s0">,</span>
            <span class="s0">properties: M.names.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Directive, </span><span class="s1">function </span><span class="s0">To_Moz_Directive(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ExpressionStatement&quot;</span><span class="s0">,</span>
            <span class="s0">expression: {</span>
                <span class="s0">type: </span><span class="s2">&quot;Literal&quot;</span><span class="s0">,</span>
                <span class="s0">value: M.value,</span>
                <span class="s0">raw: M.print_to_string()</span>
            <span class="s0">},</span>
            <span class="s0">directive: M.value</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_SimpleStatement, </span><span class="s1">function </span><span class="s0">To_Moz_ExpressionStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ExpressionStatement&quot;</span><span class="s0">,</span>
            <span class="s0">expression: to_moz(M.body)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_SwitchBranch, </span><span class="s1">function </span><span class="s0">To_Moz_SwitchCase(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;SwitchCase&quot;</span><span class="s0">,</span>
            <span class="s0">test: to_moz(M.expression),</span>
            <span class="s0">consequent: M.body.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Try, </span><span class="s1">function </span><span class="s0">To_Moz_TryStatement(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;TryStatement&quot;</span><span class="s0">,</span>
            <span class="s0">block: to_moz_block(M.body),</span>
            <span class="s0">handler: to_moz(M.bcatch),</span>
            <span class="s0">guardedHandlers: [],</span>
            <span class="s0">finalizer: to_moz(M.bfinally)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Catch, </span><span class="s1">function </span><span class="s0">To_Moz_CatchClause(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;CatchClause&quot;</span><span class="s0">,</span>
            <span class="s0">param: to_moz(M.argname),</span>
            <span class="s0">guard: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">body: to_moz_block(M)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Definitions, </span><span class="s1">function </span><span class="s0">To_Moz_VariableDeclaration(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;VariableDeclaration&quot;</span><span class="s0">,</span>
            <span class="s0">kind:</span>
                <span class="s0">M </span><span class="s1">instanceof </span><span class="s0">AST_Const ? </span><span class="s2">&quot;const&quot; </span><span class="s0">:</span>
                <span class="s0">M </span><span class="s1">instanceof </span><span class="s0">AST_Let ? </span><span class="s2">&quot;let&quot; </span><span class="s0">: </span><span class="s2">&quot;var&quot;</span><span class="s0">,</span>
            <span class="s0">declarations: M.definitions.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">const assert_clause_to_moz = assert_clause =&gt; {</span>
        <span class="s0">const assertions = [];</span>
        <span class="s1">if </span><span class="s0">(assert_clause) {</span>
            <span class="s1">for </span><span class="s0">(const { key, value } of assert_clause.properties) {</span>
                <span class="s0">const key_moz = is_basic_identifier_string(key)</span>
                    <span class="s0">? { type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">, name: key }</span>
                    <span class="s0">: { type: </span><span class="s2">&quot;Literal&quot;</span><span class="s0">, value: key, raw: JSON.stringify(key) };</span>
                <span class="s0">assertions.push({</span>
                    <span class="s0">type: </span><span class="s2">&quot;ImportAttribute&quot;</span><span class="s0">,</span>
                    <span class="s0">key: key_moz,</span>
                    <span class="s0">value: to_moz(value)</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">assertions;</span>
    <span class="s0">};</span>

    <span class="s0">def_to_moz(AST_Export, </span><span class="s1">function </span><span class="s0">To_Moz_ExportDeclaration(M) {</span>
        <span class="s1">if </span><span class="s0">(M.exported_names) {</span>
            <span class="s1">var </span><span class="s0">first_exported = M.exported_names[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">var </span><span class="s0">first_exported_name = first_exported.name;</span>
            <span class="s1">if </span><span class="s0">(first_exported_name.name === </span><span class="s2">&quot;*&quot; </span><span class="s0">&amp;&amp; !first_exported_name.quote) {</span>
                <span class="s1">var </span><span class="s0">foreign_name = first_exported.foreign_name;</span>
                <span class="s1">var </span><span class="s0">exported = foreign_name.name === </span><span class="s2">&quot;*&quot; </span><span class="s0">&amp;&amp; !foreign_name.quote</span>
                    <span class="s0">? </span><span class="s1">null</span>
                    <span class="s0">: to_moz(foreign_name);</span>
                <span class="s1">return </span><span class="s0">{</span>
                    <span class="s0">type: </span><span class="s2">&quot;ExportAllDeclaration&quot;</span><span class="s0">,</span>
                    <span class="s0">source: to_moz(M.module_name),</span>
                    <span class="s0">exported: exported,</span>
                    <span class="s0">assertions: assert_clause_to_moz(M.assert_clause)</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,</span>
                <span class="s0">specifiers: M.exported_names.map(</span><span class="s1">function </span><span class="s0">(name_mapping) {</span>
                    <span class="s1">return </span><span class="s0">{</span>
                        <span class="s0">type: </span><span class="s2">&quot;ExportSpecifier&quot;</span><span class="s0">,</span>
                        <span class="s0">exported: to_moz(name_mapping.foreign_name),</span>
                        <span class="s0">local: to_moz(name_mapping.name)</span>
                    <span class="s0">};</span>
                <span class="s0">}),</span>
                <span class="s0">declaration: to_moz(M.exported_definition),</span>
                <span class="s0">source: to_moz(M.module_name),</span>
                <span class="s0">assertions: assert_clause_to_moz(M.assert_clause)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: M.is_default ? </span><span class="s2">&quot;ExportDefaultDeclaration&quot; </span><span class="s0">: </span><span class="s2">&quot;ExportNamedDeclaration&quot;</span><span class="s0">,</span>
            <span class="s0">declaration: to_moz(M.exported_value || M.exported_definition)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Import, </span><span class="s1">function </span><span class="s0">To_Moz_ImportDeclaration(M) {</span>
        <span class="s1">var </span><span class="s0">specifiers = [];</span>
        <span class="s1">if </span><span class="s0">(M.imported_name) {</span>
            <span class="s0">specifiers.push({</span>
                <span class="s0">type: </span><span class="s2">&quot;ImportDefaultSpecifier&quot;</span><span class="s0">,</span>
                <span class="s0">local: to_moz(M.imported_name)</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(M.imported_names) {</span>
            <span class="s1">var </span><span class="s0">first_imported_foreign_name = M.imported_names[</span><span class="s4">0</span><span class="s0">].foreign_name;</span>
            <span class="s1">if </span><span class="s0">(first_imported_foreign_name.name === </span><span class="s2">&quot;*&quot; </span><span class="s0">&amp;&amp; !first_imported_foreign_name.quote) {</span>
                <span class="s0">specifiers.push({</span>
                    <span class="s0">type: </span><span class="s2">&quot;ImportNamespaceSpecifier&quot;</span><span class="s0">,</span>
                    <span class="s0">local: to_moz(M.imported_names[</span><span class="s4">0</span><span class="s0">].name)</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">M.imported_names.forEach(</span><span class="s1">function</span><span class="s0">(name_mapping) {</span>
                    <span class="s0">specifiers.push({</span>
                        <span class="s0">type: </span><span class="s2">&quot;ImportSpecifier&quot;</span><span class="s0">,</span>
                        <span class="s0">local: to_moz(name_mapping.name),</span>
                        <span class="s0">imported: to_moz(name_mapping.foreign_name)</span>
                    <span class="s0">});</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ImportDeclaration&quot;</span><span class="s0">,</span>
            <span class="s0">specifiers: specifiers,</span>
            <span class="s0">source: to_moz(M.module_name),</span>
            <span class="s0">assertions: assert_clause_to_moz(M.assert_clause)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_ImportMeta, </span><span class="s1">function </span><span class="s0">To_Moz_MetaProperty() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;MetaProperty&quot;</span><span class="s0">,</span>
            <span class="s0">meta: {</span>
                <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
                <span class="s0">name: </span><span class="s2">&quot;import&quot;</span>
            <span class="s0">},</span>
            <span class="s0">property: {</span>
                <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
                <span class="s0">name: </span><span class="s2">&quot;meta&quot;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Sequence, </span><span class="s1">function </span><span class="s0">To_Moz_SequenceExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;SequenceExpression&quot;</span><span class="s0">,</span>
            <span class="s0">expressions: M.expressions.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_DotHash, </span><span class="s1">function </span><span class="s0">To_Moz_PrivateMemberExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">,</span>
            <span class="s0">object: to_moz(M.expression),</span>
            <span class="s0">computed: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">property: {</span>
                <span class="s0">type: </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">,</span>
                <span class="s0">name: M.property</span>
            <span class="s0">},</span>
            <span class="s0">optional: M.optional</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_PropAccess, </span><span class="s1">function </span><span class="s0">To_Moz_MemberExpression(M) {</span>
        <span class="s1">var </span><span class="s0">isComputed = M </span><span class="s1">instanceof </span><span class="s0">AST_Sub;</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;MemberExpression&quot;</span><span class="s0">,</span>
            <span class="s0">object: to_moz(M.expression),</span>
            <span class="s0">computed: isComputed,</span>
            <span class="s0">property: isComputed ? to_moz(M.property) : {type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">, name: M.property},</span>
            <span class="s0">optional: M.optional</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Chain, </span><span class="s1">function </span><span class="s0">To_Moz_ChainExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ChainExpression&quot;</span><span class="s0">,</span>
            <span class="s0">expression: to_moz(M.expression)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Unary, </span><span class="s1">function </span><span class="s0">To_Moz_Unary(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: M.operator == </span><span class="s2">&quot;++&quot; </span><span class="s0">|| M.operator == </span><span class="s2">&quot;--&quot; </span><span class="s0">? </span><span class="s2">&quot;UpdateExpression&quot; </span><span class="s0">: </span><span class="s2">&quot;UnaryExpression&quot;</span><span class="s0">,</span>
            <span class="s0">operator: M.operator,</span>
            <span class="s0">prefix: M </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix,</span>
            <span class="s0">argument: to_moz(M.expression)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Binary, </span><span class="s1">function </span><span class="s0">To_Moz_BinaryExpression(M) {</span>
        <span class="s1">if </span><span class="s0">(M.operator == </span><span class="s2">&quot;=&quot; </span><span class="s0">&amp;&amp; to_moz_in_destructuring()) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;AssignmentPattern&quot;</span><span class="s0">,</span>
                <span class="s0">left: to_moz(M.left),</span>
                <span class="s0">right: to_moz(M.right)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>

        <span class="s0">const type = M.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s0">|| M.operator == </span><span class="s2">&quot;||&quot; </span><span class="s0">|| M.operator === </span><span class="s2">&quot;??&quot;</span>
            <span class="s0">? </span><span class="s2">&quot;LogicalExpression&quot;</span>
            <span class="s0">: </span><span class="s2">&quot;BinaryExpression&quot;</span><span class="s0">;</span>

        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type,</span>
            <span class="s0">left: to_moz(M.left),</span>
            <span class="s0">operator: M.operator,</span>
            <span class="s0">right: to_moz(M.right)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_PrivateIn, </span><span class="s1">function </span><span class="s0">To_Moz_BinaryExpression_PrivateIn(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;BinaryExpression&quot;</span><span class="s0">,</span>
            <span class="s0">left: { type: </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">, name: M.key.name },</span>
            <span class="s0">operator: </span><span class="s2">&quot;in&quot;</span><span class="s0">,</span>
            <span class="s0">right: to_moz(M.value),</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Array, </span><span class="s1">function </span><span class="s0">To_Moz_ArrayExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ArrayExpression&quot;</span><span class="s0">,</span>
            <span class="s0">elements: M.elements.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Object, </span><span class="s1">function </span><span class="s0">To_Moz_ObjectExpression(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;ObjectExpression&quot;</span><span class="s0">,</span>
            <span class="s0">properties: M.properties.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_ObjectProperty, </span><span class="s1">function </span><span class="s0">To_Moz_Property(M, parent) {</span>
        <span class="s1">var </span><span class="s0">key = M.key </span><span class="s1">instanceof </span><span class="s0">AST_Node ? to_moz(M.key) : {</span>
            <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
            <span class="s0">value: M.key</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">M.key === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s0">key = {</span>
                <span class="s0">type: </span><span class="s2">&quot;Literal&quot;</span><span class="s0">,</span>
                <span class="s0">value: Number(M.key)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">M.key === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s0">key = {</span>
                <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
                <span class="s0">name: M.key</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">kind;</span>
        <span class="s1">var </span><span class="s0">string_or_num = </span><span class="s1">typeof </span><span class="s0">M.key === </span><span class="s2">&quot;string&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">M.key === </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">computed = string_or_num ? </span><span class="s1">false </span><span class="s0">: !(M.key </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) || M.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef;</span>
        <span class="s1">if </span><span class="s0">(M </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal) {</span>
            <span class="s0">kind = </span><span class="s2">&quot;init&quot;</span><span class="s0">;</span>
            <span class="s0">computed = !string_or_num;</span>
        <span class="s0">} </span><span class="s1">else</span>
        <span class="s1">if </span><span class="s0">(M </span><span class="s1">instanceof </span><span class="s0">AST_ObjectGetter) {</span>
            <span class="s0">kind = </span><span class="s2">&quot;get&quot;</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else</span>
        <span class="s1">if </span><span class="s0">(M </span><span class="s1">instanceof </span><span class="s0">AST_ObjectSetter) {</span>
            <span class="s0">kind = </span><span class="s2">&quot;set&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(M </span><span class="s1">instanceof </span><span class="s0">AST_PrivateGetter || M </span><span class="s1">instanceof </span><span class="s0">AST_PrivateSetter) {</span>
            <span class="s0">const kind = M </span><span class="s1">instanceof </span><span class="s0">AST_PrivateGetter ? </span><span class="s2">&quot;get&quot; </span><span class="s0">: </span><span class="s2">&quot;set&quot;</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;MethodDefinition&quot;</span><span class="s0">,</span>
                <span class="s0">computed: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">kind: kind,</span>
                <span class="s0">static: M.static,</span>
                <span class="s0">key: {</span>
                    <span class="s0">type: </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">,</span>
                    <span class="s0">name: M.key.name</span>
                <span class="s0">},</span>
                <span class="s0">value: to_moz(M.value)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(M </span><span class="s1">instanceof </span><span class="s0">AST_ClassPrivateProperty) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;PropertyDefinition&quot;</span><span class="s0">,</span>
                <span class="s0">key: {</span>
                    <span class="s0">type: </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">,</span>
                    <span class="s0">name: M.key.name</span>
                <span class="s0">},</span>
                <span class="s0">value: to_moz(M.value),</span>
                <span class="s0">computed: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">static: M.static</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(M </span><span class="s1">instanceof </span><span class="s0">AST_ClassProperty) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;PropertyDefinition&quot;</span><span class="s0">,</span>
                <span class="s0">key,</span>
                <span class="s0">value: to_moz(M.value),</span>
                <span class="s0">computed,</span>
                <span class="s0">static: M.static</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Class) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;MethodDefinition&quot;</span><span class="s0">,</span>
                <span class="s0">computed: computed,</span>
                <span class="s0">kind: kind,</span>
                <span class="s0">static: M.static,</span>
                <span class="s0">key: to_moz(M.key),</span>
                <span class="s0">value: to_moz(M.value)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;Property&quot;</span><span class="s0">,</span>
            <span class="s0">computed: computed,</span>
            <span class="s0">kind: kind,</span>
            <span class="s0">key: key,</span>
            <span class="s0">value: to_moz(M.value)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_ConciseMethod, </span><span class="s1">function </span><span class="s0">To_Moz_MethodDefinition(M, parent) {</span>
        <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Object) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;Property&quot;</span><span class="s0">,</span>
                <span class="s0">computed: !(M.key </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) || M.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef,</span>
                <span class="s0">kind: </span><span class="s2">&quot;init&quot;</span><span class="s0">,</span>
                <span class="s0">method: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">shorthand: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">key: to_moz(M.key),</span>
                <span class="s0">value: to_moz(M.value)</span>
            <span class="s0">};</span>
        <span class="s0">}</span>

        <span class="s0">const key = M </span><span class="s1">instanceof </span><span class="s0">AST_PrivateMethod</span>
            <span class="s0">? {</span>
                <span class="s0">type: </span><span class="s2">&quot;PrivateIdentifier&quot;</span><span class="s0">,</span>
                <span class="s0">name: M.key.name</span>
            <span class="s0">}</span>
            <span class="s0">: to_moz(M.key);</span>

        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;MethodDefinition&quot;</span><span class="s0">,</span>
            <span class="s0">kind: M.key === </span><span class="s2">&quot;constructor&quot; </span><span class="s0">? </span><span class="s2">&quot;constructor&quot; </span><span class="s0">: </span><span class="s2">&quot;method&quot;</span><span class="s0">,</span>
            <span class="s0">key,</span>
            <span class="s0">value: to_moz(M.value),</span>
            <span class="s0">computed: !(M.key </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) || M.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef,</span>
            <span class="s0">static: M.static,</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Class, </span><span class="s1">function </span><span class="s0">To_Moz_Class(M) {</span>
        <span class="s1">var </span><span class="s0">type = M </span><span class="s1">instanceof </span><span class="s0">AST_ClassExpression ? </span><span class="s2">&quot;ClassExpression&quot; </span><span class="s0">: </span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: type,</span>
            <span class="s0">superClass: to_moz(M.extends),</span>
            <span class="s0">id: M.name ? to_moz(M.name) : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">body: {</span>
                <span class="s0">type: </span><span class="s2">&quot;ClassBody&quot;</span><span class="s0">,</span>
                <span class="s0">body: M.properties.map(to_moz)</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_ClassStaticBlock, </span><span class="s1">function </span><span class="s0">To_Moz_StaticBlock(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;StaticBlock&quot;</span><span class="s0">,</span>
            <span class="s0">body: M.body.map(to_moz),</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_NewTarget, </span><span class="s1">function </span><span class="s0">To_Moz_MetaProperty() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;MetaProperty&quot;</span><span class="s0">,</span>
            <span class="s0">meta: {</span>
                <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
                <span class="s0">name: </span><span class="s2">&quot;new&quot;</span>
            <span class="s0">},</span>
            <span class="s0">property: {</span>
                <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
                <span class="s0">name: </span><span class="s2">&quot;target&quot;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Symbol, </span><span class="s1">function </span><span class="s0">To_Moz_Identifier(M, parent) {</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">(M </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod &amp;&amp; parent.quote) ||</span>
            <span class="s0">((</span>
                <span class="s0">M </span><span class="s1">instanceof </span><span class="s0">AST_SymbolImportForeign ||</span>
                <span class="s0">M </span><span class="s1">instanceof </span><span class="s0">AST_SymbolExportForeign ||</span>
                <span class="s0">M </span><span class="s1">instanceof </span><span class="s0">AST_SymbolExport</span>
                <span class="s0">) &amp;&amp; M.quote)</span>
         <span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">type: </span><span class="s2">&quot;Literal&quot;</span><span class="s0">,</span>
                <span class="s0">value: M.name</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">def = M.definition();</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
            <span class="s0">name: def ? def.mangled_name || def.name : M.name</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_RegExp, </span><span class="s1">function </span><span class="s0">To_Moz_RegExpLiteral(M) {</span>
        <span class="s0">const pattern = M.value.source;</span>
        <span class="s0">const flags = M.value.flags;</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;Literal&quot;</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">raw: M.print_to_string(),</span>
            <span class="s0">regex: { pattern, flags }</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Constant, </span><span class="s1">function </span><span class="s0">To_Moz_Literal(M) {</span>
        <span class="s1">var </span><span class="s0">value = M.value;</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;Literal&quot;</span><span class="s0">,</span>
            <span class="s0">value: value,</span>
            <span class="s0">raw: M.raw || M.print_to_string()</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_Atom, </span><span class="s1">function </span><span class="s0">To_Moz_Atom(M) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;Identifier&quot;</span><span class="s0">,</span>
            <span class="s0">name: String(M.value)</span>
        <span class="s0">};</span>
    <span class="s0">});</span>

    <span class="s0">def_to_moz(AST_BigInt, M =&gt; ({</span>
        <span class="s0">type: </span><span class="s2">&quot;BigIntLiteral&quot;</span><span class="s0">,</span>
        <span class="s0">value: M.value</span>
    <span class="s0">}));</span>

    <span class="s0">AST_Boolean.DEFMETHOD(</span><span class="s2">&quot;to_mozilla_ast&quot;</span><span class="s0">, AST_Constant.prototype.to_mozilla_ast);</span>
    <span class="s0">AST_Null.DEFMETHOD(</span><span class="s2">&quot;to_mozilla_ast&quot;</span><span class="s0">, AST_Constant.prototype.to_mozilla_ast);</span>
    <span class="s0">AST_Hole.DEFMETHOD(</span><span class="s2">&quot;to_mozilla_ast&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">To_Moz_ArrayHole() { </span><span class="s1">return null</span><span class="s0">; });</span>

    <span class="s0">AST_Block.DEFMETHOD(</span><span class="s2">&quot;to_mozilla_ast&quot;</span><span class="s0">, AST_BlockStatement.prototype.to_mozilla_ast);</span>
    <span class="s0">AST_Lambda.DEFMETHOD(</span><span class="s2">&quot;to_mozilla_ast&quot;</span><span class="s0">, AST_Function.prototype.to_mozilla_ast);</span>

    <span class="s3">/* -----[ tools ]----- */</span>

    <span class="s1">function </span><span class="s0">my_start_token(moznode) {</span>
        <span class="s1">var </span><span class="s0">loc = moznode.loc, start = loc &amp;&amp; loc.start;</span>
        <span class="s1">var </span><span class="s0">range = moznode.range;</span>
        <span class="s1">return new </span><span class="s0">AST_Token(</span>
            <span class="s2">&quot;&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;&quot;</span><span class="s0">,</span>
            <span class="s0">start &amp;&amp; start.line || </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">start &amp;&amp; start.column || </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">range ? range [</span><span class="s4">0</span><span class="s0">] : moznode.start,</span>
            <span class="s1">false</span><span class="s0">,</span>
            <span class="s0">[],</span>
            <span class="s0">[],</span>
            <span class="s0">loc &amp;&amp; loc.source,</span>
        <span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">my_end_token(moznode) {</span>
        <span class="s1">var </span><span class="s0">loc = moznode.loc, end = loc &amp;&amp; loc.end;</span>
        <span class="s1">var </span><span class="s0">range = moznode.range;</span>
        <span class="s1">return new </span><span class="s0">AST_Token(</span>
            <span class="s2">&quot;&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;&quot;</span><span class="s0">,</span>
            <span class="s0">end &amp;&amp; end.line || </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">end &amp;&amp; end.column || </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">range ? range [</span><span class="s4">0</span><span class="s0">] : moznode.end,</span>
            <span class="s1">false</span><span class="s0">,</span>
            <span class="s0">[],</span>
            <span class="s0">[],</span>
            <span class="s0">loc &amp;&amp; loc.source,</span>
        <span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">FROM_MOZ_STACK = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">from_moz(node) {</span>
        <span class="s0">FROM_MOZ_STACK.push(node);</span>
        <span class="s1">var </span><span class="s0">ret = node != </span><span class="s1">null </span><span class="s0">? MOZ_TO_ME[node.type](node) : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">FROM_MOZ_STACK.pop();</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s0">AST_Node.from_mozilla_ast = </span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">var </span><span class="s0">save_stack = FROM_MOZ_STACK;</span>
        <span class="s0">FROM_MOZ_STACK = [];</span>
        <span class="s1">var </span><span class="s0">ast = from_moz(node);</span>
        <span class="s0">FROM_MOZ_STACK = save_stack;</span>
        <span class="s1">return </span><span class="s0">ast;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">set_moz_loc(mynode, moznode) {</span>
        <span class="s1">var </span><span class="s0">start = mynode.start;</span>
        <span class="s1">var </span><span class="s0">end = mynode.end;</span>
        <span class="s1">if </span><span class="s0">(!(start &amp;&amp; end)) {</span>
            <span class="s1">return </span><span class="s0">moznode;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(start.pos != </span><span class="s1">null </span><span class="s0">&amp;&amp; end.endpos != </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">moznode.range = [start.pos, end.endpos];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(start.line) {</span>
            <span class="s0">moznode.loc = {</span>
                <span class="s0">start: {line: start.line, column: start.col},</span>
                <span class="s0">end: end.endline ? {line: end.endline, column: end.endcol} : </span><span class="s1">null</span>
            <span class="s0">};</span>
            <span class="s1">if </span><span class="s0">(start.file) {</span>
                <span class="s0">moznode.loc.source = start.file;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">moznode;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">def_to_moz(mytype, handler) {</span>
        <span class="s0">mytype.DEFMETHOD(</span><span class="s2">&quot;to_mozilla_ast&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(parent) {</span>
            <span class="s1">return </span><span class="s0">set_moz_loc(</span><span class="s1">this</span><span class="s0">, handler(</span><span class="s1">this</span><span class="s0">, parent));</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">TO_MOZ_STACK = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">to_moz(node) {</span>
        <span class="s1">if </span><span class="s0">(TO_MOZ_STACK === </span><span class="s1">null</span><span class="s0">) { TO_MOZ_STACK = []; }</span>
        <span class="s0">TO_MOZ_STACK.push(node);</span>
        <span class="s1">var </span><span class="s0">ast = node != </span><span class="s1">null </span><span class="s0">? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - </span><span class="s4">2</span><span class="s0">]) : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">TO_MOZ_STACK.pop();</span>
        <span class="s1">if </span><span class="s0">(TO_MOZ_STACK.length === </span><span class="s4">0</span><span class="s0">) { TO_MOZ_STACK = </span><span class="s1">null</span><span class="s0">; }</span>
        <span class="s1">return </span><span class="s0">ast;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">to_moz_in_destructuring() {</span>
        <span class="s1">var </span><span class="s0">i = TO_MOZ_STACK.length;</span>
        <span class="s1">while </span><span class="s0">(i--) {</span>
            <span class="s1">if </span><span class="s0">(TO_MOZ_STACK[i] </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">to_moz_block(node) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s0">,</span>
            <span class="s0">body: node.body.map(to_moz)</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">to_moz_scope(type, node) {</span>
        <span class="s1">var </span><span class="s0">body = node.body.map(to_moz);</span>
        <span class="s1">if </span><span class="s0">(node.body[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement &amp;&amp; node.body[</span><span class="s4">0</span><span class="s0">].body </span><span class="s1">instanceof </span><span class="s0">AST_String) {</span>
            <span class="s0">body.unshift(to_moz(</span><span class="s1">new </span><span class="s0">AST_EmptyStatement(node.body[</span><span class="s4">0</span><span class="s0">])));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: type,</span>
            <span class="s0">body: body</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
<span class="s0">})();</span>

<span class="s3">// return true if the node at the top of the stack (that means the</span>
<span class="s3">// innermost node in the current output) is lexically the first in</span>
<span class="s3">// a statement.</span>
<span class="s1">function </span><span class="s0">first_in_statement(stack) {</span>
    <span class="s0">let node = stack.parent(-</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">, p; p = stack.parent(i); i++) {</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Statement &amp;&amp; p.body === node)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">((p </span><span class="s1">instanceof </span><span class="s0">AST_Sequence &amp;&amp; p.expressions[</span><span class="s4">0</span><span class="s0">] === node) ||</span>
            <span class="s0">(p.TYPE === </span><span class="s2">&quot;Call&quot; </span><span class="s0">&amp;&amp; p.expression === node) ||</span>
            <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_PrefixedTemplateString &amp;&amp; p.prefix === node) ||</span>
            <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Dot &amp;&amp; p.expression === node) ||</span>
            <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Sub &amp;&amp; p.expression === node) ||</span>
            <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Chain &amp;&amp; p.expression === node) ||</span>
            <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Conditional &amp;&amp; p.condition === node) ||</span>
            <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; p.left === node) ||</span>
            <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPostfix &amp;&amp; p.expression === node)</span>
        <span class="s0">) {</span>
            <span class="s0">node = p;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">// Returns whether the leftmost item in the expression is an object</span>
<span class="s1">function </span><span class="s0">left_is_object(node) {</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Object) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) </span><span class="s1">return </span><span class="s0">left_is_object(node.expressions[</span><span class="s4">0</span><span class="s0">]);</span>
    <span class="s1">if </span><span class="s0">(node.TYPE === </span><span class="s2">&quot;Call&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">left_is_object(node.expression);</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_PrefixedTemplateString) </span><span class="s1">return </span><span class="s0">left_is_object(node.prefix);</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Dot || node </span><span class="s1">instanceof </span><span class="s0">AST_Sub) </span><span class="s1">return </span><span class="s0">left_is_object(node.expression);</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Chain) </span><span class="s1">return </span><span class="s0">left_is_object(node.expression);</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Conditional) </span><span class="s1">return </span><span class="s0">left_is_object(node.condition);</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Binary) </span><span class="s1">return </span><span class="s0">left_is_object(node.left);</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPostfix) </span><span class="s1">return </span><span class="s0">left_is_object(node.expression);</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s0">const EXPECT_DIRECTIVE = /^$|[;{][\s\n]*$/;</span>
<span class="s0">const CODE_LINE_BREAK = </span><span class="s4">10</span><span class="s0">;</span>
<span class="s0">const CODE_SPACE = </span><span class="s4">32</span><span class="s0">;</span>

<span class="s0">const r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/g;</span>

<span class="s1">function </span><span class="s0">is_some_comments(comment) {</span>
    <span class="s3">// multiline comment</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s0">(comment.type === </span><span class="s2">&quot;comment2&quot; </span><span class="s0">|| comment.type === </span><span class="s2">&quot;comment1&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; /@preserve|@copyright|@lic|@cc_on|^\**!/i.test(comment.value)</span>
    <span class="s0">);</span>
<span class="s0">}</span>

<span class="s0">class Rope {</span>
    <span class="s0">constructor() {</span>
        <span class="s1">this</span><span class="s0">.committed = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.current = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">append(str) {</span>
        <span class="s1">this</span><span class="s0">.current += str;</span>
    <span class="s0">}</span>

    <span class="s0">insertAt(char, index) {</span>
        <span class="s0">const { committed, current } = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(index &lt; committed.length) {</span>
            <span class="s1">this</span><span class="s0">.committed = committed.slice(</span><span class="s4">0</span><span class="s0">, index) + char + committed.slice(index);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(index === committed.length) {</span>
            <span class="s1">this</span><span class="s0">.committed += char;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">index -= committed.length;</span>
            <span class="s1">this</span><span class="s0">.committed += current.slice(</span><span class="s4">0</span><span class="s0">, index) + char;</span>
            <span class="s1">this</span><span class="s0">.current = current.slice(index);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">charAt(index) {</span>
        <span class="s0">const { committed } = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(index &lt; committed.length) </span><span class="s1">return </span><span class="s0">committed[index];</span>
        <span class="s1">return this</span><span class="s0">.current[index - committed.length];</span>
    <span class="s0">}</span>

    <span class="s0">curLength() {</span>
        <span class="s1">return this</span><span class="s0">.current.length;</span>
    <span class="s0">}</span>

    <span class="s0">length() {</span>
        <span class="s1">return this</span><span class="s0">.committed.length + </span><span class="s1">this</span><span class="s0">.current.length;</span>
    <span class="s0">}</span>

    <span class="s0">toString() {</span>
        <span class="s1">return this</span><span class="s0">.committed + </span><span class="s1">this</span><span class="s0">.current;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">OutputStream(options) {</span>

    <span class="s1">var </span><span class="s0">readonly = !options;</span>
    <span class="s0">options = defaults(options, {</span>
        <span class="s0">ascii_only           : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">beautify             : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">braces               : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">comments             : </span><span class="s2">&quot;some&quot;</span><span class="s0">,</span>
        <span class="s0">ecma                 : </span><span class="s4">5</span><span class="s0">,</span>
        <span class="s0">ie8                  : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">indent_level         : </span><span class="s4">4</span><span class="s0">,</span>
        <span class="s0">indent_start         : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">inline_script        : </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">keep_numbers         : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">keep_quoted_props    : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">max_line_len         : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">preamble             : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">preserve_annotations : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">quote_keys           : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">quote_style          : </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">safari10             : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">semicolons           : </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">shebang              : </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">shorthand            : undefined,</span>
        <span class="s0">source_map           : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">webkit               : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">width                : </span><span class="s4">80</span><span class="s0">,</span>
        <span class="s0">wrap_iife            : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">wrap_func_args       : </span><span class="s1">true</span><span class="s0">,</span>

        <span class="s0">_destroy_ast         : </span><span class="s1">false</span>
    <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(options.shorthand === undefined)</span>
        <span class="s0">options.shorthand = options.ecma &gt; </span><span class="s4">5</span><span class="s0">;</span>

    <span class="s3">// Convert comment option to RegExp if necessary and set up comments filter</span>
    <span class="s1">var </span><span class="s0">comment_filter = return_false; </span><span class="s3">// Default case, throw all comments away</span>
    <span class="s1">if </span><span class="s0">(options.comments) {</span>
        <span class="s0">let comments = options.comments;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options.comments === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {</span>
            <span class="s1">var </span><span class="s0">regex_pos = options.comments.lastIndexOf(</span><span class="s2">&quot;/&quot;</span><span class="s0">);</span>
            <span class="s0">comments = </span><span class="s1">new </span><span class="s0">RegExp(</span>
                <span class="s0">options.comments.substr(</span><span class="s4">1</span><span class="s0">, regex_pos - </span><span class="s4">1</span><span class="s0">),</span>
                <span class="s0">options.comments.substr(regex_pos + </span><span class="s4">1</span><span class="s0">)</span>
            <span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(comments </span><span class="s1">instanceof </span><span class="s0">RegExp) {</span>
            <span class="s0">comment_filter = </span><span class="s1">function</span><span class="s0">(comment) {</span>
                <span class="s1">return </span><span class="s0">comment.type != </span><span class="s2">&quot;comment5&quot; </span><span class="s0">&amp;&amp; comments.test(comment.value);</span>
            <span class="s0">};</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">comments === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s0">comment_filter = </span><span class="s1">function</span><span class="s0">(comment) {</span>
                <span class="s1">return </span><span class="s0">comment.type != </span><span class="s2">&quot;comment5&quot; </span><span class="s0">&amp;&amp; comments(</span><span class="s1">this</span><span class="s0">, comment);</span>
            <span class="s0">};</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(comments === </span><span class="s2">&quot;some&quot;</span><span class="s0">) {</span>
            <span class="s0">comment_filter = is_some_comments;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{ </span><span class="s3">// NOTE includes &quot;all&quot; option</span>
            <span class="s0">comment_filter = return_true;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">indentation = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">current_col = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">current_line = </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">current_pos = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">OUTPUT = </span><span class="s1">new </span><span class="s0">Rope();</span>
    <span class="s0">let printed_comments = </span><span class="s1">new </span><span class="s0">Set();</span>

    <span class="s1">var </span><span class="s0">to_utf8 = options.ascii_only ? </span><span class="s1">function</span><span class="s0">(str, identifier = </span><span class="s1">false</span><span class="s0">, regexp = </span><span class="s1">false</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(options.ecma &gt;= </span><span class="s4">2015 </span><span class="s0">&amp;&amp; !options.safari10 &amp;&amp; !regexp) {</span>
            <span class="s0">str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, </span><span class="s1">function</span><span class="s0">(ch) {</span>
                <span class="s1">var </span><span class="s0">code = get_full_char_code(ch, </span><span class="s4">0</span><span class="s0">).toString(</span><span class="s4">16</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u{&quot; </span><span class="s0">+ code + </span><span class="s2">&quot;}&quot;</span><span class="s0">;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">str.replace(/[\u0000-\u001f\u007f-\uffff]/g, </span><span class="s1">function</span><span class="s0">(ch) {</span>
            <span class="s1">var </span><span class="s0">code = ch.charCodeAt(</span><span class="s4">0</span><span class="s0">).toString(</span><span class="s4">16</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(code.length &lt;= </span><span class="s4">2 </span><span class="s0">&amp;&amp; !identifier) {</span>
                <span class="s1">while </span><span class="s0">(code.length &lt; </span><span class="s4">2</span><span class="s0">) code = </span><span class="s2">&quot;0&quot; </span><span class="s0">+ code;</span>
                <span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x&quot; </span><span class="s0">+ code;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">while </span><span class="s0">(code.length &lt; </span><span class="s4">4</span><span class="s0">) code = </span><span class="s2">&quot;0&quot; </span><span class="s0">+ code;</span>
                <span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u&quot; </span><span class="s0">+ code;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">} : </span><span class="s1">function</span><span class="s0">(str) {</span>
        <span class="s1">return </span><span class="s0">str.replace(/[\ud800-\udbff][\udc00-\udfff]|([\ud800-\udbff]|[\udc00-\udfff])/g, </span><span class="s1">function</span><span class="s0">(match, lone) {</span>
            <span class="s1">if </span><span class="s0">(lone) {</span>
                <span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u&quot; </span><span class="s0">+ lone.charCodeAt(</span><span class="s4">0</span><span class="s0">).toString(</span><span class="s4">16</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">match;</span>
        <span class="s0">});</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">make_string(str, quote) {</span>
        <span class="s1">var </span><span class="s0">dq = </span><span class="s4">0</span><span class="s0">, sq = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\</span><span class="s4">0</span><span class="s0">\ufeff]/g,</span>
          <span class="s1">function</span><span class="s0">(s, i) {</span>
            <span class="s1">switch </span><span class="s0">(s) {</span>
              <span class="s1">case </span><span class="s2">'&quot;'</span><span class="s0">: ++dq; </span><span class="s1">return </span><span class="s2">'&quot;'</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;'&quot;</span><span class="s0">: ++sq; </span><span class="s1">return </span><span class="s2">&quot;'&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\\\</span><span class="s2">&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">n&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\r</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">r&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\t</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">t&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\b</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">b&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\f</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">f&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\x</span><span class="s2">0B&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s0">options.ie8 ? </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x0B&quot; </span><span class="s0">: </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">v&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\u2028</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u2028&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\u2029</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">u2029&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\ufeff</span><span class="s2">&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">ufeff&quot;</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;</span><span class="s5">\0</span><span class="s2">&quot;</span><span class="s0">:</span>
                  <span class="s1">return </span><span class="s0">/[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">]/.test(get_full_char(str, i+</span><span class="s4">1</span><span class="s0">)) ? </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x00&quot; </span><span class="s0">: </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">0&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">s;</span>
        <span class="s0">});</span>
        <span class="s1">function </span><span class="s0">quote_single() {</span>
            <span class="s1">return </span><span class="s2">&quot;'&quot; </span><span class="s0">+ str.replace(/\x27/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">'&quot;</span><span class="s0">) + </span><span class="s2">&quot;'&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">function </span><span class="s0">quote_double() {</span>
            <span class="s1">return </span><span class="s2">'&quot;' </span><span class="s0">+ str.replace(/\x22/g, </span><span class="s2">'</span><span class="s5">\\</span><span class="s2">&quot;'</span><span class="s0">) + </span><span class="s2">'&quot;'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">function </span><span class="s0">quote_template() {</span>
            <span class="s1">return </span><span class="s2">&quot;`&quot; </span><span class="s0">+ str.replace(/`/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">`&quot;</span><span class="s0">) + </span><span class="s2">&quot;`&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">str = to_utf8(str);</span>
        <span class="s1">if </span><span class="s0">(quote === </span><span class="s2">&quot;`&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">quote_template();</span>
        <span class="s1">switch </span><span class="s0">(options.quote_style) {</span>
          <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">quote_single();</span>
          <span class="s1">case </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">quote_double();</span>
          <span class="s1">case </span><span class="s4">3</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">quote == </span><span class="s2">&quot;'&quot; </span><span class="s0">? quote_single() : quote_double();</span>
          <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">dq &gt; sq ? quote_single() : quote_double();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">encode_string(str, quote) {</span>
        <span class="s1">var </span><span class="s0">ret = make_string(str, quote);</span>
        <span class="s1">if </span><span class="s0">(options.inline_script) {</span>
            <span class="s0">ret = ret.replace(/&lt;\x2f(script)([&gt;\/\t\n\f\r ])/gi, </span><span class="s2">&quot;&lt;</span><span class="s5">\\</span><span class="s2">/$1$2&quot;</span><span class="s0">);</span>
            <span class="s0">ret = ret.replace(/\x3c!--/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">x3c!--&quot;</span><span class="s0">);</span>
            <span class="s0">ret = ret.replace(/--\x3e/g, </span><span class="s2">&quot;--</span><span class="s5">\\</span><span class="s2">x3e&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">make_name(name) {</span>
        <span class="s0">name = name.toString();</span>
        <span class="s0">name = to_utf8(name, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">name;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">make_indent(back) {</span>
        <span class="s1">return </span><span class="s2">&quot; &quot;</span><span class="s0">.repeat(options.indent_start + indentation - back * options.indent_level);</span>
    <span class="s0">}</span>

    <span class="s3">/* -----[ beautification/minification ]----- */</span>

    <span class="s1">var </span><span class="s0">has_parens = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">might_need_space = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">might_need_semicolon = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">might_add_newline = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">need_newline_indented = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">need_space = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">newline_insert = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">last = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">mapping_token, mapping_name, mappings = options.source_map &amp;&amp; [];</span>

    <span class="s1">var </span><span class="s0">do_add_mapping = mappings ? </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">mappings.forEach(</span><span class="s1">function</span><span class="s0">(mapping) {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">let { name, token } = mapping;</span>
                <span class="s1">if </span><span class="s0">(name !== </span><span class="s1">false</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(token.type == </span><span class="s2">&quot;name&quot; </span><span class="s0">|| token.type === </span><span class="s2">&quot;privatename&quot;</span><span class="s0">) {</span>
                        <span class="s0">name = token.value;</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(name </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) {</span>
                        <span class="s0">name = token.type === </span><span class="s2">&quot;string&quot; </span><span class="s0">? token.value : name.name;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">options.source_map.add(</span>
                    <span class="s0">mapping.token.file,</span>
                    <span class="s0">mapping.line, mapping.col,</span>
                    <span class="s0">mapping.token.line, mapping.token.col,</span>
                    <span class="s0">is_basic_identifier_string(name) ? name : undefined</span>
                <span class="s0">);</span>
            <span class="s0">} </span><span class="s1">catch</span><span class="s0">(ex) {</span>
                <span class="s3">// Ignore bad mapping</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s0">mappings = [];</span>
    <span class="s0">} : noop;</span>

    <span class="s1">var </span><span class="s0">ensure_line_len = options.max_line_len ? </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">if </span><span class="s0">(current_col &gt; options.max_line_len) {</span>
            <span class="s1">if </span><span class="s0">(might_add_newline) {</span>
                <span class="s0">OUTPUT.insertAt(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">, might_add_newline);</span>
                <span class="s0">const curLength = OUTPUT.curLength();</span>
                <span class="s1">if </span><span class="s0">(mappings) {</span>
                    <span class="s1">var </span><span class="s0">delta = curLength - current_col;</span>
                    <span class="s0">mappings.forEach(</span><span class="s1">function</span><span class="s0">(mapping) {</span>
                        <span class="s0">mapping.line++;</span>
                        <span class="s0">mapping.col += delta;</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s0">current_line++;</span>
                <span class="s0">current_pos++;</span>
                <span class="s0">current_col = curLength;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(might_add_newline) {</span>
            <span class="s0">might_add_newline = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">do_add_mapping();</span>
        <span class="s0">}</span>
    <span class="s0">} : noop;</span>

    <span class="s1">var </span><span class="s0">requireSemicolonChars = makePredicate(</span><span class="s2">&quot;( [ + * / - , . `&quot;</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">print(str) {</span>
        <span class="s0">str = String(str);</span>
        <span class="s1">var </span><span class="s0">ch = get_full_char(str, </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(need_newline_indented &amp;&amp; ch) {</span>
            <span class="s0">need_newline_indented = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(ch !== </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">) {</span>
                <span class="s0">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                <span class="s0">indent();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(need_space &amp;&amp; ch) {</span>
            <span class="s0">need_space = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!/[\s;})]/.test(ch)) {</span>
                <span class="s0">space();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">newline_insert = -</span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">prev = last.charAt(last.length - </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(might_need_semicolon) {</span>
            <span class="s0">might_need_semicolon = </span><span class="s1">false</span><span class="s0">;</span>

            <span class="s1">if </span><span class="s0">(prev === </span><span class="s2">&quot;:&quot; </span><span class="s0">&amp;&amp; ch === </span><span class="s2">&quot;}&quot; </span><span class="s0">|| (!ch || !</span><span class="s2">&quot;;}&quot;</span><span class="s0">.includes(ch)) &amp;&amp; prev !== </span><span class="s2">&quot;;&quot;</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(options.semicolons || requireSemicolonChars.has(ch)) {</span>
                    <span class="s0">OUTPUT.append(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
                    <span class="s0">current_col++;</span>
                    <span class="s0">current_pos++;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">ensure_line_len();</span>
                    <span class="s1">if </span><span class="s0">(current_col &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                        <span class="s0">OUTPUT.append(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                        <span class="s0">current_pos++;</span>
                        <span class="s0">current_line++;</span>
                        <span class="s0">current_col = </span><span class="s4">0</span><span class="s0">;</span>
                    <span class="s0">}</span>

                    <span class="s1">if </span><span class="s0">(/^\s+$/.test(str)) {</span>
                        <span class="s3">// reset the semicolon flag, since we didn't print one</span>
                        <span class="s3">// now and might still have to later</span>
                        <span class="s0">might_need_semicolon = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>

                <span class="s1">if </span><span class="s0">(!options.beautify)</span>
                    <span class="s0">might_need_space = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(might_need_space) {</span>
            <span class="s1">if </span><span class="s0">((is_identifier_char(prev)</span>
                    <span class="s0">&amp;&amp; (is_identifier_char(ch) || ch == </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">))</span>
                <span class="s0">|| (ch == </span><span class="s2">&quot;/&quot; </span><span class="s0">&amp;&amp; ch == prev)</span>
                <span class="s0">|| ((ch == </span><span class="s2">&quot;+&quot; </span><span class="s0">|| ch == </span><span class="s2">&quot;-&quot;</span><span class="s0">) &amp;&amp; ch == last)</span>
            <span class="s0">) {</span>
                <span class="s0">OUTPUT.append(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
                <span class="s0">current_col++;</span>
                <span class="s0">current_pos++;</span>
            <span class="s0">}</span>
            <span class="s0">might_need_space = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(mapping_token) {</span>
            <span class="s0">mappings.push({</span>
                <span class="s0">token: mapping_token,</span>
                <span class="s0">name: mapping_name,</span>
                <span class="s0">line: current_line,</span>
                <span class="s0">col: current_col</span>
            <span class="s0">});</span>
            <span class="s0">mapping_token = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!might_add_newline) do_add_mapping();</span>
        <span class="s0">}</span>

        <span class="s0">OUTPUT.append(str);</span>
        <span class="s0">has_parens = str[str.length - </span><span class="s4">1</span><span class="s0">] == </span><span class="s2">&quot;(&quot;</span><span class="s0">;</span>
        <span class="s0">current_pos += str.length;</span>
        <span class="s1">var </span><span class="s0">a = str.split(/\r?\n/), n = a.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">current_line += n;</span>
        <span class="s0">current_col += a[</span><span class="s4">0</span><span class="s0">].length;</span>
        <span class="s1">if </span><span class="s0">(n &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">ensure_line_len();</span>
            <span class="s0">current_col = a[n].length;</span>
        <span class="s0">}</span>
        <span class="s0">last = str;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">star = </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">print(</span><span class="s2">&quot;*&quot;</span><span class="s0">);</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">space = options.beautify ? </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">print(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
    <span class="s0">} : </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">might_need_space = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">indent = options.beautify ? </span><span class="s1">function</span><span class="s0">(half) {</span>
        <span class="s1">if </span><span class="s0">(options.beautify) {</span>
            <span class="s0">print(make_indent(half ? </span><span class="s4">0.5 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">));</span>
        <span class="s0">}</span>
    <span class="s0">} : noop;</span>

    <span class="s1">var </span><span class="s0">with_indent = options.beautify ? </span><span class="s1">function</span><span class="s0">(col, cont) {</span>
        <span class="s1">if </span><span class="s0">(col === </span><span class="s1">true</span><span class="s0">) col = next_indent();</span>
        <span class="s1">var </span><span class="s0">save_indentation = indentation;</span>
        <span class="s0">indentation = col;</span>
        <span class="s1">var </span><span class="s0">ret = cont();</span>
        <span class="s0">indentation = save_indentation;</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">} : </span><span class="s1">function</span><span class="s0">(col, cont) { </span><span class="s1">return </span><span class="s0">cont(); };</span>

    <span class="s1">var </span><span class="s0">newline = options.beautify ? </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">if </span><span class="s0">(newline_insert &lt; </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(OUTPUT.charAt(newline_insert) != </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">) {</span>
            <span class="s0">OUTPUT.insertAt(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">, newline_insert);</span>
            <span class="s0">current_pos++;</span>
            <span class="s0">current_line++;</span>
        <span class="s0">}</span>
        <span class="s0">newline_insert++;</span>
    <span class="s0">} : options.max_line_len ? </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">ensure_line_len();</span>
        <span class="s0">might_add_newline = OUTPUT.length();</span>
    <span class="s0">} : noop;</span>

    <span class="s1">var </span><span class="s0">semicolon = options.beautify ? </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">print(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
    <span class="s0">} : </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s0">might_need_semicolon = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">force_semicolon() {</span>
        <span class="s0">might_need_semicolon = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">print(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">next_indent() {</span>
        <span class="s1">return </span><span class="s0">indentation + options.indent_level;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">with_block(cont) {</span>
        <span class="s1">var </span><span class="s0">ret;</span>
        <span class="s0">print(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
        <span class="s0">newline();</span>
        <span class="s0">with_indent(next_indent(), </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">ret = cont();</span>
        <span class="s0">});</span>
        <span class="s0">indent();</span>
        <span class="s0">print(</span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">with_parens(cont) {</span>
        <span class="s0">print(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s3">//XXX: still nice to have that for argument lists</span>
        <span class="s3">//var ret = with_indent(current_col, cont);</span>
        <span class="s1">var </span><span class="s0">ret = cont();</span>
        <span class="s0">print(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">with_square(cont) {</span>
        <span class="s0">print(</span><span class="s2">&quot;[&quot;</span><span class="s0">);</span>
        <span class="s3">//var ret = with_indent(current_col, cont);</span>
        <span class="s1">var </span><span class="s0">ret = cont();</span>
        <span class="s0">print(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">comma() {</span>
        <span class="s0">print(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
        <span class="s0">space();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">colon() {</span>
        <span class="s0">print(</span><span class="s2">&quot;:&quot;</span><span class="s0">);</span>
        <span class="s0">space();</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">add_mapping = mappings ? </span><span class="s1">function</span><span class="s0">(token, name) {</span>
        <span class="s0">mapping_token = token;</span>
        <span class="s0">mapping_name = name;</span>
    <span class="s0">} : noop;</span>

    <span class="s1">function </span><span class="s0">get() {</span>
        <span class="s1">if </span><span class="s0">(might_add_newline) {</span>
            <span class="s0">ensure_line_len();</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">OUTPUT.toString();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">has_nlb() {</span>
        <span class="s0">const output = OUTPUT.toString();</span>
        <span class="s0">let n = output.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">(n &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">const code = output.charCodeAt(n);</span>
            <span class="s1">if </span><span class="s0">(code === CODE_LINE_BREAK) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(code !== CODE_SPACE) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">n--;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">filter_comment(comment) {</span>
        <span class="s1">if </span><span class="s0">(!options.preserve_annotations) {</span>
            <span class="s0">comment = comment.replace(r_annotation, </span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(/^\s*$/.test(comment)) {</span>
            <span class="s1">return </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">comment.replace(/(&lt;\s*\/\s*)(script)/i, </span><span class="s2">&quot;&lt;</span><span class="s5">\\</span><span class="s2">/$2&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">prepend_comments(node) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">start = node.start;</span>
        <span class="s1">if </span><span class="s0">(!start) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">printed_comments = self.printed_comments;</span>

        <span class="s3">// There cannot be a newline between return/yield and its value.</span>
        <span class="s0">const keyword_with_value = </span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Exit &amp;&amp; node.value</span>
            <span class="s0">|| (node </span><span class="s1">instanceof </span><span class="s0">AST_Await || node </span><span class="s1">instanceof </span><span class="s0">AST_Yield)</span>
                <span class="s0">&amp;&amp; node.expression;</span>

        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">start.comments_before</span>
            <span class="s0">&amp;&amp; printed_comments.has(start.comments_before)</span>
        <span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(keyword_with_value) {</span>
                <span class="s0">start.comments_before = [];</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">comments = start.comments_before;</span>
        <span class="s1">if </span><span class="s0">(!comments) {</span>
            <span class="s0">comments = start.comments_before = [];</span>
        <span class="s0">}</span>
        <span class="s0">printed_comments.add(comments);</span>

        <span class="s1">if </span><span class="s0">(keyword_with_value) {</span>
            <span class="s1">var </span><span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
                <span class="s1">var </span><span class="s0">parent = tw.parent();</span>
                <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Exit</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Await</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Yield</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; parent.left === node</span>
                    <span class="s0">|| parent.TYPE == </span><span class="s2">&quot;Call&quot; </span><span class="s0">&amp;&amp; parent.expression === node</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Conditional &amp;&amp; parent.condition === node</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Dot &amp;&amp; parent.expression === node</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Sequence &amp;&amp; parent.expressions[</span><span class="s4">0</span><span class="s0">] === node</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Sub &amp;&amp; parent.expression === node</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPostfix) {</span>
                    <span class="s1">if </span><span class="s0">(!node.start) </span><span class="s1">return</span><span class="s0">;</span>
                    <span class="s1">var </span><span class="s0">text = node.start.comments_before;</span>
                    <span class="s1">if </span><span class="s0">(text &amp;&amp; !printed_comments.has(text)) {</span>
                        <span class="s0">printed_comments.add(text);</span>
                        <span class="s0">comments = comments.concat(text);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s0">tw.push(node);</span>
            <span class="s0">keyword_with_value.walk(tw);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(current_pos == </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(comments.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; options.shebang &amp;&amp; comments[</span><span class="s4">0</span><span class="s0">].type === </span><span class="s2">&quot;comment5&quot;</span>
                <span class="s0">&amp;&amp; !printed_comments.has(comments[</span><span class="s4">0</span><span class="s0">])) {</span>
                <span class="s0">print(</span><span class="s2">&quot;#!&quot; </span><span class="s0">+ comments.shift().value + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                <span class="s0">indent();</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">preamble = options.preamble;</span>
            <span class="s1">if </span><span class="s0">(preamble) {</span>
                <span class="s0">print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">));</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s0">comments = comments.filter(comment_filter, node).filter(c =&gt; !printed_comments.has(c));</span>
        <span class="s1">if </span><span class="s0">(comments.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">last_nlb = has_nlb();</span>
        <span class="s0">comments.forEach(</span><span class="s1">function</span><span class="s0">(c, i) {</span>
            <span class="s0">printed_comments.add(c);</span>
            <span class="s1">if </span><span class="s0">(!last_nlb) {</span>
                <span class="s1">if </span><span class="s0">(c.nlb) {</span>
                    <span class="s0">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                    <span class="s0">indent();</span>
                    <span class="s0">last_nlb = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">space();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(/comment[</span><span class="s4">134</span><span class="s0">]/.test(c.type)) {</span>
                <span class="s1">var </span><span class="s0">value = filter_comment(c.value);</span>
                <span class="s1">if </span><span class="s0">(value) {</span>
                    <span class="s0">print(</span><span class="s2">&quot;//&quot; </span><span class="s0">+ value + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                    <span class="s0">indent();</span>
                <span class="s0">}</span>
                <span class="s0">last_nlb = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(c.type == </span><span class="s2">&quot;comment2&quot;</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">value = filter_comment(c.value);</span>
                <span class="s1">if </span><span class="s0">(value) {</span>
                    <span class="s0">print(</span><span class="s2">&quot;/*&quot; </span><span class="s0">+ value + </span><span class="s2">&quot;*/&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">last_nlb = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(!last_nlb) {</span>
            <span class="s1">if </span><span class="s0">(start.nlb) {</span>
                <span class="s0">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                <span class="s0">indent();</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">space();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">append_comments(node, tail) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">token = node.end;</span>
        <span class="s1">if </span><span class="s0">(!token) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">printed_comments = self.printed_comments;</span>
        <span class="s1">var </span><span class="s0">comments = token[tail ? </span><span class="s2">&quot;comments_before&quot; </span><span class="s0">: </span><span class="s2">&quot;comments_after&quot;</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(!comments || printed_comments.has(comments)) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!(node </span><span class="s1">instanceof </span><span class="s0">AST_Statement || comments.every((c) =&gt;</span>
            <span class="s0">!/comment[</span><span class="s4">134</span><span class="s0">]/.test(c.type)</span>
        <span class="s0">))) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s0">printed_comments.add(comments);</span>
        <span class="s1">var </span><span class="s0">insert = OUTPUT.length();</span>
        <span class="s0">comments.filter(comment_filter, node).forEach(</span><span class="s1">function</span><span class="s0">(c, i) {</span>
            <span class="s1">if </span><span class="s0">(printed_comments.has(c)) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s0">printed_comments.add(c);</span>
            <span class="s0">need_space = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(need_newline_indented) {</span>
                <span class="s0">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                <span class="s0">indent();</span>
                <span class="s0">need_newline_indented = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(c.nlb &amp;&amp; (i &gt; </span><span class="s4">0 </span><span class="s0">|| !has_nlb())) {</span>
                <span class="s0">print(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
                <span class="s0">indent();</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(i &gt; </span><span class="s4">0 </span><span class="s0">|| !tail) {</span>
                <span class="s0">space();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(/comment[</span><span class="s4">134</span><span class="s0">]/.test(c.type)) {</span>
                <span class="s0">const value = filter_comment(c.value);</span>
                <span class="s1">if </span><span class="s0">(value) {</span>
                    <span class="s0">print(</span><span class="s2">&quot;//&quot; </span><span class="s0">+ value);</span>
                <span class="s0">}</span>
                <span class="s0">need_newline_indented = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(c.type == </span><span class="s2">&quot;comment2&quot;</span><span class="s0">) {</span>
                <span class="s0">const value = filter_comment(c.value);</span>
                <span class="s1">if </span><span class="s0">(value) {</span>
                    <span class="s0">print(</span><span class="s2">&quot;/*&quot; </span><span class="s0">+ value + </span><span class="s2">&quot;*/&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">need_space = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(OUTPUT.length() &gt; insert) newline_insert = insert;</span>
    <span class="s0">}</span>

    <span class="s3">/** 
     * When output.option(&quot;_destroy_ast&quot;) is enabled, destroy the function. 
     * Call this after printing it. 
     */</span>
    <span class="s0">const gc_scope =</span>
      <span class="s0">options[</span><span class="s2">&quot;_destroy_ast&quot;</span><span class="s0">]</span>
        <span class="s0">? </span><span class="s1">function </span><span class="s0">gc_scope(scope) {</span>
            <span class="s0">scope.body.length = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">scope.argnames.length = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">: noop;</span>

    <span class="s1">var </span><span class="s0">stack = [];</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">get             : get,</span>
        <span class="s0">toString        : get,</span>
        <span class="s0">indent          : indent,</span>
        <span class="s0">in_directive    : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">use_asm         : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">active_scope    : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">indentation     : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">indentation; },</span>
        <span class="s0">current_width   : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">current_col - indentation; },</span>
        <span class="s0">should_break    : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">options.width &amp;&amp; </span><span class="s1">this</span><span class="s0">.current_width() &gt;= options.width; },</span>
        <span class="s0">has_parens      : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">has_parens; },</span>
        <span class="s0">newline         : newline,</span>
        <span class="s0">print           : print,</span>
        <span class="s0">star            : star,</span>
        <span class="s0">space           : space,</span>
        <span class="s0">comma           : comma,</span>
        <span class="s0">colon           : colon,</span>
        <span class="s0">last            : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">last; },</span>
        <span class="s0">semicolon       : semicolon,</span>
        <span class="s0">force_semicolon : force_semicolon,</span>
        <span class="s0">to_utf8         : to_utf8,</span>
        <span class="s0">print_name      : </span><span class="s1">function</span><span class="s0">(name) { print(make_name(name)); },</span>
        <span class="s0">print_string    : </span><span class="s1">function</span><span class="s0">(str, quote, escape_directive) {</span>
            <span class="s1">var </span><span class="s0">encoded = encode_string(str, quote);</span>
            <span class="s1">if </span><span class="s0">(escape_directive === </span><span class="s1">true </span><span class="s0">&amp;&amp; !encoded.includes(</span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">&quot;</span><span class="s0">)) {</span>
                <span class="s3">// Insert semicolons to break directive prologue</span>
                <span class="s1">if </span><span class="s0">(!EXPECT_DIRECTIVE.test(OUTPUT.toString())) {</span>
                    <span class="s0">force_semicolon();</span>
                <span class="s0">}</span>
                <span class="s0">force_semicolon();</span>
            <span class="s0">}</span>
            <span class="s0">print(encoded);</span>
        <span class="s0">},</span>
        <span class="s0">print_template_string_chars: </span><span class="s1">function</span><span class="s0">(str) {</span>
            <span class="s1">var </span><span class="s0">encoded = encode_string(str, </span><span class="s2">&quot;`&quot;</span><span class="s0">).replace(/\${/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">${&quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">print(encoded.substr(</span><span class="s4">1</span><span class="s0">, encoded.length - </span><span class="s4">2</span><span class="s0">));</span>
        <span class="s0">},</span>
        <span class="s0">encode_string   : encode_string,</span>
        <span class="s0">next_indent     : next_indent,</span>
        <span class="s0">with_indent     : with_indent,</span>
        <span class="s0">with_block      : with_block,</span>
        <span class="s0">with_parens     : with_parens,</span>
        <span class="s0">with_square     : with_square,</span>
        <span class="s0">add_mapping     : add_mapping,</span>
        <span class="s0">option          : </span><span class="s1">function</span><span class="s0">(opt) { </span><span class="s1">return </span><span class="s0">options[opt]; },</span>
        <span class="s0">gc_scope,</span>
        <span class="s0">printed_comments: printed_comments,</span>
        <span class="s0">prepend_comments: readonly ? noop : prepend_comments,</span>
        <span class="s0">append_comments : readonly || comment_filter === return_false ? noop : append_comments,</span>
        <span class="s0">line            : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">current_line; },</span>
        <span class="s0">col             : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">current_col; },</span>
        <span class="s0">pos             : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">current_pos; },</span>
        <span class="s0">push_node       : </span><span class="s1">function</span><span class="s0">(node) { stack.push(node); },</span>
        <span class="s0">pop_node        : </span><span class="s1">function</span><span class="s0">() { </span><span class="s1">return </span><span class="s0">stack.pop(); },</span>
        <span class="s0">parent          : </span><span class="s1">function</span><span class="s0">(n) {</span>
            <span class="s1">return </span><span class="s0">stack[stack.length - </span><span class="s4">2 </span><span class="s0">- (n || </span><span class="s4">0</span><span class="s0">)];</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

<span class="s0">}</span>

<span class="s3">/* -----[ code generators ]----- */</span>

<span class="s0">(</span><span class="s1">function</span><span class="s0">() {</span>

    <span class="s3">/* -----[ utils ]----- */</span>

    <span class="s1">function </span><span class="s0">DEFPRINT(nodetype, generator) {</span>
        <span class="s0">nodetype.DEFMETHOD(</span><span class="s2">&quot;_codegen&quot;</span><span class="s0">, generator);</span>
    <span class="s0">}</span>

    <span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output, force_parens) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">, generator = self._codegen;</span>
        <span class="s1">if </span><span class="s0">(self </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
            <span class="s0">output.active_scope = self;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!output.use_asm &amp;&amp; self </span><span class="s1">instanceof </span><span class="s0">AST_Directive &amp;&amp; self.value == </span><span class="s2">&quot;use asm&quot;</span><span class="s0">) {</span>
            <span class="s0">output.use_asm = output.active_scope;</span>
        <span class="s0">}</span>
        <span class="s1">function </span><span class="s0">doit() {</span>
            <span class="s0">output.prepend_comments(self);</span>
            <span class="s0">self.add_source_map(output);</span>
            <span class="s0">generator(self, output);</span>
            <span class="s0">output.append_comments(self);</span>
        <span class="s0">}</span>
        <span class="s0">output.push_node(self);</span>
        <span class="s1">if </span><span class="s0">(force_parens || self.needs_parens(output)) {</span>
            <span class="s0">output.with_parens(doit);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">doit();</span>
        <span class="s0">}</span>
        <span class="s0">output.pop_node();</span>
        <span class="s1">if </span><span class="s0">(self === output.use_asm) {</span>
            <span class="s0">output.use_asm = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;_print&quot;</span><span class="s0">, AST_Node.prototype.print);</span>

    <span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;print_to_string&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
        <span class="s1">var </span><span class="s0">output = OutputStream(options);</span>
        <span class="s1">this</span><span class="s0">.print(output);</span>
        <span class="s1">return </span><span class="s0">output.get();</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ PARENTHESES ]----- */</span>

    <span class="s1">function </span><span class="s0">PARENS(nodetype, func) {</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(nodetype)) {</span>
            <span class="s0">nodetype.forEach(</span><span class="s1">function</span><span class="s0">(nodetype) {</span>
                <span class="s0">PARENS(nodetype, func);</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">nodetype.DEFMETHOD(</span><span class="s2">&quot;needs_parens&quot;</span><span class="s0">, func);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">PARENS(AST_Node, return_false);</span>

    <span class="s3">// a function expression needs parens around it when it's provably</span>
    <span class="s3">// the first token to appear in a statement.</span>
    <span class="s0">PARENS(AST_Function, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">if </span><span class="s0">(!output.has_parens() &amp;&amp; first_in_statement(output)) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(output.option(</span><span class="s2">&quot;webkit&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">p = output.parent();</span>
            <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(output.option(</span><span class="s2">&quot;wrap_iife&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">p = output.parent();</span>
            <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(output.option(</span><span class="s2">&quot;wrap_func_args&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">p = output.parent();</span>
            <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.args.includes(</span><span class="s1">this</span><span class="s0">)) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Arrow, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>

        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">output.option(</span><span class="s2">&quot;wrap_func_args&quot;</span><span class="s0">)</span>
            <span class="s0">&amp;&amp; p </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
            <span class="s0">&amp;&amp; p.args.includes(</span><span class="s1">this</span><span class="s0">)</span>
        <span class="s0">) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s3">// same goes for an object literal (as in AST_Function), because</span>
    <span class="s3">// otherwise {...} would be interpreted as a block of code.</span>
    <span class="s0">PARENS(AST_Object, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">return </span><span class="s0">!output.has_parens() &amp;&amp; first_in_statement(output);</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_ClassExpression, first_in_statement);</span>

    <span class="s0">PARENS(AST_Unary, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">return </span><span class="s0">p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.expression === </span><span class="s1">this</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                <span class="s0">&amp;&amp; p.operator === </span><span class="s2">&quot;**&quot;</span>
                <span class="s0">&amp;&amp; </span><span class="s1">this instanceof </span><span class="s0">AST_UnaryPrefix</span>
                <span class="s0">&amp;&amp; p.left === </span><span class="s1">this</span>
                <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.operator !== </span><span class="s2">&quot;++&quot;</span>
                <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.operator !== </span><span class="s2">&quot;--&quot;</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Await, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">return </span><span class="s0">p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.expression === </span><span class="s1">this</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; p.operator === </span><span class="s2">&quot;**&quot; </span><span class="s0">&amp;&amp; p.left === </span><span class="s1">this</span>
            <span class="s0">|| output.option(</span><span class="s2">&quot;safari10&quot;</span><span class="s0">) &amp;&amp; p </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Sequence, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">return </span><span class="s0">p </span><span class="s1">instanceof </span><span class="s0">AST_Call                          </span><span class="s3">// (foo, bar)() or foo(1, (2, 3), 4)</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Unary                         </span><span class="s3">// !(foo, bar, baz)</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Binary                        </span><span class="s3">// 1 + (2, 3) + 4 ==&gt; 8</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_VarDef                        </span><span class="s3">// var a = (1, 2), b = a + a; ==&gt; b == 4</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess                    </span><span class="s3">// (1, {foo:2}).foo or (1, {foo:2})[&quot;foo&quot;] ==&gt; 2</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Array                         </span><span class="s3">// [ 1, (2, 3), 4 ] ==&gt; [ 1, 3, 4 ]</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_ObjectProperty                </span><span class="s3">// { foo: (1, 2) }.foo ==&gt; 2</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Conditional                   </span><span class="s3">/* (false, true) ? (a = 10, b = 20) : (c = 30) 
                                                               * ==&gt; 20 (side effect, set a := 10 and b := 20) */</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Arrow                         </span><span class="s3">// x =&gt; (x, x)</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_DefaultAssign                 </span><span class="s3">// x =&gt; (x = (0, function(){}))</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Expansion                     </span><span class="s3">// [...(a, b)]</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_ForOf &amp;&amp; </span><span class="s1">this </span><span class="s0">=== p.object    </span><span class="s3">// for (e of (foo, bar)) {}</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Yield                         </span><span class="s3">// yield (foo, bar)</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Export                        </span><span class="s3">// export default (foo, bar)</span>
        <span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Binary, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s3">// (foo &amp;&amp; bar)()</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// typeof (foo &amp;&amp; bar)</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Unary)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// (foo &amp;&amp; bar)[&quot;prop&quot;], (foo &amp;&amp; bar).prop</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// this deals with precedence: 3 * (2 + 1)</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Binary) {</span>
            <span class="s0">const po = p.operator;</span>
            <span class="s0">const so = </span><span class="s1">this</span><span class="s0">.operator;</span>

            <span class="s1">if </span><span class="s0">(so === </span><span class="s2">&quot;??&quot; </span><span class="s0">&amp;&amp; (po === </span><span class="s2">&quot;||&quot; </span><span class="s0">|| po === </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">)) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(po === </span><span class="s2">&quot;??&quot; </span><span class="s0">&amp;&amp; (so === </span><span class="s2">&quot;||&quot; </span><span class="s0">|| so === </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">)) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s0">const pp = PRECEDENCE[po];</span>
            <span class="s0">const sp = PRECEDENCE[so];</span>
            <span class="s1">if </span><span class="s0">(pp &gt; sp</span>
                <span class="s0">|| (pp == sp</span>
                    <span class="s0">&amp;&amp; (</span><span class="s1">this </span><span class="s0">=== p.right || po == </span><span class="s2">&quot;**&quot;</span><span class="s0">))) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Yield, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s3">// (yield 1) + (yield 2)</span>
        <span class="s3">// a = yield 3</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; p.operator !== </span><span class="s2">&quot;=&quot;</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// (yield 1)()</span>
        <span class="s3">// new (yield 1)()</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// (yield 1) ? yield 2 : yield 3</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Conditional &amp;&amp; p.condition === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// -(yield 4)</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Unary)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// (yield x).foo</span>
        <span class="s3">// (yield x)['foo']</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Chain, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">if </span><span class="s0">(!(p </span><span class="s1">instanceof </span><span class="s0">AST_Call || p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">p.expression === </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_PropAccess, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_New &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">) {</span>
            <span class="s3">// i.e. new (foo.bar().baz)</span>
            <span class="s3">//</span>
            <span class="s3">// if there's one call into this subtree, then we need</span>
            <span class="s3">// parens around it too, otherwise the call will be</span>
            <span class="s3">// interpreted as passing the arguments to the upper New</span>
            <span class="s3">// expression.</span>
            <span class="s1">return </span><span class="s0">walk(</span><span class="s1">this</span><span class="s0">, node =&gt; {</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) </span><span class="s1">return true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Call) {</span>
                    <span class="s1">return </span><span class="s0">walk_abort;  </span><span class="s3">// makes walk() return true.</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Call, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent(), p1;</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_New &amp;&amp; p.expression === </span><span class="s1">this</span>
            <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Export &amp;&amp; p.is_default &amp;&amp; </span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_Function)</span>
            <span class="s1">return true</span><span class="s0">;</span>

        <span class="s3">// workaround for Safari bug.</span>
        <span class="s3">// https://bugs.webkit.org/show_bug.cgi?id=123506</span>
        <span class="s1">return this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_Function</span>
            <span class="s0">&amp;&amp; p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
            <span class="s0">&amp;&amp; p.expression === </span><span class="s1">this</span>
            <span class="s0">&amp;&amp; (p1 = output.parent(</span><span class="s4">1</span><span class="s0">)) </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
            <span class="s0">&amp;&amp; p1.left === p;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_New, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.args.length === </span><span class="s4">0</span>
            <span class="s0">&amp;&amp; (p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess </span><span class="s3">// (new Date).getTime(), (new Date)[&quot;getTime&quot;]()</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.expression === </span><span class="s1">this</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_PrefixedTemplateString &amp;&amp; p.prefix === </span><span class="s1">this</span><span class="s0">)) </span><span class="s3">// (new foo)(bar)</span>
            <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_Number, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">value = </span><span class="s1">this</span><span class="s0">.getValue();</span>
            <span class="s1">if </span><span class="s0">(value &lt; </span><span class="s4">0 </span><span class="s0">|| /^</span><span class="s4">0</span><span class="s0">/.test(make_num(value))) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">PARENS(AST_BigInt, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">value = </span><span class="s1">this</span><span class="s0">.getValue();</span>
            <span class="s1">if </span><span class="s0">(value.startsWith(</span><span class="s2">&quot;-&quot;</span><span class="s0">)) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">PARENS([ AST_Assign, AST_Conditional ], </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s3">// !(a = false) → true</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Unary)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// 1 + (a = 2) + 3 → 6, side effect setting a = 2</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; !(p </span><span class="s1">instanceof </span><span class="s0">AST_Assign))</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// (a = func)() —or— new (a = Object)()</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// (a = foo) ? bar : baz</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Conditional &amp;&amp; p.condition === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// (a = foo)[&quot;prop&quot;] —or— (a = foo).prop</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; p.expression === </span><span class="s1">this</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s3">// ({a, b} = {a: 1, b: 2}), a destructuring assignment</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">AST_Assign &amp;&amp; </span><span class="s1">this</span><span class="s0">.left </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring &amp;&amp; </span><span class="s1">this</span><span class="s0">.left.is_array === </span><span class="s1">false</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ PRINTERS ]----- */</span>

    <span class="s0">DEFPRINT(AST_Directive, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print_string(self.value, self.quote);</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_Expansion, </span><span class="s1">function </span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;...&quot;</span><span class="s0">);</span>
        <span class="s0">self.expression.print(output);</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_Destructuring, </span><span class="s1">function </span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(self.is_array ? </span><span class="s2">&quot;[&quot; </span><span class="s0">: </span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">len = self.names.length;</span>
        <span class="s0">self.names.forEach(</span><span class="s1">function </span><span class="s0">(name, i) {</span>
            <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) output.comma();</span>
            <span class="s0">name.print(output);</span>
            <span class="s3">// If the final element is a hole, we need to make sure it</span>
            <span class="s3">// doesn't look like a trailing comma, by inserting an actual</span>
            <span class="s3">// trailing comma.</span>
            <span class="s1">if </span><span class="s0">(i == len - </span><span class="s4">1 </span><span class="s0">&amp;&amp; name </span><span class="s1">instanceof </span><span class="s0">AST_Hole) output.comma();</span>
        <span class="s0">});</span>
        <span class="s0">output.print(self.is_array ? </span><span class="s2">&quot;]&quot; </span><span class="s0">: </span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_Debugger, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;debugger&quot;</span><span class="s0">);</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ statements ]----- */</span>

    <span class="s1">function </span><span class="s0">display_body(body, is_toplevel, output, allow_directives) {</span>
        <span class="s1">var </span><span class="s0">last = body.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">output.in_directive = allow_directives;</span>
        <span class="s0">body.forEach(</span><span class="s1">function</span><span class="s0">(stmt, i) {</span>
            <span class="s1">if </span><span class="s0">(output.in_directive === </span><span class="s1">true </span><span class="s0">&amp;&amp; !(stmt </span><span class="s1">instanceof </span><span class="s0">AST_Directive ||</span>
                <span class="s0">stmt </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement ||</span>
                <span class="s0">(stmt </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement &amp;&amp; stmt.body </span><span class="s1">instanceof </span><span class="s0">AST_String)</span>
            <span class="s0">)) {</span>
                <span class="s0">output.in_directive = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!(stmt </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement)) {</span>
                <span class="s0">output.indent();</span>
                <span class="s0">stmt.print(output);</span>
                <span class="s1">if </span><span class="s0">(!(i == last &amp;&amp; is_toplevel)) {</span>
                    <span class="s0">output.newline();</span>
                    <span class="s1">if </span><span class="s0">(is_toplevel) output.newline();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(output.in_directive === </span><span class="s1">true </span><span class="s0">&amp;&amp;</span>
                <span class="s0">stmt </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement &amp;&amp;</span>
                <span class="s0">stmt.body </span><span class="s1">instanceof </span><span class="s0">AST_String</span>
            <span class="s0">) {</span>
                <span class="s0">output.in_directive = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s0">output.in_directive = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">AST_StatementWithBody.DEFMETHOD(</span><span class="s2">&quot;_do_print_body&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s0">print_maybe_braced_body(</span><span class="s1">this</span><span class="s0">.body, output);</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_Statement, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.body.print(output);</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Toplevel, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">display_body(self.body, </span><span class="s1">true</span><span class="s0">, output, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">output.print(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_LabeledStatement, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.label.print(output);</span>
        <span class="s0">output.colon();</span>
        <span class="s0">self.body.print(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_SimpleStatement, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.body.print(output);</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s1">function </span><span class="s0">print_braced_empty(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
        <span class="s0">output.with_indent(output.next_indent(), </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">output.append_comments(self, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">});</span>
        <span class="s0">output.add_mapping(self.end);</span>
        <span class="s0">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">print_braced(self, output, allow_directives) {</span>
        <span class="s1">if </span><span class="s0">(self.body.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">output.with_block(</span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s0">display_body(self.body, </span><span class="s1">false</span><span class="s0">, output, allow_directives);</span>
                <span class="s0">output.add_mapping(self.end);</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">print_braced_empty(self, output);</span>
    <span class="s0">}</span>
    <span class="s0">DEFPRINT(AST_BlockStatement, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">print_braced(self, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_EmptyStatement, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Do, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;do&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">make_block(self.body, output);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.print(</span><span class="s2">&quot;while&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.condition.print(output);</span>
        <span class="s0">});</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_While, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;while&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.condition.print(output);</span>
        <span class="s0">});</span>
        <span class="s0">output.space();</span>
        <span class="s0">self._do_print_body(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_For, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;for&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">if </span><span class="s0">(self.init) {</span>
                <span class="s1">if </span><span class="s0">(self.init </span><span class="s1">instanceof </span><span class="s0">AST_Definitions) {</span>
                    <span class="s0">self.init.print(output);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">parenthesize_for_noin(self.init, output, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">}</span>
                <span class="s0">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
                <span class="s0">output.space();</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(self.condition) {</span>
                <span class="s0">self.condition.print(output);</span>
                <span class="s0">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
                <span class="s0">output.space();</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.print(</span><span class="s2">&quot;;&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(self.step) {</span>
                <span class="s0">self.step.print(output);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s0">output.space();</span>
        <span class="s0">self._do_print_body(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ForIn, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;for&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(self.await) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(</span><span class="s2">&quot;await&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.init.print(output);</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(self </span><span class="s1">instanceof </span><span class="s0">AST_ForOf ? </span><span class="s2">&quot;of&quot; </span><span class="s0">: </span><span class="s2">&quot;in&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
            <span class="s0">self.object.print(output);</span>
        <span class="s0">});</span>
        <span class="s0">output.space();</span>
        <span class="s0">self._do_print_body(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_With, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;with&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.expression.print(output);</span>
        <span class="s0">});</span>
        <span class="s0">output.space();</span>
        <span class="s0">self._do_print_body(output);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ functions ]----- */</span>
    <span class="s0">AST_Lambda.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output, nokeyword) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!nokeyword) {</span>
            <span class="s1">if </span><span class="s0">(self.async) {</span>
                <span class="s0">output.print(</span><span class="s2">&quot;async&quot;</span><span class="s0">);</span>
                <span class="s0">output.space();</span>
            <span class="s0">}</span>
            <span class="s0">output.print(</span><span class="s2">&quot;function&quot;</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(self.is_generator) {</span>
                <span class="s0">output.star();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(self.name) {</span>
                <span class="s0">output.space();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.name </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) {</span>
            <span class="s0">self.name.print(output);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(nokeyword &amp;&amp; self.name </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
            <span class="s0">output.with_square(</span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s0">self.name.print(output); </span><span class="s3">// Computed method name</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.argnames.forEach(</span><span class="s1">function</span><span class="s0">(arg, i) {</span>
                <span class="s1">if </span><span class="s0">(i) output.comma();</span>
                <span class="s0">arg.print(output);</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
        <span class="s0">output.space();</span>
        <span class="s0">print_braced(self, output, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Lambda, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output);</span>
        <span class="s0">output.gc_scope(self);</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_PrefixedTemplateString, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">tag = self.prefix;</span>
        <span class="s1">var </span><span class="s0">parenthesize_tag = tag </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
            <span class="s0">|| tag </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
            <span class="s0">|| tag </span><span class="s1">instanceof </span><span class="s0">AST_Conditional</span>
            <span class="s0">|| tag </span><span class="s1">instanceof </span><span class="s0">AST_Sequence</span>
            <span class="s0">|| tag </span><span class="s1">instanceof </span><span class="s0">AST_Unary</span>
            <span class="s0">|| tag </span><span class="s1">instanceof </span><span class="s0">AST_Dot &amp;&amp; tag.expression </span><span class="s1">instanceof </span><span class="s0">AST_Object;</span>
        <span class="s1">if </span><span class="s0">(parenthesize_tag) output.print(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s0">self.prefix.print(output);</span>
        <span class="s1">if </span><span class="s0">(parenthesize_tag) output.print(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s0">self.template_string.print(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_TemplateString, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">is_tagged = output.parent() </span><span class="s1">instanceof </span><span class="s0">AST_PrefixedTemplateString;</span>

        <span class="s0">output.print(</span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; self.segments.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(!(self.segments[i] </span><span class="s1">instanceof </span><span class="s0">AST_TemplateSegment)) {</span>
                <span class="s0">output.print(</span><span class="s2">&quot;${&quot;</span><span class="s0">);</span>
                <span class="s0">self.segments[i].print(output);</span>
                <span class="s0">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_tagged) {</span>
                <span class="s0">output.print(self.segments[i].raw);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.print_template_string_chars(self.segments[i].value);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">output.print(</span><span class="s2">&quot;`&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_TemplateSegment, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print_template_string_chars(self.value);</span>
    <span class="s0">});</span>

    <span class="s0">AST_Arrow.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">parent = output.parent();</span>
        <span class="s1">var </span><span class="s0">needs_parens = (parent </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; !(parent </span><span class="s1">instanceof </span><span class="s0">AST_Assign)) ||</span>
            <span class="s0">parent </span><span class="s1">instanceof </span><span class="s0">AST_Unary ||</span>
            <span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; self === parent.expression);</span>
        <span class="s1">if </span><span class="s0">(needs_parens) { output.print(</span><span class="s2">&quot;(&quot;</span><span class="s0">); }</span>
        <span class="s1">if </span><span class="s0">(self.async) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;async&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.argnames.length === </span><span class="s4">1 </span><span class="s0">&amp;&amp; self.argnames[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) {</span>
            <span class="s0">self.argnames[</span><span class="s4">0</span><span class="s0">].print(output);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s0">self.argnames.forEach(</span><span class="s1">function</span><span class="s0">(arg, i) {</span>
                    <span class="s1">if </span><span class="s0">(i) output.comma();</span>
                    <span class="s0">arg.print(output);</span>
                <span class="s0">});</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.print(</span><span class="s2">&quot;=&gt;&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">const first_statement = self.body[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">self.body.length === </span><span class="s4">1</span>
            <span class="s0">&amp;&amp; first_statement </span><span class="s1">instanceof </span><span class="s0">AST_Return</span>
        <span class="s0">) {</span>
            <span class="s0">const returned = first_statement.value;</span>
            <span class="s1">if </span><span class="s0">(!returned) {</span>
                <span class="s0">output.print(</span><span class="s2">&quot;{}&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(left_is_object(returned)) {</span>
                <span class="s0">output.print(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
                <span class="s0">returned.print(output);</span>
                <span class="s0">output.print(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">returned.print(output);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">print_braced(self, output);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(needs_parens) { output.print(</span><span class="s2">&quot;)&quot;</span><span class="s0">); }</span>
        <span class="s0">output.gc_scope(self);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ exits ]----- */</span>
    <span class="s0">AST_Exit.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output, kind) {</span>
        <span class="s0">output.print(kind);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.value) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">const comments = </span><span class="s1">this</span><span class="s0">.value.start.comments_before;</span>
            <span class="s1">if </span><span class="s0">(comments &amp;&amp; comments.length &amp;&amp; !output.printed_comments.has(comments)) {</span>
                <span class="s0">output.print(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.value.print(output);</span>
                <span class="s0">output.print(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.value.print(output);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Return, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output, </span><span class="s2">&quot;return&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Throw, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output, </span><span class="s2">&quot;throw&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ yield ]----- */</span>

    <span class="s0">DEFPRINT(AST_Yield, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">star = self.is_star ? </span><span class="s2">&quot;*&quot; </span><span class="s0">: </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s0">output.print(</span><span class="s2">&quot;yield&quot; </span><span class="s0">+ star);</span>
        <span class="s1">if </span><span class="s0">(self.expression) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">self.expression.print(output);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_Await, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;await&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s1">var </span><span class="s0">e = self.expression;</span>
        <span class="s1">var </span><span class="s0">parens = !(</span>
               <span class="s0">e </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
            <span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
            <span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">AST_Unary</span>
            <span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
            <span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">AST_Await</span>
            <span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">AST_Object</span>
        <span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(parens) output.print(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s0">self.expression.print(output);</span>
        <span class="s1">if </span><span class="s0">(parens) output.print(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ loop control ]----- */</span>
    <span class="s0">AST_LoopControl.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output, kind) {</span>
        <span class="s0">output.print(kind);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.label) {</span>
            <span class="s0">output.space();</span>
            <span class="s1">this</span><span class="s0">.label.print(output);</span>
        <span class="s0">}</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Break, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output, </span><span class="s2">&quot;break&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Continue, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output, </span><span class="s2">&quot;continue&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ if ]----- */</span>
    <span class="s1">function </span><span class="s0">make_then(self, output) {</span>
        <span class="s1">var </span><span class="s0">b = self.body;</span>
        <span class="s1">if </span><span class="s0">(output.option(</span><span class="s2">&quot;braces&quot;</span><span class="s0">)</span>
            <span class="s0">|| output.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">) &amp;&amp; b </span><span class="s1">instanceof </span><span class="s0">AST_Do)</span>
            <span class="s1">return </span><span class="s0">make_block(b, output);</span>
        <span class="s3">// The squeezer replaces &quot;block&quot;-s that contain only a single</span>
        <span class="s3">// statement with the statement itself; technically, the AST</span>
        <span class="s3">// is correct, but this can create problems when we output an</span>
        <span class="s3">// IF having an ELSE clause where the THEN clause ends in an</span>
        <span class="s3">// IF *without* an ELSE block (then the outer ELSE would refer</span>
        <span class="s3">// to the inner IF).  This function checks for this case and</span>
        <span class="s3">// adds the block braces if needed.</span>
        <span class="s1">if </span><span class="s0">(!b) </span><span class="s1">return </span><span class="s0">output.force_semicolon();</span>
        <span class="s1">while </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(b </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
                <span class="s1">if </span><span class="s0">(!b.alternative) {</span>
                    <span class="s0">make_block(self.body, output);</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">b = b.alternative;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(b </span><span class="s1">instanceof </span><span class="s0">AST_StatementWithBody) {</span>
                <span class="s0">b = b.body;</span>
            <span class="s0">} </span><span class="s1">else break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">print_maybe_braced_body(self.body, output);</span>
    <span class="s0">}</span>
    <span class="s0">DEFPRINT(AST_If, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;if&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.condition.print(output);</span>
        <span class="s0">});</span>
        <span class="s0">output.space();</span>
        <span class="s1">if </span><span class="s0">(self.alternative) {</span>
            <span class="s0">make_then(self, output);</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(</span><span class="s2">&quot;else&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
            <span class="s1">if </span><span class="s0">(self.alternative </span><span class="s1">instanceof </span><span class="s0">AST_If)</span>
                <span class="s0">self.alternative.print(output);</span>
            <span class="s1">else</span>
                <span class="s0">print_maybe_braced_body(self.alternative, output);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">self._do_print_body(output);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ switch ]----- */</span>
    <span class="s0">DEFPRINT(AST_Switch, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;switch&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.expression.print(output);</span>
        <span class="s0">});</span>
        <span class="s0">output.space();</span>
        <span class="s1">var </span><span class="s0">last = self.body.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(last &lt; </span><span class="s4">0</span><span class="s0">) print_braced_empty(self, output);</span>
        <span class="s1">else </span><span class="s0">output.with_block(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.body.forEach(</span><span class="s1">function</span><span class="s0">(branch, i) {</span>
                <span class="s0">output.indent(</span><span class="s1">true</span><span class="s0">);</span>
                <span class="s0">branch.print(output);</span>
                <span class="s1">if </span><span class="s0">(i &lt; last &amp;&amp; branch.body.length &gt; </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s0">output.newline();</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s0">AST_SwitchBranch.DEFMETHOD(</span><span class="s2">&quot;_do_print_body&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s0">output.newline();</span>
        <span class="s1">this</span><span class="s0">.body.forEach(</span><span class="s1">function</span><span class="s0">(stmt) {</span>
            <span class="s0">output.indent();</span>
            <span class="s0">stmt.print(output);</span>
            <span class="s0">output.newline();</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Default, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;default:&quot;</span><span class="s0">);</span>
        <span class="s0">self._do_print_body(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Case, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;case&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">self.expression.print(output);</span>
        <span class="s0">output.print(</span><span class="s2">&quot;:&quot;</span><span class="s0">);</span>
        <span class="s0">self._do_print_body(output);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ exceptions ]----- */</span>
    <span class="s0">DEFPRINT(AST_Try, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;try&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">self.body.print(output);</span>
        <span class="s1">if </span><span class="s0">(self.bcatch) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">self.bcatch.print(output);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.bfinally) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">self.bfinally.print(output);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_TryBlock, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">print_braced(self, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Catch, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;catch&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(self.argname) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s0">self.argname.print(output);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">output.space();</span>
        <span class="s0">print_braced(self, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Finally, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;finally&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">print_braced(self, output);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ var/const ]----- */</span>
    <span class="s0">AST_Definitions.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output, kind) {</span>
        <span class="s0">output.print(kind);</span>
        <span class="s0">output.space();</span>
        <span class="s1">this</span><span class="s0">.definitions.forEach(</span><span class="s1">function</span><span class="s0">(def, i) {</span>
            <span class="s1">if </span><span class="s0">(i) output.comma();</span>
            <span class="s0">def.print(output);</span>
        <span class="s0">});</span>
        <span class="s1">var </span><span class="s0">p = output.parent();</span>
        <span class="s1">var </span><span class="s0">in_for = p </span><span class="s1">instanceof </span><span class="s0">AST_For || p </span><span class="s1">instanceof </span><span class="s0">AST_ForIn;</span>
        <span class="s1">var </span><span class="s0">output_semicolon = !in_for || p &amp;&amp; p.init !== </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(output_semicolon)</span>
            <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Let, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output, </span><span class="s2">&quot;let&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Var, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output, </span><span class="s2">&quot;var&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Const, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output, </span><span class="s2">&quot;const&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Import, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;import&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s1">if </span><span class="s0">(self.imported_name) {</span>
            <span class="s0">self.imported_name.print(output);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.imported_name &amp;&amp; self.imported_names) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.imported_names) {</span>
            <span class="s1">if </span><span class="s0">(self.imported_names.length === </span><span class="s4">1 </span><span class="s0">&amp;&amp;</span>
                <span class="s0">self.imported_names[</span><span class="s4">0</span><span class="s0">].foreign_name.name === </span><span class="s2">&quot;*&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">!self.imported_names[</span><span class="s4">0</span><span class="s0">].foreign_name.quote) {</span>
                <span class="s0">self.imported_names[</span><span class="s4">0</span><span class="s0">].print(output);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.print(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
                <span class="s0">self.imported_names.forEach(</span><span class="s1">function </span><span class="s0">(name_import, i) {</span>
                    <span class="s0">output.space();</span>
                    <span class="s0">name_import.print(output);</span>
                    <span class="s1">if </span><span class="s0">(i &lt; self.imported_names.length - </span><span class="s4">1</span><span class="s0">) {</span>
                        <span class="s0">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s0">output.space();</span>
                <span class="s0">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.imported_name || self.imported_names) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(</span><span class="s2">&quot;from&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s0">self.module_name.print(output);</span>
        <span class="s1">if </span><span class="s0">(self.assert_clause) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;assert&quot;</span><span class="s0">);</span>
            <span class="s0">self.assert_clause.print(output);</span>
        <span class="s0">}</span>
        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ImportMeta, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;import.meta&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_NameMapping, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">is_import = output.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Import;</span>
        <span class="s1">var </span><span class="s0">definition = self.name.definition();</span>
        <span class="s1">var </span><span class="s0">foreign_name = self.foreign_name;</span>
        <span class="s1">var </span><span class="s0">names_are_different =</span>
            <span class="s0">(definition &amp;&amp; definition.mangled_name || self.name.name) !==</span>
            <span class="s0">foreign_name.name;</span>
        <span class="s1">if </span><span class="s0">(!names_are_different &amp;&amp;</span>
            <span class="s0">foreign_name.name === </span><span class="s2">&quot;*&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">foreign_name.quote != self.name.quote) {</span>
                <span class="s3">// export * as &quot;*&quot;</span>
            <span class="s0">names_are_different = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">foreign_name_is_name = foreign_name.quote == </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(names_are_different) {</span>
            <span class="s1">if </span><span class="s0">(is_import) {</span>
                <span class="s1">if </span><span class="s0">(foreign_name_is_name) {</span>
                    <span class="s0">output.print(foreign_name.name);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">output.print_string(foreign_name.name, foreign_name.quote);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(self.name.quote == </span><span class="s1">null</span><span class="s0">) {</span>
                    <span class="s0">self.name.print(output);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">output.print_string(self.name.name, self.name.quote);</span>
                <span class="s0">}</span>
                
            <span class="s0">}</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(</span><span class="s2">&quot;as&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
            <span class="s1">if </span><span class="s0">(is_import) {</span>
                <span class="s0">self.name.print(output);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(foreign_name_is_name) {</span>
                    <span class="s0">output.print(foreign_name.name);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">output.print_string(foreign_name.name, foreign_name.quote);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(self.name.quote == </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">self.name.print(output);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.print_string(self.name.name, self.name.quote);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">DEFPRINT(AST_Export, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;export&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s1">if </span><span class="s0">(self.is_default) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;default&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.exported_names) {</span>
            <span class="s1">if </span><span class="s0">(self.exported_names.length === </span><span class="s4">1 </span><span class="s0">&amp;&amp;</span>
                <span class="s0">self.exported_names[</span><span class="s4">0</span><span class="s0">].name.name === </span><span class="s2">&quot;*&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">!self.exported_names[</span><span class="s4">0</span><span class="s0">].name.quote) {</span>
                    <span class="s0">self.exported_names[</span><span class="s4">0</span><span class="s0">].print(output);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.print(</span><span class="s2">&quot;{&quot;</span><span class="s0">);</span>
                <span class="s0">self.exported_names.forEach(</span><span class="s1">function</span><span class="s0">(name_export, i) {</span>
                    <span class="s0">output.space();</span>
                    <span class="s0">name_export.print(output);</span>
                    <span class="s1">if </span><span class="s0">(i &lt; self.exported_names.length - </span><span class="s4">1</span><span class="s0">) {</span>
                        <span class="s0">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s0">output.space();</span>
                <span class="s0">output.print(</span><span class="s2">&quot;}&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.exported_value) {</span>
            <span class="s0">self.exported_value.print(output);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.exported_definition) {</span>
            <span class="s0">self.exported_definition.print(output);</span>
            <span class="s1">if </span><span class="s0">(self.exported_definition </span><span class="s1">instanceof </span><span class="s0">AST_Definitions) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.module_name) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(</span><span class="s2">&quot;from&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
            <span class="s0">self.module_name.print(output);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.assert_clause) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;assert&quot;</span><span class="s0">);</span>
            <span class="s0">self.assert_clause.print(output);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.exported_value</span>
                <span class="s0">&amp;&amp; !(self.exported_value </span><span class="s1">instanceof </span><span class="s0">AST_Defun ||</span>
                    <span class="s0">self.exported_value </span><span class="s1">instanceof </span><span class="s0">AST_Function ||</span>
                    <span class="s0">self.exported_value </span><span class="s1">instanceof </span><span class="s0">AST_Class)</span>
            <span class="s0">|| self.module_name</span>
            <span class="s0">|| self.exported_names</span>
        <span class="s0">) {</span>
            <span class="s0">output.semicolon();</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">parenthesize_for_noin(node, output, noin) {</span>
        <span class="s1">var </span><span class="s0">parens = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s3">// need to take some precautions here:</span>
        <span class="s3">//    https://github.com/mishoo/UglifyJS2/issues/60</span>
        <span class="s1">if </span><span class="s0">(noin) {</span>
            <span class="s0">parens = walk(node, node =&gt; {</span>
                <span class="s3">// Don't go into scopes -- except arrow functions:</span>
                <span class="s3">// https://github.com/terser/terser/issues/1019#issuecomment-877642607</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_Arrow)) {</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span>
                    <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; node.operator == </span><span class="s2">&quot;in&quot;</span>
                    <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateIn</span>
                <span class="s0">) {</span>
                    <span class="s1">return </span><span class="s0">walk_abort;  </span><span class="s3">// makes walk() return true</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">node.print(output, parens);</span>
    <span class="s0">}</span>

    <span class="s0">DEFPRINT(AST_VarDef, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.name.print(output);</span>
        <span class="s1">if </span><span class="s0">(self.value) {</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(</span><span class="s2">&quot;=&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
            <span class="s1">var </span><span class="s0">p = output.parent(</span><span class="s4">1</span><span class="s0">);</span>
            <span class="s1">var </span><span class="s0">noin = p </span><span class="s1">instanceof </span><span class="s0">AST_For || p </span><span class="s1">instanceof </span><span class="s0">AST_ForIn;</span>
            <span class="s0">parenthesize_for_noin(self.value, output, noin);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ other expressions ]----- */</span>
    <span class="s0">DEFPRINT(AST_Call, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.expression.print(output);</span>
        <span class="s1">if </span><span class="s0">(self </span><span class="s1">instanceof </span><span class="s0">AST_New &amp;&amp; self.args.length === </span><span class="s4">0</span><span class="s0">)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(self.expression </span><span class="s1">instanceof </span><span class="s0">AST_Call || self.expression </span><span class="s1">instanceof </span><span class="s0">AST_Lambda) {</span>
            <span class="s0">output.add_mapping(self.start);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.optional) output.print(</span><span class="s2">&quot;?.&quot;</span><span class="s0">);</span>
        <span class="s0">output.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.args.forEach(</span><span class="s1">function</span><span class="s0">(expr, i) {</span>
                <span class="s1">if </span><span class="s0">(i) output.comma();</span>
                <span class="s0">expr.print(output);</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_New, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;new&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">AST_Call.prototype._codegen(self, output);</span>
    <span class="s0">});</span>

    <span class="s0">AST_Sequence.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">this</span><span class="s0">.expressions.forEach(</span><span class="s1">function</span><span class="s0">(node, index) {</span>
            <span class="s1">if </span><span class="s0">(index &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">output.comma();</span>
                <span class="s1">if </span><span class="s0">(output.should_break()) {</span>
                    <span class="s0">output.newline();</span>
                    <span class="s0">output.indent();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">node.print(output);</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Sequence, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output);</span>
        <span class="s3">// var p = output.parent();</span>
        <span class="s3">// if (p instanceof AST_Statement) {</span>
        <span class="s3">//     output.with_indent(output.next_indent(), function(){</span>
        <span class="s3">//         self._do_print(output);</span>
        <span class="s3">//     });</span>
        <span class="s3">// } else {</span>
        <span class="s3">//     self._do_print(output);</span>
        <span class="s3">// }</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Dot, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">expr = self.expression;</span>
        <span class="s0">expr.print(output);</span>
        <span class="s1">var </span><span class="s0">prop = self.property;</span>
        <span class="s1">var </span><span class="s0">print_computed = ALL_RESERVED_WORDS.has(prop)</span>
            <span class="s0">? output.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">)</span>
            <span class="s0">: !is_identifier_string(</span>
                <span class="s0">prop,</span>
                <span class="s0">output.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">) &gt;= </span><span class="s4">2015 </span><span class="s0">&amp;&amp; !output.option(</span><span class="s2">&quot;safari10&quot;</span><span class="s0">)</span>
            <span class="s0">);</span>

        <span class="s1">if </span><span class="s0">(self.optional) output.print(</span><span class="s2">&quot;?.&quot;</span><span class="s0">);</span>

        <span class="s1">if </span><span class="s0">(print_computed) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;[&quot;</span><span class="s0">);</span>
            <span class="s0">output.add_mapping(self.end);</span>
            <span class="s0">output.print_string(prop);</span>
            <span class="s0">output.print(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Number &amp;&amp; expr.getValue() &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(!/[xa-f.)]/i.test(output.last())) {</span>
                    <span class="s0">output.print(</span><span class="s2">&quot;.&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!self.optional) output.print(</span><span class="s2">&quot;.&quot;</span><span class="s0">);</span>
            <span class="s3">// the name after dot would be mapped about here.</span>
            <span class="s0">output.add_mapping(self.end);</span>
            <span class="s0">output.print_name(prop);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_DotHash, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">expr = self.expression;</span>
        <span class="s0">expr.print(output);</span>
        <span class="s1">var </span><span class="s0">prop = self.property;</span>

        <span class="s1">if </span><span class="s0">(self.optional) output.print(</span><span class="s2">&quot;?&quot;</span><span class="s0">);</span>
        <span class="s0">output.print(</span><span class="s2">&quot;.#&quot;</span><span class="s0">);</span>
        <span class="s0">output.add_mapping(self.end);</span>
        <span class="s0">output.print_name(prop);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Sub, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.expression.print(output);</span>
        <span class="s1">if </span><span class="s0">(self.optional) output.print(</span><span class="s2">&quot;?.&quot;</span><span class="s0">);</span>
        <span class="s0">output.print(</span><span class="s2">&quot;[&quot;</span><span class="s0">);</span>
        <span class="s0">self.property.print(output);</span>
        <span class="s0">output.print(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Chain, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.expression.print(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_UnaryPrefix, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">op = self.operator;</span>
        <span class="s1">if </span><span class="s0">(op === </span><span class="s2">&quot;--&quot; </span><span class="s0">&amp;&amp; output.last().endsWith(</span><span class="s2">&quot;!&quot;</span><span class="s0">)) {</span>
            <span class="s3">// avoid printing &quot;&lt;!--&quot;</span>
            <span class="s0">output.print(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">output.print(op);</span>
        <span class="s1">if </span><span class="s0">(/^[a-z]/i.test(op)</span>
            <span class="s0">|| (/[+-]$/.test(op)</span>
                <span class="s0">&amp;&amp; self.expression </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
                <span class="s0">&amp;&amp; /^[+-]/.test(self.expression.operator))) {</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s0">self.expression.print(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_UnaryPostfix, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.expression.print(output);</span>
        <span class="s0">output.print(self.operator);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Binary, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">op = self.operator;</span>
        <span class="s0">self.left.print(output);</span>
        <span class="s1">if </span><span class="s0">(op[</span><span class="s4">0</span><span class="s0">] == </span><span class="s2">&quot;&gt;&quot; </span><span class="s3">/* &quot;&gt;&gt;&quot; &quot;&gt;&gt;&gt;&quot; &quot;&gt;&quot; &quot;&gt;=&quot; */</span>
            <span class="s0">&amp;&amp; output.last().endsWith(</span><span class="s2">&quot;--&quot;</span><span class="s0">)) {</span>
            <span class="s3">// space is mandatory to avoid outputting --&gt;</span>
            <span class="s0">output.print(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// the space is optional depending on &quot;beautify&quot;</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s0">output.print(op);</span>
        <span class="s0">output.space();</span>
        <span class="s0">self.right.print(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Conditional, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.condition.print(output);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.print(</span><span class="s2">&quot;?&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">self.consequent.print(output);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.colon();</span>
        <span class="s0">self.alternative.print(output);</span>
    <span class="s0">});</span>

    <span class="s3">/* -----[ literals ]----- */</span>
    <span class="s0">DEFPRINT(AST_Array, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.with_square(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">a = self.elements, len = a.length;</span>
            <span class="s1">if </span><span class="s0">(len &gt; </span><span class="s4">0</span><span class="s0">) output.space();</span>
            <span class="s0">a.forEach(</span><span class="s1">function</span><span class="s0">(exp, i) {</span>
                <span class="s1">if </span><span class="s0">(i) output.comma();</span>
                <span class="s0">exp.print(output);</span>
                <span class="s3">// If the final element is a hole, we need to make sure it</span>
                <span class="s3">// doesn't look like a trailing comma, by inserting an actual</span>
                <span class="s3">// trailing comma.</span>
                <span class="s1">if </span><span class="s0">(i === len - </span><span class="s4">1 </span><span class="s0">&amp;&amp; exp </span><span class="s1">instanceof </span><span class="s0">AST_Hole)</span>
                  <span class="s0">output.comma();</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(len &gt; </span><span class="s4">0</span><span class="s0">) output.space();</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Object, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">if </span><span class="s0">(self.properties.length &gt; </span><span class="s4">0</span><span class="s0">) output.with_block(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.properties.forEach(</span><span class="s1">function</span><span class="s0">(prop, i) {</span>
                <span class="s1">if </span><span class="s0">(i) {</span>
                    <span class="s0">output.print(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span>
                    <span class="s0">output.newline();</span>
                <span class="s0">}</span>
                <span class="s0">output.indent();</span>
                <span class="s0">prop.print(output);</span>
            <span class="s0">});</span>
            <span class="s0">output.newline();</span>
        <span class="s0">});</span>
        <span class="s1">else </span><span class="s0">print_braced_empty(self, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Class, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;class&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s1">if </span><span class="s0">(self.name) {</span>
            <span class="s0">self.name.print(output);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.extends) {</span>
            <span class="s1">var </span><span class="s0">parens = (</span>
                   <span class="s0">!(self.extends </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef)</span>
                <span class="s0">&amp;&amp; !(self.extends </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess)</span>
                <span class="s0">&amp;&amp; !(self.extends </span><span class="s1">instanceof </span><span class="s0">AST_ClassExpression)</span>
                <span class="s0">&amp;&amp; !(self.extends </span><span class="s1">instanceof </span><span class="s0">AST_Function)</span>
            <span class="s0">);</span>
            <span class="s0">output.print(</span><span class="s2">&quot;extends&quot;</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(parens) {</span>
                <span class="s0">output.print(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.space();</span>
            <span class="s0">}</span>
            <span class="s0">self.extends.print(output);</span>
            <span class="s1">if </span><span class="s0">(parens) {</span>
                <span class="s0">output.print(</span><span class="s2">&quot;)&quot;</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.space();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.properties.length &gt; </span><span class="s4">0</span><span class="s0">) output.with_block(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">self.properties.forEach(</span><span class="s1">function</span><span class="s0">(prop, i) {</span>
                <span class="s1">if </span><span class="s0">(i) {</span>
                    <span class="s0">output.newline();</span>
                <span class="s0">}</span>
                <span class="s0">output.indent();</span>
                <span class="s0">prop.print(output);</span>
            <span class="s0">});</span>
            <span class="s0">output.newline();</span>
        <span class="s0">});</span>
        <span class="s1">else </span><span class="s0">output.print(</span><span class="s2">&quot;{}&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_NewTarget, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;new.target&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s3">/** Prints a prop name. Returns whether it can be used as a shorthand. */</span>
    <span class="s1">function </span><span class="s0">print_property_name(key, quote, output) {</span>
        <span class="s1">if </span><span class="s0">(output.option(</span><span class="s2">&quot;quote_keys&quot;</span><span class="s0">)) {</span>
            <span class="s0">output.print_string(key);</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;&quot; </span><span class="s0">+ +key == key &amp;&amp; key &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(output.option(</span><span class="s2">&quot;keep_numbers&quot;</span><span class="s0">)) {</span>
                <span class="s0">output.print(key);</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">output.print(make_num(key));</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">print_string = ALL_RESERVED_WORDS.has(key)</span>
            <span class="s0">? output.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">)</span>
            <span class="s0">: (</span>
                <span class="s0">output.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">) &lt; </span><span class="s4">2015 </span><span class="s0">|| output.option(</span><span class="s2">&quot;safari10&quot;</span><span class="s0">)</span>
                    <span class="s0">? !is_basic_identifier_string(key)</span>
                    <span class="s0">: !is_identifier_string(key, </span><span class="s1">true</span><span class="s0">)</span>
            <span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(print_string || (quote &amp;&amp; output.option(</span><span class="s2">&quot;keep_quoted_props&quot;</span><span class="s0">))) {</span>
            <span class="s0">output.print_string(key, quote);</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">output.print_name(key);</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">DEFPRINT(AST_ObjectKeyVal, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">function </span><span class="s0">get_name(self) {</span>
            <span class="s1">var </span><span class="s0">def = self.definition();</span>
            <span class="s1">return </span><span class="s0">def ? def.mangled_name || def.name : self.name;</span>
        <span class="s0">}</span>

        <span class="s0">const try_shorthand = output.option(</span><span class="s2">&quot;shorthand&quot;</span><span class="s0">) &amp;&amp; !(self.key </span><span class="s1">instanceof </span><span class="s0">AST_Node);</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">try_shorthand</span>
            <span class="s0">&amp;&amp; self.value </span><span class="s1">instanceof </span><span class="s0">AST_Symbol</span>
            <span class="s0">&amp;&amp; get_name(self.value) === self.key</span>
            <span class="s0">&amp;&amp; !ALL_RESERVED_WORDS.has(self.key)</span>
        <span class="s0">) {</span>
            <span class="s0">const was_shorthand = print_property_name(self.key, self.quote, output);</span>
            <span class="s1">if </span><span class="s0">(!was_shorthand) {</span>
                <span class="s0">output.colon();</span>
                <span class="s0">self.value.print(output);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
            <span class="s0">try_shorthand</span>
            <span class="s0">&amp;&amp; self.value </span><span class="s1">instanceof </span><span class="s0">AST_DefaultAssign</span>
            <span class="s0">&amp;&amp; self.value.left </span><span class="s1">instanceof </span><span class="s0">AST_Symbol</span>
            <span class="s0">&amp;&amp; get_name(self.value.left) === self.key</span>
        <span class="s0">) {</span>
            <span class="s0">const was_shorthand = print_property_name(self.key, self.quote, output);</span>
            <span class="s1">if </span><span class="s0">(!was_shorthand) {</span>
                <span class="s0">output.colon();</span>
                <span class="s0">self.value.left.print(output);</span>
            <span class="s0">}</span>
            <span class="s0">output.space();</span>
            <span class="s0">output.print(</span><span class="s2">&quot;=&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
            <span class="s0">self.value.right.print(output);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(!(self.key </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
                <span class="s0">print_property_name(self.key, self.quote, output);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">output.with_square(</span><span class="s1">function</span><span class="s0">() {</span>
                    <span class="s0">self.key.print(output);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">output.colon();</span>
            <span class="s0">self.value.print(output);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ClassPrivateProperty, (self, output) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(self.static) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;static&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>

        <span class="s0">output.print(</span><span class="s2">&quot;#&quot;</span><span class="s0">);</span>
        
        <span class="s0">print_property_name(self.key.name, self.quote, output);</span>

        <span class="s1">if </span><span class="s0">(self.value) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;=&quot;</span><span class="s0">);</span>
            <span class="s0">self.value.print(output);</span>
        <span class="s0">}</span>

        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ClassProperty, (self, output) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(self.static) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;static&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(self.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolClassProperty) {</span>
            <span class="s0">print_property_name(self.key.name, self.quote, output);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">output.print(</span><span class="s2">&quot;[&quot;</span><span class="s0">);</span>
            <span class="s0">self.key.print(output);</span>
            <span class="s0">output.print(</span><span class="s2">&quot;]&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(self.value) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;=&quot;</span><span class="s0">);</span>
            <span class="s0">self.value.print(output);</span>
        <span class="s0">}</span>

        <span class="s0">output.semicolon();</span>
    <span class="s0">});</span>
    <span class="s0">AST_ObjectProperty.DEFMETHOD(</span><span class="s2">&quot;_print_getter_setter&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(type, is_private, output) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(self.static) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot;static&quot;</span><span class="s0">);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(type) {</span>
            <span class="s0">output.print(type);</span>
            <span class="s0">output.space();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod) {</span>
            <span class="s1">if </span><span class="s0">(is_private) output.print(</span><span class="s2">&quot;#&quot;</span><span class="s0">);</span>
            <span class="s0">print_property_name(self.key.name, self.quote, output);</span>
            <span class="s0">self.key.add_source_map(output);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">output.with_square(</span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s0">self.key.print(output);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">self.value._do_print(output, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ObjectSetter, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._print_getter_setter(</span><span class="s2">&quot;set&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ObjectGetter, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._print_getter_setter(</span><span class="s2">&quot;get&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_PrivateSetter, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._print_getter_setter(</span><span class="s2">&quot;set&quot;</span><span class="s0">, </span><span class="s1">true</span><span class="s0">, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_PrivateGetter, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self._print_getter_setter(</span><span class="s2">&quot;get&quot;</span><span class="s0">, </span><span class="s1">true</span><span class="s0">, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_PrivateMethod, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">type;</span>
        <span class="s1">if </span><span class="s0">(self.is_generator &amp;&amp; self.async) {</span>
            <span class="s0">type = </span><span class="s2">&quot;async*&quot;</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.is_generator) {</span>
            <span class="s0">type = </span><span class="s2">&quot;*&quot;</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.async) {</span>
            <span class="s0">type = </span><span class="s2">&quot;async&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">self._print_getter_setter(type, </span><span class="s1">true</span><span class="s0">, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_PrivateIn, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">self.key.print(output);</span>
        <span class="s0">output.space();</span>
        <span class="s0">output.print(</span><span class="s2">&quot;in&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">self.value.print(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_SymbolPrivateProperty, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;#&quot; </span><span class="s0">+ self.name);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ConciseMethod, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">var </span><span class="s0">type;</span>
        <span class="s1">if </span><span class="s0">(self.is_generator &amp;&amp; self.async) {</span>
            <span class="s0">type = </span><span class="s2">&quot;async*&quot;</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.is_generator) {</span>
            <span class="s0">type = </span><span class="s2">&quot;*&quot;</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.async) {</span>
            <span class="s0">type = </span><span class="s2">&quot;async&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">self._print_getter_setter(type, </span><span class="s1">false</span><span class="s0">, output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_ClassStaticBlock, </span><span class="s1">function </span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;static&quot;</span><span class="s0">);</span>
        <span class="s0">output.space();</span>
        <span class="s0">print_braced(self, output);</span>
    <span class="s0">});</span>
    <span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;_do_print&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s1">var </span><span class="s0">def = </span><span class="s1">this</span><span class="s0">.definition();</span>
        <span class="s0">output.print_name(def ? def.mangled_name || def.name : </span><span class="s1">this</span><span class="s0">.name);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Symbol, </span><span class="s1">function </span><span class="s0">(self, output) {</span>
        <span class="s0">self._do_print(output);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Hole, noop);</span>
    <span class="s0">DEFPRINT(AST_This, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;this&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Super, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(</span><span class="s2">&quot;super&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Constant, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(self.getValue());</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_String, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print_string(self.getValue(), self.quote, output.in_directive);</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_Number, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s1">if </span><span class="s0">((output.option(</span><span class="s2">&quot;keep_numbers&quot;</span><span class="s0">) || output.use_asm) &amp;&amp; self.raw) {</span>
            <span class="s0">output.print(self.raw);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">output.print(make_num(self.getValue()));</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s0">DEFPRINT(AST_BigInt, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">output.print(self.getValue() + </span><span class="s2">&quot;n&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">const r_slash_script = /(&lt;\s*\/\s*script)/i;</span>
    <span class="s0">const r_starts_with_script = /^\s*script/i;</span>
    <span class="s0">const slash_script_replace = (_, $1) =&gt; $1.replace(</span><span class="s2">&quot;/&quot;</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">/&quot;</span><span class="s0">);</span>
    <span class="s0">DEFPRINT(AST_RegExp, </span><span class="s1">function</span><span class="s0">(self, output) {</span>
        <span class="s0">let { source, flags } = self.getValue();</span>
        <span class="s0">source = regexp_source_fix(source);</span>
        <span class="s0">flags = flags ? sort_regexp_flags(flags) : </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>

        <span class="s3">// Avoid outputting end of script tag</span>
        <span class="s0">source = source.replace(r_slash_script, slash_script_replace);</span>
        <span class="s1">if </span><span class="s0">(r_starts_with_script.test(source) &amp;&amp; output.last().endsWith(</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">)) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s0">output.print(output.to_utf8(`/${source}/${flags}`, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">));</span>

        <span class="s0">const parent = output.parent();</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">parent </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
            <span class="s0">&amp;&amp; /^\w/.test(parent.operator)</span>
            <span class="s0">&amp;&amp; parent.left === self</span>
        <span class="s0">) {</span>
            <span class="s0">output.print(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s3">/** if, for, while, may or may not have braces surrounding its body */</span>
    <span class="s1">function </span><span class="s0">print_maybe_braced_body(stat, output) {</span>
        <span class="s1">if </span><span class="s0">(output.option(</span><span class="s2">&quot;braces&quot;</span><span class="s0">)) {</span>
            <span class="s0">make_block(stat, output);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(!stat || stat </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement)</span>
                <span class="s0">output.force_semicolon();</span>
            <span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Let || stat </span><span class="s1">instanceof </span><span class="s0">AST_Const || stat </span><span class="s1">instanceof </span><span class="s0">AST_Class)</span>
                <span class="s0">make_block(stat, output);</span>
            <span class="s1">else</span>
                <span class="s0">stat.print(output);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">best_of(a) {</span>
        <span class="s1">var </span><span class="s0">best = a[</span><span class="s4">0</span><span class="s0">], len = best.length;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; a.length; ++i) {</span>
            <span class="s1">if </span><span class="s0">(a[i].length &lt; len) {</span>
                <span class="s0">best = a[i];</span>
                <span class="s0">len = best.length;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">best;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">make_num(num) {</span>
        <span class="s1">var </span><span class="s0">str = num.toString(</span><span class="s4">10</span><span class="s0">).replace(/^</span><span class="s4">0</span><span class="s0">\./, </span><span class="s2">&quot;.&quot;</span><span class="s0">).replace(</span><span class="s2">&quot;e+&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">candidates = [ str ];</span>
        <span class="s1">if </span><span class="s0">(Math.floor(num) === num) {</span>
            <span class="s1">if </span><span class="s0">(num &lt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">candidates.push(</span><span class="s2">&quot;-0x&quot; </span><span class="s0">+ (-num).toString(</span><span class="s4">16</span><span class="s0">).toLowerCase());</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">candidates.push(</span><span class="s2">&quot;0x&quot; </span><span class="s0">+ num.toString(</span><span class="s4">16</span><span class="s0">).toLowerCase());</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">match, len, digits;</span>
        <span class="s1">if </span><span class="s0">(match = /^\.</span><span class="s4">0</span><span class="s0">+/.exec(str)) {</span>
            <span class="s0">len = match[</span><span class="s4">0</span><span class="s0">].length;</span>
            <span class="s0">digits = str.slice(len);</span>
            <span class="s0">candidates.push(digits + </span><span class="s2">&quot;e-&quot; </span><span class="s0">+ (digits.length + len - </span><span class="s4">1</span><span class="s0">));</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(match = /</span><span class="s4">0</span><span class="s0">+$/.exec(str)) {</span>
            <span class="s0">len = match[</span><span class="s4">0</span><span class="s0">].length;</span>
            <span class="s0">candidates.push(str.slice(</span><span class="s4">0</span><span class="s0">, -len) + </span><span class="s2">&quot;e&quot; </span><span class="s0">+ len);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(match = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {</span>
            <span class="s0">candidates.push(match[</span><span class="s4">1</span><span class="s0">] + match[</span><span class="s4">2</span><span class="s0">] + </span><span class="s2">&quot;e&quot; </span><span class="s0">+ (match[</span><span class="s4">3</span><span class="s0">] - match[</span><span class="s4">2</span><span class="s0">].length));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">best_of(candidates);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">make_block(stmt, output) {</span>
        <span class="s1">if </span><span class="s0">(!stmt || stmt </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement)</span>
            <span class="s0">output.print(</span><span class="s2">&quot;{}&quot;</span><span class="s0">);</span>
        <span class="s1">else if </span><span class="s0">(stmt </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement)</span>
            <span class="s0">stmt.print(output);</span>
        <span class="s1">else </span><span class="s0">output.with_block(</span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s0">output.indent();</span>
            <span class="s0">stmt.print(output);</span>
            <span class="s0">output.newline();</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">/* -----[ source map generators ]----- */</span>

    <span class="s1">function </span><span class="s0">DEFMAP(nodetype, generator) {</span>
        <span class="s0">nodetype.forEach(</span><span class="s1">function</span><span class="s0">(nodetype) {</span>
            <span class="s0">nodetype.DEFMETHOD(</span><span class="s2">&quot;add_source_map&quot;</span><span class="s0">, generator);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s0">DEFMAP([</span>
        <span class="s3">// We could easily add info for ALL nodes, but it seems to me that</span>
        <span class="s3">// would be quite wasteful, hence this noop in the base class.</span>
        <span class="s0">AST_Node,</span>
        <span class="s3">// since the label symbol will mark it</span>
        <span class="s0">AST_LabeledStatement,</span>
        <span class="s0">AST_Toplevel,</span>
    <span class="s0">], noop);</span>

    <span class="s3">// XXX: I'm not exactly sure if we need it for all of these nodes,</span>
    <span class="s3">// or if we should add even more.</span>
    <span class="s0">DEFMAP([</span>
        <span class="s0">AST_Array,</span>
        <span class="s0">AST_BlockStatement,</span>
        <span class="s0">AST_Catch,</span>
        <span class="s0">AST_Class,</span>
        <span class="s0">AST_Constant,</span>
        <span class="s0">AST_Debugger,</span>
        <span class="s0">AST_Definitions,</span>
        <span class="s0">AST_Directive,</span>
        <span class="s0">AST_Finally,</span>
        <span class="s0">AST_Jump,</span>
        <span class="s0">AST_Lambda,</span>
        <span class="s0">AST_New,</span>
        <span class="s0">AST_Object,</span>
        <span class="s0">AST_StatementWithBody,</span>
        <span class="s0">AST_Symbol,</span>
        <span class="s0">AST_Switch,</span>
        <span class="s0">AST_SwitchBranch,</span>
        <span class="s0">AST_TemplateString,</span>
        <span class="s0">AST_TemplateSegment,</span>
        <span class="s0">AST_Try,</span>
    <span class="s0">], </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s0">output.add_mapping(</span><span class="s1">this</span><span class="s0">.start);</span>
    <span class="s0">});</span>

    <span class="s0">DEFMAP([</span>
        <span class="s0">AST_ObjectGetter,</span>
        <span class="s0">AST_ObjectSetter,</span>
        <span class="s0">AST_PrivateGetter,</span>
        <span class="s0">AST_PrivateSetter,</span>
        <span class="s0">AST_ConciseMethod,</span>
        <span class="s0">AST_PrivateMethod,</span>
    <span class="s0">], </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s0">output.add_mapping(</span><span class="s1">this</span><span class="s0">.start, </span><span class="s1">false </span><span class="s3">/*name handled below*/</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s0">DEFMAP([</span>
        <span class="s0">AST_SymbolMethod,</span>
        <span class="s0">AST_SymbolPrivateProperty</span>
    <span class="s0">], </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s0">const tok_type = </span><span class="s1">this</span><span class="s0">.end &amp;&amp; </span><span class="s1">this</span><span class="s0">.end.type;</span>
        <span class="s1">if </span><span class="s0">(tok_type === </span><span class="s2">&quot;name&quot; </span><span class="s0">|| tok_type === </span><span class="s2">&quot;privatename&quot;</span><span class="s0">) {</span>
            <span class="s0">output.add_mapping(</span><span class="s1">this</span><span class="s0">.end, </span><span class="s1">this</span><span class="s0">.name);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">output.add_mapping(</span><span class="s1">this</span><span class="s0">.end);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s0">DEFMAP([ AST_ObjectProperty ], </span><span class="s1">function</span><span class="s0">(output) {</span>
        <span class="s0">output.add_mapping(</span><span class="s1">this</span><span class="s0">.start, </span><span class="s1">this</span><span class="s0">.key);</span>
    <span class="s0">});</span>
<span class="s0">})();</span>

<span class="s0">const shallow_cmp = (node1, node2) =&gt; {</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s0">node1 === </span><span class="s1">null </span><span class="s0">&amp;&amp; node2 === </span><span class="s1">null</span>
        <span class="s0">|| node1.TYPE === node2.TYPE &amp;&amp; node1.shallow_cmp(node2)</span>
    <span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">const equivalent_to = (tree1, tree2) =&gt; {</span>
    <span class="s1">if </span><span class="s0">(!shallow_cmp(tree1, tree2)) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">const walk_1_state = [tree1];</span>
    <span class="s0">const walk_2_state = [tree2];</span>

    <span class="s0">const walk_1_push = walk_1_state.push.bind(walk_1_state);</span>
    <span class="s0">const walk_2_push = walk_2_state.push.bind(walk_2_state);</span>

    <span class="s1">while </span><span class="s0">(walk_1_state.length &amp;&amp; walk_2_state.length) {</span>
        <span class="s0">const node_1 = walk_1_state.pop();</span>
        <span class="s0">const node_2 = walk_2_state.pop();</span>

        <span class="s1">if </span><span class="s0">(!shallow_cmp(node_1, node_2)) </span><span class="s1">return false</span><span class="s0">;</span>

        <span class="s0">node_1._children_backwards(walk_1_push);</span>
        <span class="s0">node_2._children_backwards(walk_2_push);</span>

        <span class="s1">if </span><span class="s0">(walk_1_state.length !== walk_2_state.length) {</span>
            <span class="s3">// Different number of children</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">walk_1_state.length == </span><span class="s4">0 </span><span class="s0">&amp;&amp; walk_2_state.length == </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">const pass_through = () =&gt; </span><span class="s1">true</span><span class="s0">;</span>

<span class="s0">AST_Node.prototype.shallow_cmp = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;did not find a shallow_cmp function for &quot; </span><span class="s0">+ </span><span class="s1">this</span><span class="s0">.constructor.name);</span>
<span class="s0">};</span>

<span class="s0">AST_Debugger.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Directive.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.value === other.value;</span>
<span class="s0">};</span>

<span class="s0">AST_SimpleStatement.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Block.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_EmptyStatement.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_LabeledStatement.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.label.name === other.label.name;</span>
<span class="s0">};</span>

<span class="s0">AST_Do.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_While.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_For.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.init == </span><span class="s1">null </span><span class="s0">? other.init == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.init === other.init) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.condition == </span><span class="s1">null </span><span class="s0">? other.condition == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.condition === other.condition) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.step == </span><span class="s1">null </span><span class="s0">? other.step == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.step === other.step);</span>
<span class="s0">};</span>

<span class="s0">AST_ForIn.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_ForOf.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_With.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Toplevel.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Expansion.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Lambda.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.is_generator === other.is_generator &amp;&amp; </span><span class="s1">this</span><span class="s0">.async === other.async;</span>
<span class="s0">};</span>

<span class="s0">AST_Destructuring.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.is_array === other.is_array;</span>
<span class="s0">};</span>

<span class="s0">AST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_TemplateString.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_TemplateSegment.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.value === other.value;</span>
<span class="s0">};</span>

<span class="s0">AST_Jump.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_LoopControl.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Await.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Yield.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.is_star === other.is_star;</span>
<span class="s0">};</span>

<span class="s0">AST_If.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.alternative == </span><span class="s1">null </span><span class="s0">? other.alternative == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.alternative === other.alternative;</span>
<span class="s0">};</span>

<span class="s0">AST_Switch.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_SwitchBranch.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Try.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.body === other.body) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.bcatch == </span><span class="s1">null </span><span class="s0">? other.bcatch == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.bcatch === other.bcatch) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.bfinally == </span><span class="s1">null </span><span class="s0">? other.bfinally == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.bfinally === other.bfinally);</span>
<span class="s0">};</span>

<span class="s0">AST_Catch.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.argname == </span><span class="s1">null </span><span class="s0">? other.argname == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.argname === other.argname;</span>
<span class="s0">};</span>

<span class="s0">AST_Finally.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Definitions.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_VarDef.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.value == </span><span class="s1">null </span><span class="s0">? other.value == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.value === other.value;</span>
<span class="s0">};</span>

<span class="s0">AST_NameMapping.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Import.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_name == </span><span class="s1">null </span><span class="s0">? other.imported_name == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.imported_name === other.imported_name) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.imported_names == </span><span class="s1">null </span><span class="s0">? other.imported_names == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.imported_names === other.imported_names);</span>
<span class="s0">};</span>

<span class="s0">AST_ImportMeta.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Export.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_definition == </span><span class="s1">null </span><span class="s0">? other.exported_definition == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.exported_definition === other.exported_definition) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.exported_value == </span><span class="s1">null </span><span class="s0">? other.exported_value == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.exported_value === other.exported_value) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.exported_names == </span><span class="s1">null </span><span class="s0">? other.exported_names == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.exported_names === other.exported_names) &amp;&amp; </span><span class="s1">this</span><span class="s0">.module_name === other.module_name &amp;&amp; </span><span class="s1">this</span><span class="s0">.is_default === other.is_default;</span>
<span class="s0">};</span>

<span class="s0">AST_Call.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Sequence.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_PropAccess.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Chain.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Dot.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.property === other.property;</span>
<span class="s0">};</span>

<span class="s0">AST_DotHash.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.property === other.property;</span>
<span class="s0">};</span>

<span class="s0">AST_Unary.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.operator === other.operator;</span>
<span class="s0">};</span>

<span class="s0">AST_Binary.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.operator === other.operator;</span>
<span class="s0">};</span>

<span class="s0">AST_Conditional.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Array.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Object.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_ObjectProperty.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_ObjectKeyVal.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.key === other.key;</span>
<span class="s0">};</span>

<span class="s0">AST_ObjectSetter.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.static === other.static;</span>
<span class="s0">};</span>

<span class="s0">AST_ObjectGetter.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.static === other.static;</span>
<span class="s0">};</span>

<span class="s0">AST_ConciseMethod.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.static === other.static &amp;&amp; </span><span class="s1">this</span><span class="s0">.is_generator === other.is_generator &amp;&amp; </span><span class="s1">this</span><span class="s0">.async === other.async;</span>
<span class="s0">};</span>

<span class="s0">AST_Class.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name == </span><span class="s1">null </span><span class="s0">? other.name == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.name === other.name) &amp;&amp; (</span><span class="s1">this</span><span class="s0">.extends == </span><span class="s1">null </span><span class="s0">? other.extends == </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">.extends === other.extends);</span>
<span class="s0">};</span>

<span class="s0">AST_ClassProperty.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.static === other.static;</span>
<span class="s0">};</span>

<span class="s0">AST_Symbol.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.name === other.name;</span>
<span class="s0">};</span>

<span class="s0">AST_NewTarget.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_This.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_Super.prototype.shallow_cmp = pass_through;</span>

<span class="s0">AST_String.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.value === other.value;</span>
<span class="s0">};</span>

<span class="s0">AST_Number.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.value === other.value;</span>
<span class="s0">};</span>

<span class="s0">AST_BigInt.prototype.shallow_cmp = </span><span class="s1">function</span><span class="s0">(other) {</span>
    <span class="s1">return this</span><span class="s0">.value === other.value;</span>
<span class="s0">};</span>

<span class="s0">AST_RegExp.prototype.shallow_cmp = </span><span class="s1">function </span><span class="s0">(other) {</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s1">this</span><span class="s0">.value.flags === other.value.flags</span>
        <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.value.source === other.value.source</span>
    <span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">AST_Atom.prototype.shallow_cmp = pass_through;</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s0">const MASK_EXPORT_DONT_MANGLE = </span><span class="s4">1 </span><span class="s0">&lt;&lt; </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">const MASK_EXPORT_WANT_MANGLE = </span><span class="s4">1 </span><span class="s0">&lt;&lt; </span><span class="s4">1</span><span class="s0">;</span>

<span class="s0">let function_defs = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">let unmangleable_names = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s3">/** 
 * When defined, there is a function declaration somewhere that's inside of a block. 
 * See https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics 
*/</span>
<span class="s0">let scopes_with_block_defuns = </span><span class="s1">null</span><span class="s0">;</span>

<span class="s0">class SymbolDef {</span>
    <span class="s0">constructor(scope, orig, init) {</span>
        <span class="s1">this</span><span class="s0">.name = orig.name;</span>
        <span class="s1">this</span><span class="s0">.orig = [ orig ];</span>
        <span class="s1">this</span><span class="s0">.init = init;</span>
        <span class="s1">this</span><span class="s0">.eliminated = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.assignments = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.scope = scope;</span>
        <span class="s1">this</span><span class="s0">.replaced = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.global = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.export = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.mangled_name = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.undeclared = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.id = SymbolDef.next_id++;</span>
        <span class="s1">this</span><span class="s0">.chained = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.direct_access = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.escaped = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.recursive_refs = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.references = [];</span>
        <span class="s1">this</span><span class="s0">.should_replace = undefined;</span>
        <span class="s1">this</span><span class="s0">.single_use = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.fixed = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">Object.seal(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">fixed_value() {</span>
        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.fixed || </span><span class="s1">this</span><span class="s0">.fixed </span><span class="s1">instanceof </span><span class="s0">AST_Node) </span><span class="s1">return this</span><span class="s0">.fixed;</span>
        <span class="s1">return this</span><span class="s0">.fixed();</span>
    <span class="s0">}</span>
    <span class="s0">unmangleable(options) {</span>
        <span class="s1">if </span><span class="s0">(!options) options = {};</span>

        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">function_defs &amp;&amp;</span>
            <span class="s0">function_defs.has(</span><span class="s1">this</span><span class="s0">.id) &amp;&amp;</span>
            <span class="s0">keep_name(options.keep_fnames, </span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">].name)</span>
        <span class="s0">) </span><span class="s1">return true</span><span class="s0">;</span>

        <span class="s1">return this</span><span class="s0">.global &amp;&amp; !options.toplevel</span>
            <span class="s0">|| (</span><span class="s1">this</span><span class="s0">.export &amp; MASK_EXPORT_DONT_MANGLE)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.undeclared</span>
            <span class="s0">|| !options.eval &amp;&amp; </span><span class="s1">this</span><span class="s0">.scope.pinned()</span>
            <span class="s0">|| (</span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda</span>
                  <span class="s0">|| </span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun) &amp;&amp; keep_name(options.keep_fnames, </span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">].name)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod</span>
            <span class="s0">|| (</span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolClass</span>
                  <span class="s0">|| </span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefClass) &amp;&amp; keep_name(options.keep_classnames, </span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">].name);</span>
    <span class="s0">}</span>
    <span class="s0">mangle(options) {</span>
        <span class="s0">const cache = options.cache &amp;&amp; options.cache.props;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.global &amp;&amp; cache &amp;&amp; cache.has(</span><span class="s1">this</span><span class="s0">.name)) {</span>
            <span class="s1">this</span><span class="s0">.mangled_name = cache.get(</span><span class="s1">this</span><span class="s0">.name);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.mangled_name &amp;&amp; !</span><span class="s1">this</span><span class="s0">.unmangleable(options)) {</span>
            <span class="s1">var </span><span class="s0">s = </span><span class="s1">this</span><span class="s0">.scope;</span>
            <span class="s1">var </span><span class="s0">sym = </span><span class="s1">this</span><span class="s0">.orig[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(options.ie8 &amp;&amp; sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda)</span>
                <span class="s0">s = s.parent_scope;</span>
            <span class="s0">const redefinition = redefined_catch_def(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.mangled_name = redefinition</span>
                <span class="s0">? redefinition.mangled_name || redefinition.name</span>
                <span class="s0">: s.next_mangled(options, </span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.global &amp;&amp; cache) {</span>
                <span class="s0">cache.set(</span><span class="s1">this</span><span class="s0">.name, </span><span class="s1">this</span><span class="s0">.mangled_name);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">SymbolDef.next_id = </span><span class="s4">1</span><span class="s0">;</span>

<span class="s1">function </span><span class="s0">redefined_catch_def(def) {</span>
    <span class="s1">if </span><span class="s0">(def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch</span>
        <span class="s0">&amp;&amp; def.scope.is_block_scope()</span>
    <span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">def.scope.get_defun_scope().variables.get(def.name);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;figure_out_scope&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options, { parent_scope = </span><span class="s1">null</span><span class="s0">, toplevel = </span><span class="s1">this </span><span class="s0">} = {}) {</span>
    <span class="s0">options = defaults(options, {</span>
        <span class="s0">cache: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">ie8: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">safari10: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">});</span>

    <span class="s1">if </span><span class="s0">(!(toplevel </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel)) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Invalid toplevel scope&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">// pass 1: setup scope chaining and handle definitions</span>
    <span class="s1">var </span><span class="s0">scope = </span><span class="s1">this</span><span class="s0">.parent_scope = parent_scope;</span>
    <span class="s1">var </span><span class="s0">labels = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">var </span><span class="s0">defun = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">in_destructuring = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">for_scopes = [];</span>
    <span class="s1">var </span><span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker((node, descend) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node.is_block_scope()) {</span>
            <span class="s0">const save_scope = scope;</span>
            <span class="s0">node.block_scope = scope = </span><span class="s1">new </span><span class="s0">AST_Scope(node);</span>
            <span class="s0">scope._block_scope = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">scope.init_scope_vars(save_scope);</span>
            <span class="s0">scope.uses_with = save_scope.uses_with;</span>
            <span class="s0">scope.uses_eval = save_scope.uses_eval;</span>

            <span class="s1">if </span><span class="s0">(options.safari10) {</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_For || node </span><span class="s1">instanceof </span><span class="s0">AST_ForIn || node </span><span class="s1">instanceof </span><span class="s0">AST_ForOf) {</span>
                    <span class="s0">for_scopes.push(scope);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Switch) {</span>
                <span class="s3">// XXX: HACK! Ensure the switch expression gets the correct scope (the parent scope) and the body gets the contained scope</span>
                <span class="s3">// AST_Switch has a scope within the body, but it itself &quot;is a block scope&quot;</span>
                <span class="s3">// This means the switched expression has to belong to the outer scope</span>
                <span class="s3">// while the body inside belongs to the switch itself.</span>
                <span class="s3">// This is pretty nasty and warrants an AST change</span>
                <span class="s0">const the_block_scope = scope;</span>
                <span class="s0">scope = save_scope;</span>
                <span class="s0">node.expression.walk(tw);</span>
                <span class="s0">scope = the_block_scope;</span>
                <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; node.body.length; i++) {</span>
                    <span class="s0">node.body[i].walk(tw);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">descend();</span>
            <span class="s0">}</span>
            <span class="s0">scope = save_scope;</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
            <span class="s0">const save_destructuring = in_destructuring;</span>
            <span class="s0">in_destructuring = node;</span>
            <span class="s0">descend();</span>
            <span class="s0">in_destructuring = save_destructuring;</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
            <span class="s0">node.init_scope_vars(scope);</span>
            <span class="s1">var </span><span class="s0">save_scope = scope;</span>
            <span class="s1">var </span><span class="s0">save_defun = defun;</span>
            <span class="s1">var </span><span class="s0">save_labels = labels;</span>
            <span class="s0">defun = scope = node;</span>
            <span class="s0">labels = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s0">descend();</span>
            <span class="s0">scope = save_scope;</span>
            <span class="s0">defun = save_defun;</span>
            <span class="s0">labels = save_labels;</span>
            <span class="s1">return true</span><span class="s0">;        </span><span class="s3">// don't descend again in TreeWalker</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_LabeledStatement) {</span>
            <span class="s1">var </span><span class="s0">l = node.label;</span>
            <span class="s1">if </span><span class="s0">(labels.has(l.name)) {</span>
                <span class="s1">throw new </span><span class="s0">Error(string_template(</span><span class="s2">&quot;Label {name} defined twice&quot;</span><span class="s0">, l));</span>
            <span class="s0">}</span>
            <span class="s0">labels.set(l.name, l);</span>
            <span class="s0">descend();</span>
            <span class="s0">labels.</span><span class="s1">delete</span><span class="s0">(l.name);</span>
            <span class="s1">return true</span><span class="s0">;        </span><span class="s3">// no descend again</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_With) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">s = scope; s; s = s.parent_scope)</span>
                <span class="s0">s.uses_with = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) {</span>
            <span class="s0">node.scope = scope;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Label) {</span>
            <span class="s0">node.thedef = node;</span>
            <span class="s0">node.references = [];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda) {</span>
            <span class="s0">defun.def_function(node, node.name == </span><span class="s2">&quot;arguments&quot; </span><span class="s0">? undefined : defun);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun) {</span>
            <span class="s3">// Careful here, the scope where this should be defined is</span>
            <span class="s3">// the parent scope.  The reason is that we enter a new</span>
            <span class="s3">// scope when we encounter the AST_Defun node (which is</span>
            <span class="s3">// instanceof AST_Scope) but we get to the symbol a bit</span>
            <span class="s3">// later.</span>
            <span class="s0">const closest_scope = defun.parent_scope;</span>

            <span class="s3">// In strict mode, function definitions are block-scoped</span>
            <span class="s0">node.scope = tw.directives[</span><span class="s2">&quot;use strict&quot;</span><span class="s0">]</span>
                <span class="s0">? closest_scope</span>
                <span class="s0">: closest_scope.get_defun_scope();</span>

            <span class="s0">mark_export(node.scope.def_function(node, defun), </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolClass) {</span>
            <span class="s0">mark_export(defun.def_variable(node, defun), </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolImport) {</span>
            <span class="s0">scope.def_variable(node);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefClass) {</span>
            <span class="s3">// This deals with the name of the class being available</span>
            <span class="s3">// inside the class.</span>
            <span class="s0">mark_export((node.scope = defun.parent_scope).def_function(node, defun), </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolVar</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLet</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolConst</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch</span>
        <span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">def;</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolBlockDeclaration) {</span>
                <span class="s0">def = scope.def_variable(node, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">def = defun.def_variable(node, node.TYPE == </span><span class="s2">&quot;SymbolVar&quot; </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: undefined);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!def.orig.every((sym) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(sym === node) </span><span class="s1">return true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolBlockDeclaration) {</span>
                    <span class="s1">return </span><span class="s0">sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">!(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLet || sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolConst);</span>
            <span class="s0">})) {</span>
                <span class="s0">js_error(</span>
                    <span class="s0">`</span><span class="s2">&quot;${node.name}&quot; </span><span class="s0">is redeclared`,</span>
                    <span class="s0">node.start.file,</span>
                    <span class="s0">node.start.line,</span>
                    <span class="s0">node.start.col,</span>
                    <span class="s0">node.start.pos</span>
                <span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg)) mark_export(def, </span><span class="s4">2</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(defun !== scope) {</span>
                <span class="s0">node.mark_enclosed();</span>
                <span class="s1">var </span><span class="s0">def = scope.find_variable(node);</span>
                <span class="s1">if </span><span class="s0">(node.thedef !== def) {</span>
                    <span class="s0">node.thedef = def;</span>
                    <span class="s0">node.reference();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_LabelRef) {</span>
            <span class="s1">var </span><span class="s0">sym = labels.get(node.name);</span>
            <span class="s1">if </span><span class="s0">(!sym) </span><span class="s1">throw new </span><span class="s0">Error(string_template(</span><span class="s2">&quot;Undefined label {name} [{line},{col}]&quot;</span><span class="s0">, {</span>
                <span class="s0">name: node.name,</span>
                <span class="s0">line: node.start.line,</span>
                <span class="s0">col: node.start.col</span>
            <span class="s0">}));</span>
            <span class="s0">node.thedef = sym;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!(scope </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) &amp;&amp; (node </span><span class="s1">instanceof </span><span class="s0">AST_Export || node </span><span class="s1">instanceof </span><span class="s0">AST_Import)) {</span>
            <span class="s0">js_error(</span>
                <span class="s0">`</span><span class="s2">&quot;${node.TYPE}&quot; </span><span class="s0">statement may only appear at the top level`,</span>
                <span class="s0">node.start.file,</span>
                <span class="s0">node.start.line,</span>
                <span class="s0">node.start.col,</span>
                <span class="s0">node.start.pos</span>
            <span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">this</span><span class="s0">.walk(tw);</span>

    <span class="s1">function </span><span class="s0">mark_export(def, level) {</span>
        <span class="s1">if </span><span class="s0">(in_destructuring) {</span>
            <span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">do </span><span class="s0">{</span>
                <span class="s0">level++;</span>
            <span class="s0">} </span><span class="s1">while </span><span class="s0">(tw.parent(i++) !== in_destructuring);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">node = tw.parent(level);</span>
        <span class="s1">if </span><span class="s0">(def.export = node </span><span class="s1">instanceof </span><span class="s0">AST_Export ? MASK_EXPORT_DONT_MANGLE : </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">exported = node.exported_definition;</span>
            <span class="s1">if </span><span class="s0">((exported </span><span class="s1">instanceof </span><span class="s0">AST_Defun || exported </span><span class="s1">instanceof </span><span class="s0">AST_DefClass) &amp;&amp; node.is_default) {</span>
                <span class="s0">def.export = MASK_EXPORT_WANT_MANGLE;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">// pass 2: find back references and eval</span>
    <span class="s0">const is_toplevel = </span><span class="s1">this instanceof </span><span class="s0">AST_Toplevel;</span>
    <span class="s1">if </span><span class="s0">(is_toplevel) {</span>
        <span class="s1">this</span><span class="s0">.globals = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker(node =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_LoopControl &amp;&amp; node.label) {</span>
            <span class="s0">node.label.thedef.references.push(node);</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
            <span class="s1">var </span><span class="s0">name = node.name;</span>
            <span class="s1">if </span><span class="s0">(name == </span><span class="s2">&quot;eval&quot; </span><span class="s0">&amp;&amp; tw.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Call) {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">s = node.scope; s &amp;&amp; !s.uses_eval; s = s.parent_scope) {</span>
                    <span class="s0">s.uses_eval = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">sym;</span>
            <span class="s1">if </span><span class="s0">(tw.parent() </span><span class="s1">instanceof </span><span class="s0">AST_NameMapping &amp;&amp; tw.parent(</span><span class="s4">1</span><span class="s0">).module_name</span>
                <span class="s0">|| !(sym = node.scope.find_variable(name))) {</span>

                <span class="s0">sym = toplevel.def_global(node);</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sym.scope </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; name == </span><span class="s2">&quot;arguments&quot;</span><span class="s0">) {</span>
                <span class="s0">sym.scope.get_defun_scope().uses_arguments = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">node.thedef = sym;</span>
            <span class="s0">node.reference();</span>
            <span class="s1">if </span><span class="s0">(node.scope.is_block_scope()</span>
                <span class="s0">&amp;&amp; !(sym.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolBlockDeclaration)) {</span>
                <span class="s0">node.scope = node.scope.get_defun_scope();</span>
            <span class="s0">}</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// ensure mangling works if catch reuses a scope variable</span>
        <span class="s1">var </span><span class="s0">def;</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch &amp;&amp; (def = redefined_catch_def(node.definition()))) {</span>
            <span class="s1">var </span><span class="s0">s = node.scope;</span>
            <span class="s1">while </span><span class="s0">(s) {</span>
                <span class="s0">push_uniq(s.enclosed, def);</span>
                <span class="s1">if </span><span class="s0">(s === def.scope) </span><span class="s1">break</span><span class="s0">;</span>
                <span class="s0">s = s.parent_scope;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">this</span><span class="s0">.walk(tw);</span>

    <span class="s3">// pass 3: work around IE8 and Safari catch scope bugs</span>
    <span class="s1">if </span><span class="s0">(options.ie8 || options.safari10) {</span>
        <span class="s0">walk(</span><span class="s1">this</span><span class="s0">, node =&gt; {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch) {</span>
                <span class="s1">var </span><span class="s0">name = node.name;</span>
                <span class="s1">var </span><span class="s0">refs = node.thedef.references;</span>
                <span class="s1">var </span><span class="s0">scope = node.scope.get_defun_scope();</span>
                <span class="s1">var </span><span class="s0">def = scope.find_variable(name)</span>
                    <span class="s0">|| toplevel.globals.get(name)</span>
                    <span class="s0">|| scope.def_variable(node);</span>
                <span class="s0">refs.forEach(</span><span class="s1">function</span><span class="s0">(ref) {</span>
                    <span class="s0">ref.thedef = def;</span>
                    <span class="s0">ref.reference();</span>
                <span class="s0">});</span>
                <span class="s0">node.thedef = def;</span>
                <span class="s0">node.reference();</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">// pass 4: add symbol definitions to loop scopes</span>
    <span class="s3">// Safari/Webkit bug workaround - loop init let variable shadowing argument.</span>
    <span class="s3">// https://github.com/mishoo/UglifyJS2/issues/1753</span>
    <span class="s3">// https://bugs.webkit.org/show_bug.cgi?id=171041</span>
    <span class="s1">if </span><span class="s0">(options.safari10) {</span>
        <span class="s1">for </span><span class="s0">(const scope of for_scopes) {</span>
            <span class="s0">scope.parent_scope.variables.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
                <span class="s0">push_uniq(scope.enclosed, def);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;def_global&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(node) {</span>
    <span class="s1">var </span><span class="s0">globals = </span><span class="s1">this</span><span class="s0">.globals, name = node.name;</span>
    <span class="s1">if </span><span class="s0">(globals.has(name)) {</span>
        <span class="s1">return </span><span class="s0">globals.get(name);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">g = </span><span class="s1">new </span><span class="s0">SymbolDef(</span><span class="s1">this</span><span class="s0">, node);</span>
        <span class="s0">g.undeclared = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">g.global = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">globals.set(name, g);</span>
        <span class="s1">return </span><span class="s0">g;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;init_scope_vars&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(parent_scope) {</span>
    <span class="s1">this</span><span class="s0">.variables = </span><span class="s1">new </span><span class="s0">Map();         </span><span class="s3">// map name to AST_SymbolVar (variables defined in this scope; includes functions)</span>
    <span class="s1">this</span><span class="s0">.uses_with = </span><span class="s1">false</span><span class="s0">;             </span><span class="s3">// will be set to true if this or some nested scope uses the `with` statement</span>
    <span class="s1">this</span><span class="s0">.uses_eval = </span><span class="s1">false</span><span class="s0">;             </span><span class="s3">// will be set to true if this or nested scope uses the global `eval`</span>
    <span class="s1">this</span><span class="s0">.parent_scope = parent_scope;   </span><span class="s3">// the parent scope</span>
    <span class="s1">this</span><span class="s0">.enclosed = [];                 </span><span class="s3">// a list of variables from this or outer scope(s) that are referenced from this or inner scopes</span>
    <span class="s1">this</span><span class="s0">.cname = -</span><span class="s4">1</span><span class="s0">;                    </span><span class="s3">// the current index for mangling functions/variables</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;conflicting_def&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(name) {</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s1">this</span><span class="s0">.enclosed.find(def =&gt; def.name === name)</span>
        <span class="s0">|| </span><span class="s1">this</span><span class="s0">.variables.has(name)</span>
        <span class="s0">|| (</span><span class="s1">this</span><span class="s0">.parent_scope &amp;&amp; </span><span class="s1">this</span><span class="s0">.parent_scope.conflicting_def(name))</span>
    <span class="s0">);</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;conflicting_def_shallow&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(name) {</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s1">this</span><span class="s0">.enclosed.find(def =&gt; def.name === name)</span>
        <span class="s0">|| </span><span class="s1">this</span><span class="s0">.variables.has(name)</span>
    <span class="s0">);</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;add_child_scope&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(scope) {</span>
    <span class="s3">// `scope` is going to be moved into `this` right now.</span>
    <span class="s3">// Update the required scopes' information</span>

    <span class="s1">if </span><span class="s0">(scope.parent_scope === </span><span class="s1">this</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>

    <span class="s0">scope.parent_scope = </span><span class="s1">this</span><span class="s0">;</span>

    <span class="s3">// Propagate to this.uses_arguments from arrow functions</span>
    <span class="s1">if </span><span class="s0">((scope </span><span class="s1">instanceof </span><span class="s0">AST_Arrow) &amp;&amp; !</span><span class="s1">this</span><span class="s0">.uses_arguments) {</span>
        <span class="s1">this</span><span class="s0">.uses_arguments = walk(scope, node =&gt; {</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
                <span class="s0">&amp;&amp; node.scope </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
                <span class="s0">&amp;&amp; node.name === </span><span class="s2">&quot;arguments&quot;</span>
            <span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">walk_abort;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_Arrow)) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">this</span><span class="s0">.uses_with = </span><span class="s1">this</span><span class="s0">.uses_with || scope.uses_with;</span>
    <span class="s1">this</span><span class="s0">.uses_eval = </span><span class="s1">this</span><span class="s0">.uses_eval || scope.uses_eval;</span>

    <span class="s0">const scope_ancestry = (() =&gt; {</span>
        <span class="s0">const ancestry = [];</span>
        <span class="s0">let cur = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">ancestry.push(cur);</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">((cur = cur.parent_scope));</span>
        <span class="s0">ancestry.reverse();</span>
        <span class="s1">return </span><span class="s0">ancestry;</span>
    <span class="s0">})();</span>

    <span class="s0">const new_scope_enclosed_set = </span><span class="s1">new </span><span class="s0">Set(scope.enclosed);</span>
    <span class="s0">const to_enclose = [];</span>
    <span class="s1">for </span><span class="s0">(const scope_topdown of scope_ancestry) {</span>
        <span class="s0">to_enclose.forEach(e =&gt; push_uniq(scope_topdown.enclosed, e));</span>
        <span class="s1">for </span><span class="s0">(const def of scope_topdown.variables.values()) {</span>
            <span class="s1">if </span><span class="s0">(new_scope_enclosed_set.has(def)) {</span>
                <span class="s0">push_uniq(to_enclose, def);</span>
                <span class="s0">push_uniq(scope_topdown.enclosed, def);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">find_scopes_visible_from(scopes) {</span>
    <span class="s0">const found_scopes = </span><span class="s1">new </span><span class="s0">Set();</span>

    <span class="s1">for </span><span class="s0">(const scope of </span><span class="s1">new </span><span class="s0">Set(scopes)) {</span>
        <span class="s0">(</span><span class="s1">function </span><span class="s0">bubble_up(scope) {</span>
            <span class="s1">if </span><span class="s0">(scope == </span><span class="s1">null </span><span class="s0">|| found_scopes.has(scope)) </span><span class="s1">return</span><span class="s0">;</span>

            <span class="s0">found_scopes.add(scope);</span>

            <span class="s0">bubble_up(scope.parent_scope);</span>
        <span class="s0">})(scope);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">[...found_scopes];</span>
<span class="s0">}</span>

<span class="s3">// Creates a symbol during compression</span>
<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;create_symbol&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(SymClass, {</span>
    <span class="s0">source,</span>
    <span class="s0">tentative_name,</span>
    <span class="s0">scope,</span>
    <span class="s0">conflict_scopes = [scope],</span>
    <span class="s0">init = </span><span class="s1">null</span>
<span class="s0">} = {}) {</span>
    <span class="s0">let symbol_name;</span>

    <span class="s0">conflict_scopes = find_scopes_visible_from(conflict_scopes);</span>

    <span class="s1">if </span><span class="s0">(tentative_name) {</span>
        <span class="s3">// Implement hygiene (no new names are conflicting with existing names)</span>
        <span class="s0">tentative_name =</span>
            <span class="s0">symbol_name =</span>
            <span class="s0">tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, </span><span class="s2">&quot;_&quot;</span><span class="s0">);</span>

        <span class="s0">let i = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">while </span><span class="s0">(conflict_scopes.find(s =&gt; s.conflicting_def_shallow(symbol_name))) {</span>
            <span class="s0">symbol_name = tentative_name + </span><span class="s2">&quot;$&quot; </span><span class="s0">+ i++;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!symbol_name) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;No symbol name could be generated in create_symbol()&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">const symbol = make_node(SymClass, source, {</span>
        <span class="s0">name: symbol_name,</span>
        <span class="s0">scope</span>
    <span class="s0">});</span>

    <span class="s1">this</span><span class="s0">.def_variable(symbol, init || </span><span class="s1">null</span><span class="s0">);</span>

    <span class="s0">symbol.mark_enclosed();</span>

    <span class="s1">return </span><span class="s0">symbol;</span>
<span class="s0">});</span>


<span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, return_false);</span>
<span class="s0">AST_Class.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, return_false);</span>
<span class="s0">AST_Lambda.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, return_false);</span>
<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, return_false);</span>
<span class="s0">AST_SwitchBranch.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, return_false);</span>
<span class="s0">AST_Block.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, return_true);</span>
<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">._block_scope || </span><span class="s1">false</span><span class="s0">;</span>
<span class="s0">});</span>
<span class="s0">AST_IterationStatement.DEFMETHOD(</span><span class="s2">&quot;is_block_scope&quot;</span><span class="s0">, return_true);</span>

<span class="s0">AST_Lambda.DEFMETHOD(</span><span class="s2">&quot;init_scope_vars&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s0">AST_Scope.prototype.init_scope_vars.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
    <span class="s1">this</span><span class="s0">.uses_arguments = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.def_variable(</span><span class="s1">new </span><span class="s0">AST_SymbolFunarg({</span>
        <span class="s0">name: </span><span class="s2">&quot;arguments&quot;</span><span class="s0">,</span>
        <span class="s0">start: </span><span class="s1">this</span><span class="s0">.start,</span>
        <span class="s0">end: </span><span class="s1">this</span><span class="s0">.end</span>
    <span class="s0">}));</span>
<span class="s0">});</span>

<span class="s0">AST_Arrow.DEFMETHOD(</span><span class="s2">&quot;init_scope_vars&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s0">AST_Scope.prototype.init_scope_vars.apply(</span><span class="s1">this</span><span class="s0">, arguments);</span>
    <span class="s1">this</span><span class="s0">.uses_arguments = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;mark_enclosed&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s0">def = </span><span class="s1">this</span><span class="s0">.definition();</span>
    <span class="s1">var </span><span class="s0">s = </span><span class="s1">this</span><span class="s0">.scope;</span>
    <span class="s1">while </span><span class="s0">(s) {</span>
        <span class="s0">push_uniq(s.enclosed, def);</span>
        <span class="s1">if </span><span class="s0">(s === def.scope) </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s0">s = s.parent_scope;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;reference&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">this</span><span class="s0">.definition().references.push(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s1">this</span><span class="s0">.mark_enclosed();</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;find_variable&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(name) {</span>
    <span class="s1">if </span><span class="s0">(name </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) name = name.name;</span>
    <span class="s1">return this</span><span class="s0">.variables.get(name)</span>
        <span class="s0">|| (</span><span class="s1">this</span><span class="s0">.parent_scope &amp;&amp; </span><span class="s1">this</span><span class="s0">.parent_scope.find_variable(name));</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;def_function&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(symbol, init) {</span>
    <span class="s1">var </span><span class="s0">def = </span><span class="s1">this</span><span class="s0">.def_variable(symbol, init);</span>
    <span class="s1">if </span><span class="s0">(!def.init || def.init </span><span class="s1">instanceof </span><span class="s0">AST_Defun) def.init = init;</span>
    <span class="s1">return </span><span class="s0">def;</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;def_variable&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(symbol, init) {</span>
    <span class="s1">var </span><span class="s0">def = </span><span class="s1">this</span><span class="s0">.variables.get(symbol.name);</span>
    <span class="s1">if </span><span class="s0">(def) {</span>
        <span class="s0">def.orig.push(symbol);</span>
        <span class="s1">if </span><span class="s0">(def.init &amp;&amp; (def.scope !== symbol.scope || def.init </span><span class="s1">instanceof </span><span class="s0">AST_Function)) {</span>
            <span class="s0">def.init = init;</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">def = </span><span class="s1">new </span><span class="s0">SymbolDef(</span><span class="s1">this</span><span class="s0">, symbol, init);</span>
        <span class="s1">this</span><span class="s0">.variables.set(symbol.name, def);</span>
        <span class="s0">def.global = !</span><span class="s1">this</span><span class="s0">.parent_scope;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">symbol.thedef = def;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">next_mangled(scope, options) {</span>
    <span class="s0">let defun_scope;</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">scopes_with_block_defuns</span>
        <span class="s0">&amp;&amp; (defun_scope = scope.get_defun_scope())</span>
        <span class="s0">&amp;&amp; scopes_with_block_defuns.has(defun_scope)</span>
    <span class="s0">) {</span>
        <span class="s0">scope = defun_scope;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">ext = scope.enclosed;</span>
    <span class="s1">var </span><span class="s0">nth_identifier = options.nth_identifier;</span>
    <span class="s0">out: </span><span class="s1">while </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">m = nth_identifier.get(++scope.cname);</span>
        <span class="s1">if </span><span class="s0">(ALL_RESERVED_WORDS.has(m)) </span><span class="s1">continue</span><span class="s0">; </span><span class="s3">// skip over &quot;do&quot;</span>

        <span class="s3">// https://github.com/mishoo/UglifyJS2/issues/242 -- do not</span>
        <span class="s3">// shadow a name reserved from mangling.</span>
        <span class="s1">if </span><span class="s0">(options.reserved.has(m)) </span><span class="s1">continue</span><span class="s0">;</span>

        <span class="s3">// Functions with short names might collide with base54 output</span>
        <span class="s3">// and therefore cause collisions when keep_fnames is true.</span>
        <span class="s1">if </span><span class="s0">(unmangleable_names &amp;&amp; unmangleable_names.has(m)) </span><span class="s1">continue </span><span class="s0">out;</span>

        <span class="s3">// we must ensure that the mangled name does not shadow a name</span>
        <span class="s3">// from some parent scope that is referenced in this or in</span>
        <span class="s3">// inner scopes.</span>
        <span class="s1">for </span><span class="s0">(let i = ext.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s0">const def = ext[i];</span>
            <span class="s0">const name = def.mangled_name || (def.unmangleable(options) &amp;&amp; def.name);</span>
            <span class="s1">if </span><span class="s0">(m == name) </span><span class="s1">continue </span><span class="s0">out;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">m;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;next_mangled&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
    <span class="s1">return </span><span class="s0">next_mangled(</span><span class="s1">this</span><span class="s0">, options);</span>
<span class="s0">});</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;next_mangled&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
    <span class="s0">let name;</span>
    <span class="s0">const mangled_names = </span><span class="s1">this</span><span class="s0">.mangled_names;</span>
    <span class="s1">do </span><span class="s0">{</span>
        <span class="s0">name = next_mangled(</span><span class="s1">this</span><span class="s0">, options);</span>
    <span class="s0">} </span><span class="s1">while </span><span class="s0">(mangled_names.has(name));</span>
    <span class="s1">return </span><span class="s0">name;</span>
<span class="s0">});</span>

<span class="s0">AST_Function.DEFMETHOD(</span><span class="s2">&quot;next_mangled&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options, def) {</span>
    <span class="s3">// #179, #326</span>
    <span class="s3">// in Safari strict mode, something like (function x(x){...}) is a syntax error;</span>
    <span class="s3">// a function expression's argument cannot shadow the function expression's name</span>

    <span class="s1">var </span><span class="s0">tricky_def = def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg &amp;&amp; </span><span class="s1">this</span><span class="s0">.name &amp;&amp; </span><span class="s1">this</span><span class="s0">.name.definition();</span>

    <span class="s3">// the function's mangled_name is null when keep_fnames is true</span>
    <span class="s1">var </span><span class="s0">tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">while </span><span class="s0">(</span><span class="s1">true</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">name = next_mangled(</span><span class="s1">this</span><span class="s0">, options);</span>
        <span class="s1">if </span><span class="s0">(!tricky_name || tricky_name != name)</span>
            <span class="s1">return </span><span class="s0">name;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;unmangleable&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
    <span class="s1">var </span><span class="s0">def = </span><span class="s1">this</span><span class="s0">.definition();</span>
    <span class="s1">return </span><span class="s0">!def || def.unmangleable(options);</span>
<span class="s0">});</span>

<span class="s3">// labels are always mangleable</span>
<span class="s0">AST_Label.DEFMETHOD(</span><span class="s2">&quot;unmangleable&quot;</span><span class="s0">, return_false);</span>

<span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;unreferenced&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.definition().references.length &amp;&amp; !</span><span class="s1">this</span><span class="s0">.scope.pinned();</span>
<span class="s0">});</span>

<span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;definition&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.thedef;</span>
<span class="s0">});</span>

<span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;global&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.thedef.global;</span>
<span class="s0">});</span>

<span class="s3">/** 
 * Format the mangler options (if any) into their appropriate types 
 */</span>
<span class="s1">function </span><span class="s0">format_mangler_options(options) {</span>
    <span class="s0">options = defaults(options, {</span>
        <span class="s0">eval        : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">nth_identifier : base54,</span>
        <span class="s0">ie8         : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">keep_classnames: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">keep_fnames : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">module      : </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">reserved    : [],</span>
        <span class="s0">toplevel    : </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">(options.module) options.toplevel = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!Array.isArray(options.reserved)</span>
        <span class="s0">&amp;&amp; !(options.reserved </span><span class="s1">instanceof </span><span class="s0">Set)</span>
    <span class="s0">) {</span>
        <span class="s0">options.reserved = [];</span>
    <span class="s0">}</span>
    <span class="s0">options.reserved = </span><span class="s1">new </span><span class="s0">Set(options.reserved);</span>
    <span class="s3">// Never mangle arguments</span>
    <span class="s0">options.reserved.add(</span><span class="s2">&quot;arguments&quot;</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s0">options;</span>
<span class="s0">}</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;mangle_names&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
    <span class="s0">options = format_mangler_options(options);</span>
    <span class="s1">var </span><span class="s0">nth_identifier = options.nth_identifier;</span>

    <span class="s3">// We only need to mangle declaration nodes.  Special logic wired</span>
    <span class="s3">// into the code generator will display the mangled name if it's</span>
    <span class="s3">// present (and for AST_SymbolRef-s it'll use the mangled name of</span>
    <span class="s3">// the AST_SymbolDeclaration that it points to).</span>
    <span class="s1">var </span><span class="s0">lname = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">to_mangle = [];</span>

    <span class="s1">if </span><span class="s0">(options.keep_fnames) {</span>
        <span class="s0">function_defs = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s0">}</span>

    <span class="s0">const mangled_names = </span><span class="s1">this</span><span class="s0">.mangled_names = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s0">unmangleable_names = </span><span class="s1">new </span><span class="s0">Set();</span>

    <span class="s1">if </span><span class="s0">(options.cache) {</span>
        <span class="s1">this</span><span class="s0">.globals.forEach(collect);</span>
        <span class="s1">if </span><span class="s0">(options.cache.props) {</span>
            <span class="s0">options.cache.props.forEach(</span><span class="s1">function</span><span class="s0">(mangled_name) {</span>
                <span class="s0">mangled_names.add(mangled_name);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node, descend) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_LabeledStatement) {</span>
            <span class="s3">// lname is incremented when we get to the AST_Label</span>
            <span class="s1">var </span><span class="s0">save_nesting = lname;</span>
            <span class="s0">descend();</span>
            <span class="s0">lname = save_nesting;</span>
            <span class="s1">return true</span><span class="s0">;        </span><span class="s3">// don't descend again in TreeWalker</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Defun</span>
            <span class="s0">&amp;&amp; !(tw.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Scope)</span>
        <span class="s0">) {</span>
            <span class="s0">scopes_with_block_defuns = scopes_with_block_defuns || </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s0">scopes_with_block_defuns.add(node.parent_scope.get_defun_scope());</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
            <span class="s0">node.variables.forEach(collect);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node.is_block_scope()) {</span>
            <span class="s0">node.block_scope.variables.forEach(collect);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">function_defs</span>
            <span class="s0">&amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_VarDef</span>
            <span class="s0">&amp;&amp; node.value </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
            <span class="s0">&amp;&amp; !node.value.name</span>
            <span class="s0">&amp;&amp; keep_name(options.keep_fnames, node.name.name)</span>
        <span class="s0">) {</span>
            <span class="s0">function_defs.add(node.name.definition().id);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Label) {</span>
            <span class="s0">let name;</span>
            <span class="s1">do </span><span class="s0">{</span>
                <span class="s0">name = nth_identifier.get(++lname);</span>
            <span class="s0">} </span><span class="s1">while </span><span class="s0">(ALL_RESERVED_WORDS.has(name));</span>
            <span class="s0">node.mangled_name = name;</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!(options.ie8 || options.safari10) &amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch) {</span>
            <span class="s0">to_mangle.push(node.definition());</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s1">this</span><span class="s0">.walk(tw);</span>

    <span class="s1">if </span><span class="s0">(options.keep_fnames || options.keep_classnames) {</span>
        <span class="s3">// Collect a set of short names which are unmangleable,</span>
        <span class="s3">// for use in avoiding collisions in next_mangled.</span>
        <span class="s0">to_mangle.forEach(def =&gt; {</span>
            <span class="s1">if </span><span class="s0">(def.name.length &lt; </span><span class="s4">6 </span><span class="s0">&amp;&amp; def.unmangleable(options)) {</span>
                <span class="s0">unmangleable_names.add(def.name);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s0">to_mangle.forEach(def =&gt; { def.mangle(options); });</span>

    <span class="s0">function_defs = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">unmangleable_names = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">scopes_with_block_defuns = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">collect(symbol) {</span>
        <span class="s1">if </span><span class="s0">(symbol.export &amp; MASK_EXPORT_DONT_MANGLE) {</span>
            <span class="s0">unmangleable_names.add(symbol.name);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!options.reserved.has(symbol.name)) {</span>
            <span class="s0">to_mangle.push(symbol);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;find_colliding_names&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
    <span class="s0">const cache = options.cache &amp;&amp; options.cache.props;</span>
    <span class="s0">const avoid = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s0">options.reserved.forEach(to_avoid);</span>
    <span class="s1">this</span><span class="s0">.globals.forEach(add_def);</span>
    <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) node.variables.forEach(add_def);</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch) add_def(node.definition());</span>
    <span class="s0">}));</span>
    <span class="s1">return </span><span class="s0">avoid;</span>

    <span class="s1">function </span><span class="s0">to_avoid(name) {</span>
        <span class="s0">avoid.add(name);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">add_def(def) {</span>
        <span class="s1">var </span><span class="s0">name = def.name;</span>
        <span class="s1">if </span><span class="s0">(def.global &amp;&amp; cache &amp;&amp; cache.has(name)) name = cache.get(name);</span>
        <span class="s1">else if </span><span class="s0">(!def.unmangleable(options)) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s0">to_avoid(name);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;expand_names&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
    <span class="s0">options = format_mangler_options(options);</span>
    <span class="s1">var </span><span class="s0">nth_identifier = options.nth_identifier;</span>
    <span class="s1">if </span><span class="s0">(nth_identifier.reset &amp;&amp; nth_identifier.sort) {</span>
        <span class="s0">nth_identifier.reset();</span>
        <span class="s0">nth_identifier.sort();</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">avoid = </span><span class="s1">this</span><span class="s0">.find_colliding_names(options);</span>
    <span class="s1">var </span><span class="s0">cname = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.globals.forEach(rename);</span>
    <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) node.variables.forEach(rename);</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch) rename(node.definition());</span>
    <span class="s0">}));</span>

    <span class="s1">function </span><span class="s0">next_name() {</span>
        <span class="s1">var </span><span class="s0">name;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">name = nth_identifier.get(cname++);</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(avoid.has(name) || ALL_RESERVED_WORDS.has(name));</span>
        <span class="s1">return </span><span class="s0">name;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">rename(def) {</span>
        <span class="s1">if </span><span class="s0">(def.global &amp;&amp; options.cache) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(def.unmangleable(options)) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(options.reserved.has(def.name)) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s0">const redefinition = redefined_catch_def(def);</span>
        <span class="s0">const name = def.name = redefinition ? redefinition.name : next_name();</span>
        <span class="s0">def.orig.forEach(</span><span class="s1">function</span><span class="s0">(sym) {</span>
            <span class="s0">sym.name = name;</span>
        <span class="s0">});</span>
        <span class="s0">def.references.forEach(</span><span class="s1">function</span><span class="s0">(sym) {</span>
            <span class="s0">sym.name = name;</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;tail_node&quot;</span><span class="s0">, return_this);</span>
<span class="s0">AST_Sequence.DEFMETHOD(</span><span class="s2">&quot;tail_node&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.expressions[</span><span class="s1">this</span><span class="s0">.expressions.length - </span><span class="s4">1</span><span class="s0">];</span>
<span class="s0">});</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;compute_char_frequency&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(options) {</span>
    <span class="s0">options = format_mangler_options(options);</span>
    <span class="s1">var </span><span class="s0">nth_identifier = options.nth_identifier;</span>
    <span class="s1">if </span><span class="s0">(!nth_identifier.reset || !nth_identifier.consider || !nth_identifier.sort) {</span>
        <span class="s3">// If the identifier mangler is invariant, skip computing character frequency.</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">nth_identifier.reset();</span>

    <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">AST_Node.prototype.print = </span><span class="s1">function</span><span class="s0">(stream, force_parens) {</span>
            <span class="s1">this</span><span class="s0">._print(stream, force_parens);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">AST_Symbol &amp;&amp; !</span><span class="s1">this</span><span class="s0">.unmangleable(options)) {</span>
                <span class="s0">nth_identifier.consider(</span><span class="s1">this</span><span class="s0">.name, -</span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(options.properties) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">AST_DotHash) {</span>
                    <span class="s0">nth_identifier.consider(</span><span class="s2">&quot;#&quot; </span><span class="s0">+ </span><span class="s1">this</span><span class="s0">.property, -</span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">AST_Dot) {</span>
                    <span class="s0">nth_identifier.consider(</span><span class="s1">this</span><span class="s0">.property, -</span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">AST_Sub) {</span>
                    <span class="s0">skip_string(</span><span class="s1">this</span><span class="s0">.property);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">nth_identifier.consider(</span><span class="s1">this</span><span class="s0">.print_to_string(), </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">} </span><span class="s1">finally </span><span class="s0">{</span>
        <span class="s0">AST_Node.prototype.print = AST_Node.prototype._print;</span>
    <span class="s0">}</span>
    <span class="s0">nth_identifier.sort();</span>

    <span class="s1">function </span><span class="s0">skip_string(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_String) {</span>
            <span class="s0">nth_identifier.consider(node.value, -</span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Conditional) {</span>
            <span class="s0">skip_string(node.consequent);</span>
            <span class="s0">skip_string(node.alternative);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
            <span class="s0">skip_string(node.tail_node());</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">const base54 = (() =&gt; {</span>
    <span class="s0">const leading = </span><span class="s2">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_&quot;</span><span class="s0">.split(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
    <span class="s0">const digits = </span><span class="s2">&quot;0123456789&quot;</span><span class="s0">.split(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
    <span class="s0">let chars;</span>
    <span class="s0">let frequency;</span>
    <span class="s1">function </span><span class="s0">reset() {</span>
        <span class="s0">frequency = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">leading.forEach(</span><span class="s1">function</span><span class="s0">(ch) {</span>
            <span class="s0">frequency.set(ch, </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">});</span>
        <span class="s0">digits.forEach(</span><span class="s1">function</span><span class="s0">(ch) {</span>
            <span class="s0">frequency.set(ch, </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">consider(str, delta) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = str.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s0">frequency.set(str[i], frequency.get(str[i]) + delta);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">compare(a, b) {</span>
        <span class="s1">return </span><span class="s0">frequency.get(b) - frequency.get(a);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sort() {</span>
        <span class="s0">chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));</span>
    <span class="s0">}</span>
    <span class="s3">// Ensure this is in a usable initial state.</span>
    <span class="s0">reset();</span>
    <span class="s0">sort();</span>
    <span class="s1">function </span><span class="s0">base54(num) {</span>
        <span class="s1">var </span><span class="s0">ret = </span><span class="s2">&quot;&quot;</span><span class="s0">, base = </span><span class="s4">54</span><span class="s0">;</span>
        <span class="s0">num++;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">num--;</span>
            <span class="s0">ret += chars[num % base];</span>
            <span class="s0">num = Math.floor(num / base);</span>
            <span class="s0">base = </span><span class="s4">64</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(num &gt; </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">get: base54,</span>
        <span class="s0">consider,</span>
        <span class="s0">reset,</span>
        <span class="s0">sort</span>
    <span class="s0">};</span>
<span class="s0">})();</span>

<span class="s0">let mangle_options = undefined;</span>
<span class="s0">AST_Node.prototype.size = </span><span class="s1">function </span><span class="s0">(compressor, stack) {</span>
    <span class="s0">mangle_options = compressor &amp;&amp; compressor.mangle_options;</span>

    <span class="s0">let size = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">walk_parent(</span><span class="s1">this</span><span class="s0">, (node, info) =&gt; {</span>
        <span class="s0">size += node._size(info);</span>

        <span class="s3">// Braceless arrow functions have fake &quot;return&quot; statements</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Arrow &amp;&amp; node.is_braceless()) {</span>
            <span class="s0">size += node.body[</span><span class="s4">0</span><span class="s0">].value._size(info);</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}, stack || (compressor &amp;&amp; compressor.stack));</span>

    <span class="s3">// just to save a bit of memory</span>
    <span class="s0">mangle_options = undefined;</span>

    <span class="s1">return </span><span class="s0">size;</span>
<span class="s0">};</span>

<span class="s0">AST_Node.prototype._size = () =&gt; </span><span class="s4">0</span><span class="s0">;</span>

<span class="s0">AST_Debugger.prototype._size = () =&gt; </span><span class="s4">8</span><span class="s0">;</span>

<span class="s0">AST_Directive.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s3">// TODO string encoding stuff</span>
    <span class="s1">return </span><span class="s4">2 </span><span class="s0">+ </span><span class="s1">this</span><span class="s0">.value.length;</span>
<span class="s0">};</span>

<span class="s3">/** Count commas/semicolons necessary to show a list of expressions/statements */</span>
<span class="s0">const list_overhead = (array) =&gt; array.length &amp;&amp; array.length - </span><span class="s4">1</span><span class="s0">;</span>

<span class="s0">AST_Block.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">2 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Toplevel.prototype._size = </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_EmptyStatement.prototype._size = () =&gt; </span><span class="s4">1</span><span class="s0">;</span>

<span class="s0">AST_LabeledStatement.prototype._size = () =&gt; </span><span class="s4">2</span><span class="s0">;  </span><span class="s3">// x:</span>

<span class="s0">AST_Do.prototype._size = () =&gt; </span><span class="s4">9</span><span class="s0">;</span>

<span class="s0">AST_While.prototype._size = () =&gt; </span><span class="s4">7</span><span class="s0">;</span>

<span class="s0">AST_For.prototype._size = () =&gt; </span><span class="s4">8</span><span class="s0">;</span>

<span class="s0">AST_ForIn.prototype._size = () =&gt; </span><span class="s4">8</span><span class="s0">;</span>
<span class="s3">// AST_ForOf inherits ^</span>

<span class="s0">AST_With.prototype._size = () =&gt; </span><span class="s4">6</span><span class="s0">;</span>

<span class="s0">AST_Expansion.prototype._size = () =&gt; </span><span class="s4">3</span><span class="s0">;</span>

<span class="s0">const lambda_modifiers = func =&gt;</span>
    <span class="s0">(func.is_generator ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">) + (func.async ? </span><span class="s4">6 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>

<span class="s0">AST_Accessor.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">lambda_modifiers(</span><span class="s1">this</span><span class="s0">) + </span><span class="s4">4 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.argnames) + list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Function.prototype._size = </span><span class="s1">function </span><span class="s0">(info) {</span>
    <span class="s0">const first = !!first_in_statement(info);</span>
    <span class="s1">return </span><span class="s0">(first * </span><span class="s4">2</span><span class="s0">) + lambda_modifiers(</span><span class="s1">this</span><span class="s0">) + </span><span class="s4">12 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.argnames) + list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Defun.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">lambda_modifiers(</span><span class="s1">this</span><span class="s0">) + </span><span class="s4">13 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.argnames) + list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Arrow.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s0">let args_and_arrow = </span><span class="s4">2 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.argnames);</span>

    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">!(</span>
            <span class="s1">this</span><span class="s0">.argnames.length === </span><span class="s4">1</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.argnames[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Symbol</span>
        <span class="s0">)</span>
    <span class="s0">) {</span>
        <span class="s0">args_and_arrow += </span><span class="s4">2</span><span class="s0">; </span><span class="s3">// parens around the args</span>
    <span class="s0">}</span>

    <span class="s0">const body_overhead = </span><span class="s1">this</span><span class="s0">.is_braceless() ? </span><span class="s4">0 </span><span class="s0">: list_overhead(</span><span class="s1">this</span><span class="s0">.body) + </span><span class="s4">2</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s0">lambda_modifiers(</span><span class="s1">this</span><span class="s0">) + args_and_arrow + body_overhead;</span>
<span class="s0">};</span>

<span class="s0">AST_Destructuring.prototype._size = () =&gt; </span><span class="s4">2</span><span class="s0">;</span>

<span class="s0">AST_TemplateString.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">2 </span><span class="s0">+ (Math.floor(</span><span class="s1">this</span><span class="s0">.segments.length / </span><span class="s4">2</span><span class="s0">) * </span><span class="s4">3</span><span class="s0">);  </span><span class="s3">/* &quot;${}&quot; */</span>
<span class="s0">};</span>

<span class="s0">AST_TemplateSegment.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.value.length;</span>
<span class="s0">};</span>

<span class="s0">AST_Return.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.value ? </span><span class="s4">7 </span><span class="s0">: </span><span class="s4">6</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_Throw.prototype._size = () =&gt; </span><span class="s4">6</span><span class="s0">;</span>

<span class="s0">AST_Break.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.label ? </span><span class="s4">6 </span><span class="s0">: </span><span class="s4">5</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_Continue.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.label ? </span><span class="s4">9 </span><span class="s0">: </span><span class="s4">8</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_If.prototype._size = () =&gt; </span><span class="s4">4</span><span class="s0">;</span>

<span class="s0">AST_Switch.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">8 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Case.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">5 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Default.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">8 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Try.prototype._size = () =&gt; </span><span class="s4">3</span><span class="s0">;</span>

<span class="s0">AST_Catch.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s0">let size = </span><span class="s4">7 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.argname) {</span>
        <span class="s0">size += </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">size;</span>
<span class="s0">};</span>

<span class="s0">AST_Finally.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">7 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_Var.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">4 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.definitions);</span>
<span class="s0">};</span>

<span class="s0">AST_Let.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">4 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.definitions);</span>
<span class="s0">};</span>

<span class="s0">AST_Const.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">6 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.definitions);</span>
<span class="s0">};</span>

<span class="s0">AST_VarDef.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.value ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_NameMapping.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s3">// foreign name isn't mangled</span>
    <span class="s1">return this</span><span class="s0">.name ? </span><span class="s4">4 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_Import.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s3">// import</span>
    <span class="s0">let size = </span><span class="s4">6</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_name) size += </span><span class="s4">1</span><span class="s0">;</span>

    <span class="s3">// from</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_name || </span><span class="s1">this</span><span class="s0">.imported_names) size += </span><span class="s4">5</span><span class="s0">;</span>

    <span class="s3">// braces, and the commas</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.imported_names) {</span>
        <span class="s0">size += </span><span class="s4">2 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.imported_names);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">size;</span>
<span class="s0">};</span>

<span class="s0">AST_ImportMeta.prototype._size = () =&gt; </span><span class="s4">11</span><span class="s0">;</span>

<span class="s0">AST_Export.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s0">let size = </span><span class="s4">7 </span><span class="s0">+ (</span><span class="s1">this</span><span class="s0">.is_default ? </span><span class="s4">8 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_value) {</span>
        <span class="s0">size += </span><span class="s1">this</span><span class="s0">.exported_value._size();</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.exported_names) {</span>
        <span class="s3">// Braces and commas</span>
        <span class="s0">size += </span><span class="s4">2 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.exported_names);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.module_name) {</span>
        <span class="s3">// &quot;from &quot;</span>
        <span class="s0">size += </span><span class="s4">5</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">size;</span>
<span class="s0">};</span>

<span class="s0">AST_Call.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.optional) {</span>
        <span class="s1">return </span><span class="s4">4 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.args);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s4">2 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.args);</span>
<span class="s0">};</span>

<span class="s0">AST_New.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">6 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.args);</span>
<span class="s0">};</span>

<span class="s0">AST_Sequence.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">list_overhead(</span><span class="s1">this</span><span class="s0">.expressions);</span>
<span class="s0">};</span>

<span class="s0">AST_Dot.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.optional) {</span>
        <span class="s1">return this</span><span class="s0">.property.length + </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">.property.length + </span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_DotHash.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.optional) {</span>
        <span class="s1">return this</span><span class="s0">.property.length + </span><span class="s4">3</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">.property.length + </span><span class="s4">2</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_Sub.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.optional ? </span><span class="s4">4 </span><span class="s0">: </span><span class="s4">2</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_Unary.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator === </span><span class="s2">&quot;typeof&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s4">7</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator === </span><span class="s2">&quot;void&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s4">5</span><span class="s0">;</span>
    <span class="s1">return this</span><span class="s0">.operator.length;</span>
<span class="s0">};</span>

<span class="s0">AST_Binary.prototype._size = </span><span class="s1">function </span><span class="s0">(info) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator === </span><span class="s2">&quot;in&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s4">4</span><span class="s0">;</span>

    <span class="s0">let size = </span><span class="s1">this</span><span class="s0">.operator.length;</span>

    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">(</span><span class="s1">this</span><span class="s0">.operator === </span><span class="s2">&quot;+&quot; </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.operator === </span><span class="s2">&quot;-&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.right </span><span class="s1">instanceof </span><span class="s0">AST_Unary &amp;&amp; </span><span class="s1">this</span><span class="s0">.right.operator === </span><span class="s1">this</span><span class="s0">.operator</span>
    <span class="s0">) {</span>
        <span class="s3">// 1+ +a &gt; needs space between the +</span>
        <span class="s0">size += </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.needs_parens(info)) {</span>
        <span class="s0">size += </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">size;</span>
<span class="s0">};</span>

<span class="s0">AST_Conditional.prototype._size = () =&gt; </span><span class="s4">3</span><span class="s0">;</span>

<span class="s0">AST_Array.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">2 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.elements);</span>
<span class="s0">};</span>

<span class="s0">AST_Object.prototype._size = </span><span class="s1">function </span><span class="s0">(info) {</span>
    <span class="s0">let base = </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(first_in_statement(info)) {</span>
        <span class="s0">base += </span><span class="s4">2</span><span class="s0">; </span><span class="s3">// parens</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">base + list_overhead(</span><span class="s1">this</span><span class="s0">.properties);</span>
<span class="s0">};</span>

<span class="s3">/*#__INLINE__*/</span>
<span class="s0">const key_size = key =&gt;</span>
    <span class="s1">typeof </span><span class="s0">key === </span><span class="s2">&quot;string&quot; </span><span class="s0">? key.length : </span><span class="s4">0</span><span class="s0">;</span>

<span class="s0">AST_ObjectKeyVal.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">key_size(</span><span class="s1">this</span><span class="s0">.key) + </span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s3">/*#__INLINE__*/</span>
<span class="s0">const static_size = is_static =&gt; is_static ? </span><span class="s4">7 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">;</span>

<span class="s0">AST_ObjectGetter.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">5 </span><span class="s0">+ static_size(</span><span class="s1">this</span><span class="s0">.static) + key_size(</span><span class="s1">this</span><span class="s0">.key);</span>
<span class="s0">};</span>

<span class="s0">AST_ObjectSetter.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">5 </span><span class="s0">+ static_size(</span><span class="s1">this</span><span class="s0">.static) + key_size(</span><span class="s1">this</span><span class="s0">.key);</span>
<span class="s0">};</span>

<span class="s0">AST_ConciseMethod.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">static_size(</span><span class="s1">this</span><span class="s0">.static) + key_size(</span><span class="s1">this</span><span class="s0">.key) + lambda_modifiers(</span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">AST_PrivateMethod.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">AST_ConciseMethod.prototype._size.call(</span><span class="s1">this</span><span class="s0">) + </span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_PrivateGetter.prototype._size = AST_PrivateSetter.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">AST_ConciseMethod.prototype._size.call(</span><span class="s1">this</span><span class="s0">) + </span><span class="s4">4</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_PrivateIn.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s4">5</span><span class="s0">; </span><span class="s3">// &quot;#&quot;, and &quot; in &quot;</span>
<span class="s0">};</span>

<span class="s0">AST_Class.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s0">(</span><span class="s1">this</span><span class="s0">.name ? </span><span class="s4">8 </span><span class="s0">: </span><span class="s4">7</span><span class="s0">)</span>
        <span class="s0">+ (</span><span class="s1">this</span><span class="s0">.extends ? </span><span class="s4">8 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">)</span>
    <span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">AST_ClassStaticBlock.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s3">// &quot;class{}&quot; + semicolons</span>
    <span class="s1">return </span><span class="s4">7 </span><span class="s0">+ list_overhead(</span><span class="s1">this</span><span class="s0">.body);</span>
<span class="s0">};</span>

<span class="s0">AST_ClassProperty.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s0">static_size(</span><span class="s1">this</span><span class="s0">.static)</span>
        <span class="s0">+ (</span><span class="s1">typeof this</span><span class="s0">.key === </span><span class="s2">&quot;string&quot; </span><span class="s0">? </span><span class="s1">this</span><span class="s0">.key.length + </span><span class="s4">2 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">)</span>
        <span class="s0">+ (</span><span class="s1">this</span><span class="s0">.value ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">)</span>
    <span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">AST_ClassPrivateProperty.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">AST_ClassProperty.prototype._size.call(</span><span class="s1">this</span><span class="s0">) + </span><span class="s4">1</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_Symbol.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(!(mangle_options &amp;&amp; </span><span class="s1">this</span><span class="s0">.thedef &amp;&amp; !</span><span class="s1">this</span><span class="s0">.thedef.unmangleable(mangle_options))) {</span>
        <span class="s1">return this</span><span class="s0">.name.length;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">};</span>

<span class="s3">// TODO take propmangle into account</span>
<span class="s0">AST_SymbolClassProperty.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.name.length;</span>
<span class="s0">};</span>

<span class="s0">AST_SymbolRef.prototype._size = AST_SymbolDeclaration.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name === </span><span class="s2">&quot;arguments&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s4">9</span><span class="s0">;</span>

    <span class="s1">return </span><span class="s0">AST_Symbol.prototype._size.call(</span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">};</span>

<span class="s0">AST_NewTarget.prototype._size = () =&gt; </span><span class="s4">10</span><span class="s0">;</span>

<span class="s0">AST_SymbolImportForeign.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.name.length;</span>
<span class="s0">};</span>

<span class="s0">AST_SymbolExportForeign.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.name.length;</span>
<span class="s0">};</span>

<span class="s0">AST_This.prototype._size = () =&gt; </span><span class="s4">4</span><span class="s0">;</span>

<span class="s0">AST_Super.prototype._size = () =&gt; </span><span class="s4">5</span><span class="s0">;</span>

<span class="s0">AST_String.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.value.length + </span><span class="s4">2</span><span class="s0">;</span>
<span class="s0">};</span>

<span class="s0">AST_Number.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s0">const { value } = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(value === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(value &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; Math.floor(value) === value) {</span>
        <span class="s1">return </span><span class="s0">Math.floor(Math.log10(value) + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">value.toString().length;</span>
<span class="s0">};</span>

<span class="s0">AST_BigInt.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.value.length;</span>
<span class="s0">};</span>

<span class="s0">AST_RegExp.prototype._size = </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.value.toString().length;</span>
<span class="s0">};</span>

<span class="s0">AST_Null.prototype._size = () =&gt; </span><span class="s4">4</span><span class="s0">;</span>

<span class="s0">AST_NaN.prototype._size = () =&gt; </span><span class="s4">3</span><span class="s0">;</span>

<span class="s0">AST_Undefined.prototype._size = () =&gt; </span><span class="s4">6</span><span class="s0">; </span><span class="s3">// &quot;void 0&quot;</span>

<span class="s0">AST_Hole.prototype._size = () =&gt; </span><span class="s4">0</span><span class="s0">;  </span><span class="s3">// comma is taken into account by list_overhead()</span>

<span class="s0">AST_Infinity.prototype._size = () =&gt; </span><span class="s4">8</span><span class="s0">;</span>

<span class="s0">AST_True.prototype._size = () =&gt; </span><span class="s4">4</span><span class="s0">;</span>

<span class="s0">AST_False.prototype._size = () =&gt; </span><span class="s4">5</span><span class="s0">;</span>

<span class="s0">AST_Await.prototype._size = () =&gt; </span><span class="s4">6</span><span class="s0">;</span>

<span class="s0">AST_Yield.prototype._size = () =&gt; </span><span class="s4">6</span><span class="s0">;</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">// bitfield flags to be stored in node.flags.</span>
<span class="s3">// These are set and unset during compression, and store information in the node without requiring multiple fields.</span>
<span class="s0">const UNUSED = </span><span class="s4">0</span><span class="s0">b00000001;</span>
<span class="s0">const TRUTHY = </span><span class="s4">0</span><span class="s0">b00000010;</span>
<span class="s0">const FALSY = </span><span class="s4">0</span><span class="s0">b00000100;</span>
<span class="s0">const UNDEFINED = </span><span class="s4">0</span><span class="s0">b00001000;</span>
<span class="s0">const INLINED = </span><span class="s4">0</span><span class="s0">b00010000;</span>

<span class="s3">// Nodes to which values are ever written. Used when keep_assign is part of the unused option string.</span>
<span class="s0">const WRITE_ONLY = </span><span class="s4">0</span><span class="s0">b00100000;</span>

<span class="s3">// information specific to a single compression pass</span>
<span class="s0">const SQUEEZED = </span><span class="s4">0</span><span class="s0">b0000000100000000;</span>
<span class="s0">const OPTIMIZED = </span><span class="s4">0</span><span class="s0">b0000001000000000;</span>
<span class="s0">const TOP = </span><span class="s4">0</span><span class="s0">b0000010000000000;</span>
<span class="s0">const CLEAR_BETWEEN_PASSES = SQUEEZED | OPTIMIZED | TOP;</span>

<span class="s0">const has_flag = (node, flag) =&gt; node.flags &amp; flag;</span>
<span class="s0">const set_flag = (node, flag) =&gt; { node.flags |= flag; };</span>
<span class="s0">const clear_flag = (node, flag) =&gt; { node.flags &amp;= ~flag; };</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">function </span><span class="s0">merge_sequence(array, node) {</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
        <span class="s0">array.push(...node.expressions);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">array.push(node);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">array;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">make_sequence(orig, expressions) {</span>
    <span class="s1">if </span><span class="s0">(expressions.length == </span><span class="s4">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">expressions[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">if </span><span class="s0">(expressions.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;trying to create a sequence with length zero!&quot;</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s0">make_node(AST_Sequence, orig, {</span>
        <span class="s0">expressions: expressions.reduce(merge_sequence, [])</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">make_node_from_constant(val, orig) {</span>
    <span class="s1">switch </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">val) {</span>
      <span class="s1">case </span><span class="s2">&quot;string&quot;</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s0">make_node(AST_String, orig, {</span>
            <span class="s0">value: val</span>
        <span class="s0">});</span>
      <span class="s1">case </span><span class="s2">&quot;number&quot;</span><span class="s0">:</span>
        <span class="s1">if </span><span class="s0">(isNaN(val)) </span><span class="s1">return </span><span class="s0">make_node(AST_NaN, orig);</span>
        <span class="s1">if </span><span class="s0">(isFinite(val)) {</span>
            <span class="s1">return </span><span class="s4">1 </span><span class="s0">/ val &lt; </span><span class="s4">0 </span><span class="s0">? make_node(AST_UnaryPrefix, orig, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;-&quot;</span><span class="s0">,</span>
                <span class="s0">expression: make_node(AST_Number, orig, { value: -val })</span>
            <span class="s0">}) : make_node(AST_Number, orig, { value: val });</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">val &lt; </span><span class="s4">0 </span><span class="s0">? make_node(AST_UnaryPrefix, orig, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;-&quot;</span><span class="s0">,</span>
            <span class="s0">expression: make_node(AST_Infinity, orig)</span>
        <span class="s0">}) : make_node(AST_Infinity, orig);</span>
      <span class="s1">case </span><span class="s2">&quot;boolean&quot;</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s0">make_node(val ? AST_True : AST_False, orig);</span>
      <span class="s1">case </span><span class="s2">&quot;undefined&quot;</span><span class="s0">:</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Undefined, orig);</span>
      <span class="s1">default</span><span class="s0">:</span>
        <span class="s1">if </span><span class="s0">(val === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Null, orig, { value: </span><span class="s1">null </span><span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(val </span><span class="s1">instanceof </span><span class="s0">RegExp) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_RegExp, orig, {</span>
                <span class="s0">value: {</span>
                    <span class="s0">source: regexp_source_fix(val.source),</span>
                    <span class="s0">flags: val.flags</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">throw new </span><span class="s0">Error(string_template(</span><span class="s2">&quot;Can't handle constant of type: {type}&quot;</span><span class="s0">, {</span>
            <span class="s0">type: </span><span class="s1">typeof </span><span class="s0">val</span>
        <span class="s0">}));</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">best_of_expression(ast1, ast2) {</span>
    <span class="s1">return </span><span class="s0">ast1.size() &gt; ast2.size() ? ast2 : ast1;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">best_of_statement(ast1, ast2) {</span>
    <span class="s1">return </span><span class="s0">best_of_expression(</span>
        <span class="s0">make_node(AST_SimpleStatement, ast1, {</span>
            <span class="s0">body: ast1</span>
        <span class="s0">}),</span>
        <span class="s0">make_node(AST_SimpleStatement, ast2, {</span>
            <span class="s0">body: ast2</span>
        <span class="s0">})</span>
    <span class="s0">).body;</span>
<span class="s0">}</span>

<span class="s3">/** Find which node is smaller, and return that */</span>
<span class="s1">function </span><span class="s0">best_of(compressor, ast1, ast2) {</span>
    <span class="s1">if </span><span class="s0">(first_in_statement(compressor)) {</span>
        <span class="s1">return </span><span class="s0">best_of_statement(ast1, ast2);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">best_of_expression(ast1, ast2);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">/** Simplify an object property's key, if possible */</span>
<span class="s1">function </span><span class="s0">get_simple_key(key) {</span>
    <span class="s1">if </span><span class="s0">(key </span><span class="s1">instanceof </span><span class="s0">AST_Constant) {</span>
        <span class="s1">return </span><span class="s0">key.getValue();</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(key </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
        <span class="s0">&amp;&amp; key.operator == </span><span class="s2">&quot;void&quot;</span>
        <span class="s0">&amp;&amp; key.expression </span><span class="s1">instanceof </span><span class="s0">AST_Constant) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">key;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">read_property(obj, key) {</span>
    <span class="s0">key = get_simple_key(key);</span>
    <span class="s1">if </span><span class="s0">(key </span><span class="s1">instanceof </span><span class="s0">AST_Node) </span><span class="s1">return</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">value;</span>
    <span class="s1">if </span><span class="s0">(obj </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
        <span class="s1">var </span><span class="s0">elements = obj.elements;</span>
        <span class="s1">if </span><span class="s0">(key == </span><span class="s2">&quot;length&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node_from_constant(elements.length, obj);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">key == </span><span class="s2">&quot;number&quot; </span><span class="s0">&amp;&amp; key </span><span class="s1">in </span><span class="s0">elements) value = elements[key];</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(obj </span><span class="s1">instanceof </span><span class="s0">AST_Object) {</span>
        <span class="s0">key = </span><span class="s2">&quot;&quot; </span><span class="s0">+ key;</span>
        <span class="s1">var </span><span class="s0">props = obj.properties;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = props.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s1">var </span><span class="s0">prop = props[i];</span>
            <span class="s1">if </span><span class="s0">(!(prop </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal)) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!value &amp;&amp; props[i].key === key) value = props[i].value;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">value </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; value.fixed_value() || value;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">has_break_or_continue(loop, parent) {</span>
    <span class="s1">var </span><span class="s0">found = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(found || node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_LoopControl &amp;&amp; tw.loopcontrol_target(node) === loop) {</span>
            <span class="s1">return </span><span class="s0">found = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_LabeledStatement) tw.push(parent);</span>
    <span class="s0">tw.push(loop);</span>
    <span class="s0">loop.body.walk(tw);</span>
    <span class="s1">return </span><span class="s0">found;</span>
<span class="s0">}</span>

<span class="s3">// we shouldn't compress (1,func)(something) to</span>
<span class="s3">// func(something) because that changes the meaning of</span>
<span class="s3">// the func (becomes lexical instead of global).</span>
<span class="s1">function </span><span class="s0">maintain_this_binding(parent, orig, val) {</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">parent </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix &amp;&amp; parent.operator == </span><span class="s2">&quot;delete&quot;</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; parent.expression === orig</span>
            <span class="s0">&amp;&amp; (</span>
                <span class="s0">val </span><span class="s1">instanceof </span><span class="s0">AST_Chain</span>
                <span class="s0">|| val </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
                <span class="s0">|| val </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; val.name == </span><span class="s2">&quot;eval&quot;</span>
            <span class="s0">)</span>
    <span class="s0">) {</span>
        <span class="s0">const zero = make_node(AST_Number, orig, { value: </span><span class="s4">0 </span><span class="s0">});</span>
        <span class="s1">return </span><span class="s0">make_sequence(orig, [ zero, val ]);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">val;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_func_expr(node) {</span>
    <span class="s1">return </span><span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Arrow || node </span><span class="s1">instanceof </span><span class="s0">AST_Function;</span>
<span class="s0">}</span>

<span class="s3">/** 
 * Used to determine whether the node can benefit from negation. 
 * Not the case with arrow functions (you need an extra set of parens). */</span>
<span class="s1">function </span><span class="s0">is_iife_call(node) {</span>
    <span class="s1">if </span><span class="s0">(node.TYPE != </span><span class="s2">&quot;Call&quot;</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">node.expression </span><span class="s1">instanceof </span><span class="s0">AST_Function || is_iife_call(node.expression);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_empty(thing) {</span>
    <span class="s1">if </span><span class="s0">(thing === </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(thing </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(thing </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement) </span><span class="s1">return </span><span class="s0">thing.body.length == </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">const identifier_atom = makePredicate(</span><span class="s2">&quot;Infinity NaN undefined&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">is_identifier_atom(node) {</span>
    <span class="s1">return </span><span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Infinity</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_NaN</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Undefined;</span>
<span class="s0">}</span>

<span class="s3">/** Check if this is a SymbolRef node which has one def of a certain AST type */</span>
<span class="s1">function </span><span class="s0">is_ref_of(ref, type) {</span>
    <span class="s1">if </span><span class="s0">(!(ref </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef)) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">orig = ref.definition().orig;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = orig.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
        <span class="s1">if </span><span class="s0">(orig[i] </span><span class="s1">instanceof </span><span class="s0">type) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">/**Can we turn { block contents... } into just the block contents ? 
 * Not if one of these is inside. 
 **/</span>
<span class="s1">function </span><span class="s0">can_be_evicted_from_block(node) {</span>
    <span class="s1">return </span><span class="s0">!(</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_DefClass ||</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Defun ||</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Let ||</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Const ||</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Export ||</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Import</span>
    <span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">as_statement_array(thing) {</span>
    <span class="s1">if </span><span class="s0">(thing === </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return </span><span class="s0">[];</span>
    <span class="s1">if </span><span class="s0">(thing </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement) </span><span class="s1">return </span><span class="s0">thing.body;</span>
    <span class="s1">if </span><span class="s0">(thing </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement) </span><span class="s1">return </span><span class="s0">[];</span>
    <span class="s1">if </span><span class="s0">(thing </span><span class="s1">instanceof </span><span class="s0">AST_Statement) </span><span class="s1">return </span><span class="s0">[ thing ];</span>
    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Can't convert thing to statement array&quot;</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_reachable(scope_node, defs) {</span>
    <span class="s0">const find_ref = node =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; defs.includes(node.definition())) {</span>
            <span class="s1">return </span><span class="s0">walk_abort;</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">return </span><span class="s0">walk_parent(scope_node, (node, info) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope &amp;&amp; node !== scope_node) {</span>
            <span class="s1">var </span><span class="s0">parent = info.parent();</span>

            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">parent </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
                <span class="s0">&amp;&amp; parent.expression === node</span>
                <span class="s3">// Async/Generators aren't guaranteed to sync evaluate all of</span>
                <span class="s3">// their body steps, so it's possible they close over the variable.</span>
                <span class="s0">&amp;&amp; !(node.async || node.is_generator)</span>
            <span class="s0">) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(walk(node, find_ref)) </span><span class="s1">return </span><span class="s0">walk_abort;</span>

            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s3">/** Check if a ref refers to the name of a function/class it's defined within */</span>
<span class="s1">function </span><span class="s0">is_recursive_ref(compressor, def) {</span>
    <span class="s1">var </span><span class="s0">node;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; node = compressor.parent(i); i++) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda || node </span><span class="s1">instanceof </span><span class="s0">AST_Class) {</span>
            <span class="s1">var </span><span class="s0">name = node.name;</span>
            <span class="s1">if </span><span class="s0">(name &amp;&amp; name.definition() === def) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">// TODO this only works with AST_Defun, shouldn't it work for other ways of defining functions?</span>
<span class="s1">function </span><span class="s0">retain_top_func(fn, compressor) {</span>
    <span class="s1">return </span><span class="s0">compressor.top_retain</span>
        <span class="s0">&amp;&amp; fn </span><span class="s1">instanceof </span><span class="s0">AST_Defun</span>
        <span class="s0">&amp;&amp; has_flag(fn, TOP)</span>
        <span class="s0">&amp;&amp; fn.name</span>
        <span class="s0">&amp;&amp; compressor.top_retain(fn.name);</span>
<span class="s0">}</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">// Lists of native methods, useful for `unsafe` option which assumes they exist.</span>
<span class="s3">// Note: Lots of methods and functions are missing here, in case they aren't pure</span>
<span class="s3">// or not available in all JS environments.</span>

<span class="s1">function </span><span class="s0">make_nested_lookup(obj) {</span>
    <span class="s0">const out = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">key of Object.keys(obj)) {</span>
        <span class="s0">out.set(key, makePredicate(obj[key]));</span>
    <span class="s0">}</span>

    <span class="s0">const does_have = (global_name, fname) =&gt; {</span>
        <span class="s0">const inner_map = out.get(global_name);</span>
        <span class="s1">return </span><span class="s0">inner_map != </span><span class="s1">null </span><span class="s0">&amp;&amp; inner_map.has(fname);</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">does_have;</span>
<span class="s0">}</span>

<span class="s3">// Objects which are safe to access without throwing or causing a side effect.</span>
<span class="s3">// Usually we'd check the `unsafe` option first but these are way too common for that</span>
<span class="s0">const pure_prop_access_globals = </span><span class="s1">new </span><span class="s0">Set([</span>
    <span class="s2">&quot;Number&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;String&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Object&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Promise&quot;</span><span class="s0">,</span>
<span class="s0">]);</span>

<span class="s0">const object_methods = [</span>
    <span class="s2">&quot;constructor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueOf&quot;</span><span class="s0">,</span>
<span class="s0">];</span>

<span class="s0">const is_pure_native_method = make_nested_lookup({</span>
    <span class="s0">Array: [</span>
        <span class="s2">&quot;at&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;flat&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;includes&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;indexOf&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;join&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;lastIndexOf&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;slice&quot;</span><span class="s0">,</span>
        <span class="s0">...object_methods,</span>
    <span class="s0">],</span>
    <span class="s0">Boolean: object_methods,</span>
    <span class="s0">Function: object_methods,</span>
    <span class="s0">Number: [</span>
        <span class="s2">&quot;toExponential&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;toFixed&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;toPrecision&quot;</span><span class="s0">,</span>
        <span class="s0">...object_methods,</span>
    <span class="s0">],</span>
    <span class="s0">Object: object_methods,</span>
    <span class="s0">RegExp: [</span>
        <span class="s2">&quot;test&quot;</span><span class="s0">,</span>
        <span class="s0">...object_methods,</span>
    <span class="s0">],</span>
    <span class="s0">String: [</span>
        <span class="s2">&quot;at&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;charAt&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;charCodeAt&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;charPointAt&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;concat&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;endsWith&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;fromCharCode&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;fromCodePoint&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;includes&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;indexOf&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;italics&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;lastIndexOf&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;localeCompare&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;match&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;matchAll&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;normalize&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;padStart&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;padEnd&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;repeat&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;replace&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;replaceAll&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;search&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;slice&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;split&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;startsWith&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;substr&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;substring&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;repeat&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;toLocaleLowerCase&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;toLocaleUpperCase&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;toLowerCase&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;toUpperCase&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;trim&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;trimEnd&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;trimStart&quot;</span><span class="s0">,</span>
        <span class="s0">...object_methods,</span>
    <span class="s0">],</span>
<span class="s0">});</span>

<span class="s0">const is_pure_native_fn = make_nested_lookup({</span>
    <span class="s0">Array: [</span>
        <span class="s2">&quot;isArray&quot;</span><span class="s0">,</span>
    <span class="s0">],</span>
    <span class="s0">Math: [</span>
        <span class="s2">&quot;abs&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;acos&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;asin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;atan&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;ceil&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;cos&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;exp&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;floor&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;log&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;round&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sqrt&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;tan&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;atan2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;pow&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;max&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;min&quot;</span><span class="s0">,</span>
    <span class="s0">],</span>
    <span class="s0">Number: [</span>
        <span class="s2">&quot;isFinite&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;isNaN&quot;</span><span class="s0">,</span>
    <span class="s0">],</span>
    <span class="s0">Object: [</span>
        <span class="s2">&quot;create&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;getOwnPropertyDescriptor&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;getOwnPropertyNames&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;getPrototypeOf&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;isExtensible&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;isFrozen&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;isSealed&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;hasOwn&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;keys&quot;</span><span class="s0">,</span>
    <span class="s0">],</span>
    <span class="s0">String: [</span>
        <span class="s2">&quot;fromCharCode&quot;</span><span class="s0">,</span>
    <span class="s0">],</span>
<span class="s0">});</span>

<span class="s3">// Known numeric values which come with JS environments</span>
<span class="s0">const is_pure_native_value = make_nested_lookup({</span>
    <span class="s0">Math: [</span>
        <span class="s2">&quot;E&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;LN10&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;LN2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;LOG2E&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;LOG10E&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;PI&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;SQRT1_2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;SQRT2&quot;</span><span class="s0">,</span>
    <span class="s0">],</span>
    <span class="s0">Number: [</span>
        <span class="s2">&quot;MAX_VALUE&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;MIN_VALUE&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;NaN&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;NEGATIVE_INFINITY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;POSITIVE_INFINITY&quot;</span><span class="s0">,</span>
    <span class="s0">],</span>
<span class="s0">});</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">// Functions and methods to infer certain facts about expressions</span>
<span class="s3">// It's not always possible to be 100% sure about something just by static analysis,</span>
<span class="s3">// so `true` means yes, and `false` means maybe</span>

<span class="s0">const is_undeclared_ref = (node) =&gt;</span>
    <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; node.definition().undeclared;</span>

<span class="s0">const lazy_op = makePredicate(</span><span class="s2">&quot;&amp;&amp; || ??&quot;</span><span class="s0">);</span>
<span class="s0">const unary_side_effects = makePredicate(</span><span class="s2">&quot;delete ++ --&quot;</span><span class="s0">);</span>

<span class="s3">// methods to determine whether an expression has a boolean result type</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_is_boolean) {</span>
    <span class="s0">const unary_bool = makePredicate(</span><span class="s2">&quot;! delete&quot;</span><span class="s0">);</span>
    <span class="s0">const binary_bool = makePredicate(</span><span class="s2">&quot;in instanceof == != === !== &lt; &lt;= &gt;= &gt;&quot;</span><span class="s0">);</span>
    <span class="s0">def_is_boolean(AST_Node, return_false);</span>
    <span class="s0">def_is_boolean(AST_UnaryPrefix, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unary_bool.has(</span><span class="s1">this</span><span class="s0">.operator);</span>
    <span class="s0">});</span>
    <span class="s0">def_is_boolean(AST_Binary, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">binary_bool.has(</span><span class="s1">this</span><span class="s0">.operator)</span>
            <span class="s0">|| lazy_op.has(</span><span class="s1">this</span><span class="s0">.operator)</span>
                <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.left.is_boolean()</span>
                <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.right.is_boolean();</span>
    <span class="s0">});</span>
    <span class="s0">def_is_boolean(AST_Conditional, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.consequent.is_boolean() &amp;&amp; </span><span class="s1">this</span><span class="s0">.alternative.is_boolean();</span>
    <span class="s0">});</span>
    <span class="s0">def_is_boolean(AST_Assign, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.right.is_boolean();</span>
    <span class="s0">});</span>
    <span class="s0">def_is_boolean(AST_Sequence, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.tail_node().is_boolean();</span>
    <span class="s0">});</span>
    <span class="s0">def_is_boolean(AST_True, return_true);</span>
    <span class="s0">def_is_boolean(AST_False, return_true);</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;is_boolean&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s3">// methods to determine if an expression has a numeric result type</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_is_number) {</span>
    <span class="s0">def_is_number(AST_Node, return_false);</span>
    <span class="s0">def_is_number(AST_Number, return_true);</span>
    <span class="s0">const unary = makePredicate(</span><span class="s2">&quot;+ - ~ ++ --&quot;</span><span class="s0">);</span>
    <span class="s0">def_is_number(AST_Unary, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unary.has(</span><span class="s1">this</span><span class="s0">.operator) &amp;&amp; !(</span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_BigInt);</span>
    <span class="s0">});</span>
    <span class="s0">const numeric_ops = makePredicate(</span><span class="s2">&quot;- * / % &amp; | ^ &lt;&lt; &gt;&gt; &gt;&gt;&gt;&quot;</span><span class="s0">);</span>
    <span class="s0">def_is_number(AST_Binary, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">numeric_ops.has(</span><span class="s1">this</span><span class="s0">.operator) || </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;+&quot;</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.left.is_number(compressor)</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.right.is_number(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_is_number(AST_Assign, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">numeric_ops.has(</span><span class="s1">this</span><span class="s0">.operator.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">))</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.right.is_number(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_is_number(AST_Sequence, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.tail_node().is_number(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_is_number(AST_Conditional, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.consequent.is_number(compressor) &amp;&amp; </span><span class="s1">this</span><span class="s0">.alternative.is_number(compressor);</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;is_number&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s3">// methods to determine if an expression has a string result type</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_is_string) {</span>
    <span class="s0">def_is_string(AST_Node, return_false);</span>
    <span class="s0">def_is_string(AST_String, return_true);</span>
    <span class="s0">def_is_string(AST_TemplateString, return_true);</span>
    <span class="s0">def_is_string(AST_UnaryPrefix, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.operator == </span><span class="s2">&quot;typeof&quot;</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">def_is_string(AST_Binary, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.operator == </span><span class="s2">&quot;+&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">(</span><span class="s1">this</span><span class="s0">.left.is_string(compressor) || </span><span class="s1">this</span><span class="s0">.right.is_string(compressor));</span>
    <span class="s0">});</span>
    <span class="s0">def_is_string(AST_Assign, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;+=&quot;</span><span class="s0">) &amp;&amp; </span><span class="s1">this</span><span class="s0">.right.is_string(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_is_string(AST_Sequence, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.tail_node().is_string(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_is_string(AST_Conditional, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.consequent.is_string(compressor) &amp;&amp; </span><span class="s1">this</span><span class="s0">.alternative.is_string(compressor);</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;is_string&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">is_undefined(node, compressor) {</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s0">has_flag(node, UNDEFINED)</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Undefined</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
            <span class="s0">&amp;&amp; node.operator == </span><span class="s2">&quot;void&quot;</span>
            <span class="s0">&amp;&amp; !node.expression.has_side_effects(compressor)</span>
    <span class="s0">);</span>
<span class="s0">}</span>

<span class="s3">// Is the node explicitly null or undefined.</span>
<span class="s1">function </span><span class="s0">is_null_or_undefined(node, compressor) {</span>
    <span class="s0">let fixed;</span>
    <span class="s1">return </span><span class="s0">(</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Null</span>
        <span class="s0">|| is_undefined(node, compressor)</span>
        <span class="s0">|| (</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">&amp;&amp; (fixed = node.definition().fixed) </span><span class="s1">instanceof </span><span class="s0">AST_Node</span>
            <span class="s0">&amp;&amp; is_nullish(fixed, compressor)</span>
        <span class="s0">)</span>
    <span class="s0">);</span>
<span class="s0">}</span>

<span class="s3">// Find out if this expression is optionally chained from a base-point that we</span>
<span class="s3">// can statically analyze as null or undefined.</span>
<span class="s1">function </span><span class="s0">is_nullish_shortcircuited(node, compressor) {</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess || node </span><span class="s1">instanceof </span><span class="s0">AST_Call) {</span>
        <span class="s1">return </span><span class="s0">(</span>
            <span class="s0">(node.optional &amp;&amp; is_null_or_undefined(node.expression, compressor))</span>
            <span class="s0">|| is_nullish_shortcircuited(node.expression, compressor)</span>
        <span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Chain) </span><span class="s1">return </span><span class="s0">is_nullish_shortcircuited(node.expression, compressor);</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">// Find out if something is == null, or can short circuit into nullish.</span>
<span class="s3">// Used to optimize ?. and ??</span>
<span class="s1">function </span><span class="s0">is_nullish(node, compressor) {</span>
    <span class="s1">if </span><span class="s0">(is_null_or_undefined(node, compressor)) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">is_nullish_shortcircuited(node, compressor);</span>
<span class="s0">}</span>

<span class="s3">// Determine if expression might cause side effects</span>
<span class="s3">// If there's a possibility that a node may change something when it's executed, this returns true</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_has_side_effects) {</span>
    <span class="s0">def_has_side_effects(AST_Node, return_true);</span>

    <span class="s0">def_has_side_effects(AST_EmptyStatement, return_false);</span>
    <span class="s0">def_has_side_effects(AST_Constant, return_false);</span>
    <span class="s0">def_has_side_effects(AST_This, return_false);</span>

    <span class="s1">function </span><span class="s0">any(list, compressor) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = list.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;)</span>
            <span class="s1">if </span><span class="s0">(list[i].has_side_effects(compressor))</span>
                <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">def_has_side_effects(AST_Block, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Call, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">!</span><span class="s1">this</span><span class="s0">.is_callee_pure(compressor)</span>
            <span class="s0">&amp;&amp; (!</span><span class="s1">this</span><span class="s0">.expression.is_call_pure(compressor)</span>
                <span class="s0">|| </span><span class="s1">this</span><span class="s0">.expression.has_side_effects(compressor))</span>
        <span class="s0">) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.args, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Switch, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression.has_side_effects(compressor)</span>
            <span class="s0">|| any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Case, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression.has_side_effects(compressor)</span>
            <span class="s0">|| any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Try, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.body.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.bcatch &amp;&amp; </span><span class="s1">this</span><span class="s0">.bcatch.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.bfinally &amp;&amp; </span><span class="s1">this</span><span class="s0">.bfinally.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_If, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.condition.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.body &amp;&amp; </span><span class="s1">this</span><span class="s0">.body.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.alternative &amp;&amp; </span><span class="s1">this</span><span class="s0">.alternative.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_ImportMeta, return_false);</span>
    <span class="s0">def_has_side_effects(AST_LabeledStatement, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.body.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_SimpleStatement, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.body.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Lambda, return_false);</span>
    <span class="s0">def_has_side_effects(AST_Class, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.extends &amp;&amp; </span><span class="s1">this</span><span class="s0">.extends.has_side_effects(compressor)) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.properties, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_ClassStaticBlock, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Binary, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.left.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.right.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Assign, return_true);</span>
    <span class="s0">def_has_side_effects(AST_Conditional, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.condition.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.consequent.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.alternative.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Unary, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">unary_side_effects.has(</span><span class="s1">this</span><span class="s0">.operator)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.expression.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_SymbolRef, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.is_declared(compressor) &amp;&amp; !pure_prop_access_globals.has(</span><span class="s1">this</span><span class="s0">.name);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_SymbolClassProperty, return_false);</span>
    <span class="s0">def_has_side_effects(AST_SymbolDeclaration, return_false);</span>
    <span class="s0">def_has_side_effects(AST_Object, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.properties, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_ObjectProperty, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">(</span>
            <span class="s1">this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.value &amp;&amp; </span><span class="s1">this</span><span class="s0">.value.has_side_effects(compressor)</span>
        <span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_ClassProperty, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">(</span>
            <span class="s1">this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.static &amp;&amp; </span><span class="s1">this</span><span class="s0">.value &amp;&amp; </span><span class="s1">this</span><span class="s0">.value.has_side_effects(compressor)</span>
        <span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_ConciseMethod, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_ObjectGetter, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_ObjectSetter, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Array, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.elements, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Dot, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(is_nullish(</span><span class="s1">this</span><span class="s0">, compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.optional &amp;&amp; </span><span class="s1">this</span><span class="s0">.expression.may_throw_on_access(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.expression.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Sub, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(is_nullish(</span><span class="s1">this</span><span class="s0">, compressor)) </span><span class="s1">return false</span><span class="s0">;</span>

        <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.optional &amp;&amp; </span><span class="s1">this</span><span class="s0">.expression.may_throw_on_access(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.expression.has_side_effects(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.property.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Chain, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression.has_side_effects(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Sequence, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.expressions, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_Definitions, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.definitions, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_VarDef, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.value;</span>
    <span class="s0">});</span>
    <span class="s0">def_has_side_effects(AST_TemplateSegment, return_false);</span>
    <span class="s0">def_has_side_effects(AST_TemplateString, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.segments, compressor);</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;has_side_effects&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s3">// determine if expression may throw</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_may_throw) {</span>
    <span class="s0">def_may_throw(AST_Node, return_true);</span>

    <span class="s0">def_may_throw(AST_Constant, return_false);</span>
    <span class="s0">def_may_throw(AST_EmptyStatement, return_false);</span>
    <span class="s0">def_may_throw(AST_Lambda, return_false);</span>
    <span class="s0">def_may_throw(AST_SymbolDeclaration, return_false);</span>
    <span class="s0">def_may_throw(AST_This, return_false);</span>
    <span class="s0">def_may_throw(AST_ImportMeta, return_false);</span>

    <span class="s1">function </span><span class="s0">any(list, compressor) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = list.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;)</span>
            <span class="s1">if </span><span class="s0">(list[i].may_throw(compressor))</span>
                <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">def_may_throw(AST_Class, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.extends &amp;&amp; </span><span class="s1">this</span><span class="s0">.extends.may_throw(compressor)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.properties, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_ClassStaticBlock, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>

    <span class="s0">def_may_throw(AST_Array, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.elements, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Assign, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.right.may_throw(compressor)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;=&quot;</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.left </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return this</span><span class="s0">.left.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Binary, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.left.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.right.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Block, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Call, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(is_nullish(</span><span class="s1">this</span><span class="s0">, compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(any(</span><span class="s1">this</span><span class="s0">.args, compressor)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.is_callee_pure(compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expression.may_throw(compressor)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!(</span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_Lambda)</span>
            <span class="s0">|| any(</span><span class="s1">this</span><span class="s0">.expression.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Case, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression.may_throw(compressor)</span>
            <span class="s0">|| any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Conditional, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.condition.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.consequent.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.alternative.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Definitions, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.definitions, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_If, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.condition.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.body &amp;&amp; </span><span class="s1">this</span><span class="s0">.body.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.alternative &amp;&amp; </span><span class="s1">this</span><span class="s0">.alternative.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_LabeledStatement, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.body.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Object, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.properties, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_ObjectProperty, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s3">// TODO key may throw too</span>
        <span class="s1">return this</span><span class="s0">.value ? </span><span class="s1">this</span><span class="s0">.value.may_throw(compressor) : </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_ClassProperty, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">(</span>
            <span class="s1">this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.static &amp;&amp; </span><span class="s1">this</span><span class="s0">.value &amp;&amp; </span><span class="s1">this</span><span class="s0">.value.may_throw(compressor)</span>
        <span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_ConciseMethod, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_ObjectGetter, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_ObjectSetter, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Return, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.value &amp;&amp; </span><span class="s1">this</span><span class="s0">.value.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Sequence, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">any(</span><span class="s1">this</span><span class="s0">.expressions, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_SimpleStatement, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.body.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Dot, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(is_nullish(</span><span class="s1">this</span><span class="s0">, compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.optional &amp;&amp; </span><span class="s1">this</span><span class="s0">.expression.may_throw_on_access(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.expression.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Sub, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(is_nullish(</span><span class="s1">this</span><span class="s0">, compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.optional &amp;&amp; </span><span class="s1">this</span><span class="s0">.expression.may_throw_on_access(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.expression.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.property.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Chain, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Switch, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression.may_throw(compressor)</span>
            <span class="s0">|| any(</span><span class="s1">this</span><span class="s0">.body, compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_SymbolRef, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.is_declared(compressor) &amp;&amp; !pure_prop_access_globals.has(</span><span class="s1">this</span><span class="s0">.name);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_SymbolClassProperty, return_false);</span>
    <span class="s0">def_may_throw(AST_Try, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.bcatch ? </span><span class="s1">this</span><span class="s0">.bcatch.may_throw(compressor) : </span><span class="s1">this</span><span class="s0">.body.may_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.bfinally &amp;&amp; </span><span class="s1">this</span><span class="s0">.bfinally.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_Unary, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;typeof&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return this</span><span class="s0">.expression.may_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw(AST_VarDef, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.value) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return this</span><span class="s0">.value.may_throw(compressor);</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;may_throw&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s3">// determine if expression is constant</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_is_constant_expression) {</span>
    <span class="s1">function </span><span class="s0">all_refs_local(scope) {</span>
        <span class="s0">let result = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">walk(</span><span class="s1">this</span><span class="s0">, node =&gt; {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
                <span class="s1">if </span><span class="s0">(has_flag(</span><span class="s1">this</span><span class="s0">, INLINED)) {</span>
                    <span class="s0">result = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">return </span><span class="s0">walk_abort;</span>
                <span class="s0">}</span>
                <span class="s1">var </span><span class="s0">def = node.definition();</span>
                <span class="s1">if </span><span class="s0">(</span>
                    <span class="s0">member(def, </span><span class="s1">this</span><span class="s0">.enclosed)</span>
                    <span class="s0">&amp;&amp; !</span><span class="s1">this</span><span class="s0">.variables.has(def.name)</span>
                <span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(scope) {</span>
                        <span class="s1">var </span><span class="s0">scope_def = scope.find_variable(node);</span>
                        <span class="s1">if </span><span class="s0">(def.undeclared ? !scope_def : scope_def === def) {</span>
                            <span class="s0">result = </span><span class="s2">&quot;f&quot;</span><span class="s0">;</span>
                            <span class="s1">return true</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s0">result = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">return </span><span class="s0">walk_abort;</span>
                <span class="s0">}</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_This &amp;&amp; </span><span class="s1">this instanceof </span><span class="s0">AST_Arrow) {</span>
                <span class="s0">result = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">walk_abort;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">}</span>

    <span class="s0">def_is_constant_expression(AST_Node, return_false);</span>
    <span class="s0">def_is_constant_expression(AST_Constant, return_true);</span>
    <span class="s0">def_is_constant_expression(AST_Class, </span><span class="s1">function</span><span class="s0">(scope) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.extends &amp;&amp; !</span><span class="s1">this</span><span class="s0">.extends.is_constant_expression(scope)) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">for </span><span class="s0">(const prop of </span><span class="s1">this</span><span class="s0">.properties) {</span>
            <span class="s1">if </span><span class="s0">(prop.computed_key() &amp;&amp; !prop.key.is_constant_expression(scope)) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(prop.static &amp;&amp; prop.value &amp;&amp; !prop.value.is_constant_expression(scope)) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_ClassStaticBlock) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">all_refs_local.call(</span><span class="s1">this</span><span class="s0">, scope);</span>
    <span class="s0">});</span>
    <span class="s0">def_is_constant_expression(AST_Lambda, all_refs_local);</span>
    <span class="s0">def_is_constant_expression(AST_Unary, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.expression.is_constant_expression();</span>
    <span class="s0">});</span>
    <span class="s0">def_is_constant_expression(AST_Binary, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.left.is_constant_expression()</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.right.is_constant_expression();</span>
    <span class="s0">});</span>
    <span class="s0">def_is_constant_expression(AST_Array, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.elements.every((l) =&gt; l.is_constant_expression());</span>
    <span class="s0">});</span>
    <span class="s0">def_is_constant_expression(AST_Object, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.properties.every((l) =&gt; l.is_constant_expression());</span>
    <span class="s0">});</span>
    <span class="s0">def_is_constant_expression(AST_ObjectProperty, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">!!(!(</span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_Node) &amp;&amp; </span><span class="s1">this</span><span class="s0">.value &amp;&amp; </span><span class="s1">this</span><span class="s0">.value.is_constant_expression());</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;is_constant_expression&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>


<span class="s3">// may_throw_on_access()</span>
<span class="s3">// returns true if this node may be null, undefined or contain `AST_Accessor`</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_may_throw_on_access) {</span>
    <span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;may_throw_on_access&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">!compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s0">)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">._dot_throw(compressor);</span>
    <span class="s0">});</span>

    <span class="s1">function </span><span class="s0">is_strict(compressor) {</span>
        <span class="s1">return </span><span class="s0">/strict/.test(compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>

    <span class="s0">def_may_throw_on_access(AST_Node, is_strict);</span>
    <span class="s0">def_may_throw_on_access(AST_Null, return_true);</span>
    <span class="s0">def_may_throw_on_access(AST_Undefined, return_true);</span>
    <span class="s0">def_may_throw_on_access(AST_Constant, return_false);</span>
    <span class="s0">def_may_throw_on_access(AST_Array, return_false);</span>
    <span class="s0">def_may_throw_on_access(AST_Object, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(!is_strict(compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s1">this</span><span class="s0">.properties.length; --i &gt;=</span><span class="s4">0</span><span class="s0">;)</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.properties[i]._dot_throw(compressor)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s3">// Do not be as strict with classes as we are with objects.</span>
    <span class="s3">// Hopefully the community is not going to abuse static getters and setters.</span>
    <span class="s3">// https://github.com/terser/terser/issues/724#issuecomment-643655656</span>
    <span class="s0">def_may_throw_on_access(AST_Class, return_false);</span>
    <span class="s0">def_may_throw_on_access(AST_ObjectProperty, return_false);</span>
    <span class="s0">def_may_throw_on_access(AST_ObjectGetter, return_true);</span>
    <span class="s0">def_may_throw_on_access(AST_Expansion, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression._dot_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_Function, return_false);</span>
    <span class="s0">def_may_throw_on_access(AST_Arrow, return_false);</span>
    <span class="s0">def_may_throw_on_access(AST_UnaryPostfix, return_false);</span>
    <span class="s0">def_may_throw_on_access(AST_UnaryPrefix, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.operator == </span><span class="s2">&quot;void&quot;</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_Binary, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;||&quot; </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;??&quot;</span><span class="s0">)</span>
            <span class="s0">&amp;&amp; (</span><span class="s1">this</span><span class="s0">.left._dot_throw(compressor) || </span><span class="s1">this</span><span class="s0">.right._dot_throw(compressor));</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_Assign, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.logical) </span><span class="s1">return true</span><span class="s0">;</span>

        <span class="s1">return this</span><span class="s0">.operator == </span><span class="s2">&quot;=&quot;</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.right._dot_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_Conditional, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.consequent._dot_throw(compressor)</span>
            <span class="s0">|| </span><span class="s1">this</span><span class="s0">.alternative._dot_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_Dot, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(!is_strict(compressor)) </span><span class="s1">return false</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.property == </span><span class="s2">&quot;prototype&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">!(</span>
                <span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_Function</span>
                <span class="s0">|| </span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_Class</span>
            <span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_Chain, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.expression._dot_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_Sequence, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">return this</span><span class="s0">.tail_node()._dot_throw(compressor);</span>
    <span class="s0">});</span>
    <span class="s0">def_may_throw_on_access(AST_SymbolRef, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.name === </span><span class="s2">&quot;arguments&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.scope </span><span class="s1">instanceof </span><span class="s0">AST_Lambda) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(has_flag(</span><span class="s1">this</span><span class="s0">, UNDEFINED)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!is_strict(compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(is_undeclared_ref(</span><span class="s1">this</span><span class="s0">) &amp;&amp; </span><span class="s1">this</span><span class="s0">.is_declared(compressor)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.is_immutable()) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">fixed = </span><span class="s1">this</span><span class="s0">.fixed_value();</span>
        <span class="s1">return </span><span class="s0">!fixed || fixed._dot_throw(compressor);</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;_dot_throw&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">is_lhs(node, parent) {</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Unary &amp;&amp; unary_side_effects.has(parent.operator)) </span><span class="s1">return </span><span class="s0">parent.expression;</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Assign &amp;&amp; parent.left === node) </span><span class="s1">return </span><span class="s0">node;</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_ForIn &amp;&amp; parent.init === node) </span><span class="s1">return </span><span class="s0">node;</span>
<span class="s0">}</span>

<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_find_defs) {</span>
    <span class="s1">function </span><span class="s0">to_node(value, orig) {</span>
        <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
            <span class="s1">if </span><span class="s0">(!(value </span><span class="s1">instanceof </span><span class="s0">AST_Constant)) {</span>
                <span class="s3">// Value may be a function, an array including functions and even a complex assign / block expression,</span>
                <span class="s3">// so it should never be shared in different places.</span>
                <span class="s3">// Otherwise wrong information may be used in the compression phase</span>
                <span class="s0">value = value.clone(</span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">make_node(value.CTOR, orig, value);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(value)) </span><span class="s1">return </span><span class="s0">make_node(AST_Array, orig, {</span>
            <span class="s0">elements: value.map(</span><span class="s1">function</span><span class="s0">(value) {</span>
                <span class="s1">return </span><span class="s0">to_node(value, orig);</span>
            <span class="s0">})</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(value &amp;&amp; </span><span class="s1">typeof </span><span class="s0">value == </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">props = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">key </span><span class="s1">in </span><span class="s0">value) </span><span class="s1">if </span><span class="s0">(HOP(value, key)) {</span>
                <span class="s0">props.push(make_node(AST_ObjectKeyVal, orig, {</span>
                    <span class="s0">key: key,</span>
                    <span class="s0">value: to_node(value[key], orig)</span>
                <span class="s0">}));</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Object, orig, {</span>
                <span class="s0">properties: props</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">make_node_from_constant(value, orig);</span>
    <span class="s0">}</span>

    <span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;resolve_defines&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s0">)) </span><span class="s1">return this</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.figure_out_scope({ ie8: compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">) });</span>
        <span class="s1">return this</span><span class="s0">.transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
            <span class="s1">var </span><span class="s0">def = node._find_defs(compressor, </span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(!def) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">level = </span><span class="s4">0</span><span class="s0">, child = node, parent;</span>
            <span class="s1">while </span><span class="s0">(parent = </span><span class="s1">this</span><span class="s0">.parent(level++)) {</span>
                <span class="s1">if </span><span class="s0">(!(parent </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess)) </span><span class="s1">break</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(parent.expression !== child) </span><span class="s1">break</span><span class="s0">;</span>
                <span class="s0">child = parent;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(is_lhs(child, parent)) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">def;</span>
        <span class="s0">}));</span>
    <span class="s0">});</span>
    <span class="s0">def_find_defs(AST_Node, noop);</span>
    <span class="s0">def_find_defs(AST_Chain, </span><span class="s1">function</span><span class="s0">(compressor, suffix) {</span>
        <span class="s1">return this</span><span class="s0">.expression._find_defs(compressor, suffix);</span>
    <span class="s0">});</span>
    <span class="s0">def_find_defs(AST_Dot, </span><span class="s1">function</span><span class="s0">(compressor, suffix) {</span>
        <span class="s1">return this</span><span class="s0">.expression._find_defs(compressor, </span><span class="s2">&quot;.&quot; </span><span class="s0">+ </span><span class="s1">this</span><span class="s0">.property + suffix);</span>
    <span class="s0">});</span>
    <span class="s0">def_find_defs(AST_SymbolDeclaration, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.global()) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">def_find_defs(AST_SymbolRef, </span><span class="s1">function</span><span class="s0">(compressor, suffix) {</span>
        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.global()) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">defines = compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">name = </span><span class="s1">this</span><span class="s0">.name + suffix;</span>
        <span class="s1">if </span><span class="s0">(HOP(defines, name)) </span><span class="s1">return </span><span class="s0">to_node(defines[name], </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_find_defs(AST_ImportMeta, </span><span class="s1">function</span><span class="s0">(compressor, suffix) {</span>
        <span class="s1">var </span><span class="s0">defines = compressor.option(</span><span class="s2">&quot;global_defs&quot;</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">name = </span><span class="s2">&quot;import.meta&quot; </span><span class="s0">+ suffix;</span>
        <span class="s1">if </span><span class="s0">(HOP(defines, name)) </span><span class="s1">return </span><span class="s0">to_node(defines[name], </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;_find_defs&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s3">// method to negate an expression</span>
<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_negate) {</span>
    <span class="s1">function </span><span class="s0">basic_negation(exp) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, exp, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;!&quot;</span><span class="s0">,</span>
            <span class="s0">expression: exp</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">best(orig, alt, first_in_statement) {</span>
        <span class="s1">var </span><span class="s0">negated = basic_negation(orig);</span>
        <span class="s1">if </span><span class="s0">(first_in_statement) {</span>
            <span class="s1">var </span><span class="s0">stat = make_node(AST_SimpleStatement, alt, {</span>
                <span class="s0">body: alt</span>
            <span class="s0">});</span>
            <span class="s1">return </span><span class="s0">best_of_expression(negated, stat) === stat ? alt : negated;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">best_of_expression(negated, alt);</span>
    <span class="s0">}</span>
    <span class="s0">def_negate(AST_Node, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">basic_negation(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_Statement, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot negate a statement&quot;</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_Function, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">basic_negation(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_Class, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">basic_negation(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_Arrow, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">basic_negation(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_UnaryPrefix, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;!&quot;</span><span class="s0">)</span>
            <span class="s1">return this</span><span class="s0">.expression;</span>
        <span class="s1">return </span><span class="s0">basic_negation(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_Sequence, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">var </span><span class="s0">expressions = </span><span class="s1">this</span><span class="s0">.expressions.slice();</span>
        <span class="s0">expressions.push(expressions.pop().negate(compressor));</span>
        <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, expressions);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_Conditional, </span><span class="s1">function</span><span class="s0">(compressor, first_in_statement) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">.clone();</span>
        <span class="s0">self.consequent = self.consequent.negate(compressor);</span>
        <span class="s0">self.alternative = self.alternative.negate(compressor);</span>
        <span class="s1">return </span><span class="s0">best(</span><span class="s1">this</span><span class="s0">, self, first_in_statement);</span>
    <span class="s0">});</span>
    <span class="s0">def_negate(AST_Binary, </span><span class="s1">function</span><span class="s0">(compressor, first_in_statement) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">.clone(), op = </span><span class="s1">this</span><span class="s0">.operator;</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe_comps&quot;</span><span class="s0">)) {</span>
            <span class="s1">switch </span><span class="s0">(op) {</span>
              <span class="s1">case </span><span class="s2">&quot;&lt;=&quot; </span><span class="s0">: self.operator = </span><span class="s2">&quot;&gt;&quot;  </span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
              <span class="s1">case </span><span class="s2">&quot;&lt;&quot;  </span><span class="s0">: self.operator = </span><span class="s2">&quot;&gt;=&quot; </span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
              <span class="s1">case </span><span class="s2">&quot;&gt;=&quot; </span><span class="s0">: self.operator = </span><span class="s2">&quot;&lt;&quot;  </span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
              <span class="s1">case </span><span class="s2">&quot;&gt;&quot;  </span><span class="s0">: self.operator = </span><span class="s2">&quot;&lt;=&quot; </span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">switch </span><span class="s0">(op) {</span>
          <span class="s1">case </span><span class="s2">&quot;==&quot; </span><span class="s0">: self.operator = </span><span class="s2">&quot;!=&quot;</span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
          <span class="s1">case </span><span class="s2">&quot;!=&quot; </span><span class="s0">: self.operator = </span><span class="s2">&quot;==&quot;</span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
          <span class="s1">case </span><span class="s2">&quot;===&quot;</span><span class="s0">: self.operator = </span><span class="s2">&quot;!==&quot;</span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
          <span class="s1">case </span><span class="s2">&quot;!==&quot;</span><span class="s0">: self.operator = </span><span class="s2">&quot;===&quot;</span><span class="s0">; </span><span class="s1">return </span><span class="s0">self;</span>
          <span class="s1">case </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">:</span>
            <span class="s0">self.operator = </span><span class="s2">&quot;||&quot;</span><span class="s0">;</span>
            <span class="s0">self.left = self.left.negate(compressor, first_in_statement);</span>
            <span class="s0">self.right = self.right.negate(compressor);</span>
            <span class="s1">return </span><span class="s0">best(</span><span class="s1">this</span><span class="s0">, self, first_in_statement);</span>
          <span class="s1">case </span><span class="s2">&quot;||&quot;</span><span class="s0">:</span>
            <span class="s0">self.operator = </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">;</span>
            <span class="s0">self.left = self.left.negate(compressor, first_in_statement);</span>
            <span class="s0">self.right = self.right.negate(compressor);</span>
            <span class="s1">return </span><span class="s0">best(</span><span class="s1">this</span><span class="s0">, self, first_in_statement);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">basic_negation(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;negate&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor, first_in_statement) {</span>
        <span class="s1">return </span><span class="s0">func.call(</span><span class="s1">this</span><span class="s0">, compressor, first_in_statement);</span>
    <span class="s0">});</span>
<span class="s0">});</span>

<span class="s3">// Is the callee of this function pure?</span>
<span class="s1">var </span><span class="s0">global_pure_fns = makePredicate(</span><span class="s2">&quot;Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError&quot;</span><span class="s0">);</span>
<span class="s0">AST_Call.DEFMETHOD(</span><span class="s2">&quot;is_callee_pure&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">expr = </span><span class="s1">this</span><span class="s0">.expression;</span>
        <span class="s1">var </span><span class="s0">first_arg = (</span><span class="s1">this</span><span class="s0">.args &amp;&amp; </span><span class="s1">this</span><span class="s0">.args[</span><span class="s4">0</span><span class="s0">] &amp;&amp; </span><span class="s1">this</span><span class="s0">.args[</span><span class="s4">0</span><span class="s0">].evaluate(compressor));</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">expr.expression &amp;&amp; expr.expression.name === </span><span class="s2">&quot;hasOwnProperty&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">(first_arg == </span><span class="s1">null </span><span class="s0">|| first_arg.thedef &amp;&amp; first_arg.thedef.undeclared)</span>
        <span class="s0">) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is_undeclared_ref(expr) &amp;&amp; global_pure_fns.has(expr.name)) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">expr </span><span class="s1">instanceof </span><span class="s0">AST_Dot</span>
            <span class="s0">&amp;&amp; is_undeclared_ref(expr.expression)</span>
            <span class="s0">&amp;&amp; is_pure_native_fn(expr.expression.name, expr.property)</span>
        <span class="s0">) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">!!has_annotation(</span><span class="s1">this</span><span class="s0">, _PURE) || !compressor.pure_funcs(</span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">});</span>

<span class="s3">// If I call this, is it a pure function?</span>
<span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;is_call_pure&quot;</span><span class="s0">, return_false);</span>
<span class="s0">AST_Dot.DEFMETHOD(</span><span class="s2">&quot;is_call_pure&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">const expr = </span><span class="s1">this</span><span class="s0">.expression;</span>

    <span class="s0">let native_obj;</span>
    <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
        <span class="s0">native_obj = </span><span class="s2">&quot;Array&quot;</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr.is_boolean()) {</span>
        <span class="s0">native_obj = </span><span class="s2">&quot;Boolean&quot;</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr.is_number(compressor)) {</span>
        <span class="s0">native_obj = </span><span class="s2">&quot;Number&quot;</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_RegExp) {</span>
        <span class="s0">native_obj = </span><span class="s2">&quot;RegExp&quot;</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr.is_string(compressor)) {</span>
        <span class="s0">native_obj = </span><span class="s2">&quot;String&quot;</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.may_throw_on_access(compressor)) {</span>
        <span class="s0">native_obj = </span><span class="s2">&quot;Object&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">native_obj != </span><span class="s1">null </span><span class="s0">&amp;&amp; is_pure_native_method(native_obj, </span><span class="s1">this</span><span class="s0">.property);</span>
<span class="s0">});</span>

<span class="s3">// tell me if a statement aborts</span>
<span class="s0">const aborts = (thing) =&gt; thing &amp;&amp; thing.aborts();</span>

<span class="s0">(</span><span class="s1">function</span><span class="s0">(def_aborts) {</span>
    <span class="s0">def_aborts(AST_Statement, return_null);</span>
    <span class="s0">def_aborts(AST_Jump, return_this);</span>
    <span class="s1">function </span><span class="s0">block_aborts() {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.body.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(aborts(</span><span class="s1">this</span><span class="s0">.body[i])) {</span>
                <span class="s1">return this</span><span class="s0">.body[i];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">def_aborts(AST_Import, return_null);</span>
    <span class="s0">def_aborts(AST_BlockStatement, block_aborts);</span>
    <span class="s0">def_aborts(AST_SwitchBranch, block_aborts);</span>
    <span class="s0">def_aborts(AST_DefClass, </span><span class="s1">function </span><span class="s0">() {</span>
        <span class="s1">for </span><span class="s0">(const prop of </span><span class="s1">this</span><span class="s0">.properties) {</span>
            <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_ClassStaticBlock) {</span>
                <span class="s1">if </span><span class="s0">(prop.aborts()) </span><span class="s1">return </span><span class="s0">prop;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">});</span>
    <span class="s0">def_aborts(AST_ClassStaticBlock, block_aborts);</span>
    <span class="s0">def_aborts(AST_If, </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return this</span><span class="s0">.alternative &amp;&amp; aborts(</span><span class="s1">this</span><span class="s0">.body) &amp;&amp; aborts(</span><span class="s1">this</span><span class="s0">.alternative) &amp;&amp; </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">});</span>
<span class="s0">})(</span><span class="s1">function</span><span class="s0">(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;aborts&quot;</span><span class="s0">, func);</span>
<span class="s0">});</span>

<span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;contains_this&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">return </span><span class="s0">walk(</span><span class="s1">this</span><span class="s0">, node =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_This) </span><span class="s1">return </span><span class="s0">walk_abort;</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node !== </span><span class="s1">this</span>
            <span class="s0">&amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Scope</span>
            <span class="s0">&amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_Arrow)</span>
        <span class="s0">) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">is_modified(compressor, tw, node, value, level, immutable) {</span>
    <span class="s1">var </span><span class="s0">parent = tw.parent(level);</span>
    <span class="s1">var </span><span class="s0">lhs = is_lhs(node, parent);</span>
    <span class="s1">if </span><span class="s0">(lhs) </span><span class="s1">return </span><span class="s0">lhs;</span>
    <span class="s1">if </span><span class="s0">(!immutable</span>
        <span class="s0">&amp;&amp; parent </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
        <span class="s0">&amp;&amp; parent.expression === node</span>
        <span class="s0">&amp;&amp; !(value </span><span class="s1">instanceof </span><span class="s0">AST_Arrow)</span>
        <span class="s0">&amp;&amp; !(value </span><span class="s1">instanceof </span><span class="s0">AST_Class)</span>
        <span class="s0">&amp;&amp; !parent.is_callee_pure(compressor)</span>
        <span class="s0">&amp;&amp; (!(value </span><span class="s1">instanceof </span><span class="s0">AST_Function)</span>
            <span class="s0">|| !(parent </span><span class="s1">instanceof </span><span class="s0">AST_New) &amp;&amp; value.contains_this())) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
        <span class="s1">return </span><span class="s0">is_modified(compressor, tw, parent, parent, level + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal &amp;&amp; node === parent.value) {</span>
        <span class="s1">var </span><span class="s0">obj = tw.parent(level + </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">is_modified(compressor, tw, obj, obj, level + </span><span class="s4">2</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; parent.expression === node) {</span>
        <span class="s1">var </span><span class="s0">prop = read_property(value, parent.property);</span>
        <span class="s1">return </span><span class="s0">!immutable &amp;&amp; is_modified(compressor, tw, parent, prop, level + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">// methods to evaluate a constant expression</span>

<span class="s1">function </span><span class="s0">def_eval(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;_eval&quot;</span><span class="s0">, func);</span>
<span class="s0">}</span>

<span class="s3">// Used to propagate a nullish short-circuit signal upwards through the chain.</span>
<span class="s0">const nullish = Symbol(</span><span class="s2">&quot;This AST_Chain is nullish&quot;</span><span class="s0">);</span>

<span class="s3">// If the node has been successfully reduced to a constant,</span>
<span class="s3">// then its value is returned; otherwise the element itself</span>
<span class="s3">// is returned.</span>
<span class="s3">// They can be distinguished as constant value is never a</span>
<span class="s3">// descendant of AST_Node.</span>
<span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;evaluate&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s0">))</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">val = </span><span class="s1">this</span><span class="s0">._eval(compressor, </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(!val || val </span><span class="s1">instanceof </span><span class="s0">RegExp)</span>
        <span class="s1">return </span><span class="s0">val;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">val == </span><span class="s2">&quot;function&quot; </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">val == </span><span class="s2">&quot;object&quot; </span><span class="s0">|| val == nullish)</span>
        <span class="s1">return this</span><span class="s0">;</span>

    <span class="s3">// Evaluated strings can be larger than the original expression</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">val === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
        <span class="s0">const unevaluated_size = </span><span class="s1">this</span><span class="s0">.size(compressor);</span>
        <span class="s1">if </span><span class="s0">(val.length + </span><span class="s4">2 </span><span class="s0">&gt; unevaluated_size) </span><span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">val;</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">unaryPrefix = makePredicate(</span><span class="s2">&quot;! ~ - + void&quot;</span><span class="s0">);</span>
<span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;is_constant&quot;</span><span class="s0">, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s3">// Accomodate when compress option evaluate=false</span>
    <span class="s3">// as well as the common constant expressions !0 and -1</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">AST_Constant) {</span>
        <span class="s1">return </span><span class="s0">!(</span><span class="s1">this instanceof </span><span class="s0">AST_RegExp);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return this instanceof </span><span class="s0">AST_UnaryPrefix</span>
            <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
            <span class="s0">&amp;&amp; unaryPrefix.has(</span><span class="s1">this</span><span class="s0">.operator);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Statement, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">throw new </span><span class="s0">Error(string_template(</span><span class="s2">&quot;Cannot evaluate a statement [{file}:{line},{col}]&quot;</span><span class="s0">, </span><span class="s1">this</span><span class="s0">.start));</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Lambda, return_this);</span>
<span class="s0">def_eval(AST_Class, return_this);</span>
<span class="s0">def_eval(AST_Node, return_this);</span>
<span class="s0">def_eval(AST_Constant, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.getValue();</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_BigInt, return_this);</span>

<span class="s0">def_eval(AST_RegExp, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s0">let evaluated = compressor.evaluated_regexps.get(</span><span class="s1">this</span><span class="s0">.value);</span>
    <span class="s1">if </span><span class="s0">(evaluated === undefined &amp;&amp; regexp_is_safe(</span><span class="s1">this</span><span class="s0">.value.source)) {</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">const { source, flags } = </span><span class="s1">this</span><span class="s0">.value;</span>
            <span class="s0">evaluated = </span><span class="s1">new </span><span class="s0">RegExp(source, flags);</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
            <span class="s0">evaluated = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">compressor.evaluated_regexps.set(</span><span class="s1">this</span><span class="s0">.value, evaluated);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">evaluated || </span><span class="s1">this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_TemplateString, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.segments.length !== </span><span class="s4">1</span><span class="s0">) </span><span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">return this</span><span class="s0">.segments[</span><span class="s4">0</span><span class="s0">].value;</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Function, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">fn = </span><span class="s1">function </span><span class="s0">() { };</span>
        <span class="s0">fn.node = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">fn.toString = () =&gt; </span><span class="s1">this</span><span class="s0">.print_to_string();</span>
        <span class="s1">return </span><span class="s0">fn;</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Array, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">elements = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = </span><span class="s1">this</span><span class="s0">.elements.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">element = </span><span class="s1">this</span><span class="s0">.elements[i];</span>
            <span class="s1">var </span><span class="s0">value = element._eval(compressor, depth);</span>
            <span class="s1">if </span><span class="s0">(element === value)</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s0">elements.push(value);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">elements;</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Object, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">val = {};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = </span><span class="s1">this</span><span class="s0">.properties.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">prop = </span><span class="s1">this</span><span class="s0">.properties[i];</span>
            <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_Expansion)</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">key = prop.key;</span>
            <span class="s1">if </span><span class="s0">(key </span><span class="s1">instanceof </span><span class="s0">AST_Symbol) {</span>
                <span class="s0">key = key.name;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(key </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
                <span class="s0">key = key._eval(compressor, depth);</span>
                <span class="s1">if </span><span class="s0">(key === prop.key)</span>
                    <span class="s1">return this</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">Object.prototype[key] === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(prop.value </span><span class="s1">instanceof </span><span class="s0">AST_Function)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">val[key] = prop.value._eval(compressor, depth);</span>
            <span class="s1">if </span><span class="s0">(val[key] === prop.value)</span>
                <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">val;</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">non_converting_unary = makePredicate(</span><span class="s2">&quot;! typeof void&quot;</span><span class="s0">);</span>
<span class="s0">def_eval(AST_UnaryPrefix, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s1">var </span><span class="s0">e = </span><span class="s1">this</span><span class="s0">.expression;</span>
    <span class="s3">// Function would be evaluated to an array and so typeof would</span>
    <span class="s3">// incorrectly return 'object'. Hence making is a special case.</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;typeofs&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;typeof&quot;</span>
        <span class="s0">&amp;&amp; (e </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
            <span class="s0">|| e </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">&amp;&amp; e.fixed_value() </span><span class="s1">instanceof </span><span class="s0">AST_Lambda)) {</span>
        <span class="s1">return typeof function </span><span class="s0">() { };</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!non_converting_unary.has(</span><span class="s1">this</span><span class="s0">.operator))</span>
        <span class="s0">depth++;</span>
    <span class="s0">e = e._eval(compressor, depth);</span>
    <span class="s1">if </span><span class="s0">(e === </span><span class="s1">this</span><span class="s0">.expression)</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">switch </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator) {</span>
        <span class="s1">case </span><span class="s2">&quot;!&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s0">!e;</span>
        <span class="s1">case </span><span class="s2">&quot;typeof&quot;</span><span class="s0">:</span>
            <span class="s3">// typeof &lt;RegExp&gt; returns &quot;object&quot; or &quot;function&quot; on different platforms</span>
            <span class="s3">// so cannot evaluate reliably</span>
            <span class="s1">if </span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">RegExp)</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s1">return typeof </span><span class="s0">e;</span>
        <span class="s1">case </span><span class="s2">&quot;void&quot;</span><span class="s0">: </span><span class="s1">return void </span><span class="s0">e;</span>
        <span class="s1">case </span><span class="s2">&quot;~&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s0">~e;</span>
        <span class="s1">case </span><span class="s2">&quot;-&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s0">-e;</span>
        <span class="s1">case </span><span class="s2">&quot;+&quot;</span><span class="s0">: </span><span class="s1">return </span><span class="s0">+e;</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">non_converting_binary = makePredicate(</span><span class="s2">&quot;&amp;&amp; || ?? === !==&quot;</span><span class="s0">);</span>
<span class="s0">const identity_comparison = makePredicate(</span><span class="s2">&quot;== != === !==&quot;</span><span class="s0">);</span>
<span class="s0">const has_identity = value =&gt; </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;object&quot;</span>
    <span class="s0">|| </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;function&quot;</span>
    <span class="s0">|| </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;symbol&quot;</span><span class="s0">;</span>

<span class="s0">def_eval(AST_Binary, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s1">if </span><span class="s0">(!non_converting_binary.has(</span><span class="s1">this</span><span class="s0">.operator))</span>
        <span class="s0">depth++;</span>

    <span class="s1">var </span><span class="s0">left = </span><span class="s1">this</span><span class="s0">.left._eval(compressor, depth);</span>
    <span class="s1">if </span><span class="s0">(left === </span><span class="s1">this</span><span class="s0">.left)</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">right = </span><span class="s1">this</span><span class="s0">.right._eval(compressor, depth);</span>
    <span class="s1">if </span><span class="s0">(right === </span><span class="s1">this</span><span class="s0">.right)</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">result;</span>

    <span class="s1">if </span><span class="s0">(left != </span><span class="s1">null</span>
        <span class="s0">&amp;&amp; right != </span><span class="s1">null</span>
        <span class="s0">&amp;&amp; identity_comparison.has(</span><span class="s1">this</span><span class="s0">.operator)</span>
        <span class="s0">&amp;&amp; has_identity(left)</span>
        <span class="s0">&amp;&amp; has_identity(right)</span>
        <span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">left === </span><span class="s1">typeof </span><span class="s0">right) {</span>
        <span class="s3">// Do not compare by reference</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">switch </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator) {</span>
        <span class="s1">case </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">: result = left &amp;&amp; right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;||&quot;</span><span class="s0">: result = left || right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;??&quot;</span><span class="s0">: result = left != </span><span class="s1">null </span><span class="s0">? left : right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;|&quot;</span><span class="s0">: result = left | right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&amp;&quot;</span><span class="s0">: result = left &amp; right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;^&quot;</span><span class="s0">: result = left ^ right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;+&quot;</span><span class="s0">: result = left + right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;*&quot;</span><span class="s0">: result = left * right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;**&quot;</span><span class="s0">: result = Math.pow(left, right); </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;/&quot;</span><span class="s0">: result = left / right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;%&quot;</span><span class="s0">: result = left % right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;-&quot;</span><span class="s0">: result = left - right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&lt;&lt;&quot;</span><span class="s0">: result = left &lt;&lt; right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&gt;&gt;&quot;</span><span class="s0">: result = left &gt;&gt; right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&gt;&gt;&gt;&quot;</span><span class="s0">: result = left &gt;&gt;&gt; right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;==&quot;</span><span class="s0">: result = left == right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;===&quot;</span><span class="s0">: result = left === right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;!=&quot;</span><span class="s0">: result = left != right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;!==&quot;</span><span class="s0">: result = left !== right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&lt;&quot;</span><span class="s0">: result = left &lt; right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">: result = left &lt;= right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&gt;&quot;</span><span class="s0">: result = left &gt; right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">: result = left &gt;= right; </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(isNaN(result) &amp;&amp; compressor.find_parent(AST_With)) {</span>
        <span class="s3">// leave original expression as is</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">result;</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Conditional, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s1">var </span><span class="s0">condition = </span><span class="s1">this</span><span class="s0">.condition._eval(compressor, depth);</span>
    <span class="s1">if </span><span class="s0">(condition === </span><span class="s1">this</span><span class="s0">.condition)</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">node = condition ? </span><span class="s1">this</span><span class="s0">.consequent : </span><span class="s1">this</span><span class="s0">.alternative;</span>
    <span class="s1">var </span><span class="s0">value = node._eval(compressor, depth);</span>
    <span class="s1">return </span><span class="s0">value === node ? </span><span class="s1">this </span><span class="s0">: value;</span>
<span class="s0">});</span>

<span class="s3">// Set of AST_SymbolRef which are currently being evaluated.</span>
<span class="s3">// Avoids infinite recursion of ._eval()</span>
<span class="s0">const reentrant_ref_eval = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s0">def_eval(AST_SymbolRef, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s1">if </span><span class="s0">(reentrant_ref_eval.has(</span><span class="s1">this</span><span class="s0">))</span>
        <span class="s1">return this</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">fixed = </span><span class="s1">this</span><span class="s0">.fixed_value();</span>
    <span class="s1">if </span><span class="s0">(!fixed)</span>
        <span class="s1">return this</span><span class="s0">;</span>

    <span class="s0">reentrant_ref_eval.add(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">const value = fixed._eval(compressor, depth);</span>
    <span class="s0">reentrant_ref_eval.</span><span class="s1">delete</span><span class="s0">(</span><span class="s1">this</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(value === fixed)</span>
        <span class="s1">return this</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(value &amp;&amp; </span><span class="s1">typeof </span><span class="s0">value == </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">escaped = </span><span class="s1">this</span><span class="s0">.definition().escaped;</span>
        <span class="s1">if </span><span class="s0">(escaped &amp;&amp; depth &gt; escaped)</span>
            <span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">value;</span>
<span class="s0">});</span>

<span class="s0">const global_objs = { Array, Math, Number, Object, String };</span>

<span class="s0">const regexp_flags = </span><span class="s1">new </span><span class="s0">Set([</span>
    <span class="s2">&quot;dotAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;global&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ignoreCase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;multiline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sticky&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unicode&quot;</span><span class="s0">,</span>
<span class="s0">]);</span>

<span class="s0">def_eval(AST_PropAccess, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s0">let obj = </span><span class="s1">this</span><span class="s0">.expression._eval(compressor, depth + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(obj === nullish || (</span><span class="s1">this</span><span class="s0">.optional &amp;&amp; obj == </span><span class="s1">null</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">nullish;</span>

    <span class="s3">// `.length` of strings and arrays is always safe</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.property === </span><span class="s2">&quot;length&quot;</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">obj === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">obj.length;</span>
        <span class="s0">}</span>

        <span class="s0">const is_spreadless_array =</span>
            <span class="s0">obj </span><span class="s1">instanceof </span><span class="s0">AST_Array</span>
            <span class="s0">&amp;&amp; obj.elements.every(el =&gt; !(el </span><span class="s1">instanceof </span><span class="s0">AST_Expansion));</span>

        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">is_spreadless_array</span>
            <span class="s0">&amp;&amp; obj.elements.every(el =&gt; !el.has_side_effects(compressor))</span>
        <span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">obj.elements.length;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">key = </span><span class="s1">this</span><span class="s0">.property;</span>
        <span class="s1">if </span><span class="s0">(key </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
            <span class="s0">key = key._eval(compressor, depth);</span>
            <span class="s1">if </span><span class="s0">(key === </span><span class="s1">this</span><span class="s0">.property)</span>
                <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">exp = </span><span class="s1">this</span><span class="s0">.expression;</span>
        <span class="s1">if </span><span class="s0">(is_undeclared_ref(exp)) {</span>
            <span class="s1">var </span><span class="s0">aa;</span>
            <span class="s1">var </span><span class="s0">first_arg = exp.name === </span><span class="s2">&quot;hasOwnProperty&quot;</span>
                <span class="s0">&amp;&amp; key === </span><span class="s2">&quot;call&quot;</span>
                <span class="s0">&amp;&amp; (aa = compressor.parent() &amp;&amp; compressor.parent().args)</span>
                <span class="s0">&amp;&amp; (aa &amp;&amp; aa[</span><span class="s4">0</span><span class="s0">]</span>
                    <span class="s0">&amp;&amp; aa[</span><span class="s4">0</span><span class="s0">].evaluate(compressor));</span>

            <span class="s0">first_arg = first_arg </span><span class="s1">instanceof </span><span class="s0">AST_Dot ? first_arg.expression : first_arg;</span>

            <span class="s1">if </span><span class="s0">(first_arg == </span><span class="s1">null </span><span class="s0">|| first_arg.thedef &amp;&amp; first_arg.thedef.undeclared) {</span>
                <span class="s1">return this</span><span class="s0">.clone();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!is_pure_native_value(exp.name, key))</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s0">obj = global_objs[exp.name];</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(obj </span><span class="s1">instanceof </span><span class="s0">RegExp) {</span>
                <span class="s1">if </span><span class="s0">(key == </span><span class="s2">&quot;source&quot;</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s0">regexp_source_fix(obj.source);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(key == </span><span class="s2">&quot;flags&quot; </span><span class="s0">|| regexp_flags.has(key)) {</span>
                    <span class="s1">return </span><span class="s0">obj[key];</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!obj || obj === exp || !HOP(obj, key))</span>
                <span class="s1">return this</span><span class="s0">;</span>

            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">obj == </span><span class="s2">&quot;function&quot;</span><span class="s0">)</span>
                <span class="s1">switch </span><span class="s0">(key) {</span>
                    <span class="s1">case </span><span class="s2">&quot;name&quot;</span><span class="s0">:</span>
                        <span class="s1">return </span><span class="s0">obj.node.name ? obj.node.name.name : </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                    <span class="s1">case </span><span class="s2">&quot;length&quot;</span><span class="s0">:</span>
                        <span class="s1">return </span><span class="s0">obj.node.length_property();</span>
                    <span class="s1">default</span><span class="s0">:</span>
                        <span class="s1">return this</span><span class="s0">;</span>
                <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">obj[key];</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Chain, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s0">const evaluated = </span><span class="s1">this</span><span class="s0">.expression._eval(compressor, depth);</span>
    <span class="s1">return </span><span class="s0">evaluated === nullish</span>
        <span class="s0">? undefined</span>
        <span class="s0">: evaluated === </span><span class="s1">this</span><span class="s0">.expression</span>
          <span class="s0">? </span><span class="s1">this</span>
          <span class="s0">: evaluated;</span>
<span class="s0">});</span>

<span class="s0">def_eval(AST_Call, </span><span class="s1">function </span><span class="s0">(compressor, depth) {</span>
    <span class="s1">var </span><span class="s0">exp = </span><span class="s1">this</span><span class="s0">.expression;</span>

    <span class="s0">const callee = exp._eval(compressor, depth);</span>
    <span class="s1">if </span><span class="s0">(callee === nullish || (</span><span class="s1">this</span><span class="s0">.optional &amp;&amp; callee == </span><span class="s1">null</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">nullish;</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">) &amp;&amp; exp </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess) {</span>
        <span class="s1">var </span><span class="s0">key = exp.property;</span>
        <span class="s1">if </span><span class="s0">(key </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
            <span class="s0">key = key._eval(compressor, depth);</span>
            <span class="s1">if </span><span class="s0">(key === exp.property)</span>
                <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">val;</span>
        <span class="s1">var </span><span class="s0">e = exp.expression;</span>
        <span class="s1">if </span><span class="s0">(is_undeclared_ref(e)) {</span>
            <span class="s1">var </span><span class="s0">first_arg = e.name === </span><span class="s2">&quot;hasOwnProperty&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">key === </span><span class="s2">&quot;call&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">(</span><span class="s1">this</span><span class="s0">.args[</span><span class="s4">0</span><span class="s0">] &amp;&amp; </span><span class="s1">this</span><span class="s0">.args[</span><span class="s4">0</span><span class="s0">].evaluate(compressor));</span>

            <span class="s0">first_arg = first_arg </span><span class="s1">instanceof </span><span class="s0">AST_Dot ? first_arg.expression : first_arg;</span>

            <span class="s1">if </span><span class="s0">((first_arg == </span><span class="s1">null </span><span class="s0">|| first_arg.thedef &amp;&amp; first_arg.thedef.undeclared)) {</span>
                <span class="s1">return this</span><span class="s0">.clone();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!is_pure_native_fn(e.name, key)) </span><span class="s1">return this</span><span class="s0">;</span>
            <span class="s0">val = global_objs[e.name];</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">val = e._eval(compressor, depth + </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(val === e || !val)</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!is_pure_native_method(val.constructor.name, key))</span>
                <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">args = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = </span><span class="s1">this</span><span class="s0">.args.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">arg = </span><span class="s1">this</span><span class="s0">.args[i];</span>
            <span class="s1">var </span><span class="s0">value = arg._eval(compressor, depth);</span>
            <span class="s1">if </span><span class="s0">(arg === value)</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(arg </span><span class="s1">instanceof </span><span class="s0">AST_Lambda)</span>
                <span class="s1">return this</span><span class="s0">;</span>
            <span class="s0">args.push(value);</span>
        <span class="s0">}</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">val[key].apply(val, args);</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) {</span>
            <span class="s3">// We don't really care</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s3">// Also a subclass of AST_Call</span>
<span class="s0">def_eval(AST_New, return_this);</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">// AST_Node#drop_side_effect_free() gets called when we don't care about the value,</span>
<span class="s3">// only about side effects. We'll be defining this method for each node type in this module</span>
<span class="s3">//</span>
<span class="s3">// Examples:</span>
<span class="s3">// foo++ -&gt; foo++</span>
<span class="s3">// 1 + func() -&gt; func()</span>
<span class="s3">// 10 -&gt; (nothing)</span>
<span class="s3">// knownPureFunc(foo++) -&gt; foo++</span>

<span class="s1">function </span><span class="s0">def_drop_side_effect_free(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;drop_side_effect_free&quot;</span><span class="s0">, func);</span>
<span class="s0">}</span>

<span class="s3">// Drop side-effect-free elements from an array of expressions.</span>
<span class="s3">// Returns an array of expressions with side-effects or null</span>
<span class="s3">// if all elements were dropped. Note: original array may be</span>
<span class="s3">// returned if nothing changed.</span>
<span class="s1">function </span><span class="s0">trim(nodes, compressor, first_in_statement) {</span>
    <span class="s1">var </span><span class="s0">len = nodes.length;</span>
    <span class="s1">if </span><span class="s0">(!len)  </span><span class="s1">return null</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">ret = [], changed = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; len; i++) {</span>
        <span class="s1">var </span><span class="s0">node = nodes[i].drop_side_effect_free(compressor, first_in_statement);</span>
        <span class="s0">changed |= node !== nodes[i];</span>
        <span class="s1">if </span><span class="s0">(node) {</span>
            <span class="s0">ret.push(node);</span>
            <span class="s0">first_in_statement = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">changed ? ret.length ? ret : </span><span class="s1">null </span><span class="s0">: nodes;</span>
<span class="s0">}</span>

<span class="s0">def_drop_side_effect_free(AST_Node, return_this);</span>
<span class="s0">def_drop_side_effect_free(AST_Constant, return_null);</span>
<span class="s0">def_drop_side_effect_free(AST_This, return_null);</span>

<span class="s0">def_drop_side_effect_free(AST_Call, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">if </span><span class="s0">(is_nullish_shortcircuited(</span><span class="s1">this</span><span class="s0">, compressor)) {</span>
        <span class="s1">return this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.is_callee_pure(compressor)) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expression.is_call_pure(compressor)) {</span>
            <span class="s1">var </span><span class="s0">exprs = </span><span class="s1">this</span><span class="s0">.args.slice();</span>
            <span class="s0">exprs.unshift(</span><span class="s1">this</span><span class="s0">.expression.expression);</span>
            <span class="s0">exprs = trim(exprs, compressor, first_in_statement);</span>
            <span class="s1">return </span><span class="s0">exprs &amp;&amp; make_sequence(</span><span class="s1">this</span><span class="s0">, exprs);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is_func_expr(</span><span class="s1">this</span><span class="s0">.expression)</span>
            <span class="s0">&amp;&amp; (!</span><span class="s1">this</span><span class="s0">.expression.name || !</span><span class="s1">this</span><span class="s0">.expression.name.definition().references.length)) {</span>
            <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.clone();</span>
            <span class="s0">node.expression.process_expression(</span><span class="s1">false</span><span class="s0">, compressor);</span>
            <span class="s1">return </span><span class="s0">node;</span>
        <span class="s0">}</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">args = trim(</span><span class="s1">this</span><span class="s0">.args, compressor, first_in_statement);</span>
    <span class="s1">return </span><span class="s0">args &amp;&amp; make_sequence(</span><span class="s1">this</span><span class="s0">, args);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Accessor, return_null);</span>

<span class="s0">def_drop_side_effect_free(AST_Function, return_null);</span>

<span class="s0">def_drop_side_effect_free(AST_Arrow, return_null);</span>

<span class="s0">def_drop_side_effect_free(AST_Class, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s0">const with_effects = [];</span>
    <span class="s0">const trimmed_extends = </span><span class="s1">this</span><span class="s0">.extends &amp;&amp; </span><span class="s1">this</span><span class="s0">.extends.drop_side_effect_free(compressor);</span>
    <span class="s1">if </span><span class="s0">(trimmed_extends)</span>
        <span class="s0">with_effects.push(trimmed_extends);</span>

    <span class="s1">for </span><span class="s0">(const prop of </span><span class="s1">this</span><span class="s0">.properties) {</span>
        <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_ClassStaticBlock) {</span>
            <span class="s1">if </span><span class="s0">(prop.has_side_effects(compressor)) {</span>
                <span class="s1">return this</span><span class="s0">; </span><span class="s3">// Be cautious about these</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">const trimmed_prop = prop.drop_side_effect_free(compressor);</span>
            <span class="s1">if </span><span class="s0">(trimmed_prop) {</span>
                <span class="s1">if </span><span class="s0">(trimmed_prop.contains_this()) </span><span class="s1">return this</span><span class="s0">;</span>

                <span class="s0">with_effects.push(trimmed_prop);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(!with_effects.length)</span>
        <span class="s1">return null</span><span class="s0">;</span>

    <span class="s0">const exprs = make_sequence(</span><span class="s1">this</span><span class="s0">, with_effects);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this instanceof </span><span class="s0">AST_DefClass) {</span>
        <span class="s3">// We want a statement</span>
        <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, </span><span class="s1">this</span><span class="s0">, { body: exprs });</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">exprs;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_ClassProperty, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s0">const key = </span><span class="s1">this</span><span class="s0">.computed_key() &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.drop_side_effect_free(compressor);</span>

    <span class="s0">const value = </span><span class="s1">this</span><span class="s0">.static &amp;&amp; </span><span class="s1">this</span><span class="s0">.value</span>
        <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.value.drop_side_effect_free(compressor);</span>

    <span class="s1">if </span><span class="s0">(key &amp;&amp; value)</span>
        <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, [key, value]);</span>
    <span class="s1">return </span><span class="s0">key || value || </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Binary, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">var </span><span class="s0">right = </span><span class="s1">this</span><span class="s0">.right.drop_side_effect_free(compressor);</span>
    <span class="s1">if </span><span class="s0">(!right)</span>
        <span class="s1">return this</span><span class="s0">.left.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s1">if </span><span class="s0">(lazy_op.has(</span><span class="s1">this</span><span class="s0">.operator)) {</span>
        <span class="s1">if </span><span class="s0">(right === </span><span class="s1">this</span><span class="s0">.right)</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.clone();</span>
        <span class="s0">node.right = right;</span>
        <span class="s1">return </span><span class="s0">node;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">left = </span><span class="s1">this</span><span class="s0">.left.drop_side_effect_free(compressor, first_in_statement);</span>
        <span class="s1">if </span><span class="s0">(!left)</span>
            <span class="s1">return this</span><span class="s0">.right.drop_side_effect_free(compressor, first_in_statement);</span>
        <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, [left, right]);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Assign, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.logical)</span>
        <span class="s1">return this</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">left = </span><span class="s1">this</span><span class="s0">.left;</span>
    <span class="s1">if </span><span class="s0">(left.has_side_effects(compressor)</span>
        <span class="s0">|| compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; left </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
        <span class="s0">&amp;&amp; left.expression.is_constant()) {</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">set_flag(</span><span class="s1">this</span><span class="s0">, WRITE_ONLY);</span>
    <span class="s1">while </span><span class="s0">(left </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess) {</span>
        <span class="s0">left = left.expression;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(left.is_constant_expression(compressor.find_parent(AST_Scope))) {</span>
        <span class="s1">return this</span><span class="s0">.right.drop_side_effect_free(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Conditional, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s1">var </span><span class="s0">consequent = </span><span class="s1">this</span><span class="s0">.consequent.drop_side_effect_free(compressor);</span>
    <span class="s1">var </span><span class="s0">alternative = </span><span class="s1">this</span><span class="s0">.alternative.drop_side_effect_free(compressor);</span>
    <span class="s1">if </span><span class="s0">(consequent === </span><span class="s1">this</span><span class="s0">.consequent &amp;&amp; alternative === </span><span class="s1">this</span><span class="s0">.alternative)</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!consequent)</span>
        <span class="s1">return </span><span class="s0">alternative ? make_node(AST_Binary, </span><span class="s1">this</span><span class="s0">, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
            <span class="s0">left: </span><span class="s1">this</span><span class="s0">.condition,</span>
            <span class="s0">right: alternative</span>
        <span class="s0">}) : </span><span class="s1">this</span><span class="s0">.condition.drop_side_effect_free(compressor);</span>
    <span class="s1">if </span><span class="s0">(!alternative)</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, </span><span class="s1">this</span><span class="s0">, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
            <span class="s0">left: </span><span class="s1">this</span><span class="s0">.condition,</span>
            <span class="s0">right: consequent</span>
        <span class="s0">});</span>
    <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">.clone();</span>
    <span class="s0">node.consequent = consequent;</span>
    <span class="s0">node.alternative = alternative;</span>
    <span class="s1">return </span><span class="s0">node;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Unary, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">if </span><span class="s0">(unary_side_effects.has(</span><span class="s1">this</span><span class="s0">.operator)) {</span>
        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.expression.has_side_effects(compressor)) {</span>
            <span class="s0">set_flag(</span><span class="s1">this</span><span class="s0">, WRITE_ONLY);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">clear_flag(</span><span class="s1">this</span><span class="s0">, WRITE_ONLY);</span>
        <span class="s0">}</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;typeof&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef)</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">expression = </span><span class="s1">this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s1">if </span><span class="s0">(first_in_statement &amp;&amp; expression &amp;&amp; is_iife_call(expression)) {</span>
        <span class="s1">if </span><span class="s0">(expression === </span><span class="s1">this</span><span class="s0">.expression &amp;&amp; </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;!&quot;</span><span class="s0">)</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">expression.negate(compressor, first_in_statement);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">expression;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_SymbolRef, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s0">const safe_access = </span><span class="s1">this</span><span class="s0">.is_declared(compressor)</span>
        <span class="s0">|| pure_prop_access_globals.has(</span><span class="s1">this</span><span class="s0">.name);</span>
    <span class="s1">return </span><span class="s0">safe_access ? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Object, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">var </span><span class="s0">values = trim(</span><span class="s1">this</span><span class="s0">.properties, compressor, first_in_statement);</span>
    <span class="s1">return </span><span class="s0">values &amp;&amp; make_sequence(</span><span class="s1">this</span><span class="s0">, values);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_ObjectProperty, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s0">const computed_key = </span><span class="s1">this instanceof </span><span class="s0">AST_ObjectKeyVal &amp;&amp; </span><span class="s1">this</span><span class="s0">.key </span><span class="s1">instanceof </span><span class="s0">AST_Node;</span>
    <span class="s0">const key = computed_key &amp;&amp; </span><span class="s1">this</span><span class="s0">.key.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s0">const value = </span><span class="s1">this</span><span class="s0">.value &amp;&amp; </span><span class="s1">this</span><span class="s0">.value.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s1">if </span><span class="s0">(key &amp;&amp; value) {</span>
        <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, [key, value]);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">key || value;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_ConciseMethod, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.computed_key() ? </span><span class="s1">this</span><span class="s0">.key : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_ObjectGetter, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.computed_key() ? </span><span class="s1">this</span><span class="s0">.key : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_ObjectSetter, </span><span class="s1">function </span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.computed_key() ? </span><span class="s1">this</span><span class="s0">.key : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Array, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">var </span><span class="s0">values = trim(</span><span class="s1">this</span><span class="s0">.elements, compressor, first_in_statement);</span>
    <span class="s1">return </span><span class="s0">values &amp;&amp; make_sequence(</span><span class="s1">this</span><span class="s0">, values);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Dot, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">if </span><span class="s0">(is_nullish_shortcircuited(</span><span class="s1">this</span><span class="s0">, compressor)) {</span>
        <span class="s1">return this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expression.may_throw_on_access(compressor)) </span><span class="s1">return this</span><span class="s0">;</span>

    <span class="s1">return this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Sub, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">if </span><span class="s0">(is_nullish_shortcircuited(</span><span class="s1">this</span><span class="s0">, compressor)) {</span>
        <span class="s1">return this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expression.may_throw_on_access(compressor)) </span><span class="s1">return this</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">expression = </span><span class="s1">this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s1">if </span><span class="s0">(!expression)</span>
        <span class="s1">return this</span><span class="s0">.property.drop_side_effect_free(compressor, first_in_statement);</span>
    <span class="s1">var </span><span class="s0">property = </span><span class="s1">this</span><span class="s0">.property.drop_side_effect_free(compressor);</span>
    <span class="s1">if </span><span class="s0">(!property)</span>
        <span class="s1">return </span><span class="s0">expression;</span>
    <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, [expression, property]);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Chain, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">return this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Sequence, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s1">var </span><span class="s0">last = </span><span class="s1">this</span><span class="s0">.tail_node();</span>
    <span class="s1">var </span><span class="s0">expr = last.drop_side_effect_free(compressor);</span>
    <span class="s1">if </span><span class="s0">(expr === last)</span>
        <span class="s1">return this</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">expressions = </span><span class="s1">this</span><span class="s0">.expressions.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(expr)</span>
        <span class="s0">expressions.push(expr);</span>
    <span class="s1">if </span><span class="s0">(!expressions.length) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Number, </span><span class="s1">this</span><span class="s0">, { value: </span><span class="s4">0 </span><span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, expressions);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_Expansion, </span><span class="s1">function </span><span class="s0">(compressor, first_in_statement) {</span>
    <span class="s1">return this</span><span class="s0">.expression.drop_side_effect_free(compressor, first_in_statement);</span>
<span class="s0">});</span>

<span class="s0">def_drop_side_effect_free(AST_TemplateSegment, return_null);</span>

<span class="s0">def_drop_side_effect_free(AST_TemplateString, </span><span class="s1">function </span><span class="s0">(compressor) {</span>
    <span class="s1">var </span><span class="s0">values = trim(</span><span class="s1">this</span><span class="s0">.segments, compressor, first_in_statement);</span>
    <span class="s1">return </span><span class="s0">values &amp;&amp; make_sequence(</span><span class="s1">this</span><span class="s0">, values);</span>
<span class="s0">});</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s0">const r_keep_assign = /keep_assign/;</span>

<span class="s3">/** Drop unused variables from this scope */</span>
<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;drop_unused&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s0">)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(self.pinned()) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">drop_funcs = !(self </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) || compressor.toplevel.funcs;</span>
    <span class="s1">var </span><span class="s0">drop_vars = !(self </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) || compressor.toplevel.vars;</span>
    <span class="s0">const assign_as_unused = r_keep_assign.test(compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">)) ? return_false : </span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
            <span class="s0">&amp;&amp; !node.logical</span>
            <span class="s0">&amp;&amp; (has_flag(node, WRITE_ONLY) || node.operator == </span><span class="s2">&quot;=&quot;</span><span class="s0">)</span>
        <span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">node.left;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Unary &amp;&amp; has_flag(node, WRITE_ONLY)) {</span>
            <span class="s1">return </span><span class="s0">node.expression;</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s1">var </span><span class="s0">in_use_ids = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">var </span><span class="s0">fixed_ids = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">if </span><span class="s0">(self </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel &amp;&amp; compressor.top_retain) {</span>
        <span class="s0">self.variables.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
            <span class="s1">if </span><span class="s0">(compressor.top_retain(def) &amp;&amp; !in_use_ids.has(def.id)) {</span>
                <span class="s0">in_use_ids.set(def.id, def);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">var_defs_by_id = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">var </span><span class="s0">initializations = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s3">// pass 1: find out which symbols are directly used in</span>
    <span class="s3">// this scope (not in nested scopes).</span>
    <span class="s1">var </span><span class="s0">scope = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node, descend) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; node.uses_arguments &amp;&amp; !tw.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)) {</span>
            <span class="s0">node.argnames.forEach(</span><span class="s1">function</span><span class="s0">(argname) {</span>
                <span class="s1">if </span><span class="s0">(!(argname </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration)) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">def = argname.definition();</span>
                <span class="s1">if </span><span class="s0">(!in_use_ids.has(def.id)) {</span>
                    <span class="s0">in_use_ids.set(def.id, def);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node === self) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Class) {</span>
            <span class="s1">if </span><span class="s0">(node.has_side_effects(compressor)) {</span>
                <span class="s0">node.visit_nondeferred_class_parts(tw);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Defun || node </span><span class="s1">instanceof </span><span class="s0">AST_DefClass) {</span>
            <span class="s1">var </span><span class="s0">node_def = node.name.definition();</span>
            <span class="s0">const in_export = tw.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Export;</span>
            <span class="s1">if </span><span class="s0">(in_export || !drop_funcs &amp;&amp; scope === self) {</span>
                <span class="s1">if </span><span class="s0">(node_def.global &amp;&amp; !in_use_ids.has(node_def.id)) {</span>
                    <span class="s0">in_use_ids.set(node_def.id, node_def);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s0">map_add(initializations, node_def.id, node);</span>
            <span class="s1">return true</span><span class="s0">; </span><span class="s3">// don't go in nested scopes</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg &amp;&amp; scope === self) {</span>
            <span class="s0">map_add(var_defs_by_id, node.definition().id, node);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Definitions &amp;&amp; scope === self) {</span>
            <span class="s0">const in_export = tw.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Export;</span>
            <span class="s0">node.definitions.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
                <span class="s1">if </span><span class="s0">(def.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolVar) {</span>
                    <span class="s0">map_add(var_defs_by_id, def.name.definition().id, def);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(in_export || !drop_vars) {</span>
                    <span class="s0">walk(def.name, node =&gt; {</span>
                        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration) {</span>
                            <span class="s0">const def = node.definition();</span>
                            <span class="s1">if </span><span class="s0">(def.global &amp;&amp; !in_use_ids.has(def.id)) {</span>
                                <span class="s0">in_use_ids.set(def.id, def);</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(def.name </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
                    <span class="s0">def.walk(tw);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(def.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration &amp;&amp; def.value) {</span>
                    <span class="s1">var </span><span class="s0">node_def = def.name.definition();</span>
                    <span class="s0">map_add(initializations, node_def.id, def.value);</span>
                    <span class="s1">if </span><span class="s0">(!node_def.chained &amp;&amp; def.name.fixed_value() === def.value) {</span>
                        <span class="s0">fixed_ids.set(node_def.id, def);</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(def.value.has_side_effects(compressor)) {</span>
                        <span class="s0">def.value.walk(tw);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">scan_ref_scoped(node, descend);</span>
    <span class="s0">});</span>
    <span class="s0">self.walk(tw);</span>
    <span class="s3">// pass 2: for every used symbol we need to walk its</span>
    <span class="s3">// initialization code to figure out if it uses other</span>
    <span class="s3">// symbols (that may not be in_use).</span>
    <span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker(scan_ref_scoped);</span>
    <span class="s0">in_use_ids.forEach(</span><span class="s1">function </span><span class="s0">(def) {</span>
        <span class="s1">var </span><span class="s0">init = initializations.get(def.id);</span>
        <span class="s1">if </span><span class="s0">(init) init.forEach(</span><span class="s1">function</span><span class="s0">(init) {</span>
            <span class="s0">init.walk(tw);</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s3">// pass 3: we should drop declarations not in_use</span>
    <span class="s1">var </span><span class="s0">tt = </span><span class="s1">new </span><span class="s0">TreeTransformer(</span>
        <span class="s1">function </span><span class="s0">before(node, descend, in_list) {</span>
            <span class="s1">var </span><span class="s0">parent = tt.parent();</span>
            <span class="s1">if </span><span class="s0">(drop_vars) {</span>
                <span class="s0">const sym = assign_as_unused(node);</span>
                <span class="s1">if </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
                    <span class="s1">var </span><span class="s0">def = sym.definition();</span>
                    <span class="s1">var </span><span class="s0">in_use = in_use_ids.has(def.id);</span>
                    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
                        <span class="s1">if </span><span class="s0">(!in_use || fixed_ids.has(def.id) &amp;&amp; fixed_ids.get(def.id) !== node) {</span>
                            <span class="s1">return </span><span class="s0">maintain_this_binding(parent, node, node.right.transform(tt));</span>
                        <span class="s0">}</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!in_use) {</span>
                        <span class="s1">return </span><span class="s0">in_list ? MAP.skip : make_node(AST_Number, node, { value: </span><span class="s4">0 </span><span class="s0">});</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(scope !== self) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">def;</span>
            <span class="s1">if </span><span class="s0">(node.name</span>
                <span class="s0">&amp;&amp; (node </span><span class="s1">instanceof </span><span class="s0">AST_ClassExpression</span>
                    <span class="s0">&amp;&amp; !keep_name(compressor.option(</span><span class="s2">&quot;keep_classnames&quot;</span><span class="s0">), (def = node.name.definition()).name)</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Function</span>
                    <span class="s0">&amp;&amp; !keep_name(compressor.option(</span><span class="s2">&quot;keep_fnames&quot;</span><span class="s0">), (def = node.name.definition()).name))) {</span>
                <span class="s3">// any declarations with same name will overshadow</span>
                <span class="s3">// name of this anonymous function and can therefore</span>
                <span class="s3">// never be used anywhere</span>
                <span class="s1">if </span><span class="s0">(!in_use_ids.has(def.id) || def.orig.length &gt; </span><span class="s4">1</span><span class="s0">) node.name = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_Accessor)) {</span>
                <span class="s1">var </span><span class="s0">trim = !compressor.option(</span><span class="s2">&quot;keep_fargs&quot;</span><span class="s0">);</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">a = node.argnames, i = a.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
                    <span class="s1">var </span><span class="s0">sym = a[i];</span>
                    <span class="s1">if </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
                        <span class="s0">sym = sym.expression;</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_DefaultAssign) {</span>
                        <span class="s0">sym = sym.left;</span>
                    <span class="s0">}</span>
                    <span class="s3">// Do not drop destructuring arguments.</span>
                    <span class="s3">// They constitute a type assertion of sorts</span>
                    <span class="s1">if </span><span class="s0">(</span>
                        <span class="s0">!(sym </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring)</span>
                        <span class="s0">&amp;&amp; !in_use_ids.has(sym.definition().id)</span>
                    <span class="s0">) {</span>
                        <span class="s0">set_flag(sym, UNUSED);</span>
                        <span class="s1">if </span><span class="s0">(trim) {</span>
                            <span class="s0">a.pop();</span>
                        <span class="s0">}</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">trim = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_DefClass &amp;&amp; node !== self) {</span>
                <span class="s0">const def = node.name.definition();</span>
                <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">const keep_class = def.global &amp;&amp; !drop_funcs || in_use_ids.has(def.id);</span>
                <span class="s1">if </span><span class="s0">(!keep_class) {</span>
                    <span class="s0">const kept = node.drop_side_effect_free(compressor);</span>
                    <span class="s1">if </span><span class="s0">(kept == </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s0">def.eliminated++;</span>
                        <span class="s1">return </span><span class="s0">in_list ? MAP.skip : make_node(AST_EmptyStatement, node);</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">kept;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Defun &amp;&amp; node !== self) {</span>
                <span class="s0">const def = node.name.definition();</span>
                <span class="s0">const keep = def.global &amp;&amp; !drop_funcs || in_use_ids.has(def.id);</span>
                <span class="s1">if </span><span class="s0">(!keep) {</span>
                    <span class="s0">def.eliminated++;</span>
                    <span class="s1">return </span><span class="s0">in_list ? MAP.skip : make_node(AST_EmptyStatement, node);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Definitions &amp;&amp; !(parent </span><span class="s1">instanceof </span><span class="s0">AST_ForIn &amp;&amp; parent.init === node)) {</span>
                <span class="s1">var </span><span class="s0">drop_block = !(parent </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_Var);</span>
                <span class="s3">// place uninitialized names at the start</span>
                <span class="s1">var </span><span class="s0">body = [], head = [], tail = [];</span>
                <span class="s3">// for unused names whose initialization has</span>
                <span class="s3">// side effects, we can cascade the init. code</span>
                <span class="s3">// into the next one, or next statement.</span>
                <span class="s1">var </span><span class="s0">side_effects = [];</span>
                <span class="s0">node.definitions.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
                    <span class="s1">if </span><span class="s0">(def.value) def.value = def.value.transform(tt);</span>
                    <span class="s1">var </span><span class="s0">is_destructure = def.name </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring;</span>
                    <span class="s1">var </span><span class="s0">sym = is_destructure</span>
                        <span class="s0">? </span><span class="s1">new </span><span class="s0">SymbolDef(</span><span class="s1">null</span><span class="s0">, { name: </span><span class="s2">&quot;&lt;destructure&gt;&quot; </span><span class="s0">}) </span><span class="s3">/* fake SymbolDef */</span>
                        <span class="s0">: def.name.definition();</span>
                    <span class="s1">if </span><span class="s0">(drop_block &amp;&amp; sym.global) </span><span class="s1">return </span><span class="s0">tail.push(def);</span>
                    <span class="s1">if </span><span class="s0">(!(drop_vars || drop_block)</span>
                        <span class="s0">|| is_destructure</span>
                            <span class="s0">&amp;&amp; (def.name.names.length</span>
                                <span class="s0">|| def.name.is_array</span>
                                <span class="s0">|| compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s0">) != </span><span class="s1">true</span><span class="s0">)</span>
                        <span class="s0">|| in_use_ids.has(sym.id)</span>
                    <span class="s0">) {</span>
                        <span class="s1">if </span><span class="s0">(def.value &amp;&amp; fixed_ids.has(sym.id) &amp;&amp; fixed_ids.get(sym.id) !== def) {</span>
                            <span class="s0">def.value = def.value.drop_side_effect_free(compressor);</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(def.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolVar) {</span>
                            <span class="s1">var </span><span class="s0">var_defs = var_defs_by_id.get(sym.id);</span>
                            <span class="s1">if </span><span class="s0">(var_defs.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; (!def.value || sym.orig.indexOf(def.name) &gt; sym.eliminated)) {</span>
                                <span class="s1">if </span><span class="s0">(def.value) {</span>
                                    <span class="s1">var </span><span class="s0">ref = make_node(AST_SymbolRef, def.name, def.name);</span>
                                    <span class="s0">sym.references.push(ref);</span>
                                    <span class="s1">var </span><span class="s0">assign = make_node(AST_Assign, def, {</span>
                                        <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                                        <span class="s0">logical: </span><span class="s1">false</span><span class="s0">,</span>
                                        <span class="s0">left: ref,</span>
                                        <span class="s0">right: def.value</span>
                                    <span class="s0">});</span>
                                    <span class="s1">if </span><span class="s0">(fixed_ids.get(sym.id) === def) {</span>
                                        <span class="s0">fixed_ids.set(sym.id, assign);</span>
                                    <span class="s0">}</span>
                                    <span class="s0">side_effects.push(assign.transform(tt));</span>
                                <span class="s0">}</span>
                                <span class="s0">remove(var_defs, def);</span>
                                <span class="s0">sym.eliminated++;</span>
                                <span class="s1">return</span><span class="s0">;</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(def.value) {</span>
                            <span class="s1">if </span><span class="s0">(side_effects.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                                <span class="s1">if </span><span class="s0">(tail.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                                    <span class="s0">side_effects.push(def.value);</span>
                                    <span class="s0">def.value = make_sequence(def.value, side_effects);</span>
                                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                                    <span class="s0">body.push(make_node(AST_SimpleStatement, node, {</span>
                                        <span class="s0">body: make_sequence(node, side_effects)</span>
                                    <span class="s0">}));</span>
                                <span class="s0">}</span>
                                <span class="s0">side_effects = [];</span>
                            <span class="s0">}</span>
                            <span class="s0">tail.push(def);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s0">head.push(def);</span>
                        <span class="s0">}</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sym.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch) {</span>
                        <span class="s1">var </span><span class="s0">value = def.value &amp;&amp; def.value.drop_side_effect_free(compressor);</span>
                        <span class="s1">if </span><span class="s0">(value) side_effects.push(value);</span>
                        <span class="s0">def.value = </span><span class="s1">null</span><span class="s0">;</span>
                        <span class="s0">head.push(def);</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">var </span><span class="s0">value = def.value &amp;&amp; def.value.drop_side_effect_free(compressor);</span>
                        <span class="s1">if </span><span class="s0">(value) {</span>
                            <span class="s0">side_effects.push(value);</span>
                        <span class="s0">}</span>
                        <span class="s0">sym.eliminated++;</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(head.length &gt; </span><span class="s4">0 </span><span class="s0">|| tail.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">node.definitions = head.concat(tail);</span>
                    <span class="s0">body.push(node);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(side_effects.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">body.push(make_node(AST_SimpleStatement, node, {</span>
                        <span class="s0">body: make_sequence(node, side_effects)</span>
                    <span class="s0">}));</span>
                <span class="s0">}</span>
                <span class="s1">switch </span><span class="s0">(body.length) {</span>
                  <span class="s1">case </span><span class="s4">0</span><span class="s0">:</span>
                    <span class="s1">return </span><span class="s0">in_list ? MAP.skip : make_node(AST_EmptyStatement, node);</span>
                  <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
                    <span class="s1">return </span><span class="s0">body[</span><span class="s4">0</span><span class="s0">];</span>
                  <span class="s1">default</span><span class="s0">:</span>
                    <span class="s1">return </span><span class="s0">in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, { body });</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">// certain combination of unused name + side effect leads to:</span>
            <span class="s3">//    https://github.com/mishoo/UglifyJS2/issues/44</span>
            <span class="s3">//    https://github.com/mishoo/UglifyJS2/issues/1830</span>
            <span class="s3">//    https://github.com/mishoo/UglifyJS2/issues/1838</span>
            <span class="s3">// that's an invalid AST.</span>
            <span class="s3">// We fix it at this stage by moving the `var` outside the `for`.</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_For) {</span>
                <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">var </span><span class="s0">block;</span>
                <span class="s1">if </span><span class="s0">(node.init </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement) {</span>
                    <span class="s0">block = node.init;</span>
                    <span class="s0">node.init = block.body.pop();</span>
                    <span class="s0">block.body.push(node);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(node.init </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
                    <span class="s0">node.init = node.init.body;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_empty(node.init)) {</span>
                    <span class="s0">node.init = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">!block ? node : in_list ? MAP.splice(block.body) : block;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_LabeledStatement</span>
                <span class="s0">&amp;&amp; node.body </span><span class="s1">instanceof </span><span class="s0">AST_For</span>
            <span class="s0">) {</span>
                <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(node.body </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement) {</span>
                    <span class="s1">var </span><span class="s0">block = node.body;</span>
                    <span class="s0">node.body = block.body.pop();</span>
                    <span class="s0">block.body.push(node);</span>
                    <span class="s1">return </span><span class="s0">in_list ? MAP.splice(block.body) : block;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement) {</span>
                <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(in_list &amp;&amp; node.body.every(can_be_evicted_from_block)) {</span>
                    <span class="s1">return </span><span class="s0">MAP.splice(node.body);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_ClassStaticBlock)) {</span>
                <span class="s0">const save_scope = scope;</span>
                <span class="s0">scope = node;</span>
                <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">scope = save_scope;</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">);</span>

    <span class="s0">self.transform(tt);</span>

    <span class="s1">function </span><span class="s0">scan_ref_scoped(node, descend) {</span>
        <span class="s1">var </span><span class="s0">node_def;</span>
        <span class="s0">const sym = assign_as_unused(node);</span>
        <span class="s1">if </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">&amp;&amp; !is_ref_of(node.left, AST_SymbolBlockDeclaration)</span>
            <span class="s0">&amp;&amp; self.variables.get(sym.name) === (node_def = sym.definition())</span>
        <span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
                <span class="s0">node.right.walk(tw);</span>
                <span class="s1">if </span><span class="s0">(!node_def.chained &amp;&amp; node.left.fixed_value() === node.right) {</span>
                    <span class="s0">fixed_ids.set(node_def.id, node);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
            <span class="s0">node_def = node.definition();</span>
            <span class="s1">if </span><span class="s0">(!in_use_ids.has(node_def.id)) {</span>
                <span class="s0">in_use_ids.set(node_def.id, node_def);</span>
                <span class="s1">if </span><span class="s0">(node_def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolCatch) {</span>
                    <span class="s0">const redef = node_def.scope.is_block_scope()</span>
                        <span class="s0">&amp;&amp; node_def.scope.get_defun_scope().variables.get(node_def.name);</span>
                    <span class="s1">if </span><span class="s0">(redef) in_use_ids.set(redef.id, redef);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Class) {</span>
            <span class="s0">descend();</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_ClassStaticBlock)) {</span>
            <span class="s1">var </span><span class="s0">save_scope = scope;</span>
            <span class="s0">scope = node;</span>
            <span class="s0">descend();</span>
            <span class="s0">scope = save_scope;</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">/** 
 * Define the method AST_Node#reduce_vars, which goes through the AST in 
 * execution order to perform basic flow analysis 
 */</span>
<span class="s1">function </span><span class="s0">def_reduce_vars(node, func) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">, func);</span>
<span class="s0">}</span>

<span class="s0">def_reduce_vars(AST_Node, noop);</span>

<span class="s3">/** Clear definition properties */</span>
<span class="s1">function </span><span class="s0">reset_def(compressor, def) {</span>
    <span class="s0">def.assignments = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">def.chained = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">def.direct_access = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">def.escaped = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">def.recursive_refs = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">def.references = [];</span>
    <span class="s0">def.single_use = undefined;</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">def.scope.pinned()</span>
        <span class="s0">|| (def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg &amp;&amp; def.scope.uses_arguments)</span>
    <span class="s0">) {</span>
        <span class="s0">def.fixed = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolConst || !compressor.exposed(def)) {</span>
        <span class="s0">def.fixed = def.init;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">def.fixed = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">reset_variables(tw, compressor, node) {</span>
    <span class="s0">node.variables.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
        <span class="s0">reset_def(compressor, def);</span>
        <span class="s1">if </span><span class="s0">(def.fixed === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">tw.defs_to_safe_ids.set(def.id, tw.safe_ids);</span>
            <span class="s0">mark(tw, def, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(def.fixed) {</span>
            <span class="s0">tw.loop_ids.set(def.id, tw.in_loop);</span>
            <span class="s0">mark(tw, def, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">reset_block_variables(compressor, node) {</span>
    <span class="s1">if </span><span class="s0">(node.block_scope) node.block_scope.variables.forEach((def) =&gt; {</span>
        <span class="s0">reset_def(compressor, def);</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">push(tw) {</span>
    <span class="s0">tw.safe_ids = Object.create(tw.safe_ids);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">pop(tw) {</span>
    <span class="s0">tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">mark(tw, def, safe) {</span>
    <span class="s0">tw.safe_ids[def.id] = safe;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">safe_to_read(tw, def) {</span>
    <span class="s1">if </span><span class="s0">(def.single_use == </span><span class="s2">&quot;m&quot;</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(tw.safe_ids[def.id]) {</span>
        <span class="s1">if </span><span class="s0">(def.fixed == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">orig = def.orig[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(orig </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg || orig.name == </span><span class="s2">&quot;arguments&quot;</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">def.fixed = make_node(AST_Undefined, orig);</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">def.fixed </span><span class="s1">instanceof </span><span class="s0">AST_Defun;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">safe_to_assign(tw, def, scope, value) {</span>
    <span class="s1">if </span><span class="s0">(def.fixed === undefined) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">let def_safe_ids;</span>
    <span class="s1">if </span><span class="s0">(def.fixed === </span><span class="s1">null</span>
        <span class="s0">&amp;&amp; (def_safe_ids = tw.defs_to_safe_ids.get(def.id))</span>
    <span class="s0">) {</span>
        <span class="s0">def_safe_ids[def.id] = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">tw.defs_to_safe_ids.</span><span class="s1">delete</span><span class="s0">(def.id);</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!HOP(tw.safe_ids, def.id)) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!safe_to_read(tw, def)) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(def.fixed === </span><span class="s1">false</span><span class="s0">) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(def.fixed != </span><span class="s1">null </span><span class="s0">&amp;&amp; (!value || def.references.length &gt; def.assignments)) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(def.fixed </span><span class="s1">instanceof </span><span class="s0">AST_Defun) {</span>
        <span class="s1">return </span><span class="s0">value </span><span class="s1">instanceof </span><span class="s0">AST_Node &amp;&amp; def.fixed.parent_scope === scope;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">def.orig.every((sym) =&gt; {</span>
        <span class="s1">return </span><span class="s0">!(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolConst</span>
            <span class="s0">|| sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun</span>
            <span class="s0">|| sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda);</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">ref_once(tw, compressor, def) {</span>
    <span class="s1">return </span><span class="s0">compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; !def.scope.pinned()</span>
        <span class="s0">&amp;&amp; def.references.length - def.recursive_refs == </span><span class="s4">1</span>
        <span class="s0">&amp;&amp; tw.loop_ids.get(def.id) === tw.in_loop;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_immutable(value) {</span>
    <span class="s1">if </span><span class="s0">(!value) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">value.is_constant()</span>
        <span class="s0">|| value </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
        <span class="s0">|| value </span><span class="s1">instanceof </span><span class="s0">AST_This;</span>
<span class="s0">}</span>

<span class="s3">// A definition &quot;escapes&quot; when its value can leave the point of use.</span>
<span class="s3">// Example: `a = b || c`</span>
<span class="s3">// In this example, &quot;b&quot; and &quot;c&quot; are escaping, because they're going into &quot;a&quot;</span>
<span class="s3">//</span>
<span class="s3">// def.escaped is != 0 when it escapes.</span>
<span class="s3">//</span>
<span class="s3">// When greater than 1, it means that N chained properties will be read off</span>
<span class="s3">// of that def before an escape occurs. This is useful for evaluating</span>
<span class="s3">// property accesses, where you need to know when to stop.</span>
<span class="s1">function </span><span class="s0">mark_escaped(tw, d, scope, node, value, level = </span><span class="s4">0</span><span class="s0">, depth = </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s1">var </span><span class="s0">parent = tw.parent(level);</span>
    <span class="s1">if </span><span class="s0">(value) {</span>
        <span class="s1">if </span><span class="s0">(value.is_constant()) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_ClassExpression) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">parent </span><span class="s1">instanceof </span><span class="s0">AST_Assign &amp;&amp; (parent.operator === </span><span class="s2">&quot;=&quot; </span><span class="s0">|| parent.logical) &amp;&amp; node === parent.right</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; (node !== parent.expression || parent </span><span class="s1">instanceof </span><span class="s0">AST_New)</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Exit &amp;&amp; node === parent.value &amp;&amp; node.scope !== d.scope</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_VarDef &amp;&amp; node === parent.value</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Yield &amp;&amp; node === parent.value &amp;&amp; node.scope !== d.scope</span>
    <span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(depth &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; !(value &amp;&amp; value.is_constant_expression(scope))) depth = </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!d.escaped || d.escaped &gt; depth) d.escaped = depth;</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
        <span class="s0">parent </span><span class="s1">instanceof </span><span class="s0">AST_Array</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Await</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; lazy_op.has(parent.operator)</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Conditional &amp;&amp; node !== parent.condition</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Expansion</span>
        <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Sequence &amp;&amp; node === parent.tail_node()</span>
    <span class="s0">) {</span>
        <span class="s0">mark_escaped(tw, d, scope, parent, parent, level + </span><span class="s4">1</span><span class="s0">, depth);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal &amp;&amp; node === parent.value) {</span>
        <span class="s1">var </span><span class="s0">obj = tw.parent(level + </span><span class="s4">1</span><span class="s0">);</span>

        <span class="s0">mark_escaped(tw, d, scope, obj, obj, level + </span><span class="s4">2</span><span class="s0">, depth);</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; node === parent.expression) {</span>
        <span class="s0">value = read_property(value, parent.property);</span>

        <span class="s0">mark_escaped(tw, d, scope, parent, value, level + </span><span class="s4">1</span><span class="s0">, depth + </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(value) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(level &gt; </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Sequence &amp;&amp; node !== parent.tail_node()) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) </span><span class="s1">return</span><span class="s0">;</span>

    <span class="s0">d.direct_access = </span><span class="s1">true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">const suppress = node =&gt; walk(node, node =&gt; {</span>
    <span class="s1">if </span><span class="s0">(!(node </span><span class="s1">instanceof </span><span class="s0">AST_Symbol)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">d = node.definition();</span>
    <span class="s1">if </span><span class="s0">(!d) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) d.references.push(node);</span>
    <span class="s0">d.fixed = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Accessor, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">push(tw);</span>
    <span class="s0">reset_variables(tw, compressor, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">descend();</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Assign, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(node.left </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
        <span class="s0">suppress(node.left);</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">const finish_walk = () =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node.logical) {</span>
            <span class="s0">node.left.walk(tw);</span>

            <span class="s0">push(tw);</span>
            <span class="s0">node.right.walk(tw);</span>
            <span class="s0">pop(tw);</span>

            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">var </span><span class="s0">sym = node.left;</span>
    <span class="s1">if </span><span class="s0">(!(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef)) </span><span class="s1">return </span><span class="s0">finish_walk();</span>

    <span class="s1">var </span><span class="s0">def = sym.definition();</span>
    <span class="s1">var </span><span class="s0">safe = safe_to_assign(tw, def, sym.scope, node.right);</span>
    <span class="s0">def.assignments++;</span>
    <span class="s1">if </span><span class="s0">(!safe) </span><span class="s1">return </span><span class="s0">finish_walk();</span>

    <span class="s1">var </span><span class="s0">fixed = def.fixed;</span>
    <span class="s1">if </span><span class="s0">(!fixed &amp;&amp; node.operator != </span><span class="s2">&quot;=&quot; </span><span class="s0">&amp;&amp; !node.logical) </span><span class="s1">return </span><span class="s0">finish_walk();</span>

    <span class="s1">var </span><span class="s0">eq = node.operator == </span><span class="s2">&quot;=&quot;</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">value = eq ? node.right : node;</span>
    <span class="s1">if </span><span class="s0">(is_modified(compressor, tw, node, value, </span><span class="s4">0</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">finish_walk();</span>

    <span class="s0">def.references.push(sym);</span>

    <span class="s1">if </span><span class="s0">(!node.logical) {</span>
        <span class="s1">if </span><span class="s0">(!eq) def.chained = </span><span class="s1">true</span><span class="s0">;</span>

        <span class="s0">def.fixed = eq ? </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">return </span><span class="s0">node.right;</span>
        <span class="s0">} : </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Binary, node, {</span>
                <span class="s0">operator: node.operator.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">),</span>
                <span class="s0">left: fixed </span><span class="s1">instanceof </span><span class="s0">AST_Node ? fixed : fixed(),</span>
                <span class="s0">right: node.right</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(node.logical) {</span>
        <span class="s0">mark(tw, def, </span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">push(tw);</span>
        <span class="s0">node.right.walk(tw);</span>
        <span class="s0">pop(tw);</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">mark(tw, def, </span><span class="s1">false</span><span class="s0">);</span>
    <span class="s0">node.right.walk(tw);</span>
    <span class="s0">mark(tw, def, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s0">mark_escaped(tw, def, sym.scope, node, value, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">);</span>

    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Binary, </span><span class="s1">function</span><span class="s0">(tw) {</span>
    <span class="s1">if </span><span class="s0">(!lazy_op.has(</span><span class="s1">this</span><span class="s0">.operator)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">this</span><span class="s0">.left.walk(tw);</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.right.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Block, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">reset_block_variables(compressor, </span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Case, </span><span class="s1">function</span><span class="s0">(tw) {</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.expression.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s0">push(tw);</span>
    <span class="s0">walk_body(</span><span class="s1">this</span><span class="s0">, tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Class, </span><span class="s1">function</span><span class="s0">(tw, descend) {</span>
    <span class="s0">clear_flag(</span><span class="s1">this</span><span class="s0">, INLINED);</span>
    <span class="s0">push(tw);</span>
    <span class="s0">descend();</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_ClassStaticBlock, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">reset_block_variables(compressor, </span><span class="s1">this</span><span class="s0">);</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Conditional, </span><span class="s1">function</span><span class="s0">(tw) {</span>
    <span class="s1">this</span><span class="s0">.condition.walk(tw);</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.consequent.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.alternative.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Chain, </span><span class="s1">function</span><span class="s0">(tw, descend) {</span>
    <span class="s3">// Chains' conditions apply left-to-right, cumulatively.</span>
    <span class="s3">// If we walk normally we don't go in that order because we would pop before pushing again</span>
    <span class="s3">// Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.</span>
    <span class="s3">// Then we pop everything when they are done being walked.</span>
    <span class="s0">const safe_ids = tw.safe_ids;</span>

    <span class="s0">descend();</span>

    <span class="s3">// Unroll back to start</span>
    <span class="s0">tw.safe_ids = safe_ids;</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Call, </span><span class="s1">function </span><span class="s0">(tw) {</span>
    <span class="s1">this</span><span class="s0">.expression.walk(tw);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.optional) {</span>
        <span class="s3">// Never pop -- it's popped at AST_Chain above</span>
        <span class="s0">push(tw);</span>
    <span class="s0">}</span>

    <span class="s1">for </span><span class="s0">(const arg of </span><span class="s1">this</span><span class="s0">.args) arg.walk(tw);</span>

    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_PropAccess, </span><span class="s1">function </span><span class="s0">(tw) {</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.optional) </span><span class="s1">return</span><span class="s0">;</span>

    <span class="s1">this</span><span class="s0">.expression.walk(tw);</span>

    <span class="s3">// Never pop -- it's popped at AST_Chain above</span>
    <span class="s0">push(tw);</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.property </span><span class="s1">instanceof </span><span class="s0">AST_Node) </span><span class="s1">this</span><span class="s0">.property.walk(tw);</span>

    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Default, </span><span class="s1">function</span><span class="s0">(tw, descend) {</span>
    <span class="s0">push(tw);</span>
    <span class="s0">descend();</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">mark_lambda(tw, descend, compressor) {</span>
    <span class="s0">clear_flag(</span><span class="s1">this</span><span class="s0">, INLINED);</span>
    <span class="s0">push(tw);</span>
    <span class="s0">reset_variables(tw, compressor, </span><span class="s1">this</span><span class="s0">);</span>

    <span class="s1">var </span><span class="s0">iife;</span>
    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.name</span>
        <span class="s0">&amp;&amp; !</span><span class="s1">this</span><span class="s0">.uses_arguments</span>
        <span class="s0">&amp;&amp; !</span><span class="s1">this</span><span class="s0">.pinned()</span>
        <span class="s0">&amp;&amp; (iife = tw.parent()) </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
        <span class="s0">&amp;&amp; iife.expression === </span><span class="s1">this</span>
        <span class="s0">&amp;&amp; !iife.args.some(arg =&gt; arg </span><span class="s1">instanceof </span><span class="s0">AST_Expansion)</span>
        <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.argnames.every(arg_name =&gt; arg_name </span><span class="s1">instanceof </span><span class="s0">AST_Symbol)</span>
    <span class="s0">) {</span>
        <span class="s3">// Virtually turn IIFE parameters into variable definitions:</span>
        <span class="s3">//   (function(a,b) {...})(c,d) =&gt; (function() {var a=c,b=d; ...})()</span>
        <span class="s3">// So existing transformation rules can work on them.</span>
        <span class="s1">this</span><span class="s0">.argnames.forEach((arg, i) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!arg.definition) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">d = arg.definition();</span>
            <span class="s3">// Avoid setting fixed when there's more than one origin for a variable value</span>
            <span class="s1">if </span><span class="s0">(d.orig.length &gt; </span><span class="s4">1</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(d.fixed === undefined &amp;&amp; (!</span><span class="s1">this</span><span class="s0">.uses_arguments || tw.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">))) {</span>
                <span class="s0">d.fixed = </span><span class="s1">function</span><span class="s0">() {</span>
                    <span class="s1">return </span><span class="s0">iife.args[i] || make_node(AST_Undefined, iife);</span>
                <span class="s0">};</span>
                <span class="s0">tw.loop_ids.set(d.id, tw.in_loop);</span>
                <span class="s0">mark(tw, d, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">d.fixed = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s0">descend();</span>
    <span class="s0">pop(tw);</span>

    <span class="s0">handle_defined_after_hoist(</span><span class="s1">this</span><span class="s0">);</span>

    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">/** 
 * It's possible for a hoisted function to use something that's not defined yet. Example: 
 * 
 * hoisted(); 
 * var defined_after = true; 
 * function hoisted() { 
 *   // use defined_after 
 * } 
 * 
 * This function is called on the parent to handle this issue. 
 */</span>
<span class="s1">function </span><span class="s0">handle_defined_after_hoist(parent) {</span>
    <span class="s0">const defuns = [];</span>
    <span class="s0">walk(parent, node =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node === parent) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Defun) defuns.push(node);</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Scope</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement</span>
        <span class="s0">) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s0">const symbols_of_interest = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s0">const defuns_of_interest = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s0">const potential_conflicts = [];</span>

    <span class="s1">for </span><span class="s0">(const defun of defuns) {</span>
        <span class="s0">const fname_def = defun.name.definition();</span>
        <span class="s0">const found_self_ref_in_other_defuns = defuns.some(</span>
            <span class="s0">d =&gt; d !== defun &amp;&amp; d.enclosed.indexOf(fname_def) !== -</span><span class="s4">1</span>
        <span class="s0">);</span>

        <span class="s1">for </span><span class="s0">(const def of defun.enclosed) {</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">def.fixed === </span><span class="s1">false</span>
                <span class="s0">|| def === fname_def</span>
                <span class="s0">|| def.scope.get_defun_scope() !== parent</span>
            <span class="s0">) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s3">// defun is hoisted, so always safe</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">def.assignments === </span><span class="s4">0</span>
                <span class="s0">&amp;&amp; def.orig.length === </span><span class="s4">1</span>
                <span class="s0">&amp;&amp; def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun</span>
            <span class="s0">) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(found_self_ref_in_other_defuns) {</span>
                <span class="s0">def.fixed = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s3">// for the slower checks below this loop</span>
            <span class="s0">potential_conflicts.push({ defun, def, fname_def });</span>
            <span class="s0">symbols_of_interest.add(def.id);</span>
            <span class="s0">symbols_of_interest.add(fname_def.id);</span>
            <span class="s0">defuns_of_interest.add(defun);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">// linearize all symbols, and locate defs that are read after the defun</span>
    <span class="s1">if </span><span class="s0">(potential_conflicts.length) {</span>
        <span class="s3">// All &quot;symbols of interest&quot;, that is, defuns or defs, that we found.</span>
        <span class="s3">// These are placed in order so we can check which is after which.</span>
        <span class="s0">const found_symbols = [];</span>
        <span class="s3">// Indices of `found_symbols` which are writes</span>
        <span class="s0">const found_symbol_writes = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s3">// Defun ranges are recorded because we don't care if a function uses the def internally</span>
        <span class="s0">const defun_ranges = </span><span class="s1">new </span><span class="s0">Map();</span>

        <span class="s0">let tw;</span>
        <span class="s0">parent.walk((tw = </span><span class="s1">new </span><span class="s0">TreeWalker((node, descend) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Defun &amp;&amp; defuns_of_interest.has(node)) {</span>
                <span class="s0">const start = found_symbols.length;</span>
                <span class="s0">descend();</span>
                <span class="s0">const end = found_symbols.length;</span>

                <span class="s0">defun_ranges.set(node, { start, end });</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// if we found a defun on the list, mark IN_DEFUN=id and descend</span>

            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Symbol &amp;&amp; node.thedef) {</span>
                <span class="s0">const id = node.definition().id;</span>
                <span class="s1">if </span><span class="s0">(symbols_of_interest.has(id)) {</span>
                    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration || is_lhs(node, tw)) {</span>
                        <span class="s0">found_symbol_writes.add(found_symbols.length);</span>
                    <span class="s0">}</span>
                    <span class="s0">found_symbols.push(id);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">})));</span>

        <span class="s1">for </span><span class="s0">(const { def, defun, fname_def } of potential_conflicts) {</span>
            <span class="s0">const defun_range = defun_ranges.get(defun);</span>

            <span class="s3">// find the index in `found_symbols`, with some special rules:</span>
            <span class="s0">const find = (sym_id, starting_at = </span><span class="s4">0</span><span class="s0">, must_be_write = </span><span class="s1">false</span><span class="s0">) =&gt; {</span>
                <span class="s0">let index = starting_at;</span>

                <span class="s1">for </span><span class="s0">(;;) {</span>
                    <span class="s0">index = found_symbols.indexOf(sym_id, index);</span>

                    <span class="s1">if </span><span class="s0">(index === -</span><span class="s4">1</span><span class="s0">) {</span>
                        <span class="s1">break</span><span class="s0">;</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(index &gt;= defun_range.start &amp;&amp; index &lt; defun_range.end) {</span>
                        <span class="s0">index = defun_range.end;</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(must_be_write &amp;&amp; !found_symbol_writes.has(index)) {</span>
                        <span class="s0">index++;</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">break</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>

                <span class="s1">return </span><span class="s0">index;</span>
            <span class="s0">};</span>

            <span class="s0">const read_defun_at = find(fname_def.id);</span>
            <span class="s0">const wrote_def_at = find(def.id, read_defun_at + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>

            <span class="s0">const wrote_def_after_reading_defun = read_defun_at != -</span><span class="s4">1 </span><span class="s0">&amp;&amp; wrote_def_at != -</span><span class="s4">1 </span><span class="s0">&amp;&amp; wrote_def_at &gt; read_defun_at;</span>

            <span class="s1">if </span><span class="s0">(wrote_def_after_reading_defun) {</span>
                <span class="s0">def.fixed = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">def_reduce_vars(AST_Lambda, mark_lambda);</span>

<span class="s0">def_reduce_vars(AST_Do, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">reset_block_variables(compressor, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">const saved_loop = tw.in_loop;</span>
    <span class="s0">tw.in_loop = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.body.walk(tw);</span>
    <span class="s1">if </span><span class="s0">(has_break_or_continue(</span><span class="s1">this</span><span class="s0">)) {</span>
        <span class="s0">pop(tw);</span>
        <span class="s0">push(tw);</span>
    <span class="s0">}</span>
    <span class="s1">this</span><span class="s0">.condition.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s0">tw.in_loop = saved_loop;</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_For, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">reset_block_variables(compressor, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.init) </span><span class="s1">this</span><span class="s0">.init.walk(tw);</span>
    <span class="s0">const saved_loop = tw.in_loop;</span>
    <span class="s0">tw.in_loop = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">push(tw);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.condition) </span><span class="s1">this</span><span class="s0">.condition.walk(tw);</span>
    <span class="s1">this</span><span class="s0">.body.walk(tw);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.step) {</span>
        <span class="s1">if </span><span class="s0">(has_break_or_continue(</span><span class="s1">this</span><span class="s0">)) {</span>
            <span class="s0">pop(tw);</span>
            <span class="s0">push(tw);</span>
        <span class="s0">}</span>
        <span class="s1">this</span><span class="s0">.step.walk(tw);</span>
    <span class="s0">}</span>
    <span class="s0">pop(tw);</span>
    <span class="s0">tw.in_loop = saved_loop;</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_ForIn, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">reset_block_variables(compressor, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">suppress(</span><span class="s1">this</span><span class="s0">.init);</span>
    <span class="s1">this</span><span class="s0">.object.walk(tw);</span>
    <span class="s0">const saved_loop = tw.in_loop;</span>
    <span class="s0">tw.in_loop = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.body.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s0">tw.in_loop = saved_loop;</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_If, </span><span class="s1">function</span><span class="s0">(tw) {</span>
    <span class="s1">this</span><span class="s0">.condition.walk(tw);</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.body.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.alternative) {</span>
        <span class="s0">push(tw);</span>
        <span class="s1">this</span><span class="s0">.alternative.walk(tw);</span>
        <span class="s0">pop(tw);</span>
    <span class="s0">}</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_LabeledStatement, </span><span class="s1">function</span><span class="s0">(tw) {</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.body.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_SymbolCatch, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">this</span><span class="s0">.definition().fixed = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_SymbolRef, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s1">var </span><span class="s0">d = </span><span class="s1">this</span><span class="s0">.definition();</span>
    <span class="s0">d.references.push(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(d.references.length == </span><span class="s4">1</span>
        <span class="s0">&amp;&amp; !d.fixed</span>
        <span class="s0">&amp;&amp; d.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun) {</span>
        <span class="s0">tw.loop_ids.set(d.id, tw.in_loop);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">fixed_value;</span>
    <span class="s1">if </span><span class="s0">(d.fixed === undefined || !safe_to_read(tw, d)) {</span>
        <span class="s0">d.fixed = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(d.fixed) {</span>
        <span class="s0">fixed_value = </span><span class="s1">this</span><span class="s0">.fixed_value();</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">fixed_value </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
            <span class="s0">&amp;&amp; is_recursive_ref(tw, d)</span>
        <span class="s0">) {</span>
            <span class="s0">d.recursive_refs++;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(fixed_value</span>
            <span class="s0">&amp;&amp; !compressor.exposed(d)</span>
            <span class="s0">&amp;&amp; ref_once(tw, compressor, d)</span>
        <span class="s0">) {</span>
            <span class="s0">d.single_use =</span>
                <span class="s0">fixed_value </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; !fixed_value.pinned()</span>
                <span class="s0">|| fixed_value </span><span class="s1">instanceof </span><span class="s0">AST_Class</span>
                <span class="s0">|| d.scope === </span><span class="s1">this</span><span class="s0">.scope &amp;&amp; fixed_value.is_constant_expression();</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">d.single_use = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is_modified(compressor, tw, </span><span class="s1">this</span><span class="s0">, fixed_value, </span><span class="s4">0</span><span class="s0">, is_immutable(fixed_value))) {</span>
            <span class="s1">if </span><span class="s0">(d.single_use) {</span>
                <span class="s0">d.single_use = </span><span class="s2">&quot;m&quot;</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">d.fixed = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">mark_escaped(tw, d, </span><span class="s1">this</span><span class="s0">.scope, </span><span class="s1">this</span><span class="s0">, fixed_value, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">);</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Toplevel, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s1">this</span><span class="s0">.globals.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
        <span class="s0">reset_def(compressor, def);</span>
    <span class="s0">});</span>
    <span class="s0">reset_variables(tw, compressor, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">descend();</span>
    <span class="s0">handle_defined_after_hoist(</span><span class="s1">this</span><span class="s0">);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Try, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">reset_block_variables(compressor, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">push(tw);</span>
    <span class="s1">this</span><span class="s0">.body.walk(tw);</span>
    <span class="s0">pop(tw);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.bcatch) {</span>
        <span class="s0">push(tw);</span>
        <span class="s1">this</span><span class="s0">.bcatch.walk(tw);</span>
        <span class="s0">pop(tw);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.bfinally) </span><span class="s1">this</span><span class="s0">.bfinally.walk(tw);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_Unary, </span><span class="s1">function</span><span class="s0">(tw) {</span>
    <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(node.operator !== </span><span class="s2">&quot;++&quot; </span><span class="s0">&amp;&amp; node.operator !== </span><span class="s2">&quot;--&quot;</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">exp = node.expression;</span>
    <span class="s1">if </span><span class="s0">(!(exp </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">def = exp.definition();</span>
    <span class="s1">var </span><span class="s0">safe = safe_to_assign(tw, def, exp.scope, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">def.assignments++;</span>
    <span class="s1">if </span><span class="s0">(!safe) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">fixed = def.fixed;</span>
    <span class="s1">if </span><span class="s0">(!fixed) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">def.references.push(exp);</span>
    <span class="s0">def.chained = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">def.fixed = </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, node, {</span>
            <span class="s0">operator: node.operator.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">),</span>
            <span class="s0">left: make_node(AST_UnaryPrefix, node, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                <span class="s0">expression: fixed </span><span class="s1">instanceof </span><span class="s0">AST_Node ? fixed : fixed()</span>
            <span class="s0">}),</span>
            <span class="s0">right: make_node(AST_Number, node, {</span>
                <span class="s0">value: </span><span class="s4">1</span>
            <span class="s0">})</span>
        <span class="s0">});</span>
    <span class="s0">};</span>
    <span class="s0">mark(tw, def, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_VarDef, </span><span class="s1">function</span><span class="s0">(tw, descend) {</span>
    <span class="s1">var </span><span class="s0">node = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(node.name </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) {</span>
        <span class="s0">suppress(node.name);</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">d = node.name.definition();</span>
    <span class="s1">if </span><span class="s0">(node.value) {</span>
        <span class="s1">if </span><span class="s0">(safe_to_assign(tw, d, node.name.scope, node.value)) {</span>
            <span class="s0">d.fixed = </span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s1">return </span><span class="s0">node.value;</span>
            <span class="s0">};</span>
            <span class="s0">tw.loop_ids.set(d.id, tw.in_loop);</span>
            <span class="s0">mark(tw, d, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">descend();</span>
            <span class="s0">mark(tw, d, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">d.fixed = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_reduce_vars(AST_While, </span><span class="s1">function</span><span class="s0">(tw, descend, compressor) {</span>
    <span class="s0">reset_block_variables(compressor, </span><span class="s1">this</span><span class="s0">);</span>
    <span class="s0">const saved_loop = tw.in_loop;</span>
    <span class="s0">tw.in_loop = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">push(tw);</span>
    <span class="s0">descend();</span>
    <span class="s0">pop(tw);</span>
    <span class="s0">tw.in_loop = saved_loop;</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">function </span><span class="s0">loop_body(x) {</span>
    <span class="s1">if </span><span class="s0">(x </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement) {</span>
        <span class="s1">return </span><span class="s0">x.body </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement ? x.body : x;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">x;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">is_lhs_read_only(lhs) {</span>
    <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_This) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) </span><span class="s1">return </span><span class="s0">lhs.definition().orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda;</span>
    <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess) {</span>
        <span class="s0">lhs = lhs.expression;</span>
        <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
            <span class="s1">if </span><span class="s0">(lhs.is_immutable()) </span><span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">lhs = lhs.fixed_value();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!lhs) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_RegExp) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_Constant) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">is_lhs_read_only(lhs);</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">/** var a = 1 --&gt; var a*/</span>
<span class="s1">function </span><span class="s0">remove_initializers(var_statement) {</span>
    <span class="s1">var </span><span class="s0">decls = [];</span>
    <span class="s0">var_statement.definitions.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
        <span class="s1">if </span><span class="s0">(def.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration) {</span>
            <span class="s0">def.value = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">decls.push(def);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">def.declarations_as_names().forEach(name =&gt; {</span>
                <span class="s0">decls.push(make_node(AST_VarDef, def, {</span>
                    <span class="s0">name,</span>
                    <span class="s0">value: </span><span class="s1">null</span>
                <span class="s0">}));</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">decls.length ? make_node(AST_Var, var_statement, { definitions: decls }) : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s3">/** Called on code which we know is unreachable, to keep elements that affect outside of it. */</span>
<span class="s1">function </span><span class="s0">trim_unreachable_code(compressor, stat, target) {</span>
    <span class="s0">walk(stat, node =&gt; {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Var) {</span>
            <span class="s0">const no_initializers = remove_initializers(node);</span>
            <span class="s1">if </span><span class="s0">(no_initializers) target.push(no_initializers);</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Defun</span>
            <span class="s0">&amp;&amp; (node === stat || !compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">))</span>
        <span class="s0">) {</span>
            <span class="s0">target.push(node === stat ? node : make_node(AST_Var, node, {</span>
                <span class="s0">definitions: [</span>
                    <span class="s0">make_node(AST_VarDef, node, {</span>
                        <span class="s0">name: make_node(AST_SymbolVar, node.name, node.name),</span>
                        <span class="s0">value: </span><span class="s1">null</span>
                    <span class="s0">})</span>
                <span class="s0">]</span>
            <span class="s0">}));</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Export || node </span><span class="s1">instanceof </span><span class="s0">AST_Import) {</span>
            <span class="s0">target.push(node);</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s3">/** Tighten a bunch of statements together, and perform statement-level optimization. */</span>
<span class="s1">function </span><span class="s0">tighten_body(statements, compressor) {</span>
    <span class="s0">const nearest_scope = compressor.find_scope();</span>
    <span class="s0">const defun_scope = nearest_scope.get_defun_scope();</span>
    <span class="s0">const { in_loop, in_try } = find_loop_scope_try();</span>

    <span class="s1">var </span><span class="s0">CHANGED, max_iter = </span><span class="s4">10</span><span class="s0">;</span>
    <span class="s1">do </span><span class="s0">{</span>
        <span class="s0">CHANGED = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">eliminate_spurious_blocks(statements);</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">)) {</span>
            <span class="s0">eliminate_dead_code(statements, compressor);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;if_return&quot;</span><span class="s0">)) {</span>
            <span class="s0">handle_if_return(statements, compressor);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(compressor.sequences_limit &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s0">sequencesize(statements, compressor);</span>
            <span class="s0">sequencesize_2(statements, compressor);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;join_vars&quot;</span><span class="s0">)) {</span>
            <span class="s0">join_consecutive_vars(statements);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;collapse_vars&quot;</span><span class="s0">)) {</span>
            <span class="s0">collapse(statements, compressor);</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">while </span><span class="s0">(CHANGED &amp;&amp; max_iter-- &gt; </span><span class="s4">0</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">find_loop_scope_try() {</span>
        <span class="s1">var </span><span class="s0">node = compressor.self(), level = </span><span class="s4">0</span><span class="s0">, in_loop = </span><span class="s1">false</span><span class="s0">, in_try = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement) {</span>
                <span class="s0">in_loop = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_TryBlock) {</span>
                <span class="s0">in_try = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(node = compressor.parent(level++));</span>

        <span class="s1">return </span><span class="s0">{ in_loop, in_try };</span>
    <span class="s0">}</span>

    <span class="s3">// Search from right to left for assignment-like expressions:</span>
    <span class="s3">// - `var a = x;`</span>
    <span class="s3">// - `a = x;`</span>
    <span class="s3">// - `++a`</span>
    <span class="s3">// For each candidate, scan from left to right for first usage, then try</span>
    <span class="s3">// to fold assignment into the site for compression.</span>
    <span class="s3">// Will not attempt to collapse assignments into or past code blocks</span>
    <span class="s3">// which are not sequentially executed, e.g. loops and conditionals.</span>
    <span class="s1">function </span><span class="s0">collapse(statements, compressor) {</span>
        <span class="s1">if </span><span class="s0">(nearest_scope.pinned() || defun_scope.pinned())</span>
            <span class="s1">return </span><span class="s0">statements;</span>
        <span class="s1">var </span><span class="s0">args;</span>
        <span class="s1">var </span><span class="s0">candidates = [];</span>
        <span class="s1">var </span><span class="s0">stat_index = statements.length;</span>
        <span class="s1">var </span><span class="s0">scanner = </span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function </span><span class="s0">(node) {</span>
            <span class="s1">if </span><span class="s0">(abort)</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s3">// Skip nodes before `candidate` as quickly as possible</span>
            <span class="s1">if </span><span class="s0">(!hit) {</span>
                <span class="s1">if </span><span class="s0">(node !== hit_stack[hit_index])</span>
                    <span class="s1">return </span><span class="s0">node;</span>
                <span class="s0">hit_index++;</span>
                <span class="s1">if </span><span class="s0">(hit_index &lt; hit_stack.length)</span>
                    <span class="s1">return </span><span class="s0">handle_custom_scan_order(node);</span>
                <span class="s0">hit = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">stop_after = find_stop(node, </span><span class="s4">0</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(stop_after === node)</span>
                    <span class="s0">abort = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s3">// Stop immediately if these node types are encountered</span>
            <span class="s1">var </span><span class="s0">parent = scanner.parent();</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
                    <span class="s0">&amp;&amp; (node.logical || node.operator != </span><span class="s2">&quot;=&quot; </span><span class="s0">&amp;&amp; lhs.equivalent_to(node.left))</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Await</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; lhs </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; lhs.equivalent_to(node.expression)</span>
                <span class="s0">||</span>
                    <span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Call || node </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess)</span>
                    <span class="s0">&amp;&amp; node.optional</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Debugger</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Expansion</span>
                    <span class="s0">&amp;&amp; node.expression </span><span class="s1">instanceof </span><span class="s0">AST_Symbol</span>
                    <span class="s0">&amp;&amp; (</span>
                        <span class="s0">node.expression </span><span class="s1">instanceof </span><span class="s0">AST_This</span>
                        <span class="s0">|| node.expression.definition().references.length &gt; </span><span class="s4">1</span>
                    <span class="s0">)</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_For)</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_LoopControl</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Try</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_With</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Yield</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Export</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Class</span>
                <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_For &amp;&amp; node !== parent.init</span>
                <span class="s0">|| !replace_all</span>
                    <span class="s0">&amp;&amp; (</span>
                        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
                        <span class="s0">&amp;&amp; !node.is_declared(compressor)</span>
                        <span class="s0">&amp;&amp; !pure_prop_access_globals.has(node)</span>
                    <span class="s0">)</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
                    <span class="s0">&amp;&amp; parent </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
                    <span class="s0">&amp;&amp; has_annotation(parent, _NOINLINE)</span>
            <span class="s0">) {</span>
                <span class="s0">abort = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s3">// Stop only if candidate is found within conditional branches</span>
            <span class="s1">if </span><span class="s0">(!stop_if_hit &amp;&amp; (!lhs_local || !replace_all)</span>
                <span class="s0">&amp;&amp; (parent </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; lazy_op.has(parent.operator) &amp;&amp; parent.left !== node</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Conditional &amp;&amp; parent.condition !== node</span>
                    <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_If &amp;&amp; parent.condition !== node)) {</span>
                <span class="s0">stop_if_hit = parent;</span>
            <span class="s0">}</span>
            <span class="s3">// Replace variable with assignment when found</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">can_replace</span>
                <span class="s0">&amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration)</span>
                <span class="s0">&amp;&amp; lhs.equivalent_to(node)</span>
                <span class="s0">&amp;&amp; !shadows(scanner.find_scope() || nearest_scope, lvalues)</span>
            <span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(stop_if_hit) {</span>
                    <span class="s0">abort = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">return </span><span class="s0">node;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is_lhs(node, parent)) {</span>
                    <span class="s1">if </span><span class="s0">(value_def)</span>
                        <span class="s0">replaced++;</span>
                    <span class="s1">return </span><span class="s0">node;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">replaced++;</span>
                    <span class="s1">if </span><span class="s0">(value_def &amp;&amp; candidate </span><span class="s1">instanceof </span><span class="s0">AST_VarDef)</span>
                        <span class="s1">return </span><span class="s0">node;</span>
                <span class="s0">}</span>
                <span class="s0">CHANGED = abort = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(candidate </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPostfix) {</span>
                    <span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, candidate, candidate);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(candidate </span><span class="s1">instanceof </span><span class="s0">AST_VarDef) {</span>
                    <span class="s1">var </span><span class="s0">def = candidate.name.definition();</span>
                    <span class="s1">var </span><span class="s0">value = candidate.value;</span>
                    <span class="s1">if </span><span class="s0">(def.references.length - def.replaced == </span><span class="s4">1 </span><span class="s0">&amp;&amp; !compressor.exposed(def)) {</span>
                        <span class="s0">def.replaced++;</span>
                        <span class="s1">if </span><span class="s0">(funarg &amp;&amp; is_identifier_atom(value)) {</span>
                            <span class="s1">return </span><span class="s0">value.transform(compressor);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s1">return </span><span class="s0">maintain_this_binding(parent, node, value);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">make_node(AST_Assign, candidate, {</span>
                        <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                        <span class="s0">logical: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">left: make_node(AST_SymbolRef, candidate.name, candidate.name),</span>
                        <span class="s0">right: value</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s0">clear_flag(candidate, WRITE_ONLY);</span>
                <span class="s1">return </span><span class="s0">candidate;</span>
            <span class="s0">}</span>
            <span class="s3">// These node types have child nodes that execute sequentially,</span>
            <span class="s3">// but are otherwise not safe to scan into or beyond them.</span>
            <span class="s1">var </span><span class="s0">sym;</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Exit</span>
                <span class="s0">&amp;&amp; (side_effects || lhs </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess || may_modify(lhs))</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
                <span class="s0">&amp;&amp; (side_effects || node.expression.may_throw_on_access(compressor))</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
                <span class="s0">&amp;&amp; ((lvalues.has(node.name) &amp;&amp; lvalues.get(node.name).modified) || side_effects &amp;&amp; may_modify(node))</span>
                <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_VarDef &amp;&amp; node.value</span>
                <span class="s0">&amp;&amp; (lvalues.has(node.name.name) || side_effects &amp;&amp; may_modify(node.name))</span>
                <span class="s0">|| (sym = is_lhs(node.left, node))</span>
                <span class="s0">&amp;&amp; (sym </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess || lvalues.has(sym.name))</span>
                <span class="s0">|| may_throw</span>
                <span class="s0">&amp;&amp; (in_try ? node.has_side_effects(compressor) : side_effects_external(node))) {</span>
                <span class="s0">stop_after = node;</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope)</span>
                    <span class="s0">abort = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">handle_custom_scan_order(node);</span>
        <span class="s0">}, </span><span class="s1">function </span><span class="s0">(node) {</span>
            <span class="s1">if </span><span class="s0">(abort)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(stop_after === node)</span>
                <span class="s0">abort = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(stop_if_hit === node)</span>
                <span class="s0">stop_if_hit = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">});</span>

        <span class="s1">var </span><span class="s0">multi_replacer = </span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function </span><span class="s0">(node) {</span>
            <span class="s1">if </span><span class="s0">(abort)</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s3">// Skip nodes before `candidate` as quickly as possible</span>
            <span class="s1">if </span><span class="s0">(!hit) {</span>
                <span class="s1">if </span><span class="s0">(node !== hit_stack[hit_index])</span>
                    <span class="s1">return </span><span class="s0">node;</span>
                <span class="s0">hit_index++;</span>
                <span class="s1">if </span><span class="s0">(hit_index &lt; hit_stack.length)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">hit = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s3">// Replace variable when found</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
                <span class="s0">&amp;&amp; node.name == def.name) {</span>
                <span class="s1">if </span><span class="s0">(!--replaced)</span>
                    <span class="s0">abort = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(is_lhs(node, multi_replacer.parent()))</span>
                    <span class="s1">return </span><span class="s0">node;</span>
                <span class="s0">def.replaced++;</span>
                <span class="s0">value_def.replaced--;</span>
                <span class="s1">return </span><span class="s0">candidate.value;</span>
            <span class="s0">}</span>
            <span class="s3">// Skip (non-executed) functions and (leading) default case in switch statements</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Default || node </span><span class="s1">instanceof </span><span class="s0">AST_Scope)</span>
                <span class="s1">return </span><span class="s0">node;</span>
        <span class="s0">});</span>

        <span class="s1">while </span><span class="s0">(--stat_index &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s3">// Treat parameters as collapsible in IIFE, i.e.</span>
            <span class="s3">//   function(a, b){ ... }(x());</span>
            <span class="s3">// would be translated into equivalent assignments:</span>
            <span class="s3">//   var a = x(), b = undefined;</span>
            <span class="s1">if </span><span class="s0">(stat_index == </span><span class="s4">0 </span><span class="s0">&amp;&amp; compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">))</span>
                <span class="s0">extract_args();</span>
            <span class="s3">// Find collapsible assignments</span>
            <span class="s1">var </span><span class="s0">hit_stack = [];</span>
            <span class="s0">extract_candidates(statements[stat_index]);</span>
            <span class="s1">while </span><span class="s0">(candidates.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">hit_stack = candidates.pop();</span>
                <span class="s1">var </span><span class="s0">hit_index = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">candidate = hit_stack[hit_stack.length - </span><span class="s4">1</span><span class="s0">];</span>
                <span class="s1">var </span><span class="s0">value_def = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">stop_after = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">stop_if_hit = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">lhs = get_lhs(candidate);</span>
                <span class="s1">if </span><span class="s0">(!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor))</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s3">// Locate symbols which may execute code outside of scanning range</span>
                <span class="s1">var </span><span class="s0">lvalues = get_lvalues(candidate);</span>
                <span class="s1">var </span><span class="s0">lhs_local = is_lhs_local(lhs);</span>
                <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
                    <span class="s0">lvalues.set(lhs.name, { def: lhs.definition(), modified: </span><span class="s1">false </span><span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">var </span><span class="s0">side_effects = value_has_side_effects(candidate);</span>
                <span class="s1">var </span><span class="s0">replace_all = replace_all_symbols();</span>
                <span class="s1">var </span><span class="s0">may_throw = candidate.may_throw(compressor);</span>
                <span class="s1">var </span><span class="s0">funarg = candidate.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg;</span>
                <span class="s1">var </span><span class="s0">hit = funarg;</span>
                <span class="s1">var </span><span class="s0">abort = </span><span class="s1">false</span><span class="s0">, replaced = </span><span class="s4">0</span><span class="s0">, can_replace = !args || !hit;</span>
                <span class="s1">if </span><span class="s0">(!can_replace) {</span>
                    <span class="s1">for </span><span class="s0">(</span>
                        <span class="s0">let j = compressor.self().argnames.lastIndexOf(candidate.name) + </span><span class="s4">1</span><span class="s0">;</span>
                        <span class="s0">!abort &amp;&amp; j &lt; args.length;</span>
                        <span class="s0">j++</span>
                    <span class="s0">) {</span>
                        <span class="s0">args[j].transform(scanner);</span>
                    <span class="s0">}</span>
                    <span class="s0">can_replace = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = stat_index; !abort &amp;&amp; i &lt; statements.length; i++) {</span>
                    <span class="s0">statements[i].transform(scanner);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(value_def) {</span>
                    <span class="s1">var </span><span class="s0">def = candidate.name.definition();</span>
                    <span class="s1">if </span><span class="s0">(abort &amp;&amp; def.references.length - def.replaced &gt; replaced)</span>
                        <span class="s0">replaced = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">abort = </span><span class="s1">false</span><span class="s0">;</span>
                        <span class="s0">hit_index = </span><span class="s4">0</span><span class="s0">;</span>
                        <span class="s0">hit = funarg;</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = stat_index; !abort &amp;&amp; i &lt; statements.length; i++) {</span>
                            <span class="s0">statements[i].transform(multi_replacer);</span>
                        <span class="s0">}</span>
                        <span class="s0">value_def.single_use = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(replaced &amp;&amp; !remove_candidate(candidate))</span>
                    <span class="s0">statements.splice(stat_index, </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">handle_custom_scan_order(node) {</span>
            <span class="s3">// Skip (non-executed) functions</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope)</span>
                <span class="s1">return </span><span class="s0">node;</span>

            <span class="s3">// Scan case expressions first in a switch statement</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Switch) {</span>
                <span class="s0">node.expression = node.expression.transform(scanner);</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = node.body.length; !abort &amp;&amp; i &lt; len; i++) {</span>
                    <span class="s1">var </span><span class="s0">branch = node.body[i];</span>
                    <span class="s1">if </span><span class="s0">(branch </span><span class="s1">instanceof </span><span class="s0">AST_Case) {</span>
                        <span class="s1">if </span><span class="s0">(!hit) {</span>
                            <span class="s1">if </span><span class="s0">(branch !== hit_stack[hit_index])</span>
                                <span class="s1">continue</span><span class="s0">;</span>
                            <span class="s0">hit_index++;</span>
                        <span class="s0">}</span>
                        <span class="s0">branch.expression = branch.expression.transform(scanner);</span>
                        <span class="s1">if </span><span class="s0">(!replace_all)</span>
                            <span class="s1">break</span><span class="s0">;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">abort = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">redefined_within_scope(def, scope) {</span>
            <span class="s1">if </span><span class="s0">(def.global)</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">let cur_scope = def.scope;</span>
            <span class="s1">while </span><span class="s0">(cur_scope &amp;&amp; cur_scope !== scope) {</span>
                <span class="s1">if </span><span class="s0">(cur_scope.variables.has(def.name)) {</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">cur_scope = cur_scope.parent_scope;</span>
            <span class="s0">}</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">has_overlapping_symbol(fn, arg, fn_strict) {</span>
            <span class="s1">var </span><span class="s0">found = </span><span class="s1">false</span><span class="s0">, scan_this = !(fn </span><span class="s1">instanceof </span><span class="s0">AST_Arrow);</span>
            <span class="s0">arg.walk(</span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function </span><span class="s0">(node, descend) {</span>
                <span class="s1">if </span><span class="s0">(found)</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; (fn.variables.has(node.name) || redefined_within_scope(node.definition(), fn))) {</span>
                    <span class="s1">var </span><span class="s0">s = node.definition().scope;</span>
                    <span class="s1">if </span><span class="s0">(s !== defun_scope)</span>
                        <span class="s1">while </span><span class="s0">(s = s.parent_scope) {</span>
                            <span class="s1">if </span><span class="s0">(s === defun_scope)</span>
                                <span class="s1">return true</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">found = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">((fn_strict || scan_this) &amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_This) {</span>
                    <span class="s1">return </span><span class="s0">found = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope &amp;&amp; !(node </span><span class="s1">instanceof </span><span class="s0">AST_Arrow)) {</span>
                    <span class="s1">var </span><span class="s0">prev = scan_this;</span>
                    <span class="s0">scan_this = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">descend();</span>
                    <span class="s0">scan_this = prev;</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}));</span>
            <span class="s1">return </span><span class="s0">found;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">extract_args() {</span>
            <span class="s1">var </span><span class="s0">iife, fn = compressor.self();</span>
            <span class="s1">if </span><span class="s0">(is_func_expr(fn)</span>
                <span class="s0">&amp;&amp; !fn.name</span>
                <span class="s0">&amp;&amp; !fn.uses_arguments</span>
                <span class="s0">&amp;&amp; !fn.pinned()</span>
                <span class="s0">&amp;&amp; (iife = compressor.parent()) </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
                <span class="s0">&amp;&amp; iife.expression === fn</span>
                <span class="s0">&amp;&amp; iife.args.every((arg) =&gt; !(arg </span><span class="s1">instanceof </span><span class="s0">AST_Expansion))) {</span>
                <span class="s1">var </span><span class="s0">fn_strict = compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(fn_strict &amp;&amp; !member(fn_strict, fn.body))</span>
                    <span class="s0">fn_strict = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">len = fn.argnames.length;</span>
                <span class="s0">args = iife.args.slice(len);</span>
                <span class="s1">var </span><span class="s0">names = </span><span class="s1">new </span><span class="s0">Set();</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = len; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
                    <span class="s1">var </span><span class="s0">sym = fn.argnames[i];</span>
                    <span class="s1">var </span><span class="s0">arg = iife.args[i];</span>
                    <span class="s3">// The following two line fix is a duplicate of the fix at</span>
                    <span class="s3">// https://github.com/terser/terser/commit/011d3eb08cefe6922c7d1bdfa113fc4aeaca1b75</span>
                    <span class="s3">// This might mean that these two pieces of code (one here in collapse_vars and another in reduce_vars</span>
                    <span class="s3">// Might be doing the exact same thing.</span>
                    <span class="s0">const def = sym.definition &amp;&amp; sym.definition();</span>
                    <span class="s0">const is_reassigned = def &amp;&amp; def.orig.length &gt; </span><span class="s4">1</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(is_reassigned)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">args.unshift(make_node(AST_VarDef, sym, {</span>
                        <span class="s0">name: sym,</span>
                        <span class="s0">value: arg</span>
                    <span class="s0">}));</span>
                    <span class="s1">if </span><span class="s0">(names.has(sym.name))</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">names.add(sym.name);</span>
                    <span class="s1">if </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
                        <span class="s1">var </span><span class="s0">elements = iife.args.slice(i);</span>
                        <span class="s1">if </span><span class="s0">(elements.every((arg) =&gt; !has_overlapping_symbol(fn, arg, fn_strict)</span>
                        <span class="s0">)) {</span>
                            <span class="s0">candidates.unshift([make_node(AST_VarDef, sym, {</span>
                                <span class="s0">name: sym.expression,</span>
                                <span class="s0">value: make_node(AST_Array, iife, {</span>
                                    <span class="s0">elements: elements</span>
                                <span class="s0">})</span>
                            <span class="s0">})]);</span>
                        <span class="s0">}</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">if </span><span class="s0">(!arg) {</span>
                            <span class="s0">arg = make_node(AST_Undefined, sym).transform(compressor);</span>
                        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(arg </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; arg.pinned()</span>
                            <span class="s0">|| has_overlapping_symbol(fn, arg, fn_strict)) {</span>
                            <span class="s0">arg = </span><span class="s1">null</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(arg)</span>
                            <span class="s0">candidates.unshift([make_node(AST_VarDef, sym, {</span>
                                <span class="s0">name: sym,</span>
                                <span class="s0">value: arg</span>
                            <span class="s0">})]);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">extract_candidates(expr) {</span>
            <span class="s0">hit_stack.push(expr);</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
                <span class="s1">if </span><span class="s0">(!expr.left.has_side_effects(compressor)</span>
                    <span class="s0">&amp;&amp; !(expr.right </span><span class="s1">instanceof </span><span class="s0">AST_Chain)) {</span>
                    <span class="s0">candidates.push(hit_stack.slice());</span>
                <span class="s0">}</span>
                <span class="s0">extract_candidates(expr.right);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Binary) {</span>
                <span class="s0">extract_candidates(expr.left);</span>
                <span class="s0">extract_candidates(expr.right);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Call &amp;&amp; !has_annotation(expr, _NOINLINE)) {</span>
                <span class="s0">extract_candidates(expr.expression);</span>
                <span class="s0">expr.args.forEach(extract_candidates);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Case) {</span>
                <span class="s0">extract_candidates(expr.expression);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Conditional) {</span>
                <span class="s0">extract_candidates(expr.condition);</span>
                <span class="s0">extract_candidates(expr.consequent);</span>
                <span class="s0">extract_candidates(expr.alternative);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Definitions) {</span>
                <span class="s1">var </span><span class="s0">len = expr.definitions.length;</span>
                <span class="s3">// limit number of trailing variable definitions for consideration</span>
                <span class="s1">var </span><span class="s0">i = len - </span><span class="s4">200</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(i &lt; </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(; i &lt; len; i++) {</span>
                    <span class="s0">extract_candidates(expr.definitions[i]);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_DWLoop) {</span>
                <span class="s0">extract_candidates(expr.condition);</span>
                <span class="s1">if </span><span class="s0">(!(expr.body </span><span class="s1">instanceof </span><span class="s0">AST_Block)) {</span>
                    <span class="s0">extract_candidates(expr.body);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Exit) {</span>
                <span class="s1">if </span><span class="s0">(expr.value)</span>
                    <span class="s0">extract_candidates(expr.value);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_For) {</span>
                <span class="s1">if </span><span class="s0">(expr.init)</span>
                    <span class="s0">extract_candidates(expr.init);</span>
                <span class="s1">if </span><span class="s0">(expr.condition)</span>
                    <span class="s0">extract_candidates(expr.condition);</span>
                <span class="s1">if </span><span class="s0">(expr.step)</span>
                    <span class="s0">extract_candidates(expr.step);</span>
                <span class="s1">if </span><span class="s0">(!(expr.body </span><span class="s1">instanceof </span><span class="s0">AST_Block)) {</span>
                    <span class="s0">extract_candidates(expr.body);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_ForIn) {</span>
                <span class="s0">extract_candidates(expr.object);</span>
                <span class="s1">if </span><span class="s0">(!(expr.body </span><span class="s1">instanceof </span><span class="s0">AST_Block)) {</span>
                    <span class="s0">extract_candidates(expr.body);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
                <span class="s0">extract_candidates(expr.condition);</span>
                <span class="s1">if </span><span class="s0">(!(expr.body </span><span class="s1">instanceof </span><span class="s0">AST_Block)) {</span>
                    <span class="s0">extract_candidates(expr.body);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(expr.alternative &amp;&amp; !(expr.alternative </span><span class="s1">instanceof </span><span class="s0">AST_Block)) {</span>
                    <span class="s0">extract_candidates(expr.alternative);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
                <span class="s0">expr.expressions.forEach(extract_candidates);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
                <span class="s0">extract_candidates(expr.body);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Switch) {</span>
                <span class="s0">extract_candidates(expr.expression);</span>
                <span class="s0">expr.body.forEach(extract_candidates);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Unary) {</span>
                <span class="s1">if </span><span class="s0">(expr.operator == </span><span class="s2">&quot;++&quot; </span><span class="s0">|| expr.operator == </span><span class="s2">&quot;--&quot;</span><span class="s0">) {</span>
                    <span class="s0">candidates.push(hit_stack.slice());</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_VarDef) {</span>
                <span class="s1">if </span><span class="s0">(expr.value &amp;&amp; !(expr.value </span><span class="s1">instanceof </span><span class="s0">AST_Chain)) {</span>
                    <span class="s0">candidates.push(hit_stack.slice());</span>
                    <span class="s0">extract_candidates(expr.value);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">hit_stack.pop();</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">find_stop(node, level, write_only) {</span>
            <span class="s1">var </span><span class="s0">parent = scanner.parent(level);</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
                <span class="s1">if </span><span class="s0">(write_only</span>
                    <span class="s0">&amp;&amp; !parent.logical</span>
                    <span class="s0">&amp;&amp; !(parent.left </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
                        <span class="s0">|| lvalues.has(parent.left.name))) {</span>
                    <span class="s1">return </span><span class="s0">find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, write_only);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Binary) {</span>
                <span class="s1">if </span><span class="s0">(write_only &amp;&amp; (!lazy_op.has(parent.operator) || parent.left === node)) {</span>
                    <span class="s1">return </span><span class="s0">find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, write_only);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Call)</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Case)</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Conditional) {</span>
                <span class="s1">if </span><span class="s0">(write_only &amp;&amp; parent.condition === node) {</span>
                    <span class="s1">return </span><span class="s0">find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, write_only);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Definitions) {</span>
                <span class="s1">return </span><span class="s0">find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Exit) {</span>
                <span class="s1">return </span><span class="s0">write_only ? find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, write_only) : node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
                <span class="s1">if </span><span class="s0">(write_only &amp;&amp; parent.condition === node) {</span>
                    <span class="s1">return </span><span class="s0">find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, write_only);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement)</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
                <span class="s1">return </span><span class="s0">find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, parent.tail_node() !== node);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
                <span class="s1">return </span><span class="s0">find_stop(parent, level + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Switch)</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_VarDef)</span>
                <span class="s1">return </span><span class="s0">node;</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">mangleable_var(var_def) {</span>
            <span class="s1">var </span><span class="s0">value = var_def.value;</span>
            <span class="s1">if </span><span class="s0">(!(value </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(value.name == </span><span class="s2">&quot;arguments&quot;</span><span class="s0">)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">def = value.definition();</span>
            <span class="s1">if </span><span class="s0">(def.undeclared)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">value_def = def;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">get_lhs(expr) {</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Assign &amp;&amp; expr.logical) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_VarDef &amp;&amp; expr.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration) {</span>
                <span class="s1">var </span><span class="s0">def = expr.name.definition();</span>
                <span class="s1">if </span><span class="s0">(!member(expr.name, def.orig))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">referenced = def.references.length - def.replaced;</span>
                <span class="s1">if </span><span class="s0">(!referenced)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">declared = def.orig.length - def.eliminated;</span>
                <span class="s1">if </span><span class="s0">(declared &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; !(expr.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg)</span>
                    <span class="s0">|| (referenced &gt; </span><span class="s4">1 </span><span class="s0">? mangleable_var(expr) : !compressor.exposed(def))) {</span>
                    <span class="s1">return </span><span class="s0">make_node(AST_SymbolRef, expr.name, expr.name);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">const lhs = expr </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
                    <span class="s0">? expr.left</span>
                    <span class="s0">: expr.expression;</span>
                <span class="s1">return </span><span class="s0">!is_ref_of(lhs, AST_SymbolConst)</span>
                    <span class="s0">&amp;&amp; !is_ref_of(lhs, AST_SymbolLet) &amp;&amp; lhs;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">get_rvalue(expr) {</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
                <span class="s1">return </span><span class="s0">expr.right;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">expr.value;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">get_lvalues(expr) {</span>
            <span class="s1">var </span><span class="s0">lvalues = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Unary)</span>
                <span class="s1">return </span><span class="s0">lvalues;</span>
            <span class="s1">var </span><span class="s0">tw = </span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function </span><span class="s0">(node) {</span>
                <span class="s1">var </span><span class="s0">sym = node;</span>
                <span class="s1">while </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess)</span>
                    <span class="s0">sym = sym.expression;</span>
                <span class="s1">if </span><span class="s0">(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
                    <span class="s0">const prev = lvalues.get(sym.name);</span>
                    <span class="s1">if </span><span class="s0">(!prev || !prev.modified) {</span>
                        <span class="s0">lvalues.set(sym.name, {</span>
                            <span class="s0">def: sym.definition(),</span>
                            <span class="s0">modified: is_modified(compressor, tw, node, node, </span><span class="s4">0</span><span class="s0">)</span>
                        <span class="s0">});</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s0">get_rvalue(expr).walk(tw);</span>
            <span class="s1">return </span><span class="s0">lvalues;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">remove_candidate(expr) {</span>
            <span class="s1">if </span><span class="s0">(expr.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg) {</span>
                <span class="s1">var </span><span class="s0">iife = compressor.parent(), argnames = compressor.self().argnames;</span>
                <span class="s1">var </span><span class="s0">index = argnames.indexOf(expr.name);</span>
                <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">iife.args.length = Math.min(iife.args.length, argnames.length - </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">var </span><span class="s0">args = iife.args;</span>
                    <span class="s1">if </span><span class="s0">(args[index])</span>
                        <span class="s0">args[index] = make_node(AST_Number, args[index], {</span>
                            <span class="s0">value: </span><span class="s4">0</span>
                        <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">found = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">statements[stat_index].transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function </span><span class="s0">(node, descend, in_list) {</span>
                <span class="s1">if </span><span class="s0">(found)</span>
                    <span class="s1">return </span><span class="s0">node;</span>
                <span class="s1">if </span><span class="s0">(node === expr || node.body === expr) {</span>
                    <span class="s0">found = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_VarDef) {</span>
                        <span class="s0">node.value = node.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolConst</span>
                            <span class="s0">? make_node(AST_Undefined, node.value) </span><span class="s3">// `const` always needs value.</span>
                            <span class="s0">: </span><span class="s1">null</span><span class="s0">;</span>
                        <span class="s1">return </span><span class="s0">node;</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">in_list ? MAP.skip : </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}, </span><span class="s1">function </span><span class="s0">(node) {</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sequence)</span>
                    <span class="s1">switch </span><span class="s0">(node.expressions.length) {</span>
                        <span class="s1">case </span><span class="s4">0</span><span class="s0">: </span><span class="s1">return null</span><span class="s0">;</span>
                        <span class="s1">case </span><span class="s4">1</span><span class="s0">: </span><span class="s1">return </span><span class="s0">node.expressions[</span><span class="s4">0</span><span class="s0">];</span>
                    <span class="s0">}</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">is_lhs_local(lhs) {</span>
            <span class="s1">while </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess)</span>
                <span class="s0">lhs = lhs.expression;</span>
            <span class="s1">return </span><span class="s0">lhs </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
                <span class="s0">&amp;&amp; lhs.definition().scope.get_defun_scope() === defun_scope</span>
                <span class="s0">&amp;&amp; !(in_loop</span>
                    <span class="s0">&amp;&amp; (lvalues.has(lhs.name)</span>
                        <span class="s0">|| candidate </span><span class="s1">instanceof </span><span class="s0">AST_Unary</span>
                        <span class="s0">|| (candidate </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
                            <span class="s0">&amp;&amp; !candidate.logical</span>
                            <span class="s0">&amp;&amp; candidate.operator != </span><span class="s2">&quot;=&quot;</span><span class="s0">)));</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">value_has_side_effects(expr) {</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Unary)</span>
                <span class="s1">return </span><span class="s0">unary_side_effects.has(expr.operator);</span>
            <span class="s1">return </span><span class="s0">get_rvalue(expr).has_side_effects(compressor);</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">replace_all_symbols() {</span>
            <span class="s1">if </span><span class="s0">(side_effects)</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(value_def)</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
                <span class="s1">var </span><span class="s0">def = lhs.definition();</span>
                <span class="s1">if </span><span class="s0">(def.references.length - def.replaced == (candidate </span><span class="s1">instanceof </span><span class="s0">AST_VarDef ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">2</span><span class="s0">)) {</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">may_modify(sym) {</span>
            <span class="s1">if </span><span class="s0">(!sym.definition)</span>
                <span class="s1">return true</span><span class="s0">; </span><span class="s3">// AST_Destructuring</span>
            <span class="s1">var </span><span class="s0">def = sym.definition();</span>
            <span class="s1">if </span><span class="s0">(def.orig.length == </span><span class="s4">1 </span><span class="s0">&amp;&amp; def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun)</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(def.scope.get_defun_scope() !== defun_scope)</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">def.references.some((ref) =&gt;</span>
                <span class="s0">ref.scope.get_defun_scope() !== defun_scope</span>
            <span class="s0">);</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">side_effects_external(node, lhs) {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign)</span>
                <span class="s1">return </span><span class="s0">side_effects_external(node.left, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Unary)</span>
                <span class="s1">return </span><span class="s0">side_effects_external(node.expression, </span><span class="s1">true</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_VarDef)</span>
                <span class="s1">return </span><span class="s0">node.value &amp;&amp; side_effects_external(node.value);</span>
            <span class="s1">if </span><span class="s0">(lhs) {</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Dot)</span>
                    <span class="s1">return </span><span class="s0">side_effects_external(node.expression, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sub)</span>
                    <span class="s1">return </span><span class="s0">side_effects_external(node.expression, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef)</span>
                    <span class="s1">return </span><span class="s0">node.definition().scope.get_defun_scope() !== defun_scope;</span>
            <span class="s0">}</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s3">/** 
         * Will any of the pulled-in lvalues shadow a variable in newScope or parents? 
         * similar to scope_encloses_variables_in_this_scope */</span>
        <span class="s1">function </span><span class="s0">shadows(my_scope, lvalues) {</span>
            <span class="s1">for </span><span class="s0">(const { def } of lvalues.values()) {</span>
                <span class="s0">const looked_up = my_scope.find_variable(def.name);</span>
                <span class="s1">if </span><span class="s0">(looked_up) {</span>
                    <span class="s1">if </span><span class="s0">(looked_up === def) </span><span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">eliminate_spurious_blocks(statements) {</span>
        <span class="s1">var </span><span class="s0">seen_dirs = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; statements.length;) {</span>
            <span class="s1">var </span><span class="s0">stat = statements[i];</span>
            <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement &amp;&amp; stat.body.every(can_be_evicted_from_block)) {</span>
                <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">eliminate_spurious_blocks(stat.body);</span>
                <span class="s0">statements.splice(i, </span><span class="s4">1</span><span class="s0">, ...stat.body);</span>
                <span class="s0">i += stat.body.length;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement) {</span>
                <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">statements.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Directive) {</span>
                <span class="s1">if </span><span class="s0">(seen_dirs.indexOf(stat.value) &lt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">i++;</span>
                    <span class="s0">seen_dirs.push(stat.value);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">statements.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else</span>
                <span class="s0">i++;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">handle_if_return(statements, compressor) {</span>
        <span class="s1">var </span><span class="s0">self = compressor.self();</span>
        <span class="s1">var </span><span class="s0">multiple_if_returns = has_multiple_if_returns(statements);</span>
        <span class="s1">var </span><span class="s0">in_lambda = self </span><span class="s1">instanceof </span><span class="s0">AST_Lambda;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = statements.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s1">var </span><span class="s0">stat = statements[i];</span>
            <span class="s1">var </span><span class="s0">j = next_index(i);</span>
            <span class="s1">var </span><span class="s0">next = statements[j];</span>

            <span class="s1">if </span><span class="s0">(in_lambda &amp;&amp; !next &amp;&amp; stat </span><span class="s1">instanceof </span><span class="s0">AST_Return) {</span>
                <span class="s1">if </span><span class="s0">(!stat.value) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">statements.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(stat.value </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix &amp;&amp; stat.value.operator == </span><span class="s2">&quot;void&quot;</span><span class="s0">) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">statements[i] = make_node(AST_SimpleStatement, stat, {</span>
                        <span class="s0">body: stat.value.expression</span>
                    <span class="s0">});</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
                <span class="s0">let ab, new_else;</span>

                <span class="s0">ab = aborts(stat.body);</span>
                <span class="s1">if </span><span class="s0">(</span>
                    <span class="s0">can_merge_flow(ab)</span>
                    <span class="s0">&amp;&amp; (new_else = as_statement_array_with_return(stat.body, ab))</span>
                <span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(ab.label) {</span>
                        <span class="s0">remove(ab.label.thedef.references, ab);</span>
                    <span class="s0">}</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">stat = stat.clone();</span>
                    <span class="s0">stat.condition = stat.condition.negate(compressor);</span>
                    <span class="s0">stat.body = make_node(AST_BlockStatement, stat, {</span>
                        <span class="s0">body: as_statement_array(stat.alternative).concat(extract_functions())</span>
                    <span class="s0">});</span>
                    <span class="s0">stat.alternative = make_node(AST_BlockStatement, stat, {</span>
                        <span class="s0">body: new_else</span>
                    <span class="s0">});</span>
                    <span class="s0">statements[i] = stat.transform(compressor);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>

                <span class="s0">ab = aborts(stat.alternative);</span>
                <span class="s1">if </span><span class="s0">(</span>
                    <span class="s0">can_merge_flow(ab)</span>
                    <span class="s0">&amp;&amp; (new_else = as_statement_array_with_return(stat.alternative, ab))</span>
                <span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(ab.label) {</span>
                        <span class="s0">remove(ab.label.thedef.references, ab);</span>
                    <span class="s0">}</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">stat = stat.clone();</span>
                    <span class="s0">stat.body = make_node(AST_BlockStatement, stat.body, {</span>
                        <span class="s0">body: as_statement_array(stat.body).concat(extract_functions())</span>
                    <span class="s0">});</span>
                    <span class="s0">stat.alternative = make_node(AST_BlockStatement, stat.alternative, {</span>
                        <span class="s0">body: new_else</span>
                    <span class="s0">});</span>
                    <span class="s0">statements[i] = stat.transform(compressor);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_If &amp;&amp; stat.body </span><span class="s1">instanceof </span><span class="s0">AST_Return) {</span>
                <span class="s1">var </span><span class="s0">value = stat.body.value;</span>
                <span class="s3">//---</span>
                <span class="s3">// pretty silly case, but:</span>
                <span class="s3">// if (foo()) return; return; ==&gt; foo(); return;</span>
                <span class="s1">if </span><span class="s0">(!value &amp;&amp; !stat.alternative</span>
                    <span class="s0">&amp;&amp; (in_lambda &amp;&amp; !next || next </span><span class="s1">instanceof </span><span class="s0">AST_Return &amp;&amp; !next.value)) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">statements[i] = make_node(AST_SimpleStatement, stat.condition, {</span>
                        <span class="s0">body: stat.condition</span>
                    <span class="s0">});</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">//---</span>
                <span class="s3">// if (foo()) return x; return y; ==&gt; return foo() ? x : y;</span>
                <span class="s1">if </span><span class="s0">(value &amp;&amp; !stat.alternative &amp;&amp; next </span><span class="s1">instanceof </span><span class="s0">AST_Return &amp;&amp; next.value) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">stat = stat.clone();</span>
                    <span class="s0">stat.alternative = next;</span>
                    <span class="s0">statements[i] = stat.transform(compressor);</span>
                    <span class="s0">statements.splice(j, </span><span class="s4">1</span><span class="s0">);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">//---</span>
                <span class="s3">// if (foo()) return x; [ return ; ] ==&gt; return foo() ? x : undefined;</span>
                <span class="s1">if </span><span class="s0">(value &amp;&amp; !stat.alternative</span>
                    <span class="s0">&amp;&amp; (!next &amp;&amp; in_lambda &amp;&amp; multiple_if_returns</span>
                        <span class="s0">|| next </span><span class="s1">instanceof </span><span class="s0">AST_Return)) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">stat = stat.clone();</span>
                    <span class="s0">stat.alternative = next || make_node(AST_Return, stat, {</span>
                        <span class="s0">value: </span><span class="s1">null</span>
                    <span class="s0">});</span>
                    <span class="s0">statements[i] = stat.transform(compressor);</span>
                    <span class="s1">if </span><span class="s0">(next)</span>
                        <span class="s0">statements.splice(j, </span><span class="s4">1</span><span class="s0">);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">//---</span>
                <span class="s3">// if (a) return b; if (c) return d; e; ==&gt; return a ? b : c ? d : void e;</span>
                <span class="s3">//</span>
                <span class="s3">// if sequences is not enabled, this can lead to an endless loop (issue #866).</span>
                <span class="s3">// however, with sequences on this helps producing slightly better output for</span>
                <span class="s3">// the example code.</span>
                <span class="s1">var </span><span class="s0">prev = statements[prev_index(i)];</span>
                <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;sequences&quot;</span><span class="s0">) &amp;&amp; in_lambda &amp;&amp; !stat.alternative</span>
                    <span class="s0">&amp;&amp; prev </span><span class="s1">instanceof </span><span class="s0">AST_If &amp;&amp; prev.body </span><span class="s1">instanceof </span><span class="s0">AST_Return</span>
                    <span class="s0">&amp;&amp; next_index(j) == statements.length &amp;&amp; next </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">stat = stat.clone();</span>
                    <span class="s0">stat.alternative = make_node(AST_BlockStatement, next, {</span>
                        <span class="s0">body: [</span>
                            <span class="s0">next,</span>
                            <span class="s0">make_node(AST_Return, next, {</span>
                                <span class="s0">value: </span><span class="s1">null</span>
                            <span class="s0">})</span>
                        <span class="s0">]</span>
                    <span class="s0">});</span>
                    <span class="s0">statements[i] = stat.transform(compressor);</span>
                    <span class="s0">statements.splice(j, </span><span class="s4">1</span><span class="s0">);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">has_multiple_if_returns(statements) {</span>
            <span class="s1">var </span><span class="s0">n = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = statements.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
                <span class="s1">var </span><span class="s0">stat = statements[i];</span>
                <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_If &amp;&amp; stat.body </span><span class="s1">instanceof </span><span class="s0">AST_Return) {</span>
                    <span class="s1">if </span><span class="s0">(++n &gt; </span><span class="s4">1</span><span class="s0">)</span>
                        <span class="s1">return true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">is_return_void(value) {</span>
            <span class="s1">return </span><span class="s0">!value || value </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix &amp;&amp; value.operator == </span><span class="s2">&quot;void&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">can_merge_flow(ab) {</span>
            <span class="s1">if </span><span class="s0">(!ab)</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = i + </span><span class="s4">1</span><span class="s0">, len = statements.length; j &lt; len; j++) {</span>
                <span class="s1">var </span><span class="s0">stat = statements[j];</span>
                <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Const || stat </span><span class="s1">instanceof </span><span class="s0">AST_Let)</span>
                    <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">lct = ab </span><span class="s1">instanceof </span><span class="s0">AST_LoopControl ? compressor.loopcontrol_target(ab) : </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">ab </span><span class="s1">instanceof </span><span class="s0">AST_Return &amp;&amp; in_lambda &amp;&amp; is_return_void(ab.value)</span>
                <span class="s0">|| ab </span><span class="s1">instanceof </span><span class="s0">AST_Continue &amp;&amp; self === loop_body(lct)</span>
                <span class="s0">|| ab </span><span class="s1">instanceof </span><span class="s0">AST_Break &amp;&amp; lct </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement &amp;&amp; self === lct;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">extract_functions() {</span>
            <span class="s1">var </span><span class="s0">tail = statements.slice(i + </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">statements.length = i + </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">tail.filter(</span><span class="s1">function </span><span class="s0">(stat) {</span>
                <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Defun) {</span>
                    <span class="s0">statements.push(stat);</span>
                    <span class="s1">return false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">as_statement_array_with_return(node, ab) {</span>
            <span class="s1">var </span><span class="s0">body = as_statement_array(node);</span>
            <span class="s1">if </span><span class="s0">(ab !== body[body.length - </span><span class="s4">1</span><span class="s0">]) {</span>
                <span class="s1">return </span><span class="s0">undefined;</span>
            <span class="s0">}</span>
            <span class="s0">body = body.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(ab.value) {</span>
                <span class="s0">body.push(make_node(AST_SimpleStatement, ab.value, {</span>
                    <span class="s0">body: ab.value.expression</span>
                <span class="s0">}));</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">body;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">next_index(i) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = i + </span><span class="s4">1</span><span class="s0">, len = statements.length; j &lt; len; j++) {</span>
                <span class="s1">var </span><span class="s0">stat = statements[j];</span>
                <span class="s1">if </span><span class="s0">(!(stat </span><span class="s1">instanceof </span><span class="s0">AST_Var &amp;&amp; declarations_only(stat))) {</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">j;</span>
        <span class="s0">}</span>

        <span class="s1">function </span><span class="s0">prev_index(i) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = i; --j &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
                <span class="s1">var </span><span class="s0">stat = statements[j];</span>
                <span class="s1">if </span><span class="s0">(!(stat </span><span class="s1">instanceof </span><span class="s0">AST_Var &amp;&amp; declarations_only(stat))) {</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">j;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">eliminate_dead_code(statements, compressor) {</span>
        <span class="s1">var </span><span class="s0">has_quit;</span>
        <span class="s1">var </span><span class="s0">self = compressor.self();</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, n = </span><span class="s4">0</span><span class="s0">, len = statements.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">stat = statements[i];</span>
            <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_LoopControl) {</span>
                <span class="s1">var </span><span class="s0">lct = compressor.loopcontrol_target(stat);</span>
                <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Break</span>
                    <span class="s0">&amp;&amp; !(lct </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement)</span>
                    <span class="s0">&amp;&amp; loop_body(lct) === self</span>
                    <span class="s0">|| stat </span><span class="s1">instanceof </span><span class="s0">AST_Continue</span>
                    <span class="s0">&amp;&amp; loop_body(lct) === self) {</span>
                    <span class="s1">if </span><span class="s0">(stat.label) {</span>
                        <span class="s0">remove(stat.label.thedef.references, stat);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">statements[n++] = stat;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">statements[n++] = stat;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(aborts(stat)) {</span>
                <span class="s0">has_quit = statements.slice(i + </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">statements.length = n;</span>
        <span class="s0">CHANGED = n != len;</span>
        <span class="s1">if </span><span class="s0">(has_quit)</span>
            <span class="s0">has_quit.forEach(</span><span class="s1">function </span><span class="s0">(stat) {</span>
                <span class="s0">trim_unreachable_code(compressor, stat, statements);</span>
            <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">declarations_only(node) {</span>
        <span class="s1">return </span><span class="s0">node.definitions.every((var_def) =&gt; !var_def.value);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">sequencesize(statements, compressor) {</span>
        <span class="s1">if </span><span class="s0">(statements.length &lt; </span><span class="s4">2</span><span class="s0">)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">seq = [], n = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">function </span><span class="s0">push_seq() {</span>
            <span class="s1">if </span><span class="s0">(!seq.length)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">body = make_sequence(seq[</span><span class="s4">0</span><span class="s0">], seq);</span>
            <span class="s0">statements[n++] = make_node(AST_SimpleStatement, body, { body: body });</span>
            <span class="s0">seq = [];</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = statements.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">stat = statements[i];</span>
            <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
                <span class="s1">if </span><span class="s0">(seq.length &gt;= compressor.sequences_limit)</span>
                    <span class="s0">push_seq();</span>
                <span class="s1">var </span><span class="s0">body = stat.body;</span>
                <span class="s1">if </span><span class="s0">(seq.length &gt; </span><span class="s4">0</span><span class="s0">)</span>
                    <span class="s0">body = body.drop_side_effect_free(compressor);</span>
                <span class="s1">if </span><span class="s0">(body)</span>
                    <span class="s0">merge_sequence(seq, body);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Definitions &amp;&amp; declarations_only(stat)</span>
                <span class="s0">|| stat </span><span class="s1">instanceof </span><span class="s0">AST_Defun) {</span>
                <span class="s0">statements[n++] = stat;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">push_seq();</span>
                <span class="s0">statements[n++] = stat;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">push_seq();</span>
        <span class="s0">statements.length = n;</span>
        <span class="s1">if </span><span class="s0">(n != len)</span>
            <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">to_simple_statement(block, decls) {</span>
        <span class="s1">if </span><span class="s0">(!(block </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement))</span>
            <span class="s1">return </span><span class="s0">block;</span>
        <span class="s1">var </span><span class="s0">stat = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = block.body.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">line = block.body[i];</span>
            <span class="s1">if </span><span class="s0">(line </span><span class="s1">instanceof </span><span class="s0">AST_Var &amp;&amp; declarations_only(line)) {</span>
                <span class="s0">decls.push(line);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat || line </span><span class="s1">instanceof </span><span class="s0">AST_Const || line </span><span class="s1">instanceof </span><span class="s0">AST_Let) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">stat = line;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">stat;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">sequencesize_2(statements, compressor) {</span>
        <span class="s1">function </span><span class="s0">cons_seq(right) {</span>
            <span class="s0">n--;</span>
            <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">left = prev.body;</span>
            <span class="s1">return </span><span class="s0">make_sequence(left, [left, right]).transform(compressor);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">n = </span><span class="s4">0</span><span class="s0">, prev;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; statements.length; i++) {</span>
            <span class="s1">var </span><span class="s0">stat = statements[i];</span>
            <span class="s1">if </span><span class="s0">(prev) {</span>
                <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Exit) {</span>
                    <span class="s0">stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor));</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_For) {</span>
                    <span class="s1">if </span><span class="s0">(!(stat.init </span><span class="s1">instanceof </span><span class="s0">AST_Definitions)) {</span>
                        <span class="s0">const abort = walk(prev.body, node =&gt; {</span>
                            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope)</span>
                                <span class="s1">return true</span><span class="s0">;</span>
                            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                                <span class="s0">&amp;&amp; node.operator === </span><span class="s2">&quot;in&quot;</span><span class="s0">) {</span>
                                <span class="s1">return </span><span class="s0">walk_abort;</span>
                            <span class="s0">}</span>
                        <span class="s0">});</span>
                        <span class="s1">if </span><span class="s0">(!abort) {</span>
                            <span class="s1">if </span><span class="s0">(stat.init)</span>
                                <span class="s0">stat.init = cons_seq(stat.init);</span>
                            <span class="s1">else </span><span class="s0">{</span>
                                <span class="s0">stat.init = prev.body;</span>
                                <span class="s0">n--;</span>
                                <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_ForIn) {</span>
                    <span class="s1">if </span><span class="s0">(!(stat.init </span><span class="s1">instanceof </span><span class="s0">AST_Const) &amp;&amp; !(stat.init </span><span class="s1">instanceof </span><span class="s0">AST_Let)) {</span>
                        <span class="s0">stat.object = cons_seq(stat.object);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
                    <span class="s0">stat.condition = cons_seq(stat.condition);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Switch) {</span>
                    <span class="s0">stat.expression = cons_seq(stat.expression);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_With) {</span>
                    <span class="s0">stat.expression = cons_seq(stat.expression);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;conditionals&quot;</span><span class="s0">) &amp;&amp; stat </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
                <span class="s1">var </span><span class="s0">decls = [];</span>
                <span class="s1">var </span><span class="s0">body = to_simple_statement(stat.body, decls);</span>
                <span class="s1">var </span><span class="s0">alt = to_simple_statement(stat.alternative, decls);</span>
                <span class="s1">if </span><span class="s0">(body !== </span><span class="s1">false </span><span class="s0">&amp;&amp; alt !== </span><span class="s1">false </span><span class="s0">&amp;&amp; decls.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s1">var </span><span class="s0">len = decls.length;</span>
                    <span class="s0">decls.push(make_node(AST_If, stat, {</span>
                        <span class="s0">condition: stat.condition,</span>
                        <span class="s0">body: body || make_node(AST_EmptyStatement, stat.body),</span>
                        <span class="s0">alternative: alt</span>
                    <span class="s0">}));</span>
                    <span class="s0">decls.unshift(n, </span><span class="s4">1</span><span class="s0">);</span>
                    <span class="s0">[].splice.apply(statements, decls);</span>
                    <span class="s0">i += len;</span>
                    <span class="s0">n += len + </span><span class="s4">1</span><span class="s0">;</span>
                    <span class="s0">prev = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">statements[n++] = stat;</span>
            <span class="s0">prev = stat </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement ? stat : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">statements.length = n;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">join_object_assignments(defn, body) {</span>
        <span class="s1">if </span><span class="s0">(!(defn </span><span class="s1">instanceof </span><span class="s0">AST_Definitions))</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">def = defn.definitions[defn.definitions.length - </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(!(def.value </span><span class="s1">instanceof </span><span class="s0">AST_Object))</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">exprs;</span>
        <span class="s1">if </span><span class="s0">(body </span><span class="s1">instanceof </span><span class="s0">AST_Assign &amp;&amp; !body.logical) {</span>
            <span class="s0">exprs = [body];</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(body </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
            <span class="s0">exprs = body.expressions.slice();</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!exprs)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">trimmed = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s1">var </span><span class="s0">node = exprs[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(!(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign))</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(node.operator != </span><span class="s2">&quot;=&quot;</span><span class="s0">)</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!(node.left </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess))</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">sym = node.left.expression;</span>
            <span class="s1">if </span><span class="s0">(!(sym </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef))</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(def.name.name != sym.name)</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!node.right.is_constant_expression(nearest_scope))</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">prop = node.left.property;</span>
            <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
                <span class="s0">prop = prop.evaluate(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_Node)</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">prop = </span><span class="s2">&quot;&quot; </span><span class="s0">+ prop;</span>
            <span class="s1">var </span><span class="s0">diff = compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">) &lt; </span><span class="s4">2015</span>
                <span class="s0">&amp;&amp; compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">) ? </span><span class="s1">function </span><span class="s0">(node) {</span>
                    <span class="s1">return </span><span class="s0">node.key != prop &amp;&amp; (node.key &amp;&amp; node.key.name != prop);</span>
                <span class="s0">} : </span><span class="s1">function </span><span class="s0">(node) {</span>
                    <span class="s1">return </span><span class="s0">node.key &amp;&amp; node.key.name != prop;</span>
                <span class="s0">};</span>
            <span class="s1">if </span><span class="s0">(!def.value.properties.every(diff))</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">p = def.value.properties.filter(</span><span class="s1">function </span><span class="s0">(p) { </span><span class="s1">return </span><span class="s0">p.key === prop; })[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(!p) {</span>
                <span class="s0">def.value.properties.push(make_node(AST_ObjectKeyVal, node, {</span>
                    <span class="s0">key: prop,</span>
                    <span class="s0">value: node.right</span>
                <span class="s0">}));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">p.value = </span><span class="s1">new </span><span class="s0">AST_Sequence({</span>
                    <span class="s0">start: p.start,</span>
                    <span class="s0">expressions: [p.value.clone(), node.right.clone()],</span>
                    <span class="s0">end: p.end</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">exprs.shift();</span>
            <span class="s0">trimmed = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(exprs.length);</span>
        <span class="s1">return </span><span class="s0">trimmed &amp;&amp; exprs;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">join_consecutive_vars(statements) {</span>
        <span class="s1">var </span><span class="s0">defs;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, j = -</span><span class="s4">1</span><span class="s0">, len = statements.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">stat = statements[i];</span>
            <span class="s1">var </span><span class="s0">prev = statements[j];</span>
            <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Definitions) {</span>
                <span class="s1">if </span><span class="s0">(prev &amp;&amp; prev.TYPE == stat.TYPE) {</span>
                    <span class="s0">prev.definitions = prev.definitions.concat(stat.definitions);</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(defs &amp;&amp; defs.TYPE == stat.TYPE &amp;&amp; declarations_only(stat)) {</span>
                    <span class="s0">defs.definitions = defs.definitions.concat(stat.definitions);</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">statements[++j] = stat;</span>
                    <span class="s0">defs = stat;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Exit) {</span>
                <span class="s0">stat.value = extract_object_assignments(stat.value);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_For) {</span>
                <span class="s1">var </span><span class="s0">exprs = join_object_assignments(prev, stat.init);</span>
                <span class="s1">if </span><span class="s0">(exprs) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">stat.init = exprs.length ? make_sequence(stat.init, exprs) : </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">statements[++j] = stat;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
                    <span class="s0">prev </span><span class="s1">instanceof </span><span class="s0">AST_Var</span>
                    <span class="s0">&amp;&amp; (!stat.init || stat.init.TYPE == prev.TYPE)</span>
                <span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(stat.init) {</span>
                        <span class="s0">prev.definitions = prev.definitions.concat(stat.init.definitions);</span>
                    <span class="s0">}</span>
                    <span class="s0">stat.init = prev;</span>
                    <span class="s0">statements[j] = stat;</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span>
                    <span class="s0">defs </span><span class="s1">instanceof </span><span class="s0">AST_Var</span>
                    <span class="s0">&amp;&amp; stat.init </span><span class="s1">instanceof </span><span class="s0">AST_Var</span>
                    <span class="s0">&amp;&amp; declarations_only(stat.init)</span>
                <span class="s0">) {</span>
                    <span class="s0">defs.definitions = defs.definitions.concat(stat.init.definitions);</span>
                    <span class="s0">stat.init = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">statements[++j] = stat;</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">statements[++j] = stat;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_ForIn) {</span>
                <span class="s0">stat.object = extract_object_assignments(stat.object);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
                <span class="s0">stat.condition = extract_object_assignments(stat.condition);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
                <span class="s1">var </span><span class="s0">exprs = join_object_assignments(prev, stat.body);</span>
                <span class="s1">if </span><span class="s0">(exprs) {</span>
                    <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(!exprs.length)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">stat.body = make_sequence(stat.body, exprs);</span>
                <span class="s0">}</span>
                <span class="s0">statements[++j] = stat;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Switch) {</span>
                <span class="s0">stat.expression = extract_object_assignments(stat.expression);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_With) {</span>
                <span class="s0">stat.expression = extract_object_assignments(stat.expression);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">statements[++j] = stat;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">statements.length = j + </span><span class="s4">1</span><span class="s0">;</span>

        <span class="s1">function </span><span class="s0">extract_object_assignments(value) {</span>
            <span class="s0">statements[++j] = stat;</span>
            <span class="s1">var </span><span class="s0">exprs = join_object_assignments(prev, value);</span>
            <span class="s1">if </span><span class="s0">(exprs) {</span>
                <span class="s0">CHANGED = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(exprs.length) {</span>
                    <span class="s1">return </span><span class="s0">make_sequence(value, exprs);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
                    <span class="s1">return </span><span class="s0">value.tail_node().left;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">return </span><span class="s0">value.left;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">value;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">/** 
 * Module that contains the inlining logic. 
 * 
 * @module 
 * 
 * The stars of the show are `inline_into_symbolref` and `inline_into_call`. 
 */</span>

<span class="s1">function </span><span class="s0">within_array_or_object_literal(compressor) {</span>
    <span class="s1">var </span><span class="s0">node, level = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">while </span><span class="s0">(node = compressor.parent(level++)) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Statement) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Array</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Object) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">scope_encloses_variables_in_this_scope(scope, pulled_scope) {</span>
    <span class="s1">for </span><span class="s0">(const enclosed of pulled_scope.enclosed) {</span>
        <span class="s1">if </span><span class="s0">(pulled_scope.variables.has(enclosed.name)) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">const looked_up = scope.find_variable(enclosed.name);</span>
        <span class="s1">if </span><span class="s0">(looked_up) {</span>
            <span class="s1">if </span><span class="s0">(looked_up === enclosed) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">inline_into_symbolref(self, compressor) {</span>
    <span class="s0">const parent = compressor.parent();</span>

    <span class="s0">const def = self.definition();</span>
    <span class="s0">const nearest_scope = compressor.find_scope();</span>
    <span class="s1">if </span><span class="s0">(compressor.top_retain &amp;&amp; def.global &amp;&amp; compressor.top_retain(def)) {</span>
        <span class="s0">def.fixed = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">def.single_use = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">self;</span>
    <span class="s0">}</span>

    <span class="s0">let fixed = self.fixed_value();</span>
    <span class="s0">let single_use = def.single_use</span>
        <span class="s0">&amp;&amp; !(parent </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
            <span class="s0">&amp;&amp; (parent.is_callee_pure(compressor))</span>
                <span class="s0">|| has_annotation(parent, _NOINLINE))</span>
        <span class="s0">&amp;&amp; !(parent </span><span class="s1">instanceof </span><span class="s0">AST_Export</span>
            <span class="s0">&amp;&amp; fixed </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
            <span class="s0">&amp;&amp; fixed.name);</span>

    <span class="s1">if </span><span class="s0">(single_use &amp;&amp; fixed </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
        <span class="s0">single_use =</span>
            <span class="s0">!fixed.has_side_effects(compressor)</span>
            <span class="s0">&amp;&amp; !fixed.may_throw(compressor);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(single_use &amp;&amp; (fixed </span><span class="s1">instanceof </span><span class="s0">AST_Lambda || fixed </span><span class="s1">instanceof </span><span class="s0">AST_Class)) {</span>
        <span class="s1">if </span><span class="s0">(retain_top_func(fixed, compressor)) {</span>
            <span class="s0">single_use = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(def.scope !== self.scope</span>
            <span class="s0">&amp;&amp; (def.escaped == </span><span class="s4">1</span>
                <span class="s0">|| has_flag(fixed, INLINED)</span>
                <span class="s0">|| within_array_or_object_literal(compressor)</span>
                <span class="s0">|| !compressor.option(</span><span class="s2">&quot;reduce_funcs&quot;</span><span class="s0">))) {</span>
            <span class="s0">single_use = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_recursive_ref(compressor, def)) {</span>
            <span class="s0">single_use = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(def.scope !== self.scope || def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg) {</span>
            <span class="s0">single_use = fixed.is_constant_expression(self.scope);</span>
            <span class="s1">if </span><span class="s0">(single_use == </span><span class="s2">&quot;f&quot;</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">scope = self.scope;</span>
                <span class="s1">do </span><span class="s0">{</span>
                    <span class="s1">if </span><span class="s0">(scope </span><span class="s1">instanceof </span><span class="s0">AST_Defun || is_func_expr(scope)) {</span>
                        <span class="s0">set_flag(scope, INLINED);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">while </span><span class="s0">(scope = scope.parent_scope);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(single_use &amp;&amp; (fixed </span><span class="s1">instanceof </span><span class="s0">AST_Lambda || fixed </span><span class="s1">instanceof </span><span class="s0">AST_Class)) {</span>
        <span class="s0">single_use =</span>
            <span class="s0">def.scope === self.scope</span>
                <span class="s0">&amp;&amp; !scope_encloses_variables_in_this_scope(nearest_scope, fixed)</span>
            <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
                <span class="s0">&amp;&amp; parent.expression === self</span>
                <span class="s0">&amp;&amp; !scope_encloses_variables_in_this_scope(nearest_scope, fixed)</span>
                <span class="s0">&amp;&amp; !(fixed.name &amp;&amp; fixed.name.definition().recursive_refs &gt; </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(single_use &amp;&amp; fixed) {</span>
        <span class="s1">if </span><span class="s0">(fixed </span><span class="s1">instanceof </span><span class="s0">AST_DefClass) {</span>
            <span class="s0">set_flag(fixed, SQUEEZED);</span>
            <span class="s0">fixed = make_node(AST_ClassExpression, fixed, fixed);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(fixed </span><span class="s1">instanceof </span><span class="s0">AST_Defun) {</span>
            <span class="s0">set_flag(fixed, SQUEEZED);</span>
            <span class="s0">fixed = make_node(AST_Function, fixed, fixed);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(def.recursive_refs &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; fixed.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun) {</span>
            <span class="s0">const defun_def = fixed.name.definition();</span>
            <span class="s0">let lambda_def = fixed.variables.get(fixed.name.name);</span>
            <span class="s0">let name = lambda_def &amp;&amp; lambda_def.orig[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(!(name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda)) {</span>
                <span class="s0">name = make_node(AST_SymbolLambda, fixed.name, fixed.name);</span>
                <span class="s0">name.scope = fixed;</span>
                <span class="s0">fixed.name = name;</span>
                <span class="s0">lambda_def = fixed.def_function(name);</span>
            <span class="s0">}</span>
            <span class="s0">walk(fixed, node =&gt; {</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; node.definition() === defun_def) {</span>
                    <span class="s0">node.thedef = lambda_def;</span>
                    <span class="s0">lambda_def.references.push(node);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">(fixed </span><span class="s1">instanceof </span><span class="s0">AST_Lambda || fixed </span><span class="s1">instanceof </span><span class="s0">AST_Class)</span>
            <span class="s0">&amp;&amp; fixed.parent_scope !== nearest_scope</span>
        <span class="s0">) {</span>
            <span class="s0">fixed = fixed.clone(</span><span class="s1">true</span><span class="s0">, compressor.get_toplevel());</span>

            <span class="s0">nearest_scope.add_child_scope(fixed);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">fixed.optimize(compressor);</span>
    <span class="s0">}</span>

    <span class="s3">// multiple uses</span>
    <span class="s1">if </span><span class="s0">(fixed) {</span>
        <span class="s0">let replace;</span>

        <span class="s1">if </span><span class="s0">(fixed </span><span class="s1">instanceof </span><span class="s0">AST_This) {</span>
            <span class="s1">if </span><span class="s0">(!(def.orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg)</span>
                <span class="s0">&amp;&amp; def.references.every((ref) =&gt;</span>
                    <span class="s0">def.scope === ref.scope</span>
                <span class="s0">)) {</span>
                <span class="s0">replace = fixed;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">var </span><span class="s0">ev = fixed.evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">ev !== fixed</span>
                <span class="s0">&amp;&amp; (compressor.option(</span><span class="s2">&quot;unsafe_regexp&quot;</span><span class="s0">) || !(ev </span><span class="s1">instanceof </span><span class="s0">RegExp))</span>
            <span class="s0">) {</span>
                <span class="s0">replace = make_node_from_constant(ev, fixed);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(replace) {</span>
            <span class="s0">const name_length = self.size(compressor);</span>
            <span class="s0">const replace_size = replace.size(compressor);</span>

            <span class="s0">let overhead = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">) &amp;&amp; !compressor.exposed(def)) {</span>
                <span class="s0">overhead =</span>
                    <span class="s0">(name_length + </span><span class="s4">2 </span><span class="s0">+ replace_size) /</span>
                    <span class="s0">(def.references.length - def.assignments);</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(replace_size &lt;= name_length + overhead) {</span>
                <span class="s1">return </span><span class="s0">replace;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">inline_into_call(self, fn, compressor) {</span>
    <span class="s1">var </span><span class="s0">exp = self.expression;</span>
    <span class="s1">var </span><span class="s0">simple_args = self.args.every((arg) =&gt; !(arg </span><span class="s1">instanceof </span><span class="s0">AST_Expansion));</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; fn </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">&amp;&amp; !has_annotation(self, _NOINLINE)</span>
    <span class="s0">) {</span>
        <span class="s0">const fixed = fn.fixed_value();</span>
        <span class="s1">if </span><span class="s0">(!retain_top_func(fixed, compressor)) {</span>
            <span class="s0">fn = fixed;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">is_func = fn </span><span class="s1">instanceof </span><span class="s0">AST_Lambda;</span>

    <span class="s1">var </span><span class="s0">stat = is_func &amp;&amp; fn.body[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">var </span><span class="s0">is_regular_func = is_func &amp;&amp; !fn.is_generator &amp;&amp; !fn.async;</span>
    <span class="s1">var </span><span class="s0">can_inline = is_regular_func &amp;&amp; compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s0">) &amp;&amp; !self.is_callee_pure(compressor);</span>
    <span class="s1">if </span><span class="s0">(can_inline &amp;&amp; stat </span><span class="s1">instanceof </span><span class="s0">AST_Return) {</span>
        <span class="s0">let returned = stat.value;</span>
        <span class="s1">if </span><span class="s0">(!returned || returned.is_constant_expression()) {</span>
            <span class="s1">if </span><span class="s0">(returned) {</span>
                <span class="s0">returned = returned.clone(</span><span class="s1">true</span><span class="s0">);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">returned = make_node(AST_Undefined, self);</span>
            <span class="s0">}</span>
            <span class="s0">const args = self.args.concat(returned);</span>
            <span class="s1">return </span><span class="s0">make_sequence(self, args).optimize(compressor);</span>
        <span class="s0">}</span>

        <span class="s3">// optimize identity function</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">fn.argnames.length === </span><span class="s4">1</span>
            <span class="s0">&amp;&amp; (fn.argnames[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg)</span>
            <span class="s0">&amp;&amp; self.args.length &lt; </span><span class="s4">2</span>
            <span class="s0">&amp;&amp; !(self.args[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Expansion)</span>
            <span class="s0">&amp;&amp; returned </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">&amp;&amp; returned.name === fn.argnames[</span><span class="s4">0</span><span class="s0">].name</span>
        <span class="s0">) {</span>
            <span class="s0">const replacement =</span>
                <span class="s0">(self.args[</span><span class="s4">0</span><span class="s0">] || make_node(AST_Undefined)).optimize(compressor);</span>

            <span class="s0">let parent;</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">replacement </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
                <span class="s0">&amp;&amp; (parent = compressor.parent()) </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
                <span class="s0">&amp;&amp; parent.expression === self</span>
            <span class="s0">) {</span>
                <span class="s3">// identity function was being used to remove `this`, like in</span>
                <span class="s3">//</span>
                <span class="s3">// id(bag.no_this)(...)</span>
                <span class="s3">//</span>
                <span class="s3">// Replace with a larger but more effish (0, bag.no_this) wrapper.</span>

                <span class="s1">return </span><span class="s0">make_sequence(self, [</span>
                    <span class="s0">make_node(AST_Number, self, { value: </span><span class="s4">0 </span><span class="s0">}),</span>
                    <span class="s0">replacement</span>
                <span class="s0">]);</span>
            <span class="s0">}</span>
            <span class="s3">// replace call with first argument or undefined if none passed</span>
            <span class="s1">return </span><span class="s0">replacement;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(can_inline) {</span>
        <span class="s1">var </span><span class="s0">scope, in_loop, level = -</span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">let def;</span>
        <span class="s0">let returned_value;</span>
        <span class="s0">let nearest_scope;</span>
        <span class="s1">if </span><span class="s0">(simple_args</span>
            <span class="s0">&amp;&amp; !fn.uses_arguments</span>
            <span class="s0">&amp;&amp; !(compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Class)</span>
            <span class="s0">&amp;&amp; !(fn.name &amp;&amp; fn </span><span class="s1">instanceof </span><span class="s0">AST_Function)</span>
            <span class="s0">&amp;&amp; (returned_value = can_flatten_body(stat))</span>
            <span class="s0">&amp;&amp; (exp === fn</span>
                <span class="s0">|| has_annotation(self, _INLINE)</span>
                <span class="s0">|| compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">)</span>
                    <span class="s0">&amp;&amp; (def = exp.definition()).references.length == </span><span class="s4">1</span>
                    <span class="s0">&amp;&amp; !is_recursive_ref(compressor, def)</span>
                    <span class="s0">&amp;&amp; fn.is_constant_expression(exp.scope))</span>
            <span class="s0">&amp;&amp; !has_annotation(self, _PURE | _NOINLINE)</span>
            <span class="s0">&amp;&amp; !fn.contains_this()</span>
            <span class="s0">&amp;&amp; can_inject_symbols()</span>
            <span class="s0">&amp;&amp; (nearest_scope = compressor.find_scope())</span>
            <span class="s0">&amp;&amp; !scope_encloses_variables_in_this_scope(nearest_scope, fn)</span>
            <span class="s0">&amp;&amp; !(</span><span class="s1">function </span><span class="s0">in_default_assign() {</span>
                    <span class="s3">// Due to the fact function parameters have their own scope</span>
                    <span class="s3">// which can't use `var something` in the function body within,</span>
                    <span class="s3">// we simply don't inline into DefaultAssign.</span>
                    <span class="s0">let i = </span><span class="s4">0</span><span class="s0">;</span>
                    <span class="s0">let p;</span>
                    <span class="s1">while </span><span class="s0">((p = compressor.parent(i++))) {</span>
                        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_DefaultAssign) </span><span class="s1">return true</span><span class="s0">;</span>
                        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Block) </span><span class="s1">break</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">return false</span><span class="s0">;</span>
                <span class="s0">})()</span>
            <span class="s0">&amp;&amp; !(scope </span><span class="s1">instanceof </span><span class="s0">AST_Class)</span>
        <span class="s0">) {</span>
            <span class="s0">set_flag(fn, SQUEEZED);</span>
            <span class="s0">nearest_scope.add_child_scope(fn);</span>
            <span class="s1">return </span><span class="s0">make_sequence(self, flatten_fn(returned_value)).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(can_inline &amp;&amp; has_annotation(self, _INLINE)) {</span>
        <span class="s0">set_flag(fn, SQUEEZED);</span>
        <span class="s0">fn = make_node(fn.CTOR === AST_Defun ? AST_Function : fn.CTOR, fn, fn);</span>
        <span class="s0">fn = fn.clone(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">fn.figure_out_scope({}, {</span>
            <span class="s0">parent_scope: compressor.find_scope(),</span>
            <span class="s0">toplevel: compressor.get_toplevel()</span>
        <span class="s0">});</span>

        <span class="s1">return </span><span class="s0">make_node(AST_Call, self, {</span>
            <span class="s0">expression: fn,</span>
            <span class="s0">args: self.args,</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>

    <span class="s0">const can_drop_this_call = is_regular_func &amp;&amp; compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s0">) &amp;&amp; fn.body.every(is_empty);</span>
    <span class="s1">if </span><span class="s0">(can_drop_this_call) {</span>
        <span class="s1">var </span><span class="s0">args = self.args.concat(make_node(AST_Undefined, self));</span>
        <span class="s1">return </span><span class="s0">make_sequence(self, args).optimize(compressor);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;negate_iife&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement</span>
        <span class="s0">&amp;&amp; is_iife_call(self)) {</span>
        <span class="s1">return </span><span class="s0">self.negate(compressor, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">ev = self.evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(ev !== self) {</span>
        <span class="s0">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
        <span class="s1">return </span><span class="s0">best_of(compressor, ev, self);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">function </span><span class="s0">return_value(stat) {</span>
        <span class="s1">if </span><span class="s0">(!stat) </span><span class="s1">return </span><span class="s0">make_node(AST_Undefined, self);</span>
        <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_Return) {</span>
            <span class="s1">if </span><span class="s0">(!stat.value) </span><span class="s1">return </span><span class="s0">make_node(AST_Undefined, self);</span>
            <span class="s1">return </span><span class="s0">stat.value.clone(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(stat </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, stat, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;void&quot;</span><span class="s0">,</span>
                <span class="s0">expression: stat.body.clone(</span><span class="s1">true</span><span class="s0">)</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">can_flatten_body(stat) {</span>
        <span class="s1">var </span><span class="s0">body = fn.body;</span>
        <span class="s1">var </span><span class="s0">len = body.length;</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s0">) &lt; </span><span class="s4">3</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">len == </span><span class="s4">1 </span><span class="s0">&amp;&amp; return_value(stat);</span>
        <span class="s0">}</span>
        <span class="s0">stat = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">line = body[i];</span>
            <span class="s1">if </span><span class="s0">(line </span><span class="s1">instanceof </span><span class="s0">AST_Var) {</span>
                <span class="s1">if </span><span class="s0">(stat &amp;&amp; !line.definitions.every((var_def) =&gt;</span>
                    <span class="s0">!var_def.value</span>
                <span class="s0">)) {</span>
                    <span class="s1">return false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stat) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(line </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement)) {</span>
                <span class="s0">stat = line;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">return_value(stat);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">can_inject_args(block_scoped, safe_to_inject) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = fn.argnames.length; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">arg = fn.argnames[i];</span>
            <span class="s1">if </span><span class="s0">(arg </span><span class="s1">instanceof </span><span class="s0">AST_DefaultAssign) {</span>
                <span class="s1">if </span><span class="s0">(has_flag(arg.left, UNUSED)) </span><span class="s1">continue</span><span class="s0">;</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(arg </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring) </span><span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(arg </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
                <span class="s1">if </span><span class="s0">(has_flag(arg.expression, UNUSED)) </span><span class="s1">continue</span><span class="s0">;</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(has_flag(arg, UNUSED)) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!safe_to_inject</span>
                <span class="s0">|| block_scoped.has(arg.name)</span>
                <span class="s0">|| identifier_atom.has(arg.name)</span>
                <span class="s0">|| scope.conflicting_def(arg.name)) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(in_loop) in_loop.push(arg.definition());</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">can_inject_vars(block_scoped, safe_to_inject) {</span>
        <span class="s1">var </span><span class="s0">len = fn.body.length;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; len; i++) {</span>
            <span class="s1">var </span><span class="s0">stat = fn.body[i];</span>
            <span class="s1">if </span><span class="s0">(!(stat </span><span class="s1">instanceof </span><span class="s0">AST_Var)) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!safe_to_inject) </span><span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = stat.definitions.length; --j &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
                <span class="s1">var </span><span class="s0">name = stat.definitions[j].name;</span>
                <span class="s1">if </span><span class="s0">(name </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring</span>
                    <span class="s0">|| block_scoped.has(name.name)</span>
                    <span class="s0">|| identifier_atom.has(name.name)</span>
                    <span class="s0">|| scope.conflicting_def(name.name)) {</span>
                    <span class="s1">return false</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(in_loop) in_loop.push(name.definition());</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">can_inject_symbols() {</span>
        <span class="s1">var </span><span class="s0">block_scoped = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">scope = compressor.parent(++level);</span>
            <span class="s1">if </span><span class="s0">(scope.is_block_scope() &amp;&amp; scope.block_scope) {</span>
                <span class="s3">// TODO this is sometimes undefined during compression.</span>
                <span class="s3">// But it should always have a value!</span>
                <span class="s0">scope.block_scope.variables.forEach(</span><span class="s1">function </span><span class="s0">(variable) {</span>
                    <span class="s0">block_scoped.add(variable.name);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(scope </span><span class="s1">instanceof </span><span class="s0">AST_Catch) {</span>
                <span class="s3">// TODO can we delete? AST_Catch is a block scope.</span>
                <span class="s1">if </span><span class="s0">(scope.argname) {</span>
                    <span class="s0">block_scoped.add(scope.argname.name);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(scope </span><span class="s1">instanceof </span><span class="s0">AST_IterationStatement) {</span>
                <span class="s0">in_loop = [];</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(scope </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
                <span class="s1">if </span><span class="s0">(scope.fixed_value() </span><span class="s1">instanceof </span><span class="s0">AST_Scope) </span><span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(!(scope </span><span class="s1">instanceof </span><span class="s0">AST_Scope));</span>

        <span class="s1">var </span><span class="s0">safe_to_inject = !(scope </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) || compressor.toplevel.vars;</span>
        <span class="s1">var </span><span class="s0">inline = compressor.option(</span><span class="s2">&quot;inline&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(!can_inject_vars(block_scoped, inline &gt;= </span><span class="s4">3 </span><span class="s0">&amp;&amp; safe_to_inject)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!can_inject_args(block_scoped, inline &gt;= </span><span class="s4">2 </span><span class="s0">&amp;&amp; safe_to_inject)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!in_loop || in_loop.length == </span><span class="s4">0 </span><span class="s0">|| !is_reachable(fn, in_loop);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">append_var(decls, expressions, name, value) {</span>
        <span class="s1">var </span><span class="s0">def = name.definition();</span>

        <span class="s3">// Name already exists, only when a function argument had the same name</span>
        <span class="s0">const already_appended = scope.variables.has(name.name);</span>
        <span class="s1">if </span><span class="s0">(!already_appended) {</span>
            <span class="s0">scope.variables.set(name.name, def);</span>
            <span class="s0">scope.enclosed.push(def);</span>
            <span class="s0">decls.push(make_node(AST_VarDef, name, {</span>
                <span class="s0">name: name,</span>
                <span class="s0">value: </span><span class="s1">null</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">sym = make_node(AST_SymbolRef, name, name);</span>
        <span class="s0">def.references.push(sym);</span>
        <span class="s1">if </span><span class="s0">(value) expressions.push(make_node(AST_Assign, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
            <span class="s0">logical: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">left: sym,</span>
            <span class="s0">right: value.clone()</span>
        <span class="s0">}));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">flatten_args(decls, expressions) {</span>
        <span class="s1">var </span><span class="s0">len = fn.argnames.length;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = self.args.length; --i &gt;= len;) {</span>
            <span class="s0">expressions.push(self.args[i]);</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(i = len; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s1">var </span><span class="s0">name = fn.argnames[i];</span>
            <span class="s1">var </span><span class="s0">value = self.args[i];</span>
            <span class="s1">if </span><span class="s0">(has_flag(name, UNUSED) || !name.name || scope.conflicting_def(name.name)) {</span>
                <span class="s1">if </span><span class="s0">(value) expressions.push(value);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">var </span><span class="s0">symbol = make_node(AST_SymbolVar, name, name);</span>
                <span class="s0">name.definition().orig.push(symbol);</span>
                <span class="s1">if </span><span class="s0">(!value &amp;&amp; in_loop) value = make_node(AST_Undefined, self);</span>
                <span class="s0">append_var(decls, expressions, symbol, value);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">decls.reverse();</span>
        <span class="s0">expressions.reverse();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">flatten_vars(decls, expressions) {</span>
        <span class="s1">var </span><span class="s0">pos = expressions.length;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, lines = fn.body.length; i &lt; lines; i++) {</span>
            <span class="s1">var </span><span class="s0">stat = fn.body[i];</span>
            <span class="s1">if </span><span class="s0">(!(stat </span><span class="s1">instanceof </span><span class="s0">AST_Var)) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">0</span><span class="s0">, defs = stat.definitions.length; j &lt; defs; j++) {</span>
                <span class="s1">var </span><span class="s0">var_def = stat.definitions[j];</span>
                <span class="s1">var </span><span class="s0">name = var_def.name;</span>
                <span class="s0">append_var(decls, expressions, name, var_def.value);</span>
                <span class="s1">if </span><span class="s0">(in_loop &amp;&amp; fn.argnames.every((argname) =&gt;</span>
                    <span class="s0">argname.name != name.name</span>
                <span class="s0">)) {</span>
                    <span class="s1">var </span><span class="s0">def = fn.variables.get(name.name);</span>
                    <span class="s1">var </span><span class="s0">sym = make_node(AST_SymbolRef, name, name);</span>
                    <span class="s0">def.references.push(sym);</span>
                    <span class="s0">expressions.splice(pos++, </span><span class="s4">0</span><span class="s0">, make_node(AST_Assign, var_def, {</span>
                        <span class="s0">operator: </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                        <span class="s0">logical: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">left: sym,</span>
                        <span class="s0">right: make_node(AST_Undefined, name)</span>
                    <span class="s0">}));</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">flatten_fn(returned_value) {</span>
        <span class="s1">var </span><span class="s0">decls = [];</span>
        <span class="s1">var </span><span class="s0">expressions = [];</span>
        <span class="s0">flatten_args(decls, expressions);</span>
        <span class="s0">flatten_vars(decls, expressions);</span>
        <span class="s0">expressions.push(returned_value);</span>

        <span class="s1">if </span><span class="s0">(decls.length) {</span>
            <span class="s0">const i = scope.body.indexOf(compressor.parent(level - </span><span class="s4">1</span><span class="s0">)) + </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">scope.body.splice(i, </span><span class="s4">0</span><span class="s0">, make_node(AST_Var, fn, {</span>
                <span class="s0">definitions: decls</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">expressions.map(exp =&gt; exp.clone(</span><span class="s1">true</span><span class="s0">));</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s0">class Compressor extends TreeWalker {</span>
    <span class="s0">constructor(options, { false_by_default = </span><span class="s1">false</span><span class="s0">, mangle_options = </span><span class="s1">false </span><span class="s0">}) {</span>
        <span class="s0">super();</span>
        <span class="s1">if </span><span class="s0">(options.defaults !== undefined &amp;&amp; !options.defaults) false_by_default = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.options = defaults(options, {</span>
            <span class="s0">arguments     : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">arrows        : !false_by_default,</span>
            <span class="s0">booleans      : !false_by_default,</span>
            <span class="s0">booleans_as_integers : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">collapse_vars : !false_by_default,</span>
            <span class="s0">comparisons   : !false_by_default,</span>
            <span class="s0">computed_props: !false_by_default,</span>
            <span class="s0">conditionals  : !false_by_default,</span>
            <span class="s0">dead_code     : !false_by_default,</span>
            <span class="s0">defaults      : </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">directives    : !false_by_default,</span>
            <span class="s0">drop_console  : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">drop_debugger : !false_by_default,</span>
            <span class="s0">ecma          : </span><span class="s4">5</span><span class="s0">,</span>
            <span class="s0">evaluate      : !false_by_default,</span>
            <span class="s0">expression    : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">global_defs   : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">hoist_funs    : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">hoist_props   : !false_by_default,</span>
            <span class="s0">hoist_vars    : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">ie8           : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">if_return     : !false_by_default,</span>
            <span class="s0">inline        : !false_by_default,</span>
            <span class="s0">join_vars     : !false_by_default,</span>
            <span class="s0">keep_classnames: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">keep_fargs    : </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">keep_fnames   : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">keep_infinity : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">lhs_constants : !false_by_default,</span>
            <span class="s0">loops         : !false_by_default,</span>
            <span class="s0">module        : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">negate_iife   : !false_by_default,</span>
            <span class="s0">passes        : </span><span class="s4">1</span><span class="s0">,</span>
            <span class="s0">properties    : !false_by_default,</span>
            <span class="s0">pure_getters  : !false_by_default &amp;&amp; </span><span class="s2">&quot;strict&quot;</span><span class="s0">,</span>
            <span class="s0">pure_funcs    : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">reduce_funcs  : !false_by_default,</span>
            <span class="s0">reduce_vars   : !false_by_default,</span>
            <span class="s0">sequences     : !false_by_default,</span>
            <span class="s0">side_effects  : !false_by_default,</span>
            <span class="s0">switches      : !false_by_default,</span>
            <span class="s0">top_retain    : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">toplevel      : !!(options &amp;&amp; options[</span><span class="s2">&quot;top_retain&quot;</span><span class="s0">]),</span>
            <span class="s0">typeofs       : !false_by_default,</span>
            <span class="s0">unsafe        : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_arrows : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_comps  : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_Function: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_math   : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_symbols: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_methods: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_proto  : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_regexp : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unsafe_undefined: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">unused        : !false_by_default,</span>
            <span class="s0">warnings      : </span><span class="s1">false  </span><span class="s3">// legacy</span>
        <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">global_defs = </span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;global_defs&quot;</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">global_defs == </span><span class="s2">&quot;object&quot;</span><span class="s0">) </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">key </span><span class="s1">in </span><span class="s0">global_defs) {</span>
            <span class="s1">if </span><span class="s0">(key[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">&quot;@&quot; </span><span class="s0">&amp;&amp; HOP(global_defs, key)) {</span>
                <span class="s0">global_defs[key.slice(</span><span class="s4">1</span><span class="s0">)] = parse(global_defs[key], {</span>
                    <span class="s0">expression: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;inline&quot;</span><span class="s0">] === </span><span class="s1">true</span><span class="s0">) </span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;inline&quot;</span><span class="s0">] = </span><span class="s4">3</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">pure_funcs = </span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;pure_funcs&quot;</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">pure_funcs == </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.pure_funcs = pure_funcs;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">this</span><span class="s0">.pure_funcs = pure_funcs ? </span><span class="s1">function</span><span class="s0">(node) {</span>
                <span class="s1">return </span><span class="s0">!pure_funcs.includes(node.expression.print_to_string());</span>
            <span class="s0">} : return_true;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">top_retain = </span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;top_retain&quot;</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(top_retain </span><span class="s1">instanceof </span><span class="s0">RegExp) {</span>
            <span class="s1">this</span><span class="s0">.top_retain = </span><span class="s1">function</span><span class="s0">(def) {</span>
                <span class="s1">return </span><span class="s0">top_retain.test(def.name);</span>
            <span class="s0">};</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">top_retain == </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.top_retain = top_retain;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(top_retain) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">top_retain == </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                <span class="s0">top_retain = top_retain.split(/,/);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.top_retain = </span><span class="s1">function</span><span class="s0">(def) {</span>
                <span class="s1">return </span><span class="s0">top_retain.includes(def.name);</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;module&quot;</span><span class="s0">]) {</span>
            <span class="s1">this</span><span class="s0">.directives[</span><span class="s2">&quot;use strict&quot;</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;toplevel&quot;</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">toplevel = </span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;toplevel&quot;</span><span class="s0">];</span>
        <span class="s1">this</span><span class="s0">.toplevel = </span><span class="s1">typeof </span><span class="s0">toplevel == </span><span class="s2">&quot;string&quot; </span><span class="s0">? {</span>
            <span class="s0">funcs: /funcs/.test(toplevel),</span>
            <span class="s0">vars: /vars/.test(toplevel)</span>
        <span class="s0">} : {</span>
            <span class="s0">funcs: toplevel,</span>
            <span class="s0">vars: toplevel</span>
        <span class="s0">};</span>
        <span class="s1">var </span><span class="s0">sequences = </span><span class="s1">this</span><span class="s0">.options[</span><span class="s2">&quot;sequences&quot;</span><span class="s0">];</span>
        <span class="s1">this</span><span class="s0">.sequences_limit = sequences == </span><span class="s4">1 </span><span class="s0">? </span><span class="s4">800 </span><span class="s0">: sequences | </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.evaluated_regexps = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s1">this</span><span class="s0">._toplevel = undefined;</span>
        <span class="s1">this</span><span class="s0">.mangle_options = mangle_options</span>
            <span class="s0">? format_mangler_options(mangle_options)</span>
            <span class="s0">: mangle_options;</span>
    <span class="s0">}</span>

    <span class="s0">option(key) {</span>
        <span class="s1">return this</span><span class="s0">.options[key];</span>
    <span class="s0">}</span>

    <span class="s0">exposed(def) {</span>
        <span class="s1">if </span><span class="s0">(def.export) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(def.global) </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = def.orig.length; i &lt; len; i++)</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.toplevel[def.orig[i] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDefun ? </span><span class="s2">&quot;funcs&quot; </span><span class="s0">: </span><span class="s2">&quot;vars&quot;</span><span class="s0">])</span>
                <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">in_boolean_context() {</span>
        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.option(</span><span class="s2">&quot;booleans&quot;</span><span class="s0">)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">.self();</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, p; p = </span><span class="s1">this</span><span class="s0">.parent(i); i++) {</span>
            <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Conditional &amp;&amp; p.condition === self</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_DWLoop &amp;&amp; p.condition === self</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_For &amp;&amp; p.condition === self</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_If &amp;&amp; p.condition === self</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix &amp;&amp; p.operator == </span><span class="s2">&quot;!&quot; </span><span class="s0">&amp;&amp; p.expression === self) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">p </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                    <span class="s0">&amp;&amp; (</span>
                        <span class="s0">p.operator == </span><span class="s2">&quot;&amp;&amp;&quot;</span>
                        <span class="s0">|| p.operator == </span><span class="s2">&quot;||&quot;</span>
                        <span class="s0">|| p.operator == </span><span class="s2">&quot;??&quot;</span>
                    <span class="s0">)</span>
                <span class="s0">|| p </span><span class="s1">instanceof </span><span class="s0">AST_Conditional</span>
                <span class="s0">|| p.tail_node() === self</span>
            <span class="s0">) {</span>
                <span class="s0">self = p;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s0">get_toplevel() {</span>
        <span class="s1">return this</span><span class="s0">._toplevel;</span>
    <span class="s0">}</span>

    <span class="s0">compress(toplevel) {</span>
        <span class="s0">toplevel = toplevel.resolve_defines(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s1">this</span><span class="s0">._toplevel = toplevel;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.option(</span><span class="s2">&quot;expression&quot;</span><span class="s0">)) {</span>
            <span class="s1">this</span><span class="s0">._toplevel.process_expression(</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">passes = +</span><span class="s1">this</span><span class="s0">.options.passes || </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">min_count = </span><span class="s4">1 </span><span class="s0">/ </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">stopping = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">nth_identifier = </span><span class="s1">this</span><span class="s0">.mangle_options &amp;&amp; </span><span class="s1">this</span><span class="s0">.mangle_options.nth_identifier || base54;</span>
        <span class="s1">var </span><span class="s0">mangle = { ie8: </span><span class="s1">this</span><span class="s0">.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">), nth_identifier: nth_identifier };</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">pass = </span><span class="s4">0</span><span class="s0">; pass &lt; passes; pass++) {</span>
            <span class="s1">this</span><span class="s0">._toplevel.figure_out_scope(mangle);</span>
            <span class="s1">if </span><span class="s0">(pass === </span><span class="s4">0 </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.option(</span><span class="s2">&quot;drop_console&quot;</span><span class="s0">)) {</span>
                <span class="s3">// must be run before reduce_vars and compress pass</span>
                <span class="s1">this</span><span class="s0">._toplevel = </span><span class="s1">this</span><span class="s0">._toplevel.drop_console();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(pass &gt; </span><span class="s4">0 </span><span class="s0">|| </span><span class="s1">this</span><span class="s0">.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">)) {</span>
                <span class="s1">this</span><span class="s0">._toplevel.reset_opt_flags(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">._toplevel = </span><span class="s1">this</span><span class="s0">._toplevel.transform(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(passes &gt; </span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s0">let count = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">walk(</span><span class="s1">this</span><span class="s0">._toplevel, () =&gt; { count++; });</span>
                <span class="s1">if </span><span class="s0">(count &lt; min_count) {</span>
                    <span class="s0">min_count = count;</span>
                    <span class="s0">stopping = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(stopping) {</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">stopping = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.option(</span><span class="s2">&quot;expression&quot;</span><span class="s0">)) {</span>
            <span class="s1">this</span><span class="s0">._toplevel.process_expression(</span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">toplevel = </span><span class="s1">this</span><span class="s0">._toplevel;</span>
        <span class="s1">this</span><span class="s0">._toplevel = undefined;</span>
        <span class="s1">return </span><span class="s0">toplevel;</span>
    <span class="s0">}</span>

    <span class="s0">before(node, descend) {</span>
        <span class="s1">if </span><span class="s0">(has_flag(node, SQUEEZED)) </span><span class="s1">return </span><span class="s0">node;</span>
        <span class="s1">var </span><span class="s0">was_scope = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
            <span class="s0">node = node.hoist_properties(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">node = node.hoist_declarations(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">was_scope = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// Before https://github.com/mishoo/UglifyJS2/pull/1602 AST_Node.optimize()</span>
        <span class="s3">// would call AST_Node.transform() if a different instance of AST_Node is</span>
        <span class="s3">// produced after def_optimize().</span>
        <span class="s3">// This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.</span>
        <span class="s3">// Migrate and defer all children's AST_Node.transform() to below, which</span>
        <span class="s3">// will now happen after this parent AST_Node has been properly substituted</span>
        <span class="s3">// thus gives a consistent AST snapshot.</span>
        <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
        <span class="s3">// Existing code relies on how AST_Node.optimize() worked, and omitting the</span>
        <span class="s3">// following replacement call would result in degraded efficiency of both</span>
        <span class="s3">// output and performance.</span>
        <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
        <span class="s1">var </span><span class="s0">opt = node.optimize(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(was_scope &amp;&amp; opt </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
            <span class="s0">opt.drop_unused(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">descend(opt, </span><span class="s1">this</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(opt === node) set_flag(opt, SQUEEZED);</span>
        <span class="s1">return </span><span class="s0">opt;</span>
    <span class="s0">}</span>

    <span class="s3">/** Alternative to plain is_lhs() which doesn't work within .optimize() */</span>
    <span class="s0">is_lhs() {</span>
        <span class="s0">const self = </span><span class="s1">this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length - </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s0">const parent = </span><span class="s1">this</span><span class="s0">.stack[</span><span class="s1">this</span><span class="s0">.stack.length - </span><span class="s4">2</span><span class="s0">];</span>
        <span class="s1">return </span><span class="s0">is_lhs(self, parent);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">def_optimize(node, optimizer) {</span>
    <span class="s0">node.DEFMETHOD(</span><span class="s2">&quot;optimize&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
        <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(has_flag(self, OPTIMIZED)) </span><span class="s1">return </span><span class="s0">self;</span>
        <span class="s1">if </span><span class="s0">(compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
        <span class="s1">var </span><span class="s0">opt = optimizer(self, compressor);</span>
        <span class="s0">set_flag(opt, OPTIMIZED);</span>
        <span class="s1">return </span><span class="s0">opt;</span>
    <span class="s0">});</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_Node, </span><span class="s1">function</span><span class="s0">(self) {</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;drop_console&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">return this</span><span class="s0">.transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(self) {</span>
        <span class="s1">if </span><span class="s0">(self.TYPE == </span><span class="s2">&quot;Call&quot;</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">exp = self.expression;</span>
            <span class="s1">if </span><span class="s0">(exp </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess) {</span>
                <span class="s1">var </span><span class="s0">name = exp.expression;</span>
                <span class="s1">while </span><span class="s0">(name.expression) {</span>
                    <span class="s0">name = name.expression;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(is_undeclared_ref(name) &amp;&amp; name.name == </span><span class="s2">&quot;console&quot;</span><span class="s0">) {</span>
                    <span class="s1">return </span><span class="s0">make_node(AST_Undefined, self);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}));</span>
<span class="s0">});</span>

<span class="s0">AST_Node.DEFMETHOD(</span><span class="s2">&quot;equivalent_to&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(node) {</span>
    <span class="s1">return </span><span class="s0">equivalent_to(</span><span class="s1">this</span><span class="s0">, node);</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;process_expression&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(insert, compressor) {</span>
    <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">tt = </span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(insert &amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Return, node, {</span>
                <span class="s0">value: node.body</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!insert &amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Return) {</span>
            <span class="s1">if </span><span class="s0">(compressor) {</span>
                <span class="s1">var </span><span class="s0">value = node.value &amp;&amp; node.value.drop_side_effect_free(compressor, </span><span class="s1">true</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">value</span>
                    <span class="s0">? make_node(AST_SimpleStatement, node, { body: value })</span>
                    <span class="s0">: make_node(AST_EmptyStatement, node);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, node, {</span>
                <span class="s0">body: node.value || make_node(AST_UnaryPrefix, node, {</span>
                    <span class="s0">operator: </span><span class="s2">&quot;void&quot;</span><span class="s0">,</span>
                    <span class="s0">expression: make_node(AST_Number, node, {</span>
                        <span class="s0">value: </span><span class="s4">0</span>
                    <span class="s0">})</span>
                <span class="s0">})</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Class || node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; node !== self) {</span>
            <span class="s1">return </span><span class="s0">node;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Block) {</span>
            <span class="s1">var </span><span class="s0">index = node.body.length - </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">node.body[index] = node.body[index].transform(tt);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
            <span class="s0">node.body = node.body.transform(tt);</span>
            <span class="s1">if </span><span class="s0">(node.alternative) {</span>
                <span class="s0">node.alternative = node.alternative.transform(tt);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_With) {</span>
            <span class="s0">node.body = node.body.transform(tt);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">node;</span>
    <span class="s0">});</span>
    <span class="s0">self.transform(tt);</span>
<span class="s0">});</span>

<span class="s0">AST_Toplevel.DEFMETHOD(</span><span class="s2">&quot;reset_opt_flags&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s0">const self = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">const reduce_vars = compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">);</span>

    <span class="s0">const preparation = </span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node, descend) {</span>
        <span class="s0">clear_flag(node, CLEAR_BETWEEN_PASSES);</span>
        <span class="s1">if </span><span class="s0">(reduce_vars) {</span>
            <span class="s1">if </span><span class="s0">(compressor.top_retain</span>
                <span class="s0">&amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Defun  </span><span class="s3">// Only functions are retained</span>
                <span class="s0">&amp;&amp; preparation.parent() === self</span>
            <span class="s0">) {</span>
                <span class="s0">set_flag(node, TOP);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">node.reduce_vars(preparation, descend, compressor);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s3">// Stack of look-up tables to keep track of whether a `SymbolDef` has been</span>
    <span class="s3">// properly assigned before use:</span>
    <span class="s3">// - `push()` &amp; `pop()` when visiting conditional branches</span>
    <span class="s0">preparation.safe_ids = Object.create(</span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">preparation.in_loop = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">preparation.loop_ids = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s0">preparation.defs_to_safe_ids = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s0">self.walk(preparation);</span>
<span class="s0">});</span>

<span class="s0">AST_Symbol.DEFMETHOD(</span><span class="s2">&quot;fixed_value&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s0">fixed = </span><span class="s1">this</span><span class="s0">.thedef.fixed;</span>
    <span class="s1">if </span><span class="s0">(!fixed || fixed </span><span class="s1">instanceof </span><span class="s0">AST_Node) </span><span class="s1">return </span><span class="s0">fixed;</span>
    <span class="s1">return </span><span class="s0">fixed();</span>
<span class="s0">});</span>

<span class="s0">AST_SymbolRef.DEFMETHOD(</span><span class="s2">&quot;is_immutable&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">var </span><span class="s0">orig = </span><span class="s1">this</span><span class="s0">.definition().orig;</span>
    <span class="s1">return </span><span class="s0">orig.length == </span><span class="s4">1 </span><span class="s0">&amp;&amp; orig[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLambda;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">find_variable(compressor, name) {</span>
    <span class="s1">var </span><span class="s0">scope, i = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">while </span><span class="s0">(scope = compressor.parent(i++)) {</span>
        <span class="s1">if </span><span class="s0">(scope </span><span class="s1">instanceof </span><span class="s0">AST_Scope) </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(scope </span><span class="s1">instanceof </span><span class="s0">AST_Catch &amp;&amp; scope.argname) {</span>
            <span class="s0">scope = scope.argname.definition().scope;</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">scope.find_variable(name);</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">global_names = makePredicate(</span><span class="s2">&quot;Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError&quot;</span><span class="s0">);</span>
<span class="s0">AST_SymbolRef.DEFMETHOD(</span><span class="s2">&quot;is_declared&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">return </span><span class="s0">!</span><span class="s1">this</span><span class="s0">.definition().undeclared</span>
        <span class="s0">|| compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">) &amp;&amp; global_names.has(</span><span class="s1">this</span><span class="s0">.name);</span>
<span class="s0">});</span>

<span class="s3">/* -----[ optimizers ]----- */</span>

<span class="s1">var </span><span class="s0">directives = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;use asm&quot;</span><span class="s0">, </span><span class="s2">&quot;use strict&quot;</span><span class="s0">]);</span>
<span class="s0">def_optimize(AST_Directive, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;directives&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; (!directives.has(self.value) || compressor.has_directive(self.value) !== self)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Debugger, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;drop_debugger&quot;</span><span class="s0">))</span>
        <span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, self);</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_LabeledStatement, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(self.body </span><span class="s1">instanceof </span><span class="s0">AST_Break</span>
        <span class="s0">&amp;&amp; compressor.loopcontrol_target(self.body) === self.body) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self.label.references.length == </span><span class="s4">0 </span><span class="s0">? self.body : self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Block, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s0">tighten_body(self.body, compressor);</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">can_be_extracted_from_if_block(node) {</span>
    <span class="s1">return </span><span class="s0">!(</span>
        <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Const</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Let</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Class</span>
    <span class="s0">);</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_BlockStatement, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s0">tighten_body(self.body, compressor);</span>
    <span class="s1">switch </span><span class="s0">(self.body.length) {</span>
      <span class="s1">case </span><span class="s4">1</span><span class="s0">:</span>
        <span class="s1">if </span><span class="s0">(!compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)</span>
            <span class="s0">&amp;&amp; compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_If</span>
            <span class="s0">&amp;&amp; can_be_extracted_from_if_block(self.body[</span><span class="s4">0</span><span class="s0">])</span>
            <span class="s0">|| can_be_evicted_from_block(self.body[</span><span class="s4">0</span><span class="s0">])) {</span>
            <span class="s1">return </span><span class="s0">self.body[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s1">case </span><span class="s4">0</span><span class="s0">: </span><span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">opt_AST_Lambda(self, compressor) {</span>
    <span class="s0">tighten_body(self.body, compressor);</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; self.body.length == </span><span class="s4">1</span>
        <span class="s0">&amp;&amp; self.body[</span><span class="s4">0</span><span class="s0">] === compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)) {</span>
        <span class="s0">self.body.length = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">}</span>
<span class="s0">def_optimize(AST_Lambda, opt_AST_Lambda);</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;hoist_declarations&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">var </span><span class="s0">hoist_funs = compressor.option(</span><span class="s2">&quot;hoist_funs&quot;</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">hoist_vars = compressor.option(</span><span class="s2">&quot;hoist_vars&quot;</span><span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(hoist_funs || hoist_vars) {</span>
        <span class="s1">var </span><span class="s0">dirs = [];</span>
        <span class="s1">var </span><span class="s0">hoisted = [];</span>
        <span class="s1">var </span><span class="s0">vars = </span><span class="s1">new </span><span class="s0">Map(), vars_found = </span><span class="s4">0</span><span class="s0">, var_decl = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s3">// let's count var_decl first, we seem to waste a lot of</span>
        <span class="s3">// space if we hoist `var` when there's only one.</span>
        <span class="s0">walk(self, node =&gt; {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope &amp;&amp; node !== self)</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Var) {</span>
                <span class="s0">++var_decl;</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s0">hoist_vars = hoist_vars &amp;&amp; var_decl &gt; </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">var </span><span class="s0">tt = </span><span class="s1">new </span><span class="s0">TreeTransformer(</span>
            <span class="s1">function </span><span class="s0">before(node) {</span>
                <span class="s1">if </span><span class="s0">(node !== self) {</span>
                    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Directive) {</span>
                        <span class="s0">dirs.push(node);</span>
                        <span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, node);</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(hoist_funs &amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Defun</span>
                        <span class="s0">&amp;&amp; !(tt.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Export)</span>
                        <span class="s0">&amp;&amp; tt.parent() === self) {</span>
                        <span class="s0">hoisted.push(node);</span>
                        <span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, node);</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(</span>
                        <span class="s0">hoist_vars</span>
                        <span class="s0">&amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Var</span>
                        <span class="s0">&amp;&amp; !node.definitions.some(def =&gt; def.name </span><span class="s1">instanceof </span><span class="s0">AST_Destructuring)</span>
                    <span class="s0">) {</span>
                        <span class="s0">node.definitions.forEach(</span><span class="s1">function</span><span class="s0">(def) {</span>
                            <span class="s0">vars.set(def.name.name, def);</span>
                            <span class="s0">++vars_found;</span>
                        <span class="s0">});</span>
                        <span class="s1">var </span><span class="s0">seq = node.to_assignments(compressor);</span>
                        <span class="s1">var </span><span class="s0">p = tt.parent();</span>
                        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_ForIn &amp;&amp; p.init === node) {</span>
                            <span class="s1">if </span><span class="s0">(seq == </span><span class="s1">null</span><span class="s0">) {</span>
                                <span class="s1">var </span><span class="s0">def = node.definitions[</span><span class="s4">0</span><span class="s0">].name;</span>
                                <span class="s1">return </span><span class="s0">make_node(AST_SymbolRef, def, def);</span>
                            <span class="s0">}</span>
                            <span class="s1">return </span><span class="s0">seq;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_For &amp;&amp; p.init === node) {</span>
                            <span class="s1">return </span><span class="s0">seq;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(!seq) </span><span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, node);</span>
                        <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, node, {</span>
                            <span class="s0">body: seq</span>
                        <span class="s0">});</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope)</span>
                        <span class="s1">return </span><span class="s0">node; </span><span class="s3">// to avoid descending in nested scopes</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">);</span>
        <span class="s0">self = self.transform(tt);</span>
        <span class="s1">if </span><span class="s0">(vars_found &gt; </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s3">// collect only vars which don't show up in self's arguments list</span>
            <span class="s1">var </span><span class="s0">defs = [];</span>
            <span class="s0">const is_lambda = self </span><span class="s1">instanceof </span><span class="s0">AST_Lambda;</span>
            <span class="s0">const args_as_names = is_lambda ? self.args_as_names() : </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">vars.forEach((def, name) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(is_lambda &amp;&amp; args_as_names.some((x) =&gt; x.name === def.name.name)) {</span>
                    <span class="s0">vars.</span><span class="s1">delete</span><span class="s0">(name);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">def = def.clone();</span>
                    <span class="s0">def.value = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">defs.push(def);</span>
                    <span class="s0">vars.set(name, def);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(defs.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s3">// try to merge in assignments</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; self.body.length;) {</span>
                    <span class="s1">if </span><span class="s0">(self.body[i] </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
                        <span class="s1">var </span><span class="s0">expr = self.body[i].body, sym, assign;</span>
                        <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
                            <span class="s0">&amp;&amp; expr.operator == </span><span class="s2">&quot;=&quot;</span>
                            <span class="s0">&amp;&amp; (sym = expr.left) </span><span class="s1">instanceof </span><span class="s0">AST_Symbol</span>
                            <span class="s0">&amp;&amp; vars.has(sym.name)</span>
                        <span class="s0">) {</span>
                            <span class="s1">var </span><span class="s0">def = vars.get(sym.name);</span>
                            <span class="s1">if </span><span class="s0">(def.value) </span><span class="s1">break</span><span class="s0">;</span>
                            <span class="s0">def.value = expr.right;</span>
                            <span class="s0">remove(defs, def);</span>
                            <span class="s0">defs.push(def);</span>
                            <span class="s0">self.body.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
                            <span class="s1">continue</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Sequence</span>
                            <span class="s0">&amp;&amp; (assign = expr.expressions[</span><span class="s4">0</span><span class="s0">]) </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
                            <span class="s0">&amp;&amp; assign.operator == </span><span class="s2">&quot;=&quot;</span>
                            <span class="s0">&amp;&amp; (sym = assign.left) </span><span class="s1">instanceof </span><span class="s0">AST_Symbol</span>
                            <span class="s0">&amp;&amp; vars.has(sym.name)</span>
                        <span class="s0">) {</span>
                            <span class="s1">var </span><span class="s0">def = vars.get(sym.name);</span>
                            <span class="s1">if </span><span class="s0">(def.value) </span><span class="s1">break</span><span class="s0">;</span>
                            <span class="s0">def.value = assign.right;</span>
                            <span class="s0">remove(defs, def);</span>
                            <span class="s0">defs.push(def);</span>
                            <span class="s0">self.body[i].body = make_sequence(expr, expr.expressions.slice(</span><span class="s4">1</span><span class="s0">));</span>
                            <span class="s1">continue</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(self.body[i] </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement) {</span>
                        <span class="s0">self.body.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(self.body[i] </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement) {</span>
                        <span class="s0">self.body.splice(i, </span><span class="s4">1</span><span class="s0">, ...self.body[i].body);</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">defs = make_node(AST_Var, self, {</span>
                    <span class="s0">definitions: defs</span>
                <span class="s0">});</span>
                <span class="s0">hoisted.push(defs);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">self.body = dirs.concat(hoisted, self.body);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">AST_Scope.DEFMETHOD(</span><span class="s2">&quot;hoist_properties&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">var </span><span class="s0">self = </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;hoist_props&quot;</span><span class="s0">) || compressor.has_directive(</span><span class="s2">&quot;use asm&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">var </span><span class="s0">top_retain = self </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel &amp;&amp; compressor.top_retain || return_false;</span>
    <span class="s1">var </span><span class="s0">defs_by_id = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">var </span><span class="s0">hoister = </span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node, descend) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_VarDef) {</span>
            <span class="s0">const sym = node.name;</span>
            <span class="s0">let def;</span>
            <span class="s0">let value;</span>
            <span class="s1">if </span><span class="s0">(sym.scope === self</span>
                <span class="s0">&amp;&amp; (def = sym.definition()).escaped != </span><span class="s4">1</span>
                <span class="s0">&amp;&amp; !def.assignments</span>
                <span class="s0">&amp;&amp; !def.direct_access</span>
                <span class="s0">&amp;&amp; !def.single_use</span>
                <span class="s0">&amp;&amp; !compressor.exposed(def)</span>
                <span class="s0">&amp;&amp; !top_retain(def)</span>
                <span class="s0">&amp;&amp; (value = sym.fixed_value()) === node.value</span>
                <span class="s0">&amp;&amp; value </span><span class="s1">instanceof </span><span class="s0">AST_Object</span>
                <span class="s0">&amp;&amp; !value.properties.some(prop =&gt;</span>
                    <span class="s0">prop </span><span class="s1">instanceof </span><span class="s0">AST_Expansion || prop.computed_key()</span>
                <span class="s0">)</span>
            <span class="s0">) {</span>
                <span class="s0">descend(node, </span><span class="s1">this</span><span class="s0">);</span>
                <span class="s0">const defs = </span><span class="s1">new </span><span class="s0">Map();</span>
                <span class="s0">const assignments = [];</span>
                <span class="s0">value.properties.forEach(({ key, value }) =&gt; {</span>
                    <span class="s0">const scope = hoister.find_scope();</span>
                    <span class="s0">const symbol = self.create_symbol(sym.CTOR, {</span>
                        <span class="s0">source: sym,</span>
                        <span class="s0">scope,</span>
                        <span class="s0">conflict_scopes: </span><span class="s1">new </span><span class="s0">Set([</span>
                            <span class="s0">scope,</span>
                            <span class="s0">...sym.definition().references.map(ref =&gt; ref.scope)</span>
                        <span class="s0">]),</span>
                        <span class="s0">tentative_name: sym.name + </span><span class="s2">&quot;_&quot; </span><span class="s0">+ key</span>
                    <span class="s0">});</span>

                    <span class="s0">defs.set(String(key), symbol.definition());</span>

                    <span class="s0">assignments.push(make_node(AST_VarDef, node, {</span>
                        <span class="s0">name: symbol,</span>
                        <span class="s0">value</span>
                    <span class="s0">}));</span>
                <span class="s0">});</span>
                <span class="s0">defs_by_id.set(def.id, defs);</span>
                <span class="s1">return </span><span class="s0">MAP.splice(assignments);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
            <span class="s0">&amp;&amp; node.expression </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">) {</span>
            <span class="s0">const defs = defs_by_id.get(node.expression.definition().id);</span>
            <span class="s1">if </span><span class="s0">(defs) {</span>
                <span class="s0">const def = defs.get(String(get_simple_key(node.property)));</span>
                <span class="s0">const sym = make_node(AST_SymbolRef, node, {</span>
                    <span class="s0">name: def.name,</span>
                    <span class="s0">scope: node.expression.scope,</span>
                    <span class="s0">thedef: def</span>
                <span class="s0">});</span>
                <span class="s0">sym.reference({});</span>
                <span class="s1">return </span><span class="s0">sym;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">self.transform(hoister);</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_SimpleStatement, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">body = self.body;</span>
        <span class="s1">var </span><span class="s0">node = body.drop_side_effect_free(compressor, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(!node) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, self);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(node !== body) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, self, { body: node });</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_While, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">return </span><span class="s0">compressor.option(</span><span class="s2">&quot;loops&quot;</span><span class="s0">) ? make_node(AST_For, self, self).optimize(compressor) : self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Do, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;loops&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">var </span><span class="s0">cond = self.condition.tail_node().evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(!(cond </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
        <span class="s1">if </span><span class="s0">(cond) </span><span class="s1">return </span><span class="s0">make_node(AST_For, self, {</span>
            <span class="s0">body: make_node(AST_BlockStatement, self.body, {</span>
                <span class="s0">body: [</span>
                    <span class="s0">self.body,</span>
                    <span class="s0">make_node(AST_SimpleStatement, self.condition, {</span>
                        <span class="s0">body: self.condition</span>
                    <span class="s0">})</span>
                <span class="s0">]</span>
            <span class="s0">})</span>
        <span class="s0">}).optimize(compressor);</span>
        <span class="s1">if </span><span class="s0">(!has_break_or_continue(self, compressor.parent())) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self.body, {</span>
                <span class="s0">body: [</span>
                    <span class="s0">self.body,</span>
                    <span class="s0">make_node(AST_SimpleStatement, self.condition, {</span>
                        <span class="s0">body: self.condition</span>
                    <span class="s0">})</span>
                <span class="s0">]</span>
            <span class="s0">}).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">if_break_in_loop(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">first = self.body </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement ? self.body.body[</span><span class="s4">0</span><span class="s0">] : self.body;</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">) &amp;&amp; is_break(first)) {</span>
        <span class="s1">var </span><span class="s0">body = [];</span>
        <span class="s1">if </span><span class="s0">(self.init </span><span class="s1">instanceof </span><span class="s0">AST_Statement) {</span>
            <span class="s0">body.push(self.init);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.init) {</span>
            <span class="s0">body.push(make_node(AST_SimpleStatement, self.init, {</span>
                <span class="s0">body: self.init</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.condition) {</span>
            <span class="s0">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                <span class="s0">body: self.condition</span>
            <span class="s0">}));</span>
        <span class="s0">}</span>
        <span class="s0">trim_unreachable_code(compressor, self.body, body);</span>
        <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
            <span class="s0">body: body</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(first </span><span class="s1">instanceof </span><span class="s0">AST_If) {</span>
        <span class="s1">if </span><span class="s0">(is_break(first.body)) {</span>
            <span class="s1">if </span><span class="s0">(self.condition) {</span>
                <span class="s0">self.condition = make_node(AST_Binary, self.condition, {</span>
                    <span class="s0">left: self.condition,</span>
                    <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
                    <span class="s0">right: first.condition.negate(compressor),</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">self.condition = first.condition.negate(compressor);</span>
            <span class="s0">}</span>
            <span class="s0">drop_it(first.alternative);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_break(first.alternative)) {</span>
            <span class="s1">if </span><span class="s0">(self.condition) {</span>
                <span class="s0">self.condition = make_node(AST_Binary, self.condition, {</span>
                    <span class="s0">left: self.condition,</span>
                    <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
                    <span class="s0">right: first.condition,</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">self.condition = first.condition;</span>
            <span class="s0">}</span>
            <span class="s0">drop_it(first.body);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">function </span><span class="s0">is_break(node) {</span>
        <span class="s1">return </span><span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Break</span>
            <span class="s0">&amp;&amp; compressor.loopcontrol_target(node) === compressor.self();</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">drop_it(rest) {</span>
        <span class="s0">rest = as_statement_array(rest);</span>
        <span class="s1">if </span><span class="s0">(self.body </span><span class="s1">instanceof </span><span class="s0">AST_BlockStatement) {</span>
            <span class="s0">self.body = self.body.clone();</span>
            <span class="s0">self.body.body = rest.concat(self.body.body.slice(</span><span class="s4">1</span><span class="s0">));</span>
            <span class="s0">self.body = self.body.transform(compressor);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">self.body = make_node(AST_BlockStatement, self.body, {</span>
                <span class="s0">body: rest</span>
            <span class="s0">}).transform(compressor);</span>
        <span class="s0">}</span>
        <span class="s0">self = if_break_in_loop(self, compressor);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_For, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;loops&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s0">) &amp;&amp; self.init) {</span>
        <span class="s0">self.init = self.init.drop_side_effect_free(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.condition) {</span>
        <span class="s1">var </span><span class="s0">cond = self.condition.evaluate(compressor);</span>
        <span class="s1">if </span><span class="s0">(!(cond </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
            <span class="s1">if </span><span class="s0">(cond) self.condition = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">else if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">)) {</span>
                <span class="s1">var </span><span class="s0">orig = self.condition;</span>
                <span class="s0">self.condition = make_node_from_constant(cond, self.condition);</span>
                <span class="s0">self.condition = best_of_expression(self.condition.transform(compressor), orig);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">)) {</span>
            <span class="s1">if </span><span class="s0">(cond </span><span class="s1">instanceof </span><span class="s0">AST_Node) cond = self.condition.tail_node().evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(!cond) {</span>
                <span class="s1">var </span><span class="s0">body = [];</span>
                <span class="s0">trim_unreachable_code(compressor, self.body, body);</span>
                <span class="s1">if </span><span class="s0">(self.init </span><span class="s1">instanceof </span><span class="s0">AST_Statement) {</span>
                    <span class="s0">body.push(self.init);</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.init) {</span>
                    <span class="s0">body.push(make_node(AST_SimpleStatement, self.init, {</span>
                        <span class="s0">body: self.init</span>
                    <span class="s0">}));</span>
                <span class="s0">}</span>
                <span class="s0">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                    <span class="s0">body: self.condition</span>
                <span class="s0">}));</span>
                <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">if_break_in_loop(self, compressor);</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_If, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(is_empty(self.alternative)) self.alternative = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;conditionals&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s3">// if condition can be statically determined, drop</span>
    <span class="s3">// one of the blocks.  note, statically determined implies</span>
    <span class="s3">// “has no side effects”; also it doesn't work for cases like</span>
    <span class="s3">// `x &amp;&amp; true`, though it probably should.</span>
    <span class="s1">var </span><span class="s0">cond = self.condition.evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">) &amp;&amp; !(cond </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
        <span class="s1">var </span><span class="s0">orig = self.condition;</span>
        <span class="s0">self.condition = make_node_from_constant(cond, orig);</span>
        <span class="s0">self.condition = best_of_expression(self.condition.transform(compressor), orig);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">)) {</span>
        <span class="s1">if </span><span class="s0">(cond </span><span class="s1">instanceof </span><span class="s0">AST_Node) cond = self.condition.tail_node().evaluate(compressor);</span>
        <span class="s1">if </span><span class="s0">(!cond) {</span>
            <span class="s1">var </span><span class="s0">body = [];</span>
            <span class="s0">trim_unreachable_code(compressor, self.body, body);</span>
            <span class="s0">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                <span class="s0">body: self.condition</span>
            <span class="s0">}));</span>
            <span class="s1">if </span><span class="s0">(self.alternative) body.push(self.alternative);</span>
            <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(cond </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
            <span class="s1">var </span><span class="s0">body = [];</span>
            <span class="s0">body.push(make_node(AST_SimpleStatement, self.condition, {</span>
                <span class="s0">body: self.condition</span>
            <span class="s0">}));</span>
            <span class="s0">body.push(self.body);</span>
            <span class="s1">if </span><span class="s0">(self.alternative) {</span>
                <span class="s0">trim_unreachable_code(compressor, self.alternative, body);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">negated = self.condition.negate(compressor);</span>
    <span class="s1">var </span><span class="s0">self_condition_length = self.condition.size();</span>
    <span class="s1">var </span><span class="s0">negated_length = negated.size();</span>
    <span class="s1">var </span><span class="s0">negated_is_best = negated_length &lt; self_condition_length;</span>
    <span class="s1">if </span><span class="s0">(self.alternative &amp;&amp; negated_is_best) {</span>
        <span class="s0">negated_is_best = </span><span class="s1">false</span><span class="s0">; </span><span class="s3">// because we already do the switch here.</span>
        <span class="s3">// no need to swap values of self_condition_length and negated_length</span>
        <span class="s3">// here because they are only used in an equality comparison later on.</span>
        <span class="s0">self.condition = negated;</span>
        <span class="s1">var </span><span class="s0">tmp = self.body;</span>
        <span class="s0">self.body = self.alternative || make_node(AST_EmptyStatement, self);</span>
        <span class="s0">self.alternative = tmp;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(is_empty(self.body) &amp;&amp; is_empty(self.alternative)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, self.condition, {</span>
            <span class="s0">body: self.condition.clone()</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.body </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement</span>
        <span class="s0">&amp;&amp; self.alternative </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, self, {</span>
            <span class="s0">body: make_node(AST_Conditional, self, {</span>
                <span class="s0">condition   : self.condition,</span>
                <span class="s0">consequent  : self.body.body,</span>
                <span class="s0">alternative : self.alternative.body</span>
            <span class="s0">})</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(is_empty(self.alternative) &amp;&amp; self.body </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
        <span class="s1">if </span><span class="s0">(self_condition_length === negated_length &amp;&amp; !negated_is_best</span>
            <span class="s0">&amp;&amp; self.condition </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; self.condition.operator == </span><span class="s2">&quot;||&quot;</span><span class="s0">) {</span>
            <span class="s3">// although the code length of self.condition and negated are the same,</span>
            <span class="s3">// negated does not require additional surrounding parentheses.</span>
            <span class="s3">// see https://github.com/mishoo/UglifyJS2/issues/979</span>
            <span class="s0">negated_is_best = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(negated_is_best) </span><span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, self, {</span>
            <span class="s0">body: make_node(AST_Binary, self, {</span>
                <span class="s0">operator : </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
                <span class="s0">left     : negated,</span>
                <span class="s0">right    : self.body.body</span>
            <span class="s0">})</span>
        <span class="s0">}).optimize(compressor);</span>
        <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, self, {</span>
            <span class="s0">body: make_node(AST_Binary, self, {</span>
                <span class="s0">operator : </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
                <span class="s0">left     : self.condition,</span>
                <span class="s0">right    : self.body.body</span>
            <span class="s0">})</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.body </span><span class="s1">instanceof </span><span class="s0">AST_EmptyStatement</span>
        <span class="s0">&amp;&amp; self.alternative </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, self, {</span>
            <span class="s0">body: make_node(AST_Binary, self, {</span>
                <span class="s0">operator : </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
                <span class="s0">left     : self.condition,</span>
                <span class="s0">right    : self.alternative.body</span>
            <span class="s0">})</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.body </span><span class="s1">instanceof </span><span class="s0">AST_Exit</span>
        <span class="s0">&amp;&amp; self.alternative </span><span class="s1">instanceof </span><span class="s0">AST_Exit</span>
        <span class="s0">&amp;&amp; self.body.TYPE == self.alternative.TYPE) {</span>
        <span class="s1">return </span><span class="s0">make_node(self.body.CTOR, self, {</span>
            <span class="s0">value: make_node(AST_Conditional, self, {</span>
                <span class="s0">condition   : self.condition,</span>
                <span class="s0">consequent  : self.body.value || make_node(AST_Undefined, self.body),</span>
                <span class="s0">alternative : self.alternative.value || make_node(AST_Undefined, self.alternative)</span>
            <span class="s0">}).transform(compressor)</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.body </span><span class="s1">instanceof </span><span class="s0">AST_If</span>
        <span class="s0">&amp;&amp; !self.body.alternative</span>
        <span class="s0">&amp;&amp; !self.alternative) {</span>
        <span class="s0">self = make_node(AST_If, self, {</span>
            <span class="s0">condition: make_node(AST_Binary, self.condition, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
                <span class="s0">left: self.condition,</span>
                <span class="s0">right: self.body.condition</span>
            <span class="s0">}),</span>
            <span class="s0">body: self.body.body,</span>
            <span class="s0">alternative: </span><span class="s1">null</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(aborts(self.body)) {</span>
        <span class="s1">if </span><span class="s0">(self.alternative) {</span>
            <span class="s1">var </span><span class="s0">alt = self.alternative;</span>
            <span class="s0">self.alternative = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
                <span class="s0">body: [ self, alt ]</span>
            <span class="s0">}).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(aborts(self.alternative)) {</span>
        <span class="s1">var </span><span class="s0">body = self.body;</span>
        <span class="s0">self.body = self.alternative;</span>
        <span class="s0">self.condition = negated_is_best ? negated : self.condition.negate(compressor);</span>
        <span class="s0">self.alternative = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
            <span class="s0">body: [ self, body ]</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Switch, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;switches&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">var </span><span class="s0">branch;</span>
    <span class="s1">var </span><span class="s0">value = self.expression.evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(!(value </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
        <span class="s1">var </span><span class="s0">orig = self.expression;</span>
        <span class="s0">self.expression = make_node_from_constant(value, orig);</span>
        <span class="s0">self.expression = best_of_expression(self.expression.transform(compressor), orig);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
        <span class="s0">value = self.expression.tail_node().evaluate(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">decl = [];</span>
    <span class="s1">var </span><span class="s0">body = [];</span>
    <span class="s1">var </span><span class="s0">default_branch;</span>
    <span class="s1">var </span><span class="s0">exact_match;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = self.body.length; i &lt; len &amp;&amp; !exact_match; i++) {</span>
        <span class="s0">branch = self.body[i];</span>
        <span class="s1">if </span><span class="s0">(branch </span><span class="s1">instanceof </span><span class="s0">AST_Default) {</span>
            <span class="s1">if </span><span class="s0">(!default_branch) {</span>
                <span class="s0">default_branch = branch;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">eliminate_branch(branch, body[body.length - </span><span class="s4">1</span><span class="s0">]);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(value </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
            <span class="s1">var </span><span class="s0">exp = branch.expression.evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(!(exp </span><span class="s1">instanceof </span><span class="s0">AST_Node) &amp;&amp; exp !== value) {</span>
                <span class="s0">eliminate_branch(branch, body[body.length - </span><span class="s4">1</span><span class="s0">]);</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(exp </span><span class="s1">instanceof </span><span class="s0">AST_Node) exp = branch.expression.tail_node().evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(exp === value) {</span>
                <span class="s0">exact_match = branch;</span>
                <span class="s1">if </span><span class="s0">(default_branch) {</span>
                    <span class="s1">var </span><span class="s0">default_index = body.indexOf(default_branch);</span>
                    <span class="s0">body.splice(default_index, </span><span class="s4">1</span><span class="s0">);</span>
                    <span class="s0">eliminate_branch(default_branch, body[default_index - </span><span class="s4">1</span><span class="s0">]);</span>
                    <span class="s0">default_branch = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">body.push(branch);</span>
    <span class="s0">}</span>
    <span class="s1">while </span><span class="s0">(i &lt; len) eliminate_branch(self.body[i++], body[body.length - </span><span class="s4">1</span><span class="s0">]);</span>
    <span class="s0">self.body = body;</span>

    <span class="s0">let default_or_exact = default_branch || exact_match;</span>
    <span class="s0">default_branch = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">exact_match = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s3">// group equivalent branches so they will be located next to each other,</span>
    <span class="s3">// that way the next micro-optimization will merge them.</span>
    <span class="s3">// ** bail micro-optimization if not a simple switch case with breaks</span>
    <span class="s1">if </span><span class="s0">(body.every((branch, i) =&gt;</span>
        <span class="s0">(branch === default_or_exact || branch.expression </span><span class="s1">instanceof </span><span class="s0">AST_Constant)</span>
        <span class="s0">&amp;&amp; (branch.body.length === </span><span class="s4">0 </span><span class="s0">|| aborts(branch) || body.length - </span><span class="s4">1 </span><span class="s0">=== i))</span>
    <span class="s0">) {</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; body.length; i++) {</span>
            <span class="s0">const branch = body[i];</span>
            <span class="s1">for </span><span class="s0">(let j = i + </span><span class="s4">1</span><span class="s0">; j &lt; body.length; j++) {</span>
                <span class="s0">const next = body[j];</span>
                <span class="s1">if </span><span class="s0">(next.body.length === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">const last_branch = j === (body.length - </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">const equivalentBranch = branches_equivalent(next, branch, </span><span class="s1">false</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(equivalentBranch || (last_branch &amp;&amp; branches_equivalent(next, branch, </span><span class="s1">true</span><span class="s0">))) {</span>
                    <span class="s1">if </span><span class="s0">(!equivalentBranch &amp;&amp; last_branch) {</span>
                        <span class="s0">next.body.push(make_node(AST_Break));</span>
                    <span class="s0">}</span>

                    <span class="s3">// let's find previous siblings with inert fallthrough...</span>
                    <span class="s0">let x = j - </span><span class="s4">1</span><span class="s0">;</span>
                    <span class="s0">let fallthroughDepth = </span><span class="s4">0</span><span class="s0">;</span>
                    <span class="s1">while </span><span class="s0">(x &gt; i) {</span>
                        <span class="s1">if </span><span class="s0">(is_inert_body(body[x--])) {</span>
                            <span class="s0">fallthroughDepth++;</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s1">break</span><span class="s0">;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>

                    <span class="s0">const plucked = body.splice(j - fallthroughDepth, </span><span class="s4">1 </span><span class="s0">+ fallthroughDepth);</span>
                    <span class="s0">body.splice(i + </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, ...plucked);</span>
                    <span class="s0">i += plucked.length;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">// merge equivalent branches in a row</span>
    <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; body.length; i++) {</span>
        <span class="s0">let branch = body[i];</span>
        <span class="s1">if </span><span class="s0">(branch.body.length === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!aborts(branch)) </span><span class="s1">continue</span><span class="s0">;</span>

        <span class="s1">for </span><span class="s0">(let j = i + </span><span class="s4">1</span><span class="s0">; j &lt; body.length; i++, j++) {</span>
            <span class="s0">let next = body[j];</span>
            <span class="s1">if </span><span class="s0">(next.body.length === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">branches_equivalent(next, branch, </span><span class="s1">false</span><span class="s0">)</span>
                <span class="s0">|| (j === body.length - </span><span class="s4">1 </span><span class="s0">&amp;&amp; branches_equivalent(next, branch, </span><span class="s1">true</span><span class="s0">))</span>
            <span class="s0">) {</span>
                <span class="s0">branch.body = [];</span>
                <span class="s0">branch = next;</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">// Prune any empty branches at the end of the switch statement.</span>
    <span class="s0">{</span>
        <span class="s0">let i = body.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(; i &gt;= </span><span class="s4">0</span><span class="s0">; i--) {</span>
            <span class="s0">let bbody = body[i].body;</span>
            <span class="s1">if </span><span class="s0">(is_break(bbody[bbody.length - </span><span class="s4">1</span><span class="s0">], compressor)) bbody.pop();</span>
            <span class="s1">if </span><span class="s0">(!is_inert_body(body[i])) </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// i now points to the index of a branch that contains a body. By incrementing, it's</span>
        <span class="s3">// pointing to the first branch that's empty.</span>
        <span class="s0">i++;</span>
        <span class="s1">if </span><span class="s0">(!default_or_exact || body.indexOf(default_or_exact) &gt;= i) {</span>
            <span class="s3">// The default behavior is to do nothing. We can take advantage of that to</span>
            <span class="s3">// remove all case expressions that are side-effect free that also do</span>
            <span class="s3">// nothing, since they'll default to doing nothing. But we can't remove any</span>
            <span class="s3">// case expressions before one that would side-effect, since they may cause</span>
            <span class="s3">// the side-effect to be skipped.</span>
            <span class="s1">for </span><span class="s0">(let j = body.length - </span><span class="s4">1</span><span class="s0">; j &gt;= i; j--) {</span>
                <span class="s0">let branch = body[j];</span>
                <span class="s1">if </span><span class="s0">(branch === default_or_exact) {</span>
                    <span class="s0">default_or_exact = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">body.pop();</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!branch.expression.has_side_effects(compressor)) {</span>
                    <span class="s0">body.pop();</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>


    <span class="s3">// Prune side-effect free branches that fall into default.</span>
    <span class="s0">DEFAULT: </span><span class="s1">if </span><span class="s0">(default_or_exact) {</span>
        <span class="s0">let default_index = body.indexOf(default_or_exact);</span>
        <span class="s0">let default_body_index = default_index;</span>
        <span class="s1">for </span><span class="s0">(; default_body_index &lt; body.length - </span><span class="s4">1</span><span class="s0">; default_body_index++) {</span>
            <span class="s1">if </span><span class="s0">(!is_inert_body(body[default_body_index])) </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(default_body_index &lt; body.length - </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">break </span><span class="s0">DEFAULT;</span>
        <span class="s0">}</span>

        <span class="s0">let side_effect_index = body.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(; side_effect_index &gt;= </span><span class="s4">0</span><span class="s0">; side_effect_index--) {</span>
            <span class="s0">let branch = body[side_effect_index];</span>
            <span class="s1">if </span><span class="s0">(branch === default_or_exact) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(branch.expression.has_side_effects(compressor)) </span><span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// If the default behavior comes after any side-effect case expressions,</span>
        <span class="s3">// then we can fold all side-effect free cases into the default branch.</span>
        <span class="s3">// If the side-effect case is after the default, then any side-effect</span>
        <span class="s3">// free cases could prevent the side-effect from occurring.</span>
        <span class="s1">if </span><span class="s0">(default_body_index &gt; side_effect_index) {</span>
            <span class="s0">let prev_body_index = default_index - </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(; prev_body_index &gt;= </span><span class="s4">0</span><span class="s0">; prev_body_index--) {</span>
                <span class="s1">if </span><span class="s0">(!is_inert_body(body[prev_body_index])) </span><span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">let before = Math.max(side_effect_index, prev_body_index) + </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">let after = default_index;</span>
            <span class="s1">if </span><span class="s0">(side_effect_index &gt; default_index) {</span>
                <span class="s3">// If the default falls into the same body as a side-effect</span>
                <span class="s3">// case, then we need preserve that case and only prune the</span>
                <span class="s3">// cases after it.</span>
                <span class="s0">after = side_effect_index;</span>
                <span class="s0">body[side_effect_index].body = body[default_body_index].body;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// The default will be the last branch.</span>
                <span class="s0">default_or_exact.body = body[default_body_index].body;</span>
            <span class="s0">}</span>

            <span class="s3">// Prune everything after the default (or last side-effect case)</span>
            <span class="s3">// until the next case with a body.</span>
            <span class="s0">body.splice(after + </span><span class="s4">1</span><span class="s0">, default_body_index - after);</span>
            <span class="s3">// Prune everything before the default that falls into it.</span>
            <span class="s0">body.splice(before, default_index - before);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">// See if we can remove the switch entirely if all cases (the default) fall into the same case body.</span>
    <span class="s0">DEFAULT: </span><span class="s1">if </span><span class="s0">(default_or_exact) {</span>
        <span class="s0">let i = body.findIndex(branch =&gt; !is_inert_body(branch));</span>
        <span class="s0">let caseBody;</span>
        <span class="s3">// `i` is equal to one of the following:</span>
        <span class="s3">// - `-1`, there is no body in the switch statement.</span>
        <span class="s3">// - `body.length - 1`, all cases fall into the same body.</span>
        <span class="s3">// - anything else, there are multiple bodies in the switch.</span>
        <span class="s1">if </span><span class="s0">(i === body.length - </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s3">// All cases fall into the case body.</span>
            <span class="s0">let branch = body[i];</span>
            <span class="s1">if </span><span class="s0">(has_nested_break(self)) </span><span class="s1">break </span><span class="s0">DEFAULT;</span>

            <span class="s3">// This is the last case body, and we've already pruned any breaks, so it's</span>
            <span class="s3">// safe to hoist.</span>
            <span class="s0">caseBody = make_node(AST_BlockStatement, branch, {</span>
                <span class="s0">body: branch.body</span>
            <span class="s0">});</span>
            <span class="s0">branch.body = [];</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(i !== -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s3">// If there are multiple bodies, then we cannot optimize anything.</span>
            <span class="s1">break </span><span class="s0">DEFAULT;</span>
        <span class="s0">}</span>

        <span class="s0">let sideEffect = body.find(branch =&gt; {</span>
            <span class="s1">return </span><span class="s0">(</span>
                <span class="s0">branch !== default_or_exact</span>
                <span class="s0">&amp;&amp; branch.expression.has_side_effects(compressor)</span>
            <span class="s0">);</span>
        <span class="s0">});</span>
        <span class="s3">// If no cases cause a side-effect, we can eliminate the switch entirely.</span>
        <span class="s1">if </span><span class="s0">(!sideEffect) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
                <span class="s0">body: decl.concat(</span>
                    <span class="s0">statement(self.expression),</span>
                    <span class="s0">default_or_exact.expression ? statement(default_or_exact.expression) : [],</span>
                    <span class="s0">caseBody || []</span>
                <span class="s0">)</span>
            <span class="s0">}).optimize(compressor);</span>
        <span class="s0">}</span>

        <span class="s3">// If we're this far, either there was no body or all cases fell into the same body.</span>
        <span class="s3">// If there was no body, then we don't need a default branch (because the default is</span>
        <span class="s3">// do nothing). If there was a body, we'll extract it to after the switch, so the</span>
        <span class="s3">// switch's new default is to do nothing and we can still prune it.</span>
        <span class="s0">const default_index = body.indexOf(default_or_exact);</span>
        <span class="s0">body.splice(default_index, </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">default_or_exact = </span><span class="s1">null</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(caseBody) {</span>
            <span class="s3">// Recurse into switch statement one more time so that we can append the case body</span>
            <span class="s3">// outside of the switch. This recursion will only happen once since we've pruned</span>
            <span class="s3">// the default case.</span>
            <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
                <span class="s0">body: decl.concat(self, caseBody)</span>
            <span class="s0">}).optimize(compressor);</span>
        <span class="s0">}</span>
        <span class="s3">// If we fall here, there is a default branch somewhere, there are no case bodies,</span>
        <span class="s3">// and there's a side-effect somewhere. Just let the below paths take care of it.</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(body.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">body[</span><span class="s4">0</span><span class="s0">].body = decl.concat(body[</span><span class="s4">0</span><span class="s0">].body);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(body.length == </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
            <span class="s0">body: decl.concat(statement(self.expression))</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(body.length == </span><span class="s4">1 </span><span class="s0">&amp;&amp; !has_nested_break(self)) {</span>
        <span class="s3">// This is the last case body, and we've already pruned any breaks, so it's</span>
        <span class="s3">// safe to hoist.</span>
        <span class="s0">let branch = body[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">return </span><span class="s0">make_node(AST_If, self, {</span>
            <span class="s0">condition: make_node(AST_Binary, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;===&quot;</span><span class="s0">,</span>
                <span class="s0">left: self.expression,</span>
                <span class="s0">right: branch.expression,</span>
            <span class="s0">}),</span>
            <span class="s0">body: make_node(AST_BlockStatement, branch, {</span>
                <span class="s0">body: branch.body</span>
            <span class="s0">}),</span>
            <span class="s0">alternative: </span><span class="s1">null</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(body.length === </span><span class="s4">2 </span><span class="s0">&amp;&amp; default_or_exact &amp;&amp; !has_nested_break(self)) {</span>
        <span class="s0">let branch = body[</span><span class="s4">0</span><span class="s0">] === default_or_exact ? body[</span><span class="s4">1</span><span class="s0">] : body[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s0">let exact_exp = default_or_exact.expression &amp;&amp; statement(default_or_exact.expression);</span>
        <span class="s1">if </span><span class="s0">(aborts(body[</span><span class="s4">0</span><span class="s0">])) {</span>
            <span class="s3">// Only the first branch body could have a break (at the last statement)</span>
            <span class="s0">let first = body[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(is_break(first.body[first.body.length - </span><span class="s4">1</span><span class="s0">], compressor)) {</span>
                <span class="s0">first.body.pop();</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">make_node(AST_If, self, {</span>
                <span class="s0">condition: make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: </span><span class="s2">&quot;===&quot;</span><span class="s0">,</span>
                    <span class="s0">left: self.expression,</span>
                    <span class="s0">right: branch.expression,</span>
                <span class="s0">}),</span>
                <span class="s0">body: make_node(AST_BlockStatement, branch, {</span>
                    <span class="s0">body: branch.body</span>
                <span class="s0">}),</span>
                <span class="s0">alternative: make_node(AST_BlockStatement, default_or_exact, {</span>
                    <span class="s0">body: [].concat(</span>
                        <span class="s0">exact_exp || [],</span>
                        <span class="s0">default_or_exact.body</span>
                    <span class="s0">)</span>
                <span class="s0">})</span>
            <span class="s0">}).optimize(compressor);</span>
        <span class="s0">}</span>
        <span class="s0">let operator = </span><span class="s2">&quot;===&quot;</span><span class="s0">;</span>
        <span class="s0">let consequent = make_node(AST_BlockStatement, branch, {</span>
            <span class="s0">body: branch.body,</span>
        <span class="s0">});</span>
        <span class="s0">let always = make_node(AST_BlockStatement, default_or_exact, {</span>
            <span class="s0">body: [].concat(</span>
                <span class="s0">exact_exp || [],</span>
                <span class="s0">default_or_exact.body</span>
            <span class="s0">)</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(body[</span><span class="s4">0</span><span class="s0">] === default_or_exact) {</span>
            <span class="s0">operator = </span><span class="s2">&quot;!==&quot;</span><span class="s0">;</span>
            <span class="s0">let tmp = always;</span>
            <span class="s0">always = consequent;</span>
            <span class="s0">consequent = tmp;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
            <span class="s0">body: [</span>
                <span class="s0">make_node(AST_If, self, {</span>
                    <span class="s0">condition: make_node(AST_Binary, self, {</span>
                        <span class="s0">operator: operator,</span>
                        <span class="s0">left: self.expression,</span>
                        <span class="s0">right: branch.expression,</span>
                    <span class="s0">}),</span>
                    <span class="s0">body: consequent,</span>
                    <span class="s0">alternative: </span><span class="s1">null</span>
                <span class="s0">})</span>
            <span class="s0">].concat(always)</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">function </span><span class="s0">eliminate_branch(branch, prev) {</span>
        <span class="s1">if </span><span class="s0">(prev &amp;&amp; !aborts(prev)) {</span>
            <span class="s0">prev.body = prev.body.concat(branch.body);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">trim_unreachable_code(compressor, branch, decl);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">branches_equivalent(branch, prev, insertBreak) {</span>
        <span class="s0">let bbody = branch.body;</span>
        <span class="s0">let pbody = prev.body;</span>
        <span class="s1">if </span><span class="s0">(insertBreak) {</span>
            <span class="s0">bbody = bbody.concat(make_node(AST_Break));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(bbody.length !== pbody.length) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">let bblock = make_node(AST_BlockStatement, branch, { body: bbody });</span>
        <span class="s0">let pblock = make_node(AST_BlockStatement, prev, { body: pbody });</span>
        <span class="s1">return </span><span class="s0">bblock.equivalent_to(pblock);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">statement(expression) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_SimpleStatement, expression, {</span>
            <span class="s0">body: expression</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">has_nested_break(root) {</span>
        <span class="s0">let has_break = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">let tw = </span><span class="s1">new </span><span class="s0">TreeWalker(node =&gt; {</span>
            <span class="s1">if </span><span class="s0">(has_break) </span><span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda) </span><span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_SimpleStatement) </span><span class="s1">return true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!is_break(node, tw)) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s0">let parent = tw.parent();</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">parent </span><span class="s1">instanceof </span><span class="s0">AST_SwitchBranch</span>
                <span class="s0">&amp;&amp; parent.body[parent.body.length - </span><span class="s4">1</span><span class="s0">] === node</span>
            <span class="s0">) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">has_break = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">});</span>
        <span class="s0">root.walk(tw);</span>
        <span class="s1">return </span><span class="s0">has_break;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">is_break(node, stack) {</span>
        <span class="s1">return </span><span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Break</span>
            <span class="s0">&amp;&amp; stack.loopcontrol_target(node) === self;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">is_inert_body(branch) {</span>
        <span class="s1">return </span><span class="s0">!aborts(branch) &amp;&amp; !make_node(AST_BlockStatement, branch, {</span>
            <span class="s0">body: branch.body</span>
        <span class="s0">}).has_side_effects(compressor);</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Try, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(self.bcatch &amp;&amp; self.bfinally &amp;&amp; self.bfinally.body.every(is_empty)) self.bfinally = </span><span class="s1">null</span><span class="s0">;</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">) &amp;&amp; self.body.body.every(is_empty)) {</span>
        <span class="s1">var </span><span class="s0">body = [];</span>
        <span class="s1">if </span><span class="s0">(self.bcatch) {</span>
            <span class="s0">trim_unreachable_code(compressor, self.bcatch, body);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.bfinally) body.push(...self.bfinally.body);</span>
        <span class="s1">return </span><span class="s0">make_node(AST_BlockStatement, self, {</span>
            <span class="s0">body: body</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">AST_Definitions.DEFMETHOD(</span><span class="s2">&quot;to_assignments&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">var </span><span class="s0">reduce_vars = compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">);</span>
    <span class="s1">var </span><span class="s0">assignments = [];</span>

    <span class="s1">for </span><span class="s0">(const def of </span><span class="s1">this</span><span class="s0">.definitions) {</span>
        <span class="s1">if </span><span class="s0">(def.value) {</span>
            <span class="s1">var </span><span class="s0">name = make_node(AST_SymbolRef, def.name, def.name);</span>
            <span class="s0">assignments.push(make_node(AST_Assign, def, {</span>
                <span class="s0">operator : </span><span class="s2">&quot;=&quot;</span><span class="s0">,</span>
                <span class="s0">logical: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">left     : name,</span>
                <span class="s0">right    : def.value</span>
            <span class="s0">}));</span>
            <span class="s1">if </span><span class="s0">(reduce_vars) name.definition().fixed = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">const thedef = def.name.definition();</span>
        <span class="s0">thedef.eliminated++;</span>
        <span class="s0">thedef.replaced--;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(assignments.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return null</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, assignments);</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Definitions, </span><span class="s1">function</span><span class="s0">(self) {</span>
    <span class="s1">if </span><span class="s0">(self.definitions.length == </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_EmptyStatement, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_VarDef, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">self.name </span><span class="s1">instanceof </span><span class="s0">AST_SymbolLet</span>
        <span class="s0">&amp;&amp; self.value != </span><span class="s1">null</span>
        <span class="s0">&amp;&amp; is_undefined(self.value, compressor)</span>
    <span class="s0">) {</span>
        <span class="s0">self.value = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Import, </span><span class="s1">function</span><span class="s0">(self) {</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Call, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">exp = self.expression;</span>
    <span class="s1">var </span><span class="s0">fn = exp;</span>
    <span class="s0">inline_array_like_spread(self.args);</span>
    <span class="s1">var </span><span class="s0">simple_args = self.args.every((arg) =&gt;</span>
        <span class="s0">!(arg </span><span class="s1">instanceof </span><span class="s0">AST_Expansion)</span>
    <span class="s0">);</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; fn </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">&amp;&amp; !has_annotation(self, _NOINLINE)</span>
    <span class="s0">) {</span>
        <span class="s0">const fixed = fn.fixed_value();</span>
        <span class="s1">if </span><span class="s0">(!retain_top_func(fixed, compressor)) {</span>
            <span class="s0">fn = fixed;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">is_func = fn </span><span class="s1">instanceof </span><span class="s0">AST_Lambda;</span>

    <span class="s1">if </span><span class="s0">(is_func &amp;&amp; fn.pinned()) </span><span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; simple_args</span>
        <span class="s0">&amp;&amp; is_func</span>
        <span class="s0">&amp;&amp; !fn.uses_arguments) {</span>
        <span class="s1">var </span><span class="s0">pos = </span><span class="s4">0</span><span class="s0">, last = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = self.args.length; i &lt; len; i++) {</span>
            <span class="s1">if </span><span class="s0">(fn.argnames[i] </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
                <span class="s1">if </span><span class="s0">(has_flag(fn.argnames[i].expression, UNUSED)) </span><span class="s1">while </span><span class="s0">(i &lt; len) {</span>
                    <span class="s1">var </span><span class="s0">node = self.args[i++].drop_side_effect_free(compressor);</span>
                    <span class="s1">if </span><span class="s0">(node) {</span>
                        <span class="s0">self.args[pos++] = node;</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else while </span><span class="s0">(i &lt; len) {</span>
                    <span class="s0">self.args[pos++] = self.args[i++];</span>
                <span class="s0">}</span>
                <span class="s0">last = pos;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">trim = i &gt;= fn.argnames.length;</span>
            <span class="s1">if </span><span class="s0">(trim || has_flag(fn.argnames[i], UNUSED)) {</span>
                <span class="s1">var </span><span class="s0">node = self.args[i].drop_side_effect_free(compressor);</span>
                <span class="s1">if </span><span class="s0">(node) {</span>
                    <span class="s0">self.args[pos++] = node;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!trim) {</span>
                    <span class="s0">self.args[pos++] = make_node(AST_Number, self.args[i], {</span>
                        <span class="s0">value: </span><span class="s4">0</span>
                    <span class="s0">});</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">self.args[pos++] = self.args[i];</span>
            <span class="s0">}</span>
            <span class="s0">last = pos;</span>
        <span class="s0">}</span>
        <span class="s0">self.args.length = last;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)) {</span>
        <span class="s1">if </span><span class="s0">(exp </span><span class="s1">instanceof </span><span class="s0">AST_Dot &amp;&amp; exp.start.value === </span><span class="s2">&quot;Array&quot; </span><span class="s0">&amp;&amp; exp.property === </span><span class="s2">&quot;from&quot; </span><span class="s0">&amp;&amp; self.args.length === </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s0">const [argument] = self.args;</span>
            <span class="s1">if </span><span class="s0">(argument </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
                <span class="s1">return </span><span class="s0">make_node(AST_Array, argument, {</span>
                    <span class="s0">elements: argument.elements</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(is_undeclared_ref(exp)) </span><span class="s1">switch </span><span class="s0">(exp.name) {</span>
          <span class="s1">case </span><span class="s2">&quot;Array&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length != </span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">make_node(AST_Array, self, {</span>
                    <span class="s0">elements: self.args</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.args[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Number &amp;&amp; self.args[</span><span class="s4">0</span><span class="s0">].value &lt;= </span><span class="s4">11</span><span class="s0">) {</span>
                <span class="s0">const elements = [];</span>
                <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; self.args[</span><span class="s4">0</span><span class="s0">].value; i++) elements.push(</span><span class="s1">new </span><span class="s0">AST_Hole);</span>
                <span class="s1">return new </span><span class="s0">AST_Array({ elements });</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;Object&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">make_node(AST_Object, self, {</span>
                    <span class="s0">properties: []</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;String&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_String, self, {</span>
                <span class="s0">value: </span><span class="s2">&quot;&quot;</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(self.args.length &lt;= </span><span class="s4">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
                <span class="s0">left: self.args[</span><span class="s4">0</span><span class="s0">],</span>
                <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                <span class="s0">right: make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s0">})</span>
            <span class="s0">}).optimize(compressor);</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;Number&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_Number, self, {</span>
                <span class="s0">value: </span><span class="s4">0</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">1 </span><span class="s0">&amp;&amp; compressor.option(</span><span class="s2">&quot;unsafe_math&quot;</span><span class="s0">)) {</span>
                <span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, self, {</span>
                    <span class="s0">expression: self.args[</span><span class="s4">0</span><span class="s0">],</span>
                    <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;Symbol&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">1 </span><span class="s0">&amp;&amp; self.args[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_String &amp;&amp; compressor.option(</span><span class="s2">&quot;unsafe_symbols&quot;</span><span class="s0">))</span>
                <span class="s0">self.args.length = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;Boolean&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_False, self);</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">1</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, self, {</span>
                <span class="s0">expression: make_node(AST_UnaryPrefix, self, {</span>
                    <span class="s0">expression: self.args[</span><span class="s4">0</span><span class="s0">],</span>
                    <span class="s0">operator: </span><span class="s2">&quot;!&quot;</span>
                <span class="s0">}),</span>
                <span class="s0">operator: </span><span class="s2">&quot;!&quot;</span>
            <span class="s0">}).optimize(compressor);</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;RegExp&quot;</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">params = [];</span>
            <span class="s1">if </span><span class="s0">(self.args.length &gt;= </span><span class="s4">1</span>
                <span class="s0">&amp;&amp; self.args.length &lt;= </span><span class="s4">2</span>
                <span class="s0">&amp;&amp; self.args.every((arg) =&gt; {</span>
                    <span class="s1">var </span><span class="s0">value = arg.evaluate(compressor);</span>
                    <span class="s0">params.push(value);</span>
                    <span class="s1">return </span><span class="s0">arg !== value;</span>
                <span class="s0">})</span>
                <span class="s0">&amp;&amp; regexp_is_safe(params[</span><span class="s4">0</span><span class="s0">])</span>
            <span class="s0">) {</span>
                <span class="s0">let [ source, flags ] = params;</span>
                <span class="s0">source = regexp_source_fix(</span><span class="s1">new </span><span class="s0">RegExp(source).source);</span>
                <span class="s0">const rx = make_node(AST_RegExp, self, {</span>
                    <span class="s0">value: { source, flags }</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(rx._eval(compressor) !== rx) {</span>
                    <span class="s1">return </span><span class="s0">rx;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(exp </span><span class="s1">instanceof </span><span class="s0">AST_Dot) </span><span class="s1">switch</span><span class="s0">(exp.property) {</span>
          <span class="s1">case </span><span class="s2">&quot;toString&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">0 </span><span class="s0">&amp;&amp; !exp.expression.may_throw_on_access(compressor)) {</span>
                <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
                    <span class="s0">left: make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s0">}),</span>
                    <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                    <span class="s0">right: exp.expression</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;join&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(exp.expression </span><span class="s1">instanceof </span><span class="s0">AST_Array) EXIT: {</span>
                <span class="s1">var </span><span class="s0">separator;</span>
                <span class="s1">if </span><span class="s0">(self.args.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">separator = self.args[</span><span class="s4">0</span><span class="s0">].evaluate(compressor);</span>
                    <span class="s1">if </span><span class="s0">(separator === self.args[</span><span class="s4">0</span><span class="s0">]) </span><span class="s1">break </span><span class="s0">EXIT; </span><span class="s3">// not a constant</span>
                <span class="s0">}</span>
                <span class="s1">var </span><span class="s0">elements = [];</span>
                <span class="s1">var </span><span class="s0">consts = [];</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = exp.expression.elements.length; i &lt; len; i++) {</span>
                    <span class="s1">var </span><span class="s0">el = exp.expression.elements[i];</span>
                    <span class="s1">if </span><span class="s0">(el </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) </span><span class="s1">break </span><span class="s0">EXIT;</span>
                    <span class="s1">var </span><span class="s0">value = el.evaluate(compressor);</span>
                    <span class="s1">if </span><span class="s0">(value !== el) {</span>
                        <span class="s0">consts.push(value);</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s1">if </span><span class="s0">(consts.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                            <span class="s0">elements.push(make_node(AST_String, self, {</span>
                                <span class="s0">value: consts.join(separator)</span>
                            <span class="s0">}));</span>
                            <span class="s0">consts.length = </span><span class="s4">0</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s0">elements.push(el);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(consts.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                    <span class="s0">elements.push(make_node(AST_String, self, {</span>
                        <span class="s0">value: consts.join(separator)</span>
                    <span class="s0">}));</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(elements.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(elements.length == </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(elements[</span><span class="s4">0</span><span class="s0">].is_string(compressor)) {</span>
                        <span class="s1">return </span><span class="s0">elements[</span><span class="s4">0</span><span class="s0">];</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">make_node(AST_Binary, elements[</span><span class="s4">0</span><span class="s0">], {</span>
                        <span class="s0">operator : </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                        <span class="s0">left     : make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s0">}),</span>
                        <span class="s0">right    : elements[</span><span class="s4">0</span><span class="s0">]</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(separator == </span><span class="s2">&quot;&quot;</span><span class="s0">) {</span>
                    <span class="s1">var </span><span class="s0">first;</span>
                    <span class="s1">if </span><span class="s0">(elements[</span><span class="s4">0</span><span class="s0">].is_string(compressor)</span>
                        <span class="s0">|| elements[</span><span class="s4">1</span><span class="s0">].is_string(compressor)) {</span>
                        <span class="s0">first = elements.shift();</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">first = make_node(AST_String, self, { value: </span><span class="s2">&quot;&quot; </span><span class="s0">});</span>
                    <span class="s0">}</span>
                    <span class="s1">return </span><span class="s0">elements.reduce(</span><span class="s1">function</span><span class="s0">(prev, el) {</span>
                        <span class="s1">return </span><span class="s0">make_node(AST_Binary, el, {</span>
                            <span class="s0">operator : </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                            <span class="s0">left     : prev,</span>
                            <span class="s0">right    : el</span>
                        <span class="s0">});</span>
                    <span class="s0">}, first).optimize(compressor);</span>
                <span class="s0">}</span>
                <span class="s3">// need this awkward cloning to not affect original element</span>
                <span class="s3">// best_of will decide which one to get through.</span>
                <span class="s1">var </span><span class="s0">node = self.clone();</span>
                <span class="s0">node.expression = node.expression.clone();</span>
                <span class="s0">node.expression.expression = node.expression.expression.clone();</span>
                <span class="s0">node.expression.expression.elements = elements;</span>
                <span class="s1">return </span><span class="s0">best_of(compressor, self, node);</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;charAt&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(exp.expression.is_string(compressor)) {</span>
                <span class="s1">var </span><span class="s0">arg = self.args[</span><span class="s4">0</span><span class="s0">];</span>
                <span class="s1">var </span><span class="s0">index = arg ? arg.evaluate(compressor) : </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(index !== arg) {</span>
                    <span class="s1">return </span><span class="s0">make_node(AST_Sub, exp, {</span>
                        <span class="s0">expression: exp.expression,</span>
                        <span class="s0">property: make_node_from_constant(index | </span><span class="s4">0</span><span class="s0">, arg || exp)</span>
                    <span class="s0">}).optimize(compressor);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;apply&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">2 </span><span class="s0">&amp;&amp; self.args[</span><span class="s4">1</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
                <span class="s1">var </span><span class="s0">args = self.args[</span><span class="s4">1</span><span class="s0">].elements.slice();</span>
                <span class="s0">args.unshift(self.args[</span><span class="s4">0</span><span class="s0">]);</span>
                <span class="s1">return </span><span class="s0">make_node(AST_Call, self, {</span>
                    <span class="s0">expression: make_node(AST_Dot, exp, {</span>
                        <span class="s0">expression: exp.expression,</span>
                        <span class="s0">optional: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">property: </span><span class="s2">&quot;call&quot;</span>
                    <span class="s0">}),</span>
                    <span class="s0">args: args</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;call&quot;</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">func = exp.expression;</span>
            <span class="s1">if </span><span class="s0">(func </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
                <span class="s0">func = func.fixed_value();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(func </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; !func.contains_this()) {</span>
                <span class="s1">return </span><span class="s0">(self.args.length ? make_sequence(</span><span class="s1">this</span><span class="s0">, [</span>
                    <span class="s0">self.args[</span><span class="s4">0</span><span class="s0">],</span>
                    <span class="s0">make_node(AST_Call, self, {</span>
                        <span class="s0">expression: exp.expression,</span>
                        <span class="s0">args: self.args.slice(</span><span class="s4">1</span><span class="s0">)</span>
                    <span class="s0">})</span>
                <span class="s0">]) : make_node(AST_Call, self, {</span>
                    <span class="s0">expression: exp.expression,</span>
                    <span class="s0">args: []</span>
                <span class="s0">})).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe_Function&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; is_undeclared_ref(exp)</span>
        <span class="s0">&amp;&amp; exp.name == </span><span class="s2">&quot;Function&quot;</span><span class="s0">) {</span>
        <span class="s3">// new Function() =&gt; function(){}</span>
        <span class="s1">if </span><span class="s0">(self.args.length == </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_Function, self, {</span>
            <span class="s0">argnames: [],</span>
            <span class="s0">body: []</span>
        <span class="s0">}).optimize(compressor);</span>
        <span class="s1">var </span><span class="s0">nth_identifier = compressor.mangle_options &amp;&amp; compressor.mangle_options.nth_identifier || base54;</span>
        <span class="s1">if </span><span class="s0">(self.args.every((x) =&gt; x </span><span class="s1">instanceof </span><span class="s0">AST_String)) {</span>
            <span class="s3">// quite a corner-case, but we can handle it:</span>
            <span class="s3">//   https://github.com/mishoo/UglifyJS2/issues/203</span>
            <span class="s3">// if the code argument is a constant, then we can minify it.</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s1">var </span><span class="s0">code = </span><span class="s2">&quot;n(function(&quot; </span><span class="s0">+ self.args.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">).map(</span><span class="s1">function</span><span class="s0">(arg) {</span>
                    <span class="s1">return </span><span class="s0">arg.value;</span>
                <span class="s0">}).join(</span><span class="s2">&quot;,&quot;</span><span class="s0">) + </span><span class="s2">&quot;){&quot; </span><span class="s0">+ self.args[self.args.length - </span><span class="s4">1</span><span class="s0">].value + </span><span class="s2">&quot;})&quot;</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">ast = parse(code);</span>
                <span class="s1">var </span><span class="s0">mangle = { ie8: compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">), nth_identifier: nth_identifier };</span>
                <span class="s0">ast.figure_out_scope(mangle);</span>
                <span class="s1">var </span><span class="s0">comp = </span><span class="s1">new </span><span class="s0">Compressor(compressor.options, {</span>
                    <span class="s0">mangle_options: compressor.mangle_options</span>
                <span class="s0">});</span>
                <span class="s0">ast = ast.transform(comp);</span>
                <span class="s0">ast.figure_out_scope(mangle);</span>
                <span class="s0">ast.compute_char_frequency(mangle);</span>
                <span class="s0">ast.mangle_names(mangle);</span>
                <span class="s1">var </span><span class="s0">fun;</span>
                <span class="s0">walk(ast, node =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(is_func_expr(node)) {</span>
                        <span class="s0">fun = node;</span>
                        <span class="s1">return </span><span class="s0">walk_abort;</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s1">var </span><span class="s0">code = OutputStream();</span>
                <span class="s0">AST_BlockStatement.prototype._codegen.call(fun, fun, code);</span>
                <span class="s0">self.args = [</span>
                    <span class="s0">make_node(AST_String, self, {</span>
                        <span class="s0">value: fun.argnames.map(</span><span class="s1">function</span><span class="s0">(arg) {</span>
                            <span class="s1">return </span><span class="s0">arg.print_to_string();</span>
                        <span class="s0">}).join(</span><span class="s2">&quot;,&quot;</span><span class="s0">)</span>
                    <span class="s0">}),</span>
                    <span class="s0">make_node(AST_String, self.args[self.args.length - </span><span class="s4">1</span><span class="s0">], {</span>
                        <span class="s0">value: code.get().replace(/^{|}$/g, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
                    <span class="s0">})</span>
                <span class="s0">];</span>
                <span class="s1">return </span><span class="s0">self;</span>
            <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) {</span>
                <span class="s1">if </span><span class="s0">(!(ex </span><span class="s1">instanceof </span><span class="s0">JS_Parse_Error)) {</span>
                    <span class="s1">throw </span><span class="s0">ex;</span>
                <span class="s0">}</span>

                <span class="s3">// Otherwise, it crashes at runtime. Or maybe it's nonstandard syntax.</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">inline_into_call(self, fn, compressor);</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_New, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">) &amp;&amp;</span>
        <span class="s0">is_undeclared_ref(self.expression) &amp;&amp;</span>
        <span class="s0">[</span><span class="s2">&quot;Object&quot;</span><span class="s0">, </span><span class="s2">&quot;RegExp&quot;</span><span class="s0">, </span><span class="s2">&quot;Function&quot;</span><span class="s0">, </span><span class="s2">&quot;Error&quot;</span><span class="s0">, </span><span class="s2">&quot;Array&quot;</span><span class="s0">].includes(self.expression.name)</span>
    <span class="s0">) </span><span class="s1">return </span><span class="s0">make_node(AST_Call, self, self).transform(compressor);</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Sequence, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">var </span><span class="s0">expressions = [];</span>
    <span class="s0">filter_for_side_effects();</span>
    <span class="s1">var </span><span class="s0">end = expressions.length - </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">trim_right_for_undefined();</span>
    <span class="s1">if </span><span class="s0">(end == </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">self = maintain_this_binding(compressor.parent(), compressor.self(), expressions[</span><span class="s4">0</span><span class="s0">]);</span>
        <span class="s1">if </span><span class="s0">(!(self </span><span class="s1">instanceof </span><span class="s0">AST_Sequence)) self = self.optimize(compressor);</span>
        <span class="s1">return </span><span class="s0">self;</span>
    <span class="s0">}</span>
    <span class="s0">self.expressions = expressions;</span>
    <span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">function </span><span class="s0">filter_for_side_effects() {</span>
        <span class="s1">var </span><span class="s0">first = first_in_statement(compressor);</span>
        <span class="s1">var </span><span class="s0">last = self.expressions.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">self.expressions.forEach(</span><span class="s1">function</span><span class="s0">(expr, index) {</span>
            <span class="s1">if </span><span class="s0">(index &lt; last) expr = expr.drop_side_effect_free(compressor, first);</span>
            <span class="s1">if </span><span class="s0">(expr) {</span>
                <span class="s0">merge_sequence(expressions, expr);</span>
                <span class="s0">first = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">trim_right_for_undefined() {</span>
        <span class="s1">while </span><span class="s0">(end &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; is_undefined(expressions[end], compressor)) end--;</span>
        <span class="s1">if </span><span class="s0">(end &lt; expressions.length - </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s0">expressions[end] = make_node(AST_UnaryPrefix, self, {</span>
                <span class="s0">operator   : </span><span class="s2">&quot;void&quot;</span><span class="s0">,</span>
                <span class="s0">expression : expressions[end]</span>
            <span class="s0">});</span>
            <span class="s0">expressions.length = end + </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">AST_Unary.DEFMETHOD(</span><span class="s2">&quot;lift_sequences&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;sequences&quot;</span><span class="s0">)) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.expression </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
            <span class="s1">var </span><span class="s0">x = </span><span class="s1">this</span><span class="s0">.expression.expressions.slice();</span>
            <span class="s1">var </span><span class="s0">e = </span><span class="s1">this</span><span class="s0">.clone();</span>
            <span class="s0">e.expression = x.pop();</span>
            <span class="s0">x.push(e);</span>
            <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, x).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_UnaryPostfix, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">return </span><span class="s0">self.lift_sequences(compressor);</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_UnaryPrefix, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">e = self.expression;</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">self.operator == </span><span class="s2">&quot;delete&quot; </span><span class="s0">&amp;&amp;</span>
        <span class="s0">!(</span>
            <span class="s0">e </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef ||</span>
            <span class="s0">e </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess ||</span>
            <span class="s0">e </span><span class="s1">instanceof </span><span class="s0">AST_Chain ||</span>
            <span class="s0">is_identifier_atom(e)</span>
        <span class="s0">)</span>
    <span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">make_sequence(self, [e, make_node(AST_True, self)]).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">seq = self.lift_sequences(compressor);</span>
    <span class="s1">if </span><span class="s0">(seq !== self) {</span>
        <span class="s1">return </span><span class="s0">seq;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s0">) &amp;&amp; self.operator == </span><span class="s2">&quot;void&quot;</span><span class="s0">) {</span>
        <span class="s0">e = e.drop_side_effect_free(compressor);</span>
        <span class="s1">if </span><span class="s0">(e) {</span>
            <span class="s0">self.expression = e;</span>
            <span class="s1">return </span><span class="s0">self;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Undefined, self).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.in_boolean_context()) {</span>
        <span class="s1">switch </span><span class="s0">(self.operator) {</span>
          <span class="s1">case </span><span class="s2">&quot;!&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix &amp;&amp; e.operator == </span><span class="s2">&quot;!&quot;</span><span class="s0">) {</span>
                <span class="s3">// !!foo ==&gt; foo, if we're in boolean context</span>
                <span class="s1">return </span><span class="s0">e.expression;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">AST_Binary) {</span>
                <span class="s0">self = best_of(compressor, self, e.negate(compressor, first_in_statement(compressor)));</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;typeof&quot;</span><span class="s0">:</span>
            <span class="s3">// typeof always returns a non-empty string, thus it's</span>
            <span class="s3">// always true in booleans</span>
            <span class="s3">// And we don't need to check if it's undeclared, because in typeof, that's OK</span>
            <span class="s1">return </span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef ? make_node(AST_True, self) : make_sequence(self, [</span>
                <span class="s0">e,</span>
                <span class="s0">make_node(AST_True, self)</span>
            <span class="s0">])).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.operator == </span><span class="s2">&quot;-&quot; </span><span class="s0">&amp;&amp; e </span><span class="s1">instanceof </span><span class="s0">AST_Infinity) {</span>
        <span class="s0">e = e.transform(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(e </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
        <span class="s0">&amp;&amp; (self.operator == </span><span class="s2">&quot;+&quot; </span><span class="s0">|| self.operator == </span><span class="s2">&quot;-&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; (e.operator == </span><span class="s2">&quot;*&quot; </span><span class="s0">|| e.operator == </span><span class="s2">&quot;/&quot; </span><span class="s0">|| e.operator == </span><span class="s2">&quot;%&quot;</span><span class="s0">)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: e.operator,</span>
            <span class="s0">left: make_node(AST_UnaryPrefix, e.left, {</span>
                <span class="s0">operator: self.operator,</span>
                <span class="s0">expression: e.left</span>
            <span class="s0">}),</span>
            <span class="s0">right: e.right</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// avoids infinite recursion of numerals</span>
    <span class="s1">if </span><span class="s0">(self.operator != </span><span class="s2">&quot;-&quot;</span>
        <span class="s0">|| !(e </span><span class="s1">instanceof </span><span class="s0">AST_Number || e </span><span class="s1">instanceof </span><span class="s0">AST_Infinity || e </span><span class="s1">instanceof </span><span class="s0">AST_BigInt)) {</span>
        <span class="s1">var </span><span class="s0">ev = self.evaluate(compressor);</span>
        <span class="s1">if </span><span class="s0">(ev !== self) {</span>
            <span class="s0">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
            <span class="s1">return </span><span class="s0">best_of(compressor, ev, self);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">AST_Binary.DEFMETHOD(</span><span class="s2">&quot;lift_sequences&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;sequences&quot;</span><span class="s0">)) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.left </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
            <span class="s1">var </span><span class="s0">x = </span><span class="s1">this</span><span class="s0">.left.expressions.slice();</span>
            <span class="s1">var </span><span class="s0">e = </span><span class="s1">this</span><span class="s0">.clone();</span>
            <span class="s0">e.left = x.pop();</span>
            <span class="s0">x.push(e);</span>
            <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, x).optimize(compressor);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.right </span><span class="s1">instanceof </span><span class="s0">AST_Sequence &amp;&amp; !</span><span class="s1">this</span><span class="s0">.left.has_side_effects(compressor)) {</span>
            <span class="s1">var </span><span class="s0">assign = </span><span class="s1">this</span><span class="s0">.operator == </span><span class="s2">&quot;=&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.left </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef;</span>
            <span class="s1">var </span><span class="s0">x = </span><span class="s1">this</span><span class="s0">.right.expressions;</span>
            <span class="s1">var </span><span class="s0">last = x.length - </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; last; i++) {</span>
                <span class="s1">if </span><span class="s0">(!assign &amp;&amp; x[i].has_side_effects(compressor)) </span><span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(i == last) {</span>
                <span class="s0">x = x.slice();</span>
                <span class="s1">var </span><span class="s0">e = </span><span class="s1">this</span><span class="s0">.clone();</span>
                <span class="s0">e.right = x.pop();</span>
                <span class="s0">x.push(e);</span>
                <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, x).optimize(compressor);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(i &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">e = </span><span class="s1">this</span><span class="s0">.clone();</span>
                <span class="s0">e.right = make_sequence(</span><span class="s1">this</span><span class="s0">.right, x.slice(i));</span>
                <span class="s0">x = x.slice(</span><span class="s4">0</span><span class="s0">, i);</span>
                <span class="s0">x.push(e);</span>
                <span class="s1">return </span><span class="s0">make_sequence(</span><span class="s1">this</span><span class="s0">, x).optimize(compressor);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return this</span><span class="s0">;</span>
<span class="s0">});</span>

<span class="s1">var </span><span class="s0">commutativeOperators = makePredicate(</span><span class="s2">&quot;== === != !== * &amp; | ^&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">is_object(node) {</span>
    <span class="s1">return </span><span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_Array</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Object</span>
        <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_Class;</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_Binary, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">function </span><span class="s0">reversible() {</span>
        <span class="s1">return </span><span class="s0">self.left.is_constant()</span>
            <span class="s0">|| self.right.is_constant()</span>
            <span class="s0">|| !self.left.has_side_effects(compressor)</span>
                <span class="s0">&amp;&amp; !self.right.has_side_effects(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">reverse(op) {</span>
        <span class="s1">if </span><span class="s0">(reversible()) {</span>
            <span class="s1">if </span><span class="s0">(op) self.operator = op;</span>
            <span class="s1">var </span><span class="s0">tmp = self.left;</span>
            <span class="s0">self.left = self.right;</span>
            <span class="s0">self.right = tmp;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;lhs_constants&quot;</span><span class="s0">) &amp;&amp; commutativeOperators.has(self.operator)) {</span>
        <span class="s1">if </span><span class="s0">(self.right.is_constant()</span>
            <span class="s0">&amp;&amp; !self.left.is_constant()) {</span>
            <span class="s3">// if right is a constant, whatever side effects the</span>
            <span class="s3">// left side might have could not influence the</span>
            <span class="s3">// result.  hence, force switch.</span>

            <span class="s1">if </span><span class="s0">(!(self.left </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                  <span class="s0">&amp;&amp; PRECEDENCE[self.left.operator] &gt;= PRECEDENCE[self.operator])) {</span>
                <span class="s0">reverse();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">self = self.lift_sequences(compressor);</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;comparisons&quot;</span><span class="s0">)) </span><span class="s1">switch </span><span class="s0">(self.operator) {</span>
      <span class="s1">case </span><span class="s2">&quot;===&quot;</span><span class="s0">:</span>
      <span class="s1">case </span><span class="s2">&quot;!==&quot;</span><span class="s0">:</span>
        <span class="s1">var </span><span class="s0">is_strict_comparison = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">((self.left.is_string(compressor) &amp;&amp; self.right.is_string(compressor)) ||</span>
            <span class="s0">(self.left.is_number(compressor) &amp;&amp; self.right.is_number(compressor)) ||</span>
            <span class="s0">(self.left.is_boolean() &amp;&amp; self.right.is_boolean()) ||</span>
            <span class="s0">self.left.equivalent_to(self.right)) {</span>
            <span class="s0">self.operator = self.operator.substr(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">// XXX: intentionally falling down to the next case</span>
      <span class="s1">case </span><span class="s2">&quot;==&quot;</span><span class="s0">:</span>
      <span class="s1">case </span><span class="s2">&quot;!=&quot;</span><span class="s0">:</span>
        <span class="s3">// void 0 == x =&gt; null == x</span>
        <span class="s1">if </span><span class="s0">(!is_strict_comparison &amp;&amp; is_undefined(self.left, compressor)) {</span>
            <span class="s0">self.left = make_node(AST_Null, self.left);</span>
        <span class="s3">// x == void 0 =&gt; x == null</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!is_strict_comparison &amp;&amp; is_undefined(self.right, compressor)) {</span>
            <span class="s0">self.right = make_node(AST_Null, self.right);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;typeofs&quot;</span><span class="s0">)</span>
            <span class="s3">// &quot;undefined&quot; == typeof x =&gt; undefined === x</span>
            <span class="s0">&amp;&amp; self.left </span><span class="s1">instanceof </span><span class="s0">AST_String</span>
            <span class="s0">&amp;&amp; self.left.value == </span><span class="s2">&quot;undefined&quot;</span>
            <span class="s0">&amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
            <span class="s0">&amp;&amp; self.right.operator == </span><span class="s2">&quot;typeof&quot;</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">expr = self.right.expression;</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef ? expr.is_declared(compressor)</span>
                <span class="s0">: !(expr </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">))) {</span>
                <span class="s0">self.right = expr;</span>
                <span class="s0">self.left = make_node(AST_Undefined, self.left).optimize(compressor);</span>
                <span class="s1">if </span><span class="s0">(self.operator.length == </span><span class="s4">2</span><span class="s0">) self.operator += </span><span class="s2">&quot;=&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;typeofs&quot;</span><span class="s0">)</span>
            <span class="s3">// typeof x === &quot;undefined&quot; =&gt; x === undefined</span>
            <span class="s0">&amp;&amp; self.left </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
            <span class="s0">&amp;&amp; self.left.operator == </span><span class="s2">&quot;typeof&quot;</span>
            <span class="s0">&amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_String</span>
            <span class="s0">&amp;&amp; self.right.value == </span><span class="s2">&quot;undefined&quot;</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">expr = self.left.expression;</span>
            <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef ? expr.is_declared(compressor)</span>
                <span class="s0">: !(expr </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess &amp;&amp; compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">))) {</span>
                <span class="s0">self.left = expr;</span>
                <span class="s0">self.right = make_node(AST_Undefined, self.right).optimize(compressor);</span>
                <span class="s1">if </span><span class="s0">(self.operator.length == </span><span class="s4">2</span><span class="s0">) self.operator += </span><span class="s2">&quot;=&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s3">// obj !== obj =&gt; false</span>
            <span class="s0">&amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">&amp;&amp; self.left.definition() === self.right.definition()</span>
            <span class="s0">&amp;&amp; is_object(self.left.fixed_value())) {</span>
            <span class="s1">return </span><span class="s0">make_node(self.operator[</span><span class="s4">0</span><span class="s0">] == </span><span class="s2">&quot;=&quot; </span><span class="s0">? AST_True : AST_False, self);</span>
        <span class="s0">}</span>
        <span class="s1">break</span><span class="s0">;</span>
      <span class="s1">case </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">:</span>
      <span class="s1">case </span><span class="s2">&quot;||&quot;</span><span class="s0">:</span>
        <span class="s1">var </span><span class="s0">lhs = self.left;</span>
        <span class="s1">if </span><span class="s0">(lhs.operator == self.operator) {</span>
            <span class="s0">lhs = lhs.right;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(lhs </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
            <span class="s0">&amp;&amp; lhs.operator == (self.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s0">? </span><span class="s2">&quot;!==&quot; </span><span class="s0">: </span><span class="s2">&quot;===&quot;</span><span class="s0">)</span>
            <span class="s0">&amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
            <span class="s0">&amp;&amp; lhs.operator == self.right.operator</span>
            <span class="s0">&amp;&amp; (is_undefined(lhs.left, compressor) &amp;&amp; self.right.left </span><span class="s1">instanceof </span><span class="s0">AST_Null</span>
                <span class="s0">|| lhs.left </span><span class="s1">instanceof </span><span class="s0">AST_Null &amp;&amp; is_undefined(self.right.left, compressor))</span>
            <span class="s0">&amp;&amp; !lhs.right.has_side_effects(compressor)</span>
            <span class="s0">&amp;&amp; lhs.right.equivalent_to(self.right.right)) {</span>
            <span class="s1">var </span><span class="s0">combined = make_node(AST_Binary, self, {</span>
                <span class="s0">operator: lhs.operator.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">),</span>
                <span class="s0">left: make_node(AST_Null, self),</span>
                <span class="s0">right: lhs.right</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(lhs !== self.left) {</span>
                <span class="s0">combined = make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: self.operator,</span>
                    <span class="s0">left: self.left.left,</span>
                    <span class="s0">right: combined</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">combined;</span>
        <span class="s0">}</span>
        <span class="s1">break</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.operator == </span><span class="s2">&quot;+&quot; </span><span class="s0">&amp;&amp; compressor.in_boolean_context()) {</span>
        <span class="s1">var </span><span class="s0">ll = self.left.evaluate(compressor);</span>
        <span class="s1">var </span><span class="s0">rr = self.right.evaluate(compressor);</span>
        <span class="s1">if </span><span class="s0">(ll &amp;&amp; </span><span class="s1">typeof </span><span class="s0">ll == </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">make_sequence(self, [</span>
                <span class="s0">self.right,</span>
                <span class="s0">make_node(AST_True, self)</span>
            <span class="s0">]).optimize(compressor);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(rr &amp;&amp; </span><span class="s1">typeof </span><span class="s0">rr == </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">make_sequence(self, [</span>
                <span class="s0">self.left,</span>
                <span class="s0">make_node(AST_True, self)</span>
            <span class="s0">]).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;comparisons&quot;</span><span class="s0">) &amp;&amp; self.is_boolean()) {</span>
        <span class="s1">if </span><span class="s0">(!(compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Binary)</span>
            <span class="s0">|| compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
            <span class="s1">var </span><span class="s0">negated = make_node(AST_UnaryPrefix, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;!&quot;</span><span class="s0">,</span>
                <span class="s0">expression: self.negate(compressor, first_in_statement(compressor))</span>
            <span class="s0">});</span>
            <span class="s0">self = best_of(compressor, self, negated);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe_comps&quot;</span><span class="s0">)) {</span>
            <span class="s1">switch </span><span class="s0">(self.operator) {</span>
              <span class="s1">case </span><span class="s2">&quot;&lt;&quot;</span><span class="s0">: reverse(</span><span class="s2">&quot;&gt;&quot;</span><span class="s0">); </span><span class="s1">break</span><span class="s0">;</span>
              <span class="s1">case </span><span class="s2">&quot;&lt;=&quot;</span><span class="s0">: reverse(</span><span class="s2">&quot;&gt;=&quot;</span><span class="s0">); </span><span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(self.operator == </span><span class="s2">&quot;+&quot;</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_String</span>
            <span class="s0">&amp;&amp; self.right.getValue() == </span><span class="s2">&quot;&quot;</span>
            <span class="s0">&amp;&amp; self.left.is_string(compressor)) {</span>
            <span class="s1">return </span><span class="s0">self.left;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_String</span>
            <span class="s0">&amp;&amp; self.left.getValue() == </span><span class="s2">&quot;&quot;</span>
            <span class="s0">&amp;&amp; self.right.is_string(compressor)) {</span>
            <span class="s1">return </span><span class="s0">self.right;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
            <span class="s0">&amp;&amp; self.left.operator == </span><span class="s2">&quot;+&quot;</span>
            <span class="s0">&amp;&amp; self.left.left </span><span class="s1">instanceof </span><span class="s0">AST_String</span>
            <span class="s0">&amp;&amp; self.left.left.getValue() == </span><span class="s2">&quot;&quot;</span>
            <span class="s0">&amp;&amp; self.right.is_string(compressor)) {</span>
            <span class="s0">self.left = self.left.right;</span>
            <span class="s1">return </span><span class="s0">self;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s0">)) {</span>
        <span class="s1">switch </span><span class="s0">(self.operator) {</span>
          <span class="s1">case </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">ll = has_flag(self.left, TRUTHY)</span>
                <span class="s0">? </span><span class="s1">true</span>
                <span class="s0">: has_flag(self.left, FALSY)</span>
                    <span class="s0">? </span><span class="s1">false</span>
                    <span class="s0">: self.left.evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(!ll) {</span>
                <span class="s1">return </span><span class="s0">maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(ll </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
                <span class="s1">return </span><span class="s0">make_sequence(self, [ self.left, self.right ]).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">rr = self.right.evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(!rr) {</span>
                <span class="s1">if </span><span class="s0">(compressor.in_boolean_context()) {</span>
                    <span class="s1">return </span><span class="s0">make_sequence(self, [</span>
                        <span class="s0">self.left,</span>
                        <span class="s0">make_node(AST_False, self)</span>
                    <span class="s0">]).optimize(compressor);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">set_flag(self, FALSY);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(rr </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
                <span class="s1">var </span><span class="s0">parent = compressor.parent();</span>
                <span class="s1">if </span><span class="s0">(parent.operator == </span><span class="s2">&quot;&amp;&amp;&quot; </span><span class="s0">&amp;&amp; parent.left === compressor.self() || compressor.in_boolean_context()) {</span>
                    <span class="s1">return </span><span class="s0">self.left.optimize(compressor);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">// x || false &amp;&amp; y ---&gt; x ? y : false</span>
            <span class="s1">if </span><span class="s0">(self.left.operator == </span><span class="s2">&quot;||&quot;</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">lr = self.left.right.evaluate(compressor);</span>
                <span class="s1">if </span><span class="s0">(!lr) </span><span class="s1">return </span><span class="s0">make_node(AST_Conditional, self, {</span>
                    <span class="s0">condition: self.left.left,</span>
                    <span class="s0">consequent: self.right,</span>
                    <span class="s0">alternative: self.left.right</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;||&quot;</span><span class="s0">:</span>
            <span class="s1">var </span><span class="s0">ll = has_flag(self.left, TRUTHY)</span>
              <span class="s0">? </span><span class="s1">true</span>
              <span class="s0">: has_flag(self.left, FALSY)</span>
                <span class="s0">? </span><span class="s1">false</span>
                <span class="s0">: self.left.evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(!ll) {</span>
                <span class="s1">return </span><span class="s0">make_sequence(self, [ self.left, self.right ]).optimize(compressor);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(ll </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
                <span class="s1">return </span><span class="s0">maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">rr = self.right.evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(!rr) {</span>
                <span class="s1">var </span><span class="s0">parent = compressor.parent();</span>
                <span class="s1">if </span><span class="s0">(parent.operator == </span><span class="s2">&quot;||&quot; </span><span class="s0">&amp;&amp; parent.left === compressor.self() || compressor.in_boolean_context()) {</span>
                    <span class="s1">return </span><span class="s0">self.left.optimize(compressor);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(rr </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
                <span class="s1">if </span><span class="s0">(compressor.in_boolean_context()) {</span>
                    <span class="s1">return </span><span class="s0">make_sequence(self, [</span>
                        <span class="s0">self.left,</span>
                        <span class="s0">make_node(AST_True, self)</span>
                    <span class="s0">]).optimize(compressor);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">set_flag(self, TRUTHY);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(self.left.operator == </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">lr = self.left.right.evaluate(compressor);</span>
                <span class="s1">if </span><span class="s0">(lr &amp;&amp; !(lr </span><span class="s1">instanceof </span><span class="s0">AST_Node)) </span><span class="s1">return </span><span class="s0">make_node(AST_Conditional, self, {</span>
                    <span class="s0">condition: self.left.left,</span>
                    <span class="s0">consequent: self.left.right,</span>
                    <span class="s0">alternative: self.right</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;??&quot;</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(is_nullish(self.left, compressor)) {</span>
                <span class="s1">return </span><span class="s0">self.right;</span>
            <span class="s0">}</span>

            <span class="s1">var </span><span class="s0">ll = self.left.evaluate(compressor);</span>
            <span class="s1">if </span><span class="s0">(!(ll </span><span class="s1">instanceof </span><span class="s0">AST_Node)) {</span>
                <span class="s3">// if we know the value for sure we can simply compute right away.</span>
                <span class="s1">return </span><span class="s0">ll == </span><span class="s1">null </span><span class="s0">? self.right : self.left;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(compressor.in_boolean_context()) {</span>
                <span class="s0">const rr = self.right.evaluate(compressor);</span>
                <span class="s1">if </span><span class="s0">(!(rr </span><span class="s1">instanceof </span><span class="s0">AST_Node) &amp;&amp; !rr) {</span>
                    <span class="s1">return </span><span class="s0">self.left;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">associative = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">switch </span><span class="s0">(self.operator) {</span>
          <span class="s1">case </span><span class="s2">&quot;+&quot;</span><span class="s0">:</span>
            <span class="s3">// (x + &quot;foo&quot;) + &quot;bar&quot; =&gt; x + &quot;foobar&quot;</span>
            <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                <span class="s0">&amp;&amp; self.left </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                <span class="s0">&amp;&amp; self.left.operator == </span><span class="s2">&quot;+&quot;</span>
                <span class="s0">&amp;&amp; self.left.is_string(compressor)) {</span>
                <span class="s1">var </span><span class="s0">binary = make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                    <span class="s0">left: self.left.right,</span>
                    <span class="s0">right: self.right,</span>
                <span class="s0">});</span>
                <span class="s1">var </span><span class="s0">r = binary.optimize(compressor);</span>
                <span class="s1">if </span><span class="s0">(binary !== r) {</span>
                    <span class="s0">self = make_node(AST_Binary, self, {</span>
                        <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                        <span class="s0">left: self.left.left,</span>
                        <span class="s0">right: r</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">// (x + &quot;foo&quot;) + (&quot;bar&quot; + y) =&gt; (x + &quot;foobar&quot;) + y</span>
            <span class="s1">if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                <span class="s0">&amp;&amp; self.left.operator == </span><span class="s2">&quot;+&quot;</span>
                <span class="s0">&amp;&amp; self.left.is_string(compressor)</span>
                <span class="s0">&amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                <span class="s0">&amp;&amp; self.right.operator == </span><span class="s2">&quot;+&quot;</span>
                <span class="s0">&amp;&amp; self.right.is_string(compressor)) {</span>
                <span class="s1">var </span><span class="s0">binary = make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                    <span class="s0">left: self.left.right,</span>
                    <span class="s0">right: self.right.left,</span>
                <span class="s0">});</span>
                <span class="s1">var </span><span class="s0">m = binary.optimize(compressor);</span>
                <span class="s1">if </span><span class="s0">(binary !== m) {</span>
                    <span class="s0">self = make_node(AST_Binary, self, {</span>
                        <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                        <span class="s0">left: make_node(AST_Binary, self.left, {</span>
                            <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                            <span class="s0">left: self.left.left,</span>
                            <span class="s0">right: m</span>
                        <span class="s0">}),</span>
                        <span class="s0">right: self.right.right</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">// a + -b =&gt; a - b</span>
            <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
                <span class="s0">&amp;&amp; self.right.operator == </span><span class="s2">&quot;-&quot;</span>
                <span class="s0">&amp;&amp; self.left.is_number(compressor)) {</span>
                <span class="s0">self = make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: </span><span class="s2">&quot;-&quot;</span><span class="s0">,</span>
                    <span class="s0">left: self.left,</span>
                    <span class="s0">right: self.right.expression</span>
                <span class="s0">});</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// -a + b =&gt; b - a</span>
            <span class="s1">if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
                <span class="s0">&amp;&amp; self.left.operator == </span><span class="s2">&quot;-&quot;</span>
                <span class="s0">&amp;&amp; reversible()</span>
                <span class="s0">&amp;&amp; self.right.is_number(compressor)) {</span>
                <span class="s0">self = make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: </span><span class="s2">&quot;-&quot;</span><span class="s0">,</span>
                    <span class="s0">left: self.right,</span>
                    <span class="s0">right: self.left.expression</span>
                <span class="s0">});</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// `foo${bar}baz` + 1 =&gt; `foo${bar}baz1`</span>
            <span class="s1">if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_TemplateString) {</span>
                <span class="s1">var </span><span class="s0">l = self.left;</span>
                <span class="s1">var </span><span class="s0">r = self.right.evaluate(compressor);</span>
                <span class="s1">if </span><span class="s0">(r != self.right) {</span>
                    <span class="s0">l.segments[l.segments.length - </span><span class="s4">1</span><span class="s0">].value += String(r);</span>
                    <span class="s1">return </span><span class="s0">l;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">// 1 + `foo${bar}baz` =&gt; `1foo${bar}baz`</span>
            <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_TemplateString) {</span>
                <span class="s1">var </span><span class="s0">r = self.right;</span>
                <span class="s1">var </span><span class="s0">l = self.left.evaluate(compressor);</span>
                <span class="s1">if </span><span class="s0">(l != self.left) {</span>
                    <span class="s0">r.segments[</span><span class="s4">0</span><span class="s0">].value = String(l) + r.segments[</span><span class="s4">0</span><span class="s0">].value;</span>
                    <span class="s1">return </span><span class="s0">r;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">// `1${bar}2` + `foo${bar}baz` =&gt; `1${bar}2foo${bar}baz`</span>
            <span class="s1">if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_TemplateString</span>
                <span class="s0">&amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_TemplateString) {</span>
                <span class="s1">var </span><span class="s0">l = self.left;</span>
                <span class="s1">var </span><span class="s0">segments = l.segments;</span>
                <span class="s1">var </span><span class="s0">r = self.right;</span>
                <span class="s0">segments[segments.length - </span><span class="s4">1</span><span class="s0">].value += r.segments[</span><span class="s4">0</span><span class="s0">].value;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; r.segments.length; i++) {</span>
                    <span class="s0">segments.push(r.segments[i]);</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">l;</span>
            <span class="s0">}</span>
          <span class="s1">case </span><span class="s2">&quot;*&quot;</span><span class="s0">:</span>
            <span class="s0">associative = compressor.option(</span><span class="s2">&quot;unsafe_math&quot;</span><span class="s0">);</span>
          <span class="s1">case </span><span class="s2">&quot;&amp;&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;|&quot;</span><span class="s0">:</span>
          <span class="s1">case </span><span class="s2">&quot;^&quot;</span><span class="s0">:</span>
            <span class="s3">// a + +b =&gt; +b + a</span>
            <span class="s1">if </span><span class="s0">(self.left.is_number(compressor)</span>
                <span class="s0">&amp;&amp; self.right.is_number(compressor)</span>
                <span class="s0">&amp;&amp; reversible()</span>
                <span class="s0">&amp;&amp; !(self.left </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                    <span class="s0">&amp;&amp; self.left.operator != self.operator</span>
                    <span class="s0">&amp;&amp; PRECEDENCE[self.left.operator] &gt;= PRECEDENCE[self.operator])) {</span>
                <span class="s1">var </span><span class="s0">reversed = make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: self.operator,</span>
                    <span class="s0">left: self.right,</span>
                    <span class="s0">right: self.left</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                    <span class="s0">&amp;&amp; !(self.left </span><span class="s1">instanceof </span><span class="s0">AST_Constant)) {</span>
                    <span class="s0">self = best_of(compressor, reversed, self);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">self = best_of(compressor, self, reversed);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(associative &amp;&amp; self.is_number(compressor)) {</span>
                <span class="s3">// a + (b + c) =&gt; (a + b) + c</span>
                <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                    <span class="s0">&amp;&amp; self.right.operator == self.operator) {</span>
                    <span class="s0">self = make_node(AST_Binary, self, {</span>
                        <span class="s0">operator: self.operator,</span>
                        <span class="s0">left: make_node(AST_Binary, self.left, {</span>
                            <span class="s0">operator: self.operator,</span>
                            <span class="s0">left: self.left,</span>
                            <span class="s0">right: self.right.left,</span>
                            <span class="s0">start: self.left.start,</span>
                            <span class="s0">end: self.right.left.end</span>
                        <span class="s0">}),</span>
                        <span class="s0">right: self.right.right</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
                <span class="s3">// (n + 2) + 3 =&gt; 5 + n</span>
                <span class="s3">// (2 * n) * 3 =&gt; 6 + n</span>
                <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                    <span class="s0">&amp;&amp; self.left </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                    <span class="s0">&amp;&amp; self.left.operator == self.operator) {</span>
                    <span class="s1">if </span><span class="s0">(self.left.left </span><span class="s1">instanceof </span><span class="s0">AST_Constant) {</span>
                        <span class="s0">self = make_node(AST_Binary, self, {</span>
                            <span class="s0">operator: self.operator,</span>
                            <span class="s0">left: make_node(AST_Binary, self.left, {</span>
                                <span class="s0">operator: self.operator,</span>
                                <span class="s0">left: self.left.left,</span>
                                <span class="s0">right: self.right,</span>
                                <span class="s0">start: self.left.left.start,</span>
                                <span class="s0">end: self.right.end</span>
                            <span class="s0">}),</span>
                            <span class="s0">right: self.left.right</span>
                        <span class="s0">});</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.left.right </span><span class="s1">instanceof </span><span class="s0">AST_Constant) {</span>
                        <span class="s0">self = make_node(AST_Binary, self, {</span>
                            <span class="s0">operator: self.operator,</span>
                            <span class="s0">left: make_node(AST_Binary, self.left, {</span>
                                <span class="s0">operator: self.operator,</span>
                                <span class="s0">left: self.left.right,</span>
                                <span class="s0">right: self.right,</span>
                                <span class="s0">start: self.left.right.start,</span>
                                <span class="s0">end: self.right.end</span>
                            <span class="s0">}),</span>
                            <span class="s0">right: self.left.left</span>
                        <span class="s0">});</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s3">// (a | 1) | (2 | d) =&gt; (3 | a) | b</span>
                <span class="s1">if </span><span class="s0">(self.left </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                    <span class="s0">&amp;&amp; self.left.operator == self.operator</span>
                    <span class="s0">&amp;&amp; self.left.right </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                    <span class="s0">&amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                    <span class="s0">&amp;&amp; self.right.operator == self.operator</span>
                    <span class="s0">&amp;&amp; self.right.left </span><span class="s1">instanceof </span><span class="s0">AST_Constant) {</span>
                    <span class="s0">self = make_node(AST_Binary, self, {</span>
                        <span class="s0">operator: self.operator,</span>
                        <span class="s0">left: make_node(AST_Binary, self.left, {</span>
                            <span class="s0">operator: self.operator,</span>
                            <span class="s0">left: make_node(AST_Binary, self.left.left, {</span>
                                <span class="s0">operator: self.operator,</span>
                                <span class="s0">left: self.left.right,</span>
                                <span class="s0">right: self.right.left,</span>
                                <span class="s0">start: self.left.right.start,</span>
                                <span class="s0">end: self.right.left.end</span>
                            <span class="s0">}),</span>
                            <span class="s0">right: self.left.left</span>
                        <span class="s0">}),</span>
                        <span class="s0">right: self.right.right</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// x &amp;&amp; (y &amp;&amp; z)  ==&gt;  x &amp;&amp; y &amp;&amp; z</span>
    <span class="s3">// x || (y || z)  ==&gt;  x || y || z</span>
    <span class="s3">// x + (&quot;y&quot; + z)  ==&gt;  x + &quot;y&quot; + z</span>
    <span class="s3">// &quot;x&quot; + (y + &quot;z&quot;)==&gt;  &quot;x&quot; + y + &quot;z&quot;</span>
    <span class="s1">if </span><span class="s0">(self.right </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
        <span class="s0">&amp;&amp; self.right.operator == self.operator</span>
        <span class="s0">&amp;&amp; (lazy_op.has(self.operator)</span>
            <span class="s0">|| (self.operator == </span><span class="s2">&quot;+&quot;</span>
                <span class="s0">&amp;&amp; (self.right.left.is_string(compressor)</span>
                    <span class="s0">|| (self.left.is_string(compressor)</span>
                        <span class="s0">&amp;&amp; self.right.right.is_string(compressor)))))</span>
    <span class="s0">) {</span>
        <span class="s0">self.left = make_node(AST_Binary, self.left, {</span>
            <span class="s0">operator : self.operator,</span>
            <span class="s0">left     : self.left.transform(compressor),</span>
            <span class="s0">right    : self.right.left.transform(compressor)</span>
        <span class="s0">});</span>
        <span class="s0">self.right = self.right.right.transform(compressor);</span>
        <span class="s1">return </span><span class="s0">self.transform(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">ev = self.evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(ev !== self) {</span>
        <span class="s0">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
        <span class="s1">return </span><span class="s0">best_of(compressor, ev, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_SymbolExport, </span><span class="s1">function</span><span class="s0">(self) {</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_SymbolRef, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">!compressor.option(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; is_undeclared_ref(self)</span>
        <span class="s0">&amp;&amp; !compressor.find_parent(AST_With)</span>
    <span class="s0">) {</span>
        <span class="s1">switch </span><span class="s0">(self.name) {</span>
          <span class="s1">case </span><span class="s2">&quot;undefined&quot;</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Undefined, self).optimize(compressor);</span>
          <span class="s1">case </span><span class="s2">&quot;NaN&quot;</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">make_node(AST_NaN, self).optimize(compressor);</span>
          <span class="s1">case </span><span class="s2">&quot;Infinity&quot;</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Infinity, self).optimize(compressor);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">) &amp;&amp; !compressor.is_lhs()) {</span>
        <span class="s1">return </span><span class="s0">inline_into_symbolref(self, compressor);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">self;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">is_atomic(lhs, self) {</span>
    <span class="s1">return </span><span class="s0">lhs </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef || lhs.TYPE === self.TYPE;</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_Undefined, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe_undefined&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">undef = find_variable(compressor, </span><span class="s2">&quot;undefined&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(undef) {</span>
            <span class="s1">var </span><span class="s0">ref = make_node(AST_SymbolRef, self, {</span>
                <span class="s0">name   : </span><span class="s2">&quot;undefined&quot;</span><span class="s0">,</span>
                <span class="s0">scope  : undef.scope,</span>
                <span class="s0">thedef : undef</span>
            <span class="s0">});</span>
            <span class="s0">set_flag(ref, UNDEFINED);</span>
            <span class="s1">return </span><span class="s0">ref;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">lhs = compressor.is_lhs();</span>
    <span class="s1">if </span><span class="s0">(lhs &amp;&amp; is_atomic(lhs, self)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, self, {</span>
        <span class="s0">operator: </span><span class="s2">&quot;void&quot;</span><span class="s0">,</span>
        <span class="s0">expression: make_node(AST_Number, self, {</span>
            <span class="s0">value: </span><span class="s4">0</span>
        <span class="s0">})</span>
    <span class="s0">});</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Infinity, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">lhs = compressor.is_lhs();</span>
    <span class="s1">if </span><span class="s0">(lhs &amp;&amp; is_atomic(lhs, self)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">compressor.option(</span><span class="s2">&quot;keep_infinity&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; !(lhs &amp;&amp; !is_atomic(lhs, self))</span>
        <span class="s0">&amp;&amp; !find_variable(compressor, </span><span class="s2">&quot;Infinity&quot;</span><span class="s0">)</span>
    <span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">self;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
        <span class="s0">operator: </span><span class="s2">&quot;/&quot;</span><span class="s0">,</span>
        <span class="s0">left: make_node(AST_Number, self, {</span>
            <span class="s0">value: </span><span class="s4">1</span>
        <span class="s0">}),</span>
        <span class="s0">right: make_node(AST_Number, self, {</span>
            <span class="s0">value: </span><span class="s4">0</span>
        <span class="s0">})</span>
    <span class="s0">});</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_NaN, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">lhs = compressor.is_lhs();</span>
    <span class="s1">if </span><span class="s0">(lhs &amp;&amp; !is_atomic(lhs, self)</span>
        <span class="s0">|| find_variable(compressor, </span><span class="s2">&quot;NaN&quot;</span><span class="s0">)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;/&quot;</span><span class="s0">,</span>
            <span class="s0">left: make_node(AST_Number, self, {</span>
                <span class="s0">value: </span><span class="s4">0</span>
            <span class="s0">}),</span>
            <span class="s0">right: make_node(AST_Number, self, {</span>
                <span class="s0">value: </span><span class="s4">0</span>
            <span class="s0">})</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">const ASSIGN_OPS = makePredicate(</span><span class="s2">&quot;+ - / * % &gt;&gt; &lt;&lt; &gt;&gt;&gt; | ^ &amp;&quot;</span><span class="s0">);</span>
<span class="s0">const ASSIGN_OPS_COMMUTATIVE = makePredicate(</span><span class="s2">&quot;* | ^ &amp;&quot;</span><span class="s0">);</span>
<span class="s0">def_optimize(AST_Assign, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(self.logical) {</span>
        <span class="s1">return </span><span class="s0">self.lift_sequences(compressor);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">def;</span>
    <span class="s3">// x = x ---&gt; x</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">self.operator === </span><span class="s2">&quot;=&quot;</span>
        <span class="s0">&amp;&amp; self.left </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">&amp;&amp; self.left.name !== </span><span class="s2">&quot;arguments&quot;</span>
        <span class="s0">&amp;&amp; !(def = self.left.definition()).undeclared</span>
        <span class="s0">&amp;&amp; self.right.equivalent_to(self.left)</span>
    <span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">self.right;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; self.left </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">&amp;&amp; (def = self.left.definition()).scope === compressor.find_parent(AST_Lambda)) {</span>
        <span class="s1">var </span><span class="s0">level = </span><span class="s4">0</span><span class="s0">, node, parent = self;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">node = parent;</span>
            <span class="s0">parent = compressor.parent(level++);</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Exit) {</span>
                <span class="s1">if </span><span class="s0">(in_try(level, parent)) </span><span class="s1">break</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(is_reachable(def.scope, [ def ])) </span><span class="s1">break</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(self.operator == </span><span class="s2">&quot;=&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">self.right;</span>
                <span class="s0">def.fixed = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
                    <span class="s0">operator: self.operator.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">),</span>
                    <span class="s0">left: self.left,</span>
                    <span class="s0">right: self.right</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; parent.right === node</span>
            <span class="s0">|| parent </span><span class="s1">instanceof </span><span class="s0">AST_Sequence &amp;&amp; parent.tail_node() === node);</span>
    <span class="s0">}</span>
    <span class="s0">self = self.lift_sequences(compressor);</span>

    <span class="s1">if </span><span class="s0">(self.operator == </span><span class="s2">&quot;=&quot; </span><span class="s0">&amp;&amp; self.left </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef &amp;&amp; self.right </span><span class="s1">instanceof </span><span class="s0">AST_Binary) {</span>
        <span class="s3">// x = expr1 OP expr2</span>
        <span class="s1">if </span><span class="s0">(self.right.left </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">&amp;&amp; self.right.left.name == self.left.name</span>
            <span class="s0">&amp;&amp; ASSIGN_OPS.has(self.right.operator)) {</span>
            <span class="s3">// x = x - 2  ---&gt;  x -= 2</span>
            <span class="s0">self.operator = self.right.operator + </span><span class="s2">&quot;=&quot;</span><span class="s0">;</span>
            <span class="s0">self.right = self.right.right;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self.right.right </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
            <span class="s0">&amp;&amp; self.right.right.name == self.left.name</span>
            <span class="s0">&amp;&amp; ASSIGN_OPS_COMMUTATIVE.has(self.right.operator)</span>
            <span class="s0">&amp;&amp; !self.right.left.has_side_effects(compressor)) {</span>
            <span class="s3">// x = 2 &amp; x  ---&gt;  x &amp;= 2</span>
            <span class="s0">self.operator = self.right.operator + </span><span class="s2">&quot;=&quot;</span><span class="s0">;</span>
            <span class="s0">self.right = self.right.left;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">function </span><span class="s0">in_try(level, node) {</span>
        <span class="s1">function </span><span class="s0">may_assignment_throw() {</span>
            <span class="s0">const right = self.right;</span>
            <span class="s0">self.right = make_node(AST_Null, right);</span>
            <span class="s0">const may_throw = node.may_throw(compressor);</span>
            <span class="s0">self.right = right;</span>

            <span class="s1">return </span><span class="s0">may_throw;</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">stop_at = self.left.definition().scope.get_defun_scope();</span>
        <span class="s1">var </span><span class="s0">parent;</span>
        <span class="s1">while </span><span class="s0">((parent = compressor.parent(level++)) !== stop_at) {</span>
            <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_Try) {</span>
                <span class="s1">if </span><span class="s0">(parent.bfinally) </span><span class="s1">return true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(parent.bcatch &amp;&amp; may_assignment_throw()) </span><span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_DefaultAssign, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s0">)) {</span>
        <span class="s1">return </span><span class="s0">self;</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">evaluateRight = self.right.evaluate(compressor);</span>

    <span class="s3">// `[x = undefined] = foo` ---&gt; `[x] = foo`</span>
    <span class="s3">// `(arg = undefined) =&gt; ...` ---&gt; `(arg) =&gt; ...` (unless `keep_fargs`)</span>
    <span class="s3">// `((arg = undefined) =&gt; ...)()` ---&gt; `((arg) =&gt; ...)()`</span>
    <span class="s0">let lambda, iife;</span>
    <span class="s1">if </span><span class="s0">(evaluateRight === undefined) {</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">(lambda = compressor.parent()) </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
                <span class="s0">? (</span>
                    <span class="s0">compressor.option(</span><span class="s2">&quot;keep_fargs&quot;</span><span class="s0">) === </span><span class="s1">false</span>
                    <span class="s0">|| (iife = compressor.parent(</span><span class="s4">1</span><span class="s0">)).TYPE === </span><span class="s2">&quot;Call&quot;</span>
                        <span class="s0">&amp;&amp; iife.expression === lambda</span>
                <span class="s0">)</span>
                <span class="s0">: </span><span class="s1">true</span>
        <span class="s0">) {</span>
            <span class="s0">self = self.left;</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(evaluateRight !== self.right) {</span>
        <span class="s0">evaluateRight = make_node_from_constant(evaluateRight, self.right);</span>
        <span class="s0">self.right = best_of_expression(evaluateRight, self.right);</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">is_nullish_check(check, check_subject, compressor) {</span>
    <span class="s1">if </span><span class="s0">(check_subject.may_throw(compressor)) </span><span class="s1">return false</span><span class="s0">;</span>

    <span class="s0">let nullish_side;</span>

    <span class="s3">// foo == null</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">check </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
        <span class="s0">&amp;&amp; check.operator === </span><span class="s2">&quot;==&quot;</span>
        <span class="s3">// which side is nullish?</span>
        <span class="s0">&amp;&amp; (</span>
            <span class="s0">(nullish_side = is_nullish(check.left, compressor) &amp;&amp; check.left)</span>
            <span class="s0">|| (nullish_side = is_nullish(check.right, compressor) &amp;&amp; check.right)</span>
        <span class="s0">)</span>
        <span class="s3">// is the other side the same as the check_subject</span>
        <span class="s0">&amp;&amp; (</span>
            <span class="s0">nullish_side === check.left</span>
                <span class="s0">? check.right</span>
                <span class="s0">: check.left</span>
        <span class="s0">).equivalent_to(check_subject)</span>
    <span class="s0">) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s3">// foo === null || foo === undefined</span>
    <span class="s1">if </span><span class="s0">(check </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; check.operator === </span><span class="s2">&quot;||&quot;</span><span class="s0">) {</span>
        <span class="s0">let null_cmp;</span>
        <span class="s0">let undefined_cmp;</span>

        <span class="s0">const find_comparison = cmp =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!(</span>
                <span class="s0">cmp </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
                <span class="s0">&amp;&amp; (cmp.operator === </span><span class="s2">&quot;===&quot; </span><span class="s0">|| cmp.operator === </span><span class="s2">&quot;==&quot;</span><span class="s0">)</span>
            <span class="s0">)) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s0">let found = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">let defined_side;</span>

            <span class="s1">if </span><span class="s0">(cmp.left </span><span class="s1">instanceof </span><span class="s0">AST_Null) {</span>
                <span class="s0">found++;</span>
                <span class="s0">null_cmp = cmp;</span>
                <span class="s0">defined_side = cmp.right;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(cmp.right </span><span class="s1">instanceof </span><span class="s0">AST_Null) {</span>
                <span class="s0">found++;</span>
                <span class="s0">null_cmp = cmp;</span>
                <span class="s0">defined_side = cmp.left;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(is_undefined(cmp.left, compressor)) {</span>
                <span class="s0">found++;</span>
                <span class="s0">undefined_cmp = cmp;</span>
                <span class="s0">defined_side = cmp.right;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(is_undefined(cmp.right, compressor)) {</span>
                <span class="s0">found++;</span>
                <span class="s0">undefined_cmp = cmp;</span>
                <span class="s0">defined_side = cmp.left;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(found !== </span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(!defined_side.equivalent_to(check_subject)) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>

            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">};</span>

        <span class="s1">if </span><span class="s0">(!find_comparison(check.left)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!find_comparison(check.right)) </span><span class="s1">return false</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(null_cmp &amp;&amp; undefined_cmp &amp;&amp; null_cmp !== undefined_cmp) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_Conditional, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;conditionals&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s3">// This looks like lift_sequences(), should probably be under &quot;sequences&quot;</span>
    <span class="s1">if </span><span class="s0">(self.condition </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
        <span class="s1">var </span><span class="s0">expressions = self.condition.expressions.slice();</span>
        <span class="s0">self.condition = expressions.pop();</span>
        <span class="s0">expressions.push(self);</span>
        <span class="s1">return </span><span class="s0">make_sequence(self, expressions);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">cond = self.condition.evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(cond !== self.condition) {</span>
        <span class="s1">if </span><span class="s0">(cond) {</span>
            <span class="s1">return </span><span class="s0">maintain_this_binding(compressor.parent(), compressor.self(), self.consequent);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">maintain_this_binding(compressor.parent(), compressor.self(), self.alternative);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">negated = cond.negate(compressor, first_in_statement(compressor));</span>
    <span class="s1">if </span><span class="s0">(best_of(compressor, cond, negated) === negated) {</span>
        <span class="s0">self = make_node(AST_Conditional, self, {</span>
            <span class="s0">condition: negated,</span>
            <span class="s0">consequent: self.alternative,</span>
            <span class="s0">alternative: self.consequent</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">condition = self.condition;</span>
    <span class="s1">var </span><span class="s0">consequent = self.consequent;</span>
    <span class="s1">var </span><span class="s0">alternative = self.alternative;</span>
    <span class="s3">// x?x:y --&gt; x||y</span>
    <span class="s1">if </span><span class="s0">(condition </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">&amp;&amp; consequent </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">&amp;&amp; condition.definition() === consequent.definition()) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
            <span class="s0">left: condition,</span>
            <span class="s0">right: alternative</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// if (foo) exp = something; else exp = something_else;</span>
    <span class="s3">//                   |</span>
    <span class="s3">//                   v</span>
    <span class="s3">// exp = foo ? something : something_else;</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">consequent </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
        <span class="s0">&amp;&amp; alternative </span><span class="s1">instanceof </span><span class="s0">AST_Assign</span>
        <span class="s0">&amp;&amp; consequent.operator === alternative.operator</span>
        <span class="s0">&amp;&amp; consequent.logical === alternative.logical</span>
        <span class="s0">&amp;&amp; consequent.left.equivalent_to(alternative.left)</span>
        <span class="s0">&amp;&amp; (!self.condition.has_side_effects(compressor)</span>
            <span class="s0">|| consequent.operator == </span><span class="s2">&quot;=&quot;</span>
                <span class="s0">&amp;&amp; !consequent.left.has_side_effects(compressor))</span>
    <span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Assign, self, {</span>
            <span class="s0">operator: consequent.operator,</span>
            <span class="s0">left: consequent.left,</span>
            <span class="s0">logical: consequent.logical,</span>
            <span class="s0">right: make_node(AST_Conditional, self, {</span>
                <span class="s0">condition: self.condition,</span>
                <span class="s0">consequent: consequent.right,</span>
                <span class="s0">alternative: alternative.right</span>
            <span class="s0">})</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// x ? y(a) : y(b) --&gt; y(x ? a : b)</span>
    <span class="s1">var </span><span class="s0">arg_index;</span>
    <span class="s1">if </span><span class="s0">(consequent </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
        <span class="s0">&amp;&amp; alternative.TYPE === consequent.TYPE</span>
        <span class="s0">&amp;&amp; consequent.args.length &gt; </span><span class="s4">0</span>
        <span class="s0">&amp;&amp; consequent.args.length == alternative.args.length</span>
        <span class="s0">&amp;&amp; consequent.expression.equivalent_to(alternative.expression)</span>
        <span class="s0">&amp;&amp; !self.condition.has_side_effects(compressor)</span>
        <span class="s0">&amp;&amp; !consequent.expression.has_side_effects(compressor)</span>
        <span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">(arg_index = single_arg_diff()) == </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">node = consequent.clone();</span>
        <span class="s0">node.args[arg_index] = make_node(AST_Conditional, self, {</span>
            <span class="s0">condition: self.condition,</span>
            <span class="s0">consequent: consequent.args[arg_index],</span>
            <span class="s0">alternative: alternative.args[arg_index]</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">node;</span>
    <span class="s0">}</span>
    <span class="s3">// a ? b : c ? b : d --&gt; (a || c) ? b : d</span>
    <span class="s1">if </span><span class="s0">(alternative </span><span class="s1">instanceof </span><span class="s0">AST_Conditional</span>
        <span class="s0">&amp;&amp; consequent.equivalent_to(alternative.consequent)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Conditional, self, {</span>
            <span class="s0">condition: make_node(AST_Binary, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
                <span class="s0">left: condition,</span>
                <span class="s0">right: alternative.condition</span>
            <span class="s0">}),</span>
            <span class="s0">consequent: consequent,</span>
            <span class="s0">alternative: alternative.alternative</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>

    <span class="s3">// a == null ? b : a -&gt; a ?? b</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">) &gt;= </span><span class="s4">2020 </span><span class="s0">&amp;&amp;</span>
        <span class="s0">is_nullish_check(condition, alternative, compressor)</span>
    <span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;??&quot;</span><span class="s0">,</span>
            <span class="s0">left: alternative,</span>
            <span class="s0">right: consequent</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>

    <span class="s3">// a ? b : (c, b) --&gt; (a || c), b</span>
    <span class="s1">if </span><span class="s0">(alternative </span><span class="s1">instanceof </span><span class="s0">AST_Sequence</span>
        <span class="s0">&amp;&amp; consequent.equivalent_to(alternative.expressions[alternative.expressions.length - </span><span class="s4">1</span><span class="s0">])) {</span>
        <span class="s1">return </span><span class="s0">make_sequence(self, [</span>
            <span class="s0">make_node(AST_Binary, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
                <span class="s0">left: condition,</span>
                <span class="s0">right: make_sequence(self, alternative.expressions.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">))</span>
            <span class="s0">}),</span>
            <span class="s0">consequent</span>
        <span class="s0">]).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s3">// a ? b : (c &amp;&amp; b) --&gt; (a || c) &amp;&amp; b</span>
    <span class="s1">if </span><span class="s0">(alternative </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
        <span class="s0">&amp;&amp; alternative.operator == </span><span class="s2">&quot;&amp;&amp;&quot;</span>
        <span class="s0">&amp;&amp; consequent.equivalent_to(alternative.right)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
            <span class="s0">left: make_node(AST_Binary, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
                <span class="s0">left: condition,</span>
                <span class="s0">right: alternative.left</span>
            <span class="s0">}),</span>
            <span class="s0">right: consequent</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s3">// x?y?z:a:a --&gt; x&amp;&amp;y?z:a</span>
    <span class="s1">if </span><span class="s0">(consequent </span><span class="s1">instanceof </span><span class="s0">AST_Conditional</span>
        <span class="s0">&amp;&amp; consequent.alternative.equivalent_to(alternative)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Conditional, self, {</span>
            <span class="s0">condition: make_node(AST_Binary, self, {</span>
                <span class="s0">left: self.condition,</span>
                <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
                <span class="s0">right: consequent.condition</span>
            <span class="s0">}),</span>
            <span class="s0">consequent: consequent.consequent,</span>
            <span class="s0">alternative: alternative</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// x ? y : y --&gt; x, y</span>
    <span class="s1">if </span><span class="s0">(consequent.equivalent_to(alternative)) {</span>
        <span class="s1">return </span><span class="s0">make_sequence(self, [</span>
            <span class="s0">self.condition,</span>
            <span class="s0">consequent</span>
        <span class="s0">]).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s3">// x ? y || z : z --&gt; x &amp;&amp; y || z</span>
    <span class="s1">if </span><span class="s0">(consequent </span><span class="s1">instanceof </span><span class="s0">AST_Binary</span>
        <span class="s0">&amp;&amp; consequent.operator == </span><span class="s2">&quot;||&quot;</span>
        <span class="s0">&amp;&amp; consequent.right.equivalent_to(alternative)) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
            <span class="s0">left: make_node(AST_Binary, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
                <span class="s0">left: self.condition,</span>
                <span class="s0">right: consequent.left</span>
            <span class="s0">}),</span>
            <span class="s0">right: alternative</span>
        <span class="s0">}).optimize(compressor);</span>
    <span class="s0">}</span>

    <span class="s0">const in_bool = compressor.in_boolean_context();</span>
    <span class="s1">if </span><span class="s0">(is_true(self.consequent)) {</span>
        <span class="s1">if </span><span class="s0">(is_false(self.alternative)) {</span>
            <span class="s3">// c ? true : false ---&gt; !!c</span>
            <span class="s1">return </span><span class="s0">booleanize(self.condition);</span>
        <span class="s0">}</span>
        <span class="s3">// c ? true : x ---&gt; !!c || x</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
            <span class="s0">left: booleanize(self.condition),</span>
            <span class="s0">right: self.alternative</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(is_false(self.consequent)) {</span>
        <span class="s1">if </span><span class="s0">(is_true(self.alternative)) {</span>
            <span class="s3">// c ? false : true ---&gt; !c</span>
            <span class="s1">return </span><span class="s0">booleanize(self.condition.negate(compressor));</span>
        <span class="s0">}</span>
        <span class="s3">// c ? false : x ---&gt; !c &amp;&amp; x</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
            <span class="s0">left: booleanize(self.condition.negate(compressor)),</span>
            <span class="s0">right: self.alternative</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(is_true(self.alternative)) {</span>
        <span class="s3">// c ? x : true ---&gt; !c || x</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;||&quot;</span><span class="s0">,</span>
            <span class="s0">left: booleanize(self.condition.negate(compressor)),</span>
            <span class="s0">right: self.consequent</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(is_false(self.alternative)) {</span>
        <span class="s3">// c ? x : false ---&gt; !!c &amp;&amp; x</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;&amp;&amp;&quot;</span><span class="s0">,</span>
            <span class="s0">left: booleanize(self.condition),</span>
            <span class="s0">right: self.consequent</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">function </span><span class="s0">booleanize(node) {</span>
        <span class="s1">if </span><span class="s0">(node.is_boolean()) </span><span class="s1">return </span><span class="s0">node;</span>
        <span class="s3">// !!expression</span>
        <span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, node, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;!&quot;</span><span class="s0">,</span>
            <span class="s0">expression: node.negate(compressor)</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">// AST_True or !0</span>
    <span class="s1">function </span><span class="s0">is_true(node) {</span>
        <span class="s1">return </span><span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_True</span>
            <span class="s0">|| in_bool</span>
                <span class="s0">&amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                <span class="s0">&amp;&amp; node.getValue()</span>
            <span class="s0">|| (node </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
                <span class="s0">&amp;&amp; node.operator == </span><span class="s2">&quot;!&quot;</span>
                <span class="s0">&amp;&amp; node.expression </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                <span class="s0">&amp;&amp; !node.expression.getValue());</span>
    <span class="s0">}</span>
    <span class="s3">// AST_False or !1</span>
    <span class="s1">function </span><span class="s0">is_false(node) {</span>
        <span class="s1">return </span><span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_False</span>
            <span class="s0">|| in_bool</span>
                <span class="s0">&amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                <span class="s0">&amp;&amp; !node.getValue()</span>
            <span class="s0">|| (node </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix</span>
                <span class="s0">&amp;&amp; node.operator == </span><span class="s2">&quot;!&quot;</span>
                <span class="s0">&amp;&amp; node.expression </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                <span class="s0">&amp;&amp; node.expression.getValue());</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">single_arg_diff() {</span>
        <span class="s1">var </span><span class="s0">a = consequent.args;</span>
        <span class="s1">var </span><span class="s0">b = alternative.args;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">, len = a.length; i &lt; len; i++) {</span>
            <span class="s1">if </span><span class="s0">(a[i] </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) </span><span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!a[i].equivalent_to(b[i])) {</span>
                <span class="s1">if </span><span class="s0">(b[i] </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = i + </span><span class="s4">1</span><span class="s0">; j &lt; len; j++) {</span>
                    <span class="s1">if </span><span class="s0">(a[j] </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) </span><span class="s1">return</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(!a[j].equivalent_to(b[j])) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">i;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Boolean, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.in_boolean_context()) </span><span class="s1">return </span><span class="s0">make_node(AST_Number, self, {</span>
        <span class="s0">value: +self.value</span>
    <span class="s0">});</span>
    <span class="s1">var </span><span class="s0">p = compressor.parent();</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;booleans_as_integers&quot;</span><span class="s0">)) {</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; (p.operator == </span><span class="s2">&quot;===&quot; </span><span class="s0">|| p.operator == </span><span class="s2">&quot;!==&quot;</span><span class="s0">)) {</span>
            <span class="s0">p.operator = p.operator.replace(/=$/, </span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Number, self, {</span>
            <span class="s0">value: +self.value</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;booleans&quot;</span><span class="s0">)) {</span>
        <span class="s1">if </span><span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; (p.operator == </span><span class="s2">&quot;==&quot;</span>
                                        <span class="s0">|| p.operator == </span><span class="s2">&quot;!=&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Number, self, {</span>
                <span class="s0">value: +self.value</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">make_node(AST_UnaryPrefix, self, {</span>
            <span class="s0">operator: </span><span class="s2">&quot;!&quot;</span><span class="s0">,</span>
            <span class="s0">expression: make_node(AST_Number, self, {</span>
                <span class="s0">value: </span><span class="s4">1 </span><span class="s0">- self.value</span>
            <span class="s0">})</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">safe_to_flatten(value, compressor) {</span>
    <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef) {</span>
        <span class="s0">value = value.fixed_value();</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!value) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!(value </span><span class="s1">instanceof </span><span class="s0">AST_Lambda || value </span><span class="s1">instanceof </span><span class="s0">AST_Class)) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!(value </span><span class="s1">instanceof </span><span class="s0">AST_Lambda &amp;&amp; value.contains_this())) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_New;</span>
<span class="s0">}</span>

<span class="s0">AST_PropAccess.DEFMETHOD(</span><span class="s2">&quot;flatten_object&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(key, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;properties&quot;</span><span class="s0">)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(key === </span><span class="s2">&quot;__proto__&quot;</span><span class="s0">) </span><span class="s1">return</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">arrows = compressor.option(</span><span class="s2">&quot;unsafe_arrows&quot;</span><span class="s0">) &amp;&amp; compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">) &gt;= </span><span class="s4">2015</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">expr = </span><span class="s1">this</span><span class="s0">.expression;</span>
    <span class="s1">if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Object) {</span>
        <span class="s1">var </span><span class="s0">props = expr.properties;</span>

        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = props.length; --i &gt;= </span><span class="s4">0</span><span class="s0">;) {</span>
            <span class="s1">var </span><span class="s0">prop = props[i];</span>

            <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;&quot; </span><span class="s0">+ (prop </span><span class="s1">instanceof </span><span class="s0">AST_ConciseMethod ? prop.key.name : prop.key) == key) {</span>
                <span class="s0">const all_props_flattenable = props.every((p) =&gt;</span>
                    <span class="s0">(p </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal</span>
                        <span class="s0">|| arrows &amp;&amp; p </span><span class="s1">instanceof </span><span class="s0">AST_ConciseMethod &amp;&amp; !p.is_generator</span>
                    <span class="s0">)</span>
                    <span class="s0">&amp;&amp; !p.computed_key()</span>
                <span class="s0">);</span>

                <span class="s1">if </span><span class="s0">(!all_props_flattenable) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(!safe_to_flatten(prop.value, compressor)) </span><span class="s1">return</span><span class="s0">;</span>

                <span class="s1">return </span><span class="s0">make_node(AST_Sub, </span><span class="s1">this</span><span class="s0">, {</span>
                    <span class="s0">expression: make_node(AST_Array, expr, {</span>
                        <span class="s0">elements: props.map(</span><span class="s1">function</span><span class="s0">(prop) {</span>
                            <span class="s1">var </span><span class="s0">v = prop.value;</span>
                            <span class="s1">if </span><span class="s0">(v </span><span class="s1">instanceof </span><span class="s0">AST_Accessor) {</span>
                                <span class="s0">v = make_node(AST_Function, v, v);</span>
                            <span class="s0">}</span>

                            <span class="s1">var </span><span class="s0">k = prop.key;</span>
                            <span class="s1">if </span><span class="s0">(k </span><span class="s1">instanceof </span><span class="s0">AST_Node &amp;&amp; !(k </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod)) {</span>
                                <span class="s1">return </span><span class="s0">make_sequence(prop, [ k, v ]);</span>
                            <span class="s0">}</span>

                            <span class="s1">return </span><span class="s0">v;</span>
                        <span class="s0">})</span>
                    <span class="s0">}),</span>
                    <span class="s0">property: make_node(AST_Number, </span><span class="s1">this</span><span class="s0">, {</span>
                        <span class="s0">value: i</span>
                    <span class="s0">})</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Sub, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">expr = self.expression;</span>
    <span class="s1">var </span><span class="s0">prop = self.property;</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;properties&quot;</span><span class="s0">)) {</span>
        <span class="s1">var </span><span class="s0">key = prop.evaluate(compressor);</span>
        <span class="s1">if </span><span class="s0">(key !== prop) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">key == </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(key == </span><span class="s2">&quot;undefined&quot;</span><span class="s0">) {</span>
                    <span class="s0">key = undefined;</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">var </span><span class="s0">value = parseFloat(key);</span>
                    <span class="s1">if </span><span class="s0">(value.toString() == key) {</span>
                        <span class="s0">key = value;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">prop = self.property = best_of_expression(</span>
                <span class="s0">prop,</span>
                <span class="s0">make_node_from_constant(key, prop).transform(compressor)</span>
            <span class="s0">);</span>
            <span class="s1">var </span><span class="s0">property = </span><span class="s2">&quot;&quot; </span><span class="s0">+ key;</span>
            <span class="s1">if </span><span class="s0">(is_basic_identifier_string(property)</span>
                <span class="s0">&amp;&amp; property.length &lt;= prop.size() + </span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">make_node(AST_Dot, self, {</span>
                    <span class="s0">expression: expr,</span>
                    <span class="s0">optional: self.optional,</span>
                    <span class="s0">property: property,</span>
                    <span class="s0">quote: prop.quote,</span>
                <span class="s0">}).optimize(compressor);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">fn;</span>
    <span class="s0">OPT_ARGUMENTS: </span><span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;arguments&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; expr </span><span class="s1">instanceof </span><span class="s0">AST_SymbolRef</span>
        <span class="s0">&amp;&amp; expr.name == </span><span class="s2">&quot;arguments&quot;</span>
        <span class="s0">&amp;&amp; expr.definition().orig.length == </span><span class="s4">1</span>
        <span class="s0">&amp;&amp; (fn = expr.scope) </span><span class="s1">instanceof </span><span class="s0">AST_Lambda</span>
        <span class="s0">&amp;&amp; fn.uses_arguments</span>
        <span class="s0">&amp;&amp; !(fn </span><span class="s1">instanceof </span><span class="s0">AST_Arrow)</span>
        <span class="s0">&amp;&amp; prop </span><span class="s1">instanceof </span><span class="s0">AST_Number) {</span>
        <span class="s1">var </span><span class="s0">index = prop.getValue();</span>
        <span class="s1">var </span><span class="s0">params = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s1">var </span><span class="s0">argnames = fn.argnames;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">n = </span><span class="s4">0</span><span class="s0">; n &lt; argnames.length; n++) {</span>
            <span class="s1">if </span><span class="s0">(!(argnames[n] </span><span class="s1">instanceof </span><span class="s0">AST_SymbolFunarg)) {</span>
                <span class="s1">break </span><span class="s0">OPT_ARGUMENTS; </span><span class="s3">// destructuring parameter - bail</span>
            <span class="s0">}</span>
            <span class="s1">var </span><span class="s0">param = argnames[n].name;</span>
            <span class="s1">if </span><span class="s0">(params.has(param)) {</span>
                <span class="s1">break </span><span class="s0">OPT_ARGUMENTS; </span><span class="s3">// duplicate parameter - bail</span>
            <span class="s0">}</span>
            <span class="s0">params.add(param);</span>
        <span class="s0">}</span>
        <span class="s1">var </span><span class="s0">argname = fn.argnames[index];</span>
        <span class="s1">if </span><span class="s0">(argname &amp;&amp; compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s0">)) {</span>
            <span class="s1">var </span><span class="s0">def = argname.definition();</span>
            <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;reduce_vars&quot;</span><span class="s0">) || def.assignments || def.orig.length &gt; </span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s0">argname = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!argname &amp;&amp; !compressor.option(</span><span class="s2">&quot;keep_fargs&quot;</span><span class="s0">) &amp;&amp; index &lt; fn.argnames.length + </span><span class="s4">5</span><span class="s0">) {</span>
            <span class="s1">while </span><span class="s0">(index &gt;= fn.argnames.length) {</span>
                <span class="s0">argname = fn.create_symbol(AST_SymbolFunarg, {</span>
                    <span class="s0">source: fn,</span>
                    <span class="s0">scope: fn,</span>
                    <span class="s0">tentative_name: </span><span class="s2">&quot;argument_&quot; </span><span class="s0">+ fn.argnames.length,</span>
                <span class="s0">});</span>
                <span class="s0">fn.argnames.push(argname);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(argname) {</span>
            <span class="s1">var </span><span class="s0">sym = make_node(AST_SymbolRef, self, argname);</span>
            <span class="s0">sym.reference({});</span>
            <span class="s0">clear_flag(argname, UNUSED);</span>
            <span class="s1">return </span><span class="s0">sym;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.is_lhs()) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">if </span><span class="s0">(key !== prop) {</span>
        <span class="s1">var </span><span class="s0">sub = self.flatten_object(property, compressor);</span>
        <span class="s1">if </span><span class="s0">(sub) {</span>
            <span class="s0">expr = self.expression = sub.expression;</span>
            <span class="s0">prop = self.property = sub.property;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;properties&quot;</span><span class="s0">) &amp;&amp; compressor.option(</span><span class="s2">&quot;side_effects&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; prop </span><span class="s1">instanceof </span><span class="s0">AST_Number &amp;&amp; expr </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
        <span class="s1">var </span><span class="s0">index = prop.getValue();</span>
        <span class="s1">var </span><span class="s0">elements = expr.elements;</span>
        <span class="s1">var </span><span class="s0">retValue = elements[index];</span>
        <span class="s0">FLATTEN: </span><span class="s1">if </span><span class="s0">(safe_to_flatten(retValue, compressor)) {</span>
            <span class="s1">var </span><span class="s0">flatten = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">var </span><span class="s0">values = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = elements.length; --i &gt; index;) {</span>
                <span class="s1">var </span><span class="s0">value = elements[i].drop_side_effect_free(compressor);</span>
                <span class="s1">if </span><span class="s0">(value) {</span>
                    <span class="s0">values.unshift(value);</span>
                    <span class="s1">if </span><span class="s0">(flatten &amp;&amp; value.has_side_effects(compressor)) flatten = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(retValue </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) </span><span class="s1">break </span><span class="s0">FLATTEN;</span>
            <span class="s0">retValue = retValue </span><span class="s1">instanceof </span><span class="s0">AST_Hole ? make_node(AST_Undefined, retValue) : retValue;</span>
            <span class="s1">if </span><span class="s0">(!flatten) values.unshift(retValue);</span>
            <span class="s1">while </span><span class="s0">(--i &gt;= </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">value = elements[i];</span>
                <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) </span><span class="s1">break </span><span class="s0">FLATTEN;</span>
                <span class="s0">value = value.drop_side_effect_free(compressor);</span>
                <span class="s1">if </span><span class="s0">(value) values.unshift(value);</span>
                <span class="s1">else </span><span class="s0">index--;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(flatten) {</span>
                <span class="s0">values.push(retValue);</span>
                <span class="s1">return </span><span class="s0">make_sequence(self, values).optimize(compressor);</span>
            <span class="s0">} </span><span class="s1">else return </span><span class="s0">make_node(AST_Sub, self, {</span>
                <span class="s0">expression: make_node(AST_Array, expr, {</span>
                    <span class="s0">elements: values</span>
                <span class="s0">}),</span>
                <span class="s0">property: make_node(AST_Number, prop, {</span>
                    <span class="s0">value: index</span>
                <span class="s0">})</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">ev = self.evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(ev !== self) {</span>
        <span class="s0">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
        <span class="s1">return </span><span class="s0">best_of(compressor, ev, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Chain, </span><span class="s1">function </span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(is_nullish(self.expression, compressor)) {</span>
        <span class="s0">let parent = compressor.parent();</span>
        <span class="s3">// It's valid to delete a nullish optional chain, but if we optimized</span>
        <span class="s3">// this to `delete undefined` then it would appear to be a syntax error</span>
        <span class="s3">// when we try to optimize the delete. Thankfully, `delete 0` is fine.</span>
        <span class="s1">if </span><span class="s0">(parent </span><span class="s1">instanceof </span><span class="s0">AST_UnaryPrefix &amp;&amp; parent.operator === </span><span class="s2">&quot;delete&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">make_node_from_constant(</span><span class="s4">0</span><span class="s0">, self);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">make_node(AST_Undefined, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Dot, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s0">const parent = compressor.parent();</span>
    <span class="s1">if </span><span class="s0">(compressor.is_lhs()) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe_proto&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; self.expression </span><span class="s1">instanceof </span><span class="s0">AST_Dot</span>
        <span class="s0">&amp;&amp; self.expression.property == </span><span class="s2">&quot;prototype&quot;</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">exp = self.expression.expression;</span>
        <span class="s1">if </span><span class="s0">(is_undeclared_ref(exp)) </span><span class="s1">switch </span><span class="s0">(exp.name) {</span>
          <span class="s1">case </span><span class="s2">&quot;Array&quot;</span><span class="s0">:</span>
            <span class="s0">self.expression = make_node(AST_Array, self.expression, {</span>
                <span class="s0">elements: []</span>
            <span class="s0">});</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;Function&quot;</span><span class="s0">:</span>
            <span class="s0">self.expression = make_node(AST_Function, self.expression, {</span>
                <span class="s0">argnames: [],</span>
                <span class="s0">body: []</span>
            <span class="s0">});</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;Number&quot;</span><span class="s0">:</span>
            <span class="s0">self.expression = make_node(AST_Number, self.expression, {</span>
                <span class="s0">value: </span><span class="s4">0</span>
            <span class="s0">});</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;Object&quot;</span><span class="s0">:</span>
            <span class="s0">self.expression = make_node(AST_Object, self.expression, {</span>
                <span class="s0">properties: []</span>
            <span class="s0">});</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;RegExp&quot;</span><span class="s0">:</span>
            <span class="s0">self.expression = make_node(AST_RegExp, self.expression, {</span>
                <span class="s0">value: { source: </span><span class="s2">&quot;t&quot;</span><span class="s0">, flags: </span><span class="s2">&quot;&quot; </span><span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s1">break</span><span class="s0">;</span>
          <span class="s1">case </span><span class="s2">&quot;String&quot;</span><span class="s0">:</span>
            <span class="s0">self.expression = make_node(AST_String, self.expression, {</span>
                <span class="s0">value: </span><span class="s2">&quot;&quot;</span>
            <span class="s0">});</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!(parent </span><span class="s1">instanceof </span><span class="s0">AST_Call) || !has_annotation(parent, _NOINLINE)) {</span>
        <span class="s0">const sub = self.flatten_object(self.property, compressor);</span>
        <span class="s1">if </span><span class="s0">(sub) </span><span class="s1">return </span><span class="s0">sub.optimize(compressor);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(self.expression </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess</span>
        <span class="s0">&amp;&amp; parent </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess) {</span>
        <span class="s1">return </span><span class="s0">self;</span>
    <span class="s0">}</span>

    <span class="s0">let ev = self.evaluate(compressor);</span>
    <span class="s1">if </span><span class="s0">(ev !== self) {</span>
        <span class="s0">ev = make_node_from_constant(ev, self).optimize(compressor);</span>
        <span class="s1">return </span><span class="s0">best_of(compressor, ev, self);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">literals_in_boolean_context(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.in_boolean_context()) {</span>
        <span class="s1">return </span><span class="s0">best_of(compressor, self, make_sequence(self, [</span>
            <span class="s0">self,</span>
            <span class="s0">make_node(AST_True, self)</span>
        <span class="s0">]).optimize(compressor));</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">inline_array_like_spread(elements) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; elements.length; i++) {</span>
        <span class="s1">var </span><span class="s0">el = elements[i];</span>
        <span class="s1">if </span><span class="s0">(el </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
            <span class="s1">var </span><span class="s0">expr = el.expression;</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">expr </span><span class="s1">instanceof </span><span class="s0">AST_Array</span>
                <span class="s0">&amp;&amp; !expr.elements.some(elm =&gt; elm </span><span class="s1">instanceof </span><span class="s0">AST_Hole)</span>
            <span class="s0">) {</span>
                <span class="s0">elements.splice(i, </span><span class="s4">1</span><span class="s0">, ...expr.elements);</span>
                <span class="s3">// Step back one, as the element at i is now new.</span>
                <span class="s0">i--;</span>
            <span class="s0">}</span>
            <span class="s3">// In array-like spread, spreading a non-iterable value is TypeError.</span>
            <span class="s3">// We therefore can’t optimize anything else, unlike with object spread.</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_Array, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">optimized = literals_in_boolean_context(self, compressor);</span>
    <span class="s1">if </span><span class="s0">(optimized !== self) {</span>
        <span class="s1">return </span><span class="s0">optimized;</span>
    <span class="s0">}</span>
    <span class="s0">inline_array_like_spread(self.elements);</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s1">function </span><span class="s0">inline_object_prop_spread(props, compressor) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; props.length; i++) {</span>
        <span class="s1">var </span><span class="s0">prop = props[i];</span>
        <span class="s1">if </span><span class="s0">(prop </span><span class="s1">instanceof </span><span class="s0">AST_Expansion) {</span>
            <span class="s0">const expr = prop.expression;</span>
            <span class="s1">if </span><span class="s0">(</span>
                <span class="s0">expr </span><span class="s1">instanceof </span><span class="s0">AST_Object</span>
                <span class="s0">&amp;&amp; expr.properties.every(prop =&gt; prop </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal)</span>
            <span class="s0">) {</span>
                <span class="s0">props.splice(i, </span><span class="s4">1</span><span class="s0">, ...expr.properties);</span>
                <span class="s3">// Step back one, as the property at i is now new.</span>
                <span class="s0">i--;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(expr </span><span class="s1">instanceof </span><span class="s0">AST_Constant</span>
                <span class="s0">&amp;&amp; !(expr </span><span class="s1">instanceof </span><span class="s0">AST_String)) {</span>
                <span class="s3">// Unlike array-like spread, in object spread, spreading a</span>
                <span class="s3">// non-iterable value silently does nothing; it is thus safe</span>
                <span class="s3">// to remove. AST_String is the only iterable AST_Constant.</span>
                <span class="s0">props.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">i--;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(is_nullish(expr, compressor)) {</span>
                <span class="s3">// Likewise, null and undefined can be silently removed.</span>
                <span class="s0">props.splice(i, </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">i--;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_Object, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">var </span><span class="s0">optimized = literals_in_boolean_context(self, compressor);</span>
    <span class="s1">if </span><span class="s0">(optimized !== self) {</span>
        <span class="s1">return </span><span class="s0">optimized;</span>
    <span class="s0">}</span>
    <span class="s0">inline_object_prop_spread(self.properties, compressor);</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_RegExp, literals_in_boolean_context);</span>

<span class="s0">def_optimize(AST_Return, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(self.value &amp;&amp; is_undefined(self.value, compressor)) {</span>
        <span class="s0">self.value = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Arrow, opt_AST_Lambda);</span>

<span class="s0">def_optimize(AST_Function, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s0">self = opt_AST_Lambda(self, compressor);</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;unsafe_arrows&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">) &gt;= </span><span class="s4">2015</span>
        <span class="s0">&amp;&amp; !self.name</span>
        <span class="s0">&amp;&amp; !self.is_generator</span>
        <span class="s0">&amp;&amp; !self.uses_arguments</span>
        <span class="s0">&amp;&amp; !self.pinned()) {</span>
        <span class="s0">const uses_this = walk(self, node =&gt; {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_This) </span><span class="s1">return </span><span class="s0">walk_abort;</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(!uses_this) </span><span class="s1">return </span><span class="s0">make_node(AST_Arrow, self, self).optimize(compressor);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Class, </span><span class="s1">function</span><span class="s0">(self) {</span>
    <span class="s3">// HACK to avoid compress failure.</span>
    <span class="s3">// AST_Class is not really an AST_Scope/AST_Block as it lacks a body.</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_ClassStaticBlock, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s0">tighten_body(self.body, compressor);</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Yield, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(self.expression &amp;&amp; !self.is_star &amp;&amp; is_undefined(self.expression, compressor)) {</span>
        <span class="s0">self.expression = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_TemplateString, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">!compressor.option(</span><span class="s2">&quot;evaluate&quot;</span><span class="s0">)</span>
        <span class="s0">|| compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_PrefixedTemplateString</span>
    <span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">self;</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">segments = [];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; self.segments.length; i++) {</span>
        <span class="s1">var </span><span class="s0">segment = self.segments[i];</span>
        <span class="s1">if </span><span class="s0">(segment </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
            <span class="s1">var </span><span class="s0">result = segment.evaluate(compressor);</span>
            <span class="s3">// Evaluate to constant value</span>
            <span class="s3">// Constant value shorter than ${segment}</span>
            <span class="s1">if </span><span class="s0">(result !== segment &amp;&amp; (result + </span><span class="s2">&quot;&quot;</span><span class="s0">).length &lt;= segment.size() + </span><span class="s2">&quot;${}&quot;</span><span class="s0">.length) {</span>
                <span class="s3">// There should always be a previous and next segment if segment is a node</span>
                <span class="s0">segments[segments.length - </span><span class="s4">1</span><span class="s0">].value = segments[segments.length - </span><span class="s4">1</span><span class="s0">].value + result + self.segments[++i].value;</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// `before ${`innerBefore ${any} innerAfter`} after` =&gt; `before innerBefore ${any} innerAfter after`</span>
            <span class="s3">// TODO:</span>
            <span class="s3">// `before ${'test' + foo} after` =&gt; `before innerBefore ${any} innerAfter after`</span>
            <span class="s3">// `before ${foo + 'test} after` =&gt; `before innerBefore ${any} innerAfter after`</span>
            <span class="s1">if </span><span class="s0">(segment </span><span class="s1">instanceof </span><span class="s0">AST_TemplateString) {</span>
                <span class="s1">var </span><span class="s0">inners = segment.segments;</span>
                <span class="s0">segments[segments.length - </span><span class="s4">1</span><span class="s0">].value += inners[</span><span class="s4">0</span><span class="s0">].value;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s4">1</span><span class="s0">; j &lt; inners.length; j++) {</span>
                    <span class="s0">segment = inners[j];</span>
                    <span class="s0">segments.push(segment);</span>
                <span class="s0">}</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">segments.push(segment);</span>
    <span class="s0">}</span>
    <span class="s0">self.segments = segments;</span>

    <span class="s3">// `foo` =&gt; &quot;foo&quot;</span>
    <span class="s1">if </span><span class="s0">(segments.length == </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">make_node(AST_String, self, segments[</span><span class="s4">0</span><span class="s0">]);</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">segments.length === </span><span class="s4">3</span>
        <span class="s0">&amp;&amp; segments[</span><span class="s4">1</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Node</span>
        <span class="s0">&amp;&amp; (</span>
            <span class="s0">segments[</span><span class="s4">1</span><span class="s0">].is_string(compressor)</span>
            <span class="s0">|| segments[</span><span class="s4">1</span><span class="s0">].is_number(compressor)</span>
            <span class="s0">|| is_nullish(segments[</span><span class="s4">1</span><span class="s0">], compressor)</span>
            <span class="s0">|| compressor.option(</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">)</span>
        <span class="s0">)</span>
    <span class="s0">) {</span>
        <span class="s3">// `foo${bar}` =&gt; &quot;foo&quot; + bar</span>
        <span class="s1">if </span><span class="s0">(segments[</span><span class="s4">2</span><span class="s0">].value === </span><span class="s2">&quot;&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                <span class="s0">left: make_node(AST_String, self, {</span>
                    <span class="s0">value: segments[</span><span class="s4">0</span><span class="s0">].value,</span>
                <span class="s0">}),</span>
                <span class="s0">right: segments[</span><span class="s4">1</span><span class="s0">],</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">// `${bar}baz` =&gt; bar + &quot;baz&quot;</span>
        <span class="s1">if </span><span class="s0">(segments[</span><span class="s4">0</span><span class="s0">].value === </span><span class="s2">&quot;&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_Binary, self, {</span>
                <span class="s0">operator: </span><span class="s2">&quot;+&quot;</span><span class="s0">,</span>
                <span class="s0">left: segments[</span><span class="s4">1</span><span class="s0">],</span>
                <span class="s0">right: make_node(AST_String, self, {</span>
                    <span class="s0">value: segments[</span><span class="s4">2</span><span class="s0">].value,</span>
                <span class="s0">}),</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_PrefixedTemplateString, </span><span class="s1">function</span><span class="s0">(self) {</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s3">// [&quot;p&quot;]:1 ---&gt; p:1</span>
<span class="s3">// [42]:1 ---&gt; 42:1</span>
<span class="s1">function </span><span class="s0">lift_key(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(!compressor.option(</span><span class="s2">&quot;computed_props&quot;</span><span class="s0">)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s3">// save a comparison in the typical case</span>
    <span class="s1">if </span><span class="s0">(!(self.key </span><span class="s1">instanceof </span><span class="s0">AST_Constant)) </span><span class="s1">return </span><span class="s0">self;</span>
    <span class="s3">// allow certain acceptable props as not all AST_Constants are true constants</span>
    <span class="s1">if </span><span class="s0">(self.key </span><span class="s1">instanceof </span><span class="s0">AST_String || self.key </span><span class="s1">instanceof </span><span class="s0">AST_Number) {</span>
        <span class="s1">if </span><span class="s0">(self.key.value === </span><span class="s2">&quot;__proto__&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s0">self;</span>
        <span class="s1">if </span><span class="s0">(self.key.value == </span><span class="s2">&quot;constructor&quot;</span>
            <span class="s0">&amp;&amp; compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Class) </span><span class="s1">return </span><span class="s0">self;</span>
        <span class="s1">if </span><span class="s0">(self </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal) {</span>
            <span class="s0">self.quote = self.key.quote;</span>
            <span class="s0">self.key = self.key.value;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(self </span><span class="s1">instanceof </span><span class="s0">AST_ClassProperty) {</span>
            <span class="s0">self.quote = self.key.quote;</span>
            <span class="s0">self.key = make_node(AST_SymbolClassProperty, self.key, {</span>
                <span class="s0">name: self.key.value</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">self.quote = self.key.quote;</span>
            <span class="s0">self.key = make_node(AST_SymbolMethod, self.key, {</span>
                <span class="s0">name: self.key.value</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">}</span>

<span class="s0">def_optimize(AST_ObjectProperty, lift_key);</span>

<span class="s0">def_optimize(AST_ConciseMethod, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s0">lift_key(self, compressor);</span>
    <span class="s3">// p(){return x;} ---&gt; p:()=&gt;x</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;arrows&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; compressor.parent() </span><span class="s1">instanceof </span><span class="s0">AST_Object</span>
        <span class="s0">&amp;&amp; !self.is_generator</span>
        <span class="s0">&amp;&amp; !self.value.uses_arguments</span>
        <span class="s0">&amp;&amp; !self.value.pinned()</span>
        <span class="s0">&amp;&amp; self.value.body.length == </span><span class="s4">1</span>
        <span class="s0">&amp;&amp; self.value.body[</span><span class="s4">0</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Return</span>
        <span class="s0">&amp;&amp; self.value.body[</span><span class="s4">0</span><span class="s0">].value</span>
        <span class="s0">&amp;&amp; !self.value.contains_this()) {</span>
        <span class="s1">var </span><span class="s0">arrow = make_node(AST_Arrow, self.value, self.value);</span>
        <span class="s0">arrow.async = self.async;</span>
        <span class="s0">arrow.is_generator = self.is_generator;</span>
        <span class="s1">return </span><span class="s0">make_node(AST_ObjectKeyVal, self, {</span>
            <span class="s0">key: self.key </span><span class="s1">instanceof </span><span class="s0">AST_SymbolMethod ? self.key.name : self.key,</span>
            <span class="s0">value: arrow,</span>
            <span class="s0">quote: self.quote,</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_ObjectKeyVal, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s0">lift_key(self, compressor);</span>
    <span class="s3">// p:function(){} ---&gt; p(){}</span>
    <span class="s3">// p:function*(){} ---&gt; *p(){}</span>
    <span class="s3">// p:async function(){} ---&gt; async p(){}</span>
    <span class="s3">// p:()=&gt;{} ---&gt; p(){}</span>
    <span class="s3">// p:async()=&gt;{} ---&gt; async p(){}</span>
    <span class="s1">var </span><span class="s0">unsafe_methods = compressor.option(</span><span class="s2">&quot;unsafe_methods&quot;</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(unsafe_methods</span>
        <span class="s0">&amp;&amp; compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">) &gt;= </span><span class="s4">2015</span>
        <span class="s0">&amp;&amp; (!(unsafe_methods </span><span class="s1">instanceof </span><span class="s0">RegExp) || unsafe_methods.test(self.key + </span><span class="s2">&quot;&quot;</span><span class="s0">))) {</span>
        <span class="s1">var </span><span class="s0">key = self.key;</span>
        <span class="s1">var </span><span class="s0">value = self.value;</span>
        <span class="s1">var </span><span class="s0">is_arrow_with_block = value </span><span class="s1">instanceof </span><span class="s0">AST_Arrow</span>
            <span class="s0">&amp;&amp; Array.isArray(value.body)</span>
            <span class="s0">&amp;&amp; !value.contains_this();</span>
        <span class="s1">if </span><span class="s0">((is_arrow_with_block || value </span><span class="s1">instanceof </span><span class="s0">AST_Function) &amp;&amp; !value.name) {</span>
            <span class="s1">return </span><span class="s0">make_node(AST_ConciseMethod, self, {</span>
                <span class="s0">async: value.async,</span>
                <span class="s0">is_generator: value.is_generator,</span>
                <span class="s0">key: key </span><span class="s1">instanceof </span><span class="s0">AST_Node ? key : make_node(AST_SymbolMethod, self, {</span>
                    <span class="s0">name: key,</span>
                <span class="s0">}),</span>
                <span class="s0">value: make_node(AST_Accessor, value, value),</span>
                <span class="s0">quote: self.quote,</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>
<span class="s0">});</span>

<span class="s0">def_optimize(AST_Destructuring, </span><span class="s1">function</span><span class="s0">(self, compressor) {</span>
    <span class="s1">if </span><span class="s0">(compressor.option(</span><span class="s2">&quot;pure_getters&quot;</span><span class="s0">) == </span><span class="s1">true</span>
        <span class="s0">&amp;&amp; compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s0">)</span>
        <span class="s0">&amp;&amp; !self.is_array</span>
        <span class="s0">&amp;&amp; Array.isArray(self.names)</span>
        <span class="s0">&amp;&amp; !is_destructuring_export_decl(compressor)</span>
        <span class="s0">&amp;&amp; !(self.names[self.names.length - </span><span class="s4">1</span><span class="s0">] </span><span class="s1">instanceof </span><span class="s0">AST_Expansion)) {</span>
        <span class="s1">var </span><span class="s0">keep = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; self.names.length; i++) {</span>
            <span class="s1">var </span><span class="s0">elem = self.names[i];</span>
            <span class="s1">if </span><span class="s0">(!(elem </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal</span>
                <span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">elem.key == </span><span class="s2">&quot;string&quot;</span>
                <span class="s0">&amp;&amp; elem.value </span><span class="s1">instanceof </span><span class="s0">AST_SymbolDeclaration</span>
                <span class="s0">&amp;&amp; !should_retain(compressor, elem.value.definition()))) {</span>
                <span class="s0">keep.push(elem);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(keep.length != self.names.length) {</span>
            <span class="s0">self.names = keep;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">self;</span>

    <span class="s1">function </span><span class="s0">is_destructuring_export_decl(compressor) {</span>
        <span class="s1">var </span><span class="s0">ancestors = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">a = </span><span class="s4">0</span><span class="s0">, p = </span><span class="s4">0</span><span class="s0">, len = ancestors.length; a &lt; len; p++) {</span>
            <span class="s1">var </span><span class="s0">parent = compressor.parent(p);</span>
            <span class="s1">if </span><span class="s0">(!parent) </span><span class="s1">return false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(a === </span><span class="s4">0 </span><span class="s0">&amp;&amp; parent.TYPE == </span><span class="s2">&quot;Destructuring&quot;</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!ancestors[a].test(parent.TYPE)) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">a++;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">should_retain(compressor, def) {</span>
        <span class="s1">if </span><span class="s0">(def.references.length) </span><span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!def.global) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(compressor.toplevel.vars) {</span>
             <span class="s1">if </span><span class="s0">(compressor.top_retain) {</span>
                 <span class="s1">return </span><span class="s0">compressor.top_retain(def);</span>
             <span class="s0">}</span>
             <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">});</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s3">// a small wrapper around source-map and @jridgewell/source-map</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">SourceMap(options) {</span>
    <span class="s0">options = defaults(options, {</span>
        <span class="s0">file : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">root : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">orig : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">files: {},</span>
    <span class="s0">});</span>

    <span class="s1">var </span><span class="s0">orig_map;</span>
    <span class="s1">var </span><span class="s0">generator = </span><span class="s1">new </span><span class="s0">sourceMap.SourceMapGenerator({</span>
        <span class="s0">file       : options.file,</span>
        <span class="s0">sourceRoot : options.root</span>
    <span class="s0">});</span>

    <span class="s0">let sourcesContent = {__proto__: </span><span class="s1">null</span><span class="s0">};</span>
    <span class="s0">let files = options.files;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">files) </span><span class="s1">if </span><span class="s0">(HOP(files, name)) {</span>
        <span class="s0">sourcesContent[name] = files[name];</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.orig) {</span>
        <span class="s3">// We support both @jridgewell/source-map (which has a sync</span>
        <span class="s3">// SourceMapConsumer) and source-map (which has an async</span>
        <span class="s3">// SourceMapConsumer).</span>
        <span class="s0">orig_map = await </span><span class="s1">new </span><span class="s0">sourceMap.SourceMapConsumer(options.orig);</span>
        <span class="s1">if </span><span class="s0">(orig_map.sourcesContent) {</span>
            <span class="s0">orig_map.sources.forEach(</span><span class="s1">function</span><span class="s0">(source, i) {</span>
                <span class="s1">var </span><span class="s0">content = orig_map.sourcesContent[i];</span>
                <span class="s1">if </span><span class="s0">(content) {</span>
                    <span class="s0">sourcesContent[source] = content;</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">add(source, gen_line, gen_col, orig_line, orig_col, name) {</span>
        <span class="s0">let generatedPos = { line: gen_line, column: gen_col };</span>

        <span class="s1">if </span><span class="s0">(orig_map) {</span>
            <span class="s1">var </span><span class="s0">info = orig_map.originalPositionFor({</span>
                <span class="s0">line: orig_line,</span>
                <span class="s0">column: orig_col</span>
            <span class="s0">});</span>
            <span class="s1">if </span><span class="s0">(info.source === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">generator.addMapping({</span>
                    <span class="s0">generated: generatedPos,</span>
                    <span class="s0">original: </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">source: </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">name: </span><span class="s1">null</span>
                <span class="s0">});</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">source = info.source;</span>
            <span class="s0">orig_line = info.line;</span>
            <span class="s0">orig_col = info.column;</span>
            <span class="s0">name = info.name || name;</span>
        <span class="s0">}</span>
        <span class="s0">generator.addMapping({</span>
            <span class="s0">generated : generatedPos,</span>
            <span class="s0">original  : { line: orig_line, column: orig_col },</span>
            <span class="s0">source    : source,</span>
            <span class="s0">name      : name</span>
        <span class="s0">});</span>
        <span class="s0">generator.setSourceContent(source, sourcesContent[source]);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">clean(map) {</span>
        <span class="s0">const allNull = map.sourcesContent &amp;&amp; map.sourcesContent.every(c =&gt; c == </span><span class="s1">null</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(allNull) </span><span class="s1">delete </span><span class="s0">map.sourcesContent;</span>
        <span class="s1">if </span><span class="s0">(map.file === undefined) </span><span class="s1">delete </span><span class="s0">map.file;</span>
        <span class="s1">if </span><span class="s0">(map.sourceRoot === undefined) </span><span class="s1">delete </span><span class="s0">map.sourceRoot;</span>
        <span class="s1">return </span><span class="s0">map;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getDecoded() {</span>
        <span class="s1">if </span><span class="s0">(!generator.toDecodedMap) </span><span class="s1">return null</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">clean(generator.toDecodedMap());</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getEncoded() {</span>
        <span class="s1">return </span><span class="s0">clean(generator.toJSON());</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">destroy() {</span>
        <span class="s3">// @jridgewell/source-map's SourceMapConsumer does not need to be</span>
        <span class="s3">// manually freed.</span>
        <span class="s1">if </span><span class="s0">(orig_map &amp;&amp; orig_map.destroy) orig_map.destroy();</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">add,</span>
        <span class="s0">getDecoded,</span>
        <span class="s0">getEncoded,</span>
        <span class="s0">destroy,</span>
    <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">var </span><span class="s0">domprops = [</span>
    <span class="s2">&quot;$&amp;&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$'&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$*&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$+&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$_&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$`&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;$input&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-delay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-duration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-fill-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-iteration-count&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-name&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-play-state&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-animation-timing-function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-appearance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-backface-visibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-end-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-end-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-end-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-start-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-start-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-border-start-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-box-align&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-box-direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-box-flex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-box-ordinal-group&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-box-orient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-box-pack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-box-sizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-float-edge&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-font-feature-settings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-font-language-override&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-force-broken-image-icon&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-hyphens&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-image-region&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-margin-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-margin-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-orient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-osx-font-smoothing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-outline-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-outline-radius-bottomleft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-outline-radius-bottomright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-outline-radius-topleft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-outline-radius-topright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-padding-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-padding-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-perspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-perspective-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-tab-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-text-size-adjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transform-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transform-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transition-delay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transition-duration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transition-property&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-transition-timing-function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-user-focus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-user-input&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-user-modify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-user-select&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-moz-window-dragging&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-align-content&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-align-items&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-align-self&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-delay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-duration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-fill-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-iteration-count&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-name&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-play-state&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-animation-timing-function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-appearance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-backface-visibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-background-clip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-background-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-background-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-border-bottom-left-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-border-bottom-right-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-border-image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-border-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-border-top-left-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-border-top-right-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-align&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-flex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-ordinal-group&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-orient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-pack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-shadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-box-sizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-filter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-flex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-flex-basis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-flex-direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-flex-flow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-flex-grow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-flex-shrink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-flex-wrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-justify-content&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-line-clamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-clip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-composite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-position-x&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-position-y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-repeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-mask-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-order&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-perspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-perspective-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-text-fill-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-text-size-adjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-text-stroke&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-text-stroke-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-text-stroke-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transform-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transform-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transition-delay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transition-duration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transition-property&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-transition-timing-function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;-webkit-user-select&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;10&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;11&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;12&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;13&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;14&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;15&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;17&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;18&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;19&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;20&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;@@iterator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ABORT_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ACTIVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ACTIVE_ATTRIBUTES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ACTIVE_TEXTURE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ACTIVE_UNIFORMS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ACTIVE_UNIFORM_BLOCKS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ADDITION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALIASED_LINE_WIDTH_RANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALIASED_POINT_SIZE_RANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALLOW_KEYBOARD_INPUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALLPASS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALPHA_BITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALREADY_SIGNALED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALT_MASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ALWAYS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ANY_SAMPLES_PASSED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ANY_SAMPLES_PASSED_CONSERVATIVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ANY_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ANY_UNORDERED_NODE_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ARRAY_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ARRAY_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ATTACHED_SHADERS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ATTRIBUTE_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AT_TARGET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AbortController&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AbortSignal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AbsoluteOrientationSensor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AbstractRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Accelerometer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AddSearchProvider&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AggregateError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AnalyserNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Animation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AnimationEffect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AnimationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AnimationPlaybackEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AnimationTimeline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AnonXMLHttpRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Any&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ApplicationCache&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ApplicationCacheErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ArrayBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ArrayType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Atomics&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Attr&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Audio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioBufferSourceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioDestinationNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioListener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioParam&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioParamMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioProcessingEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioScheduledSourceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioStreamTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioWorklet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AudioWorkletNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AuthenticatorAssertionResponse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AuthenticatorAttestationResponse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AuthenticatorResponse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;AutocompleteErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BACK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BAD_BOUNDARYPOINTS_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BAD_REQUEST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BANDPASS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_DST_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_DST_RGB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_EQUATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_EQUATION_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_EQUATION_RGB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_SRC_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLEND_SRC_RGB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLUE_BITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BLUR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BOOL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BOOLEAN_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BOOL_VEC2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BOOL_VEC3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BOOL_VEC4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BOTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BROWSER_DEFAULT_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BUBBLING_PHASE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BUFFER_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BUFFER_USAGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BYTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BYTES_PER_ELEMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BackgroundFetchManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BackgroundFetchRecord&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BackgroundFetchRegistration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BarProp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BarcodeDetector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BaseAudioContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BaseHref&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BatteryManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BeforeInstallPromptEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BeforeLoadEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BeforeUnloadEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BigInt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BigInt64Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BigUint64Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BiquadFilterNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Blob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BlobEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Bluetooth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BluetoothCharacteristicProperties&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BluetoothDevice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BluetoothRemoteGATTCharacteristic&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BluetoothRemoteGATTDescriptor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BluetoothRemoteGATTServer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BluetoothRemoteGATTService&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BluetoothUUID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Boolean&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;BroadcastChannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ByteLengthQueuingStrategy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CAPTURING_PHASE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CCW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CDATASection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CDATA_SECTION_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CHANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CHARSET_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CHECKING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CLAMP_TO_EDGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CLICK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CLOSED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CLOSING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT10&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT11&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT12&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT13&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT14&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT15&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_ATTACHMENT9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_BUFFER_BIT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_CLEAR_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COLOR_WRITEMASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMMENT_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPARE_REF_TO_TEXTURE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPILE_STATUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPLETION_STATUS_KHR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPRESSED_RGBA_S3TC_DXT1_EXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPRESSED_RGBA_S3TC_DXT3_EXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPRESSED_RGBA_S3TC_DXT5_EXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPRESSED_RGB_S3TC_DXT1_EXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COMPRESSED_TEXTURE_FORMATS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONDITION_SATISFIED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONFIGURATION_UNSUPPORTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONNECTING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONSTANT_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONSTANT_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONSTRAINT_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONTEXT_LOST_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CONTROL_MASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COPY_READ_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COPY_READ_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COPY_WRITE_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COPY_WRITE_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;COUNTER_STYLE_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS2Properties&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSAnimation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSCharsetRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSConditionRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSCounterStyleRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSFontFaceRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSFontFeatureValuesRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSGroupingRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSImageValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSImportRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSKeyframeRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSKeyframesRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSKeywordValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMathInvert&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMathMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMathMin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMathNegate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMathProduct&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMathSum&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMathValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMatrixComponent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMediaRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSMozDocumentRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSNameSpaceRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSNamespaceRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSNumericArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSNumericValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSPageRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSPerspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSPositionValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSPrimitiveValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSRotate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSRuleList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSScale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSSkew&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSSkewX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSSkewY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSStyleDeclaration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSStyleRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSStyleSheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSStyleValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSSupportsRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSTransformComponent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSTransformValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSTransition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSTranslate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSUnitValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSUnknownRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSUnparsedValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSValueList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSVariableReferenceValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSVariablesDeclaration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSVariablesRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSSViewportRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_ATTR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_CM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_COUNTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_CUSTOM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_DEG&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_DIMENSION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_EMS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_EXS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_BLUR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_BRIGHTNESS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_CONTRAST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_CUSTOM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_DROP_SHADOW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_GRAYSCALE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_HUE_ROTATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_INVERT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_OPACITY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_REFERENCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_SATURATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_FILTER_SEPIA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_GRAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_HZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_IDENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_IN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_INHERIT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_KHZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_MATRIX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_MATRIX3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_MM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_MS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_NUMBER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_PC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_PERCENTAGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_PERSPECTIVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_PRIMITIVE_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_PT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_PX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_RAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_RECT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_RGBCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_ROTATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_ROTATE3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_ROTATEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_ROTATEY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_ROTATEZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_S&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SCALE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SCALE3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SCALEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SCALEY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SCALEZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SKEW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SKEWX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_SKEWY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_STRING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_TRANSLATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_TRANSLATE3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_TRANSLATEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_TRANSLATEY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_TRANSLATEZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_URI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_VALUE_LIST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_VH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_VMAX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_VMIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CSS_VW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CULL_FACE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CULL_FACE_MODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CURRENT_PROGRAM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CURRENT_QUERY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CURRENT_VERTEX_ATTRIB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CUSTOM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Cache&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CacheStorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CanvasCaptureMediaStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CanvasCaptureMediaStreamTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CanvasGradient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CanvasPattern&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CanvasRenderingContext2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CaretPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ChannelMergerNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ChannelSplitterNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CharacterData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ClientRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ClientRectList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Clipboard&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ClipboardEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ClipboardItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CloseEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Collator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CommandEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Comment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CompileError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CompositionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CompressionStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Console&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ConstantSourceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Controllers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ConvolverNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CountQueuingStrategy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Counter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Credential&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CredentialsContainer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Crypto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CryptoKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CustomElementRegistry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CustomEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DATABASE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DATA_CLONE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DATA_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DBLCLICK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DECR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DECR_WRAP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DELETE_STATUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH24_STENCIL8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH32F_STENCIL8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_ATTACHMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_BITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_BUFFER_BIT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_CLEAR_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_COMPONENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_COMPONENT16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_COMPONENT24&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_COMPONENT32F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_FUNC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_RANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_STENCIL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_STENCIL_ATTACHMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_TEST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEPTH_WRITEMASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DEVICE_INELIGIBLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DIRECTION_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DIRECTION_LEFT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DIRECTION_RIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DIRECTION_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DISABLED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DISPATCH_REQUEST_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DITHER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_FRAGMENT_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_POSITION_CONTAINED_BY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_POSITION_CONTAINS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_POSITION_DISCONNECTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_POSITION_FOLLOWING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_POSITION_PRECEDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOCUMENT_TYPE_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMCursor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMImplementation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMImplementationLS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMMatrixReadOnly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMParser&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMPointReadOnly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMQuad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMRectList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMRectReadOnly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMSTRING_SIZE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMSettableTokenList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMStringList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMStringMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMTokenList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOMTransactionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_DELTA_LINE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_DELTA_PAGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_DELTA_PIXEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_DROP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_HANDWRITING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_IME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_KEYBOARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_MULTIMODAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_OPTION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_PASTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_SCRIPT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_INPUT_METHOD_VOICE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_KEY_LOCATION_JOYSTICK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_KEY_LOCATION_LEFT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_KEY_LOCATION_MOBILE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_KEY_LOCATION_NUMPAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_KEY_LOCATION_RIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_KEY_LOCATION_STANDARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_A&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ACCEPT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ADD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ALT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ALTGR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_AMPERSAND&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ASTERISK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_AT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ATTN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_B&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_BACKSPACE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_BACK_QUOTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_BACK_SLASH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_BACK_SPACE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_C&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CANCEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CAPS_LOCK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CIRCUMFLEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CLEAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CLOSE_BRACKET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CLOSE_CURLY_BRACKET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CLOSE_PAREN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_COLON&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_COMMA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CONTEXT_MENU&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CONTROL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CONVERT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CRSEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_CTRL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_DECIMAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_DELETE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_DIVIDE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_DOLLAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_DOUBLE_QUOTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_E&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_EISU&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_END&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ENTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_EQUALS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_EREOF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ESCAPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_EXCLAMATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_EXECUTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_EXSEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F10&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F11&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F12&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F13&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F14&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F15&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F17&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F18&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F19&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F20&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F21&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F22&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F23&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F24&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F25&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F26&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F27&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F28&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F29&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F30&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F31&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F33&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F34&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F35&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F36&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_F9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_FINAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_FRONT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_G&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_GREATER_THAN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_H&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_HANGUL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_HANJA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_HASH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_HELP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_HK_TOGGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_HOME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_HYPHEN_MINUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_INSERT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_J&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_JUNJA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_K&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_KANA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_KANJI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_L&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_LEFT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_LEFT_TAB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_LESS_THAN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_M&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_META&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_MODECHANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_MULTIPLY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_N&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NONCONVERT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUMPAD9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_NUM_LOCK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_O&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_102&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_COMMA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_MINUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_PERIOD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OEM_PLUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OPEN_BRACKET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OPEN_CURLY_BRACKET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_OPEN_PAREN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_P&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PA1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PAGEDOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PAGEUP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PAGE_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PAGE_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PAUSE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PERCENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PERIOD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PIPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PLAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PLUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PRINT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PRINTSCREEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PROCESSKEY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_PROPERITES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_Q&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_QUESTION_MARK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_QUOTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_R&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_REDO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_RETURN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_RIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_S&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SCROLL_LOCK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SELECT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SEMICOLON&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SEPARATOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SHIFT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SLASH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SLEEP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SPACE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_SUBTRACT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_T&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_TAB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_TILDE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_U&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_UNDERSCORE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_UNDO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_UNICODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_V&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_VOLUME_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_VOLUME_MUTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_VOLUME_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_W&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WINDOW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_ICO_00&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_ICO_CLEAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_ICO_HELP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_ATTN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_AUTO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_BACKTAB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_CLEAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_COPY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_CUSEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_ENLW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_FINISH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_FJ_JISHO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_FJ_LOYA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_FJ_MASSHOU&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_FJ_ROYA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_FJ_TOUROKU&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_JUMP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_PA1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_PA2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_PA3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_RESET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_WIN_OEM_WSCTRL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_X&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ADD_FAVORITE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_APPLICATION_LEFT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_APPLICATION_RIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_CYCLE_TRACK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_FORWARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_LOWER_VOLUME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_MEDIA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_MUTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_NEXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_PAUSE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_PLAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_PREV&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_RAISE_VOLUME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_RANDOM_PLAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_RECORD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_REPEAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_REWIND&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AUDIO_STOP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_AWAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_BACK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_BACK_FORWARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_BATTERY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_BLUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_BLUETOOTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_BOOK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_BRIGHTNESS_ADJUST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_CALCULATOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_CALENDAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_CD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_CLOSE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_COMMUNITY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_CONTRAST_ADJUST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_COPY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_CUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_CYCLE_ANGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_DISPLAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_DOCUMENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_DOS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_EJECT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_EXCEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_EXPLORER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_FAVORITES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_FINANCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_FORWARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_FRAME_BACK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_FRAME_FORWARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_GAME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_GO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_GREEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_HIBERNATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_HISTORY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_HOME_PAGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_HOT_LINKS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_I_TOUCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_KBD_BRIGHTNESS_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_KBD_LIGHT_ON_OFF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH_A&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH_B&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH_C&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH_D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH_E&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LAUNCH_F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LIGHT_BULB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_LOG_OFF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MAIL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MAIL_FORWARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MARKET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MEETING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MEMO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MENU_KB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MENU_PB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MESSENGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MON_BRIGHTNESS_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MUSIC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MY_COMPUTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_MY_SITES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_NEW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_NEWS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_OFFICE_HOME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_OPEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_OPEN_URL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_OPTION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_PASTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_PHONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_PICTURES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_POWER_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_POWER_OFF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_RED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_REFRESH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_RELOAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_REPLY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ROCKER_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ROCKER_ENTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ROCKER_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ROTATE_WINDOWS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ROTATION_KB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ROTATION_PB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SAVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SCREEN_SAVER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SCROLL_CLICK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SCROLL_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SCROLL_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SEARCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SEND&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SHOP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SPELL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SPLIT_SCREEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_STANDBY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_START&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_STOP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SUBTITLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SUPPORT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_SUSPEND&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_TASK_PANE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_TERMINAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_TIME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_TOOLS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_TOP_MENU&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_TO_DO_LIST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_TRAVEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_USER1KB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_USER2KB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_USER_PB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_UWB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_VENDOR_HOME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_VIDEO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_VIEW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_WAKE_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_WEB_CAM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_WHEEL_BUTTON&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_WLAN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_WORD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_WWW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_XFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_YELLOW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ZOOM_IN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_XF86XK_ZOOM_OUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_Y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_Z&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOM_VK_ZOOM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DONT_CARE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DOWNLOADING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAGDROP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER10&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER11&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER12&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER13&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER14&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER15&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_BUFFER9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_FRAMEBUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DRAW_FRAMEBUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DST_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DST_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DYNAMIC_COPY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DYNAMIC_DRAW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DYNAMIC_READ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DataChannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DataTransfer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DataTransferItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DataTransferItemList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DataView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Date&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DateTimeFormat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DecompressionStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DelayNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeprecationReportBody&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DesktopNotification&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DesktopNotificationCenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceLightEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceMotionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceMotionEventAcceleration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceMotionEventRotationRate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceOrientationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceProximityEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceStorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DeviceStorageChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Directory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DisplayNames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Document&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DocumentFragment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DocumentTimeline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DocumentType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DragEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;DynamicsCompressorNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;E&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ELEMENT_ARRAY_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ELEMENT_ARRAY_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ELEMENT_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EMPTY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ENCODING_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ENDED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;END_TO_END&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;END_TO_START&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ENTITY_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ENTITY_REFERENCE_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EPSILON&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EQUAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EQUALPOWER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ERROR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EXPONENTIAL_DISTANCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Element&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ElementInternals&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ElementQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EnterPictureInPictureEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Entity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EntityReference&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Error&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EvalError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Event&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EventException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EventSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;EventTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;External&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FASTEST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FIDOSDK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FILTER_ACCEPT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FILTER_INTERRUPT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FILTER_REJECT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FILTER_SKIP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FINISHED_STATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FIRST_ORDERED_NODE_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_32_UNSIGNED_INT_24_8_REV&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT2x3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT2x4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT3x2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT3x4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT4x2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_MAT4x3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_VEC2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_VEC3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FLOAT_VEC4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FOCUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FONT_FACE_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FONT_FEATURE_VALUES_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAGMENT_SHADER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAGMENT_SHADER_DERIVATIVE_HINT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAGMENT_SHADER_DERIVATIVE_HINT_OES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_BLUE_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_GREEN_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_OBJECT_NAME&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_RED_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_COMPLETE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_DEFAULT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_INCOMPLETE_ATTACHMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_INCOMPLETE_DIMENSIONS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_INCOMPLETE_MULTISAMPLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRAMEBUFFER_UNSUPPORTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRONT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRONT_AND_BACK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FRONT_FACE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FUNC_ADD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FUNC_REVERSE_SUBTRACT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FUNC_SUBTRACT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FeaturePolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FeaturePolicyViolationReportBody&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FederatedCredential&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Feed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FeedEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;File&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileReader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileSystem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileSystemDirectoryEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileSystemDirectoryReader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileSystemEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FileSystemFileEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FinalizationRegistry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FindInPage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Float32Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Float64Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FocusEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FontFace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FontFaceSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FontFaceSetLoadEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FormData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FormDataEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FragmentDirective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GENERATE_MIPMAP_HINT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GEQUAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GREATER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GREEN_BITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GainNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Gamepad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GamepadAxisMoveEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GamepadButton&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GamepadButtonEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GamepadEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GamepadHapticActuator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GamepadPose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Geolocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GeolocationCoordinates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GeolocationPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GeolocationPositionError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;GestureEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Global&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Gyroscope&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HALF_FLOAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HAVE_CURRENT_DATA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HAVE_ENOUGH_DATA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HAVE_FUTURE_DATA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HAVE_METADATA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HAVE_NOTHING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HEADERS_RECEIVED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HIDDEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HIERARCHY_REQUEST_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HIGHPASS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HIGHSHELF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HIGH_FLOAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HIGH_INT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HORIZONTAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HORIZONTAL_AXIS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HRTF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLAllCollection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLAnchorElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLAppletElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLAreaElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLAudioElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLBRElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLBaseElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLBaseFontElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLBlockquoteElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLBodyElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLButtonElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLCanvasElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLCollection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLCommandElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLContentElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDListElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDataElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDataListElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDetailsElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDialogElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDirectoryElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDivElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLEmbedElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLFieldSetElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLFontElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLFormControlsCollection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLFormElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLFrameElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLFrameSetElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLHRElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLHeadElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLHeadingElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLHtmlElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLIFrameElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLImageElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLInputElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLIsIndexElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLKeygenElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLLIElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLLabelElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLLegendElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLLinkElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLMapElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLMarqueeElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLMediaElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLMenuElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLMenuItemElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLMetaElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLMeterElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLModElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLOListElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLObjectElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLOptGroupElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLOptionElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLOptionsCollection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLOutputElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLParagraphElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLParamElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLPictureElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLPreElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLProgressElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLPropertiesCollection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLQuoteElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLScriptElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLSelectElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLShadowElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLSlotElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLSourceElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLSpanElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLStyleElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTableCaptionElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTableCellElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTableColElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTableElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTableRowElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTableSectionElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTemplateElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTextAreaElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTimeElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTitleElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLTrackElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLUListElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLUnknownElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HTMLVideoElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;HashChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Headers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;History&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Hz&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ICE_CHECKING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ICE_CLOSED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ICE_COMPLETED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ICE_CONNECTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ICE_FAILED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ICE_GATHERING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ICE_WAITING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBCursor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBCursorWithValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBDatabase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBDatabaseException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBFactory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBFileHandle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBFileRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBKeyRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBMutableFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBObjectStore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBOpenDBRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBTransaction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDBVersionChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IDLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IIRFilterNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IMPLEMENTATION_COLOR_READ_FORMAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IMPLEMENTATION_COLOR_READ_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IMPORT_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INCR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INCR_WRAP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INDEX_SIZE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INTERLEAVED_ATTRIBS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_2_10_10_10_REV&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_SAMPLER_2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_SAMPLER_2D_ARRAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_SAMPLER_3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_SAMPLER_CUBE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_VEC2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_VEC3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INT_VEC4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INUSE_ATTRIBUTE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_ACCESS_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_CHARACTER_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_ENUM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_EXPRESSION_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_FRAMEBUFFER_OPERATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_INDEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_MODIFICATION_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_NODE_TYPE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_OPERATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_STATE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVALID_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVERSE_DISTANCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;INVERT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IceCandidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IdleDeadline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ImageBitmap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ImageBitmapRenderingContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ImageCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ImageData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Infinity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;InputDeviceCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;InputDeviceInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;InputEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;InputMethodContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;InstallTrigger&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;InstallTriggerImpl&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Instance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Int16Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Int32Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Int8Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Intent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;InternalError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IntersectionObserver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IntersectionObserverEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Intl&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;IsSearchProviderInstalled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Iterator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;JSON&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KEEP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KEYDOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KEYFRAMES_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KEYFRAME_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KEYPRESS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KEYUP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KeyEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Keyboard&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KeyboardEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KeyboardLayoutMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;KeyframeEffect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LENGTHADJUST_SPACING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LENGTHADJUST_SPACINGANDGLYPHS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LENGTHADJUST_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LEQUAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LESS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINEAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINEAR_DISTANCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINEAR_MIPMAP_LINEAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINEAR_MIPMAP_NEAREST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINE_LOOP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINE_STRIP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINE_WIDTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LINK_STATUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LIVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LN10&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LN2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOADED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOADING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOG10E&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOG2E&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOWPASS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOWSHELF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOW_FLOAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LOW_INT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LSException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LSParserFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LUMINANCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LUMINANCE_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LargestContentfulPaint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LayoutShift&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LayoutShiftAttribution&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LinearAccelerationSensor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LinkError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ListFormat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LocalMediaStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Locale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Location&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Lock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;LockManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_3D_TEXTURE_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_ARRAY_TEXTURE_LAYERS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_CLIENT_WAIT_TIMEOUT_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_COLOR_ATTACHMENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_COMBINED_UNIFORM_BLOCKS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_DRAW_BUFFERS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_ELEMENTS_INDICES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_ELEMENTS_VERTICES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_ELEMENT_INDEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_FRAGMENT_INPUT_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_FRAGMENT_UNIFORM_BLOCKS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_FRAGMENT_UNIFORM_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_PROGRAM_TEXEL_OFFSET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_RENDERBUFFER_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_SAFE_INTEGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_SAMPLES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_SERVER_WAIT_TIMEOUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_TEXTURE_IMAGE_UNITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_TEXTURE_LOD_BIAS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_TEXTURE_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_UNIFORM_BLOCK_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_UNIFORM_BUFFER_BINDINGS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VARYING_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VARYING_VECTORS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VERTEX_ATTRIBS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VERTEX_OUTPUT_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VERTEX_UNIFORM_BLOCKS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VERTEX_UNIFORM_COMPONENTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MAX_VIEWPORT_DIMS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_ERR_ABORTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_ERR_DECODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_ERR_ENCRYPTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_ERR_NETWORK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_ERR_SRC_NOT_SUPPORTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_KEYERR_CLIENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_KEYERR_DOMAIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_KEYERR_HARDWARECHANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_KEYERR_OUTPUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_KEYERR_SERVICE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_KEYERR_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIA_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIUM_FLOAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MEDIUM_INT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;META_MASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIConnectionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIInput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIInputMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIMessageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIOutput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIOutputMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIDIPort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIN_PROGRAM_TEXEL_OFFSET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIN_SAFE_INTEGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIN_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MIRRORED_REPEAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MODE_ASYNCHRONOUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MODE_SYNCHRONOUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MODIFICATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOUSEDOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOUSEDRAG&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOUSEMOVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOUSEOUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOUSEOVER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOUSEUP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_KEYFRAMES_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_KEYFRAME_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_SOURCE_CURSOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_SOURCE_ERASER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_SOURCE_KEYBOARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_SOURCE_MOUSE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_SOURCE_PEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_SOURCE_TOUCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MOZ_SOURCE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSGESTURE_FLAG_BEGIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSGESTURE_FLAG_CANCEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSGESTURE_FLAG_END&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSGESTURE_FLAG_INERTIA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSGESTURE_FLAG_NONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSPOINTER_TYPE_MOUSE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSPOINTER_TYPE_PEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MSPOINTER_TYPE_TOUCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_CALLBACK_STATUS_CANCEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_CALLBACK_STATUS_CHOOSEANY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_CALLBACK_STATUS_ERROR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_CALLBACK_STATUS_JOIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_OP_STATUS_CANCELED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_OP_STATUS_ERROR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_ASYNC_OP_STATUS_SUCCESS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_ACTIVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_CANCELLED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_COMMITTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_DRAGGING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_INERTIA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_PRESELECT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_SELECTING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MANIPULATION_STATE_STOPPED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MEDIA_ERR_ENCRYPTED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MEDIA_KEYERR_CLIENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MEDIA_KEYERR_DOMAIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MEDIA_KEYERR_HARDWARECHANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MEDIA_KEYERR_OUTPUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MEDIA_KEYERR_SERVICE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MS_MEDIA_KEYERR_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Map&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Math&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MathMLElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaCapabilitiesInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaController&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaDeviceInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaDevices&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaElementAudioSourceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaEncryptedEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeyError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeyEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeyMessageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeyNeededEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeySession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeyStatusMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeySystemAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaMetadata&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaQueryList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaQueryListEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaRecorder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaRecorderErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaSession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaSettingsRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaStreamAudioDestinationNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaStreamAudioSourceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaStreamEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaStreamTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaStreamTrackAudioSourceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MediaStreamTrackEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Memory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MessageChannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MessageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MessagePort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Methods&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MimeType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MimeTypeArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Module&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MouseEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MouseScrollEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationFillMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationIterationCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationPlayState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAnimationTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozAppearance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBackfaceVisibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBinding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderBottomColors&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderEndColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderEndStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderEndWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderLeftColors&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderRightColors&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderStartColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderStartStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderStartWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBorderTopColors&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBoxAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBoxDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBoxFlex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBoxOrdinalGroup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBoxOrient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBoxPack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozBoxSizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozCSSKeyframeRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozCSSKeyframesRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnFill&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnGap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnRuleColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnRuleStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnRuleWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumnWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozColumns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozContactChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozFloatEdge&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozFontFeatureSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozFontLanguageOverride&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozForceBrokenImageIcon&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozHyphens&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozImageRegion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozMarginEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozMarginStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozMmsEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozMmsMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozMobileMessageThread&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOSXFontSmoothing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOrient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOsxFontSmoothing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOutlineRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOutlineRadiusBottomleft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOutlineRadiusBottomright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOutlineRadiusTopleft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozOutlineRadiusTopright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozPaddingEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozPaddingStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozPerspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozPerspectiveOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozPowerManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozSettingsEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozSmsEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozSmsMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozStackSizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTabSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTextAlignLast&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTextDecorationColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTextDecorationLine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTextDecorationStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTextSizeAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransformOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransformStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransitionDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransitionDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransitionProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozTransitionTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozUserFocus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozUserInput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozUserModify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozUserSelect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozWindowDragging&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MozWindowShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MutationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MutationObserver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;MutationRecord&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NAMESPACE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NAMESPACE_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEAREST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEAREST_MIPMAP_LINEAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEAREST_MIPMAP_NEAREST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEGATIVE_INFINITY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NETWORK_EMPTY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NETWORK_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NETWORK_IDLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NETWORK_LOADED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NETWORK_LOADING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NETWORK_NO_SOURCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEVER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NEXT_NO_DUPLICATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NICEST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NODE_AFTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NODE_BEFORE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NODE_BEFORE_AND_AFTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NODE_INSIDE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NON_TRANSIENT_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NOTATION_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NOTCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NOTEQUAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NOT_ALLOWED_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NOT_FOUND_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NOT_READABLE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NOT_SUPPORTED_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NO_DATA_ALLOWED_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NO_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NO_ERROR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NO_MODIFICATION_ALLOWED_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NUMBER_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NUM_COMPRESSED_TEXTURE_FORMATS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NaN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NamedNodeMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NavigationPreloadManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Navigator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NearbyLinks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NetworkInformation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Node&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NodeFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NodeIterator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NodeList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Notation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Notification&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NotifyPaintEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Number&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NumberFormat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OBJECT_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OBSOLETE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ONE_MINUS_CONSTANT_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ONE_MINUS_CONSTANT_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ONE_MINUS_DST_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ONE_MINUS_DST_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ONE_MINUS_SRC_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ONE_MINUS_SRC_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OPEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OPENED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OPENING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ORDERED_NODE_ITERATOR_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ORDERED_NODE_SNAPSHOT_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OTHER_ERROR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OUT_OF_MEMORY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Object&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OfflineAudioCompletionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OfflineAudioContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OfflineResourceList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OffscreenCanvas&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OffscreenCanvasRenderingContext2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Option&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OrientationSensor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OscillatorNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OverconstrainedError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;OverflowEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PACK_ALIGNMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PACK_ROW_LENGTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PACK_SKIP_PIXELS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PACK_SKIP_ROWS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PAGE_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PARSE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_ARC_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_ARC_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CLOSEPATH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_CUBIC_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_CUBIC_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_CUBIC_SMOOTH_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_CUBIC_SMOOTH_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_QUADRATIC_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_QUADRATIC_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_LINETO_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_LINETO_HORIZONTAL_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_LINETO_HORIZONTAL_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_LINETO_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_LINETO_VERTICAL_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_LINETO_VERTICAL_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_MOVETO_ABS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_MOVETO_REL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATHSEG_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PATH_EXISTS_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PEAKING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PERMISSION_DENIED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PERSISTENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PIXEL_PACK_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PIXEL_PACK_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PIXEL_UNPACK_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PIXEL_UNPACK_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PLAYING_STATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;POINTS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;POLYGON_OFFSET_FACTOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;POLYGON_OFFSET_FILL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;POLYGON_OFFSET_UNITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;POSITION_UNAVAILABLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;POSITIVE_INFINITY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PREV&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PREV_NO_DUPLICATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PROCESSING_INSTRUCTION_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PageChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PageTransitionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaintRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaintRequestList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PannerNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PasswordCredential&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Path2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaymentAddress&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaymentInstruments&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaymentManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaymentMethodChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaymentRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaymentRequestUpdateEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PaymentResponse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Performance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceElementTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceEventTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceLongTaskTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceMark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceMeasure&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceNavigation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceNavigationTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceObserver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceObserverEntryList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformancePaintTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceResourceTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceServerTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PerformanceTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PeriodicSyncManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PeriodicWave&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PermissionStatus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Permissions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PhotoCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PictureInPictureWindow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Plugin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PluginArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PluralRules&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PointerEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PopStateEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PopupBlockedEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Presentation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PresentationAvailability&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PresentationConnection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PresentationConnectionAvailableEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PresentationConnectionCloseEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PresentationConnectionList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PresentationReceiver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PresentationRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ProcessingInstruction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ProgressEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Promise&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PromiseRejectionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PropertyNodeList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Proxy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PublicKeyCredential&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PushManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PushSubscription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PushSubscriptionOptions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Q&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;QUERY_RESULT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;QUERY_RESULT_AVAILABLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;QUOTA_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;QUOTA_EXCEEDED_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;QueryInterface&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R11F_G11F_B10F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R16F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R16I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R16UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R32F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R32I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R32UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R8I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R8UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;R8_SNORM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RASTERIZER_DISCARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;READ_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;READ_FRAMEBUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;READ_FRAMEBUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;READ_ONLY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;READ_ONLY_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;READ_WRITE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RED_BITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RED_INTEGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;REMOVAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_ALPHA_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_BLUE_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_DEPTH_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_GREEN_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_HEIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_INTERNAL_FORMAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_RED_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_SAMPLES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_STENCIL_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERBUFFER_WIDTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERING_INTENT_ABSOLUTE_COLORIMETRIC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERING_INTENT_AUTO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERING_INTENT_PERCEPTUAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERING_INTENT_RELATIVE_COLORIMETRIC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERING_INTENT_SATURATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RENDERING_INTENT_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;REPEAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;REPLACE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG16F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG16I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG16UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG32F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG32I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG32UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG8I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG8UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG8_SNORM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB10_A2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB10_A2UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB16F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB16I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB16UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB32F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB32I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB32UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB565&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB5_A1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB8I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB8UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB8_SNORM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB9_E5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA16F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA16I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA16UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA32F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA32I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA32UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA8I&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA8UI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA8_SNORM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBA_INTEGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGBColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RGB_INTEGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RG_INTEGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ROTATION_CLOCKWISE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ROTATION_COUNTERCLOCKWISE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCCertificate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCDTMFSender&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCDTMFToneChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCDataChannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCDataChannelEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCDtlsTransport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCIceCandidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCIceTransport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCPeerConnection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCPeerConnectionIceErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCPeerConnectionIceEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCRtpReceiver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCRtpSender&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCRtpTransceiver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCSctpTransport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCSessionDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCStatsReport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RTCTrackEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RadioNodeList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Range&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RangeError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RangeException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ReadableStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ReadableStreamDefaultReader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RecordErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Rect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ReferenceError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Reflect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RegExp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RelativeOrientationSensor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RelativeTimeFormat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RemotePlayback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Report&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ReportBody&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ReportingObserver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Request&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ResizeObserver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ResizeObserverEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ResizeObserverSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Response&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;RuntimeError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_2D_ARRAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_2D_ARRAY_SHADOW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_2D_SHADOW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_CUBE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLER_CUBE_SHADOW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLE_ALPHA_TO_COVERAGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLE_BUFFERS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLE_COVERAGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLE_COVERAGE_INVERT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAMPLE_COVERAGE_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SAWTOOTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SCHEDULED_STATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SCISSOR_BOX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SCISSOR_TEST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SCROLL_PAGE_DOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SCROLL_PAGE_UP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SDP_ANSWER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SDP_OFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SDP_PRANSWER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SECURITY_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SELECT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SEPARATE_ATTRIBS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SERIALIZE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SEVERITY_ERROR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SEVERITY_FATAL_ERROR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SEVERITY_WARNING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHADER_COMPILER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHADER_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHADING_LANGUAGE_VERSION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHIFT_MASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHORT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOWING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_ALL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_ATTRIBUTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_CDATA_SECTION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_COMMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_DOCUMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_DOCUMENT_FRAGMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_DOCUMENT_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_ELEMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_ENTITY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_ENTITY_REFERENCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_NOTATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_PROCESSING_INSTRUCTION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SHOW_TEXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SIGNALED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SIGNED_NORMALIZED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SINE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SOUNDFIELD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SQLException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SQRT1_2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SQRT2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SQUARE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SRC_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SRC_ALPHA_SATURATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SRC_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SRGB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SRGB8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SRGB8_ALPHA8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;START_TO_END&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;START_TO_START&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STATIC_COPY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STATIC_DRAW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STATIC_READ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_ATTACHMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BACK_FAIL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BACK_FUNC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BACK_PASS_DEPTH_FAIL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BACK_PASS_DEPTH_PASS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BACK_REF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BACK_VALUE_MASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BACK_WRITEMASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_BUFFER_BIT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_CLEAR_VALUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_FAIL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_FUNC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_INDEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_INDEX8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_PASS_DEPTH_FAIL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_PASS_DEPTH_PASS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_REF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_TEST&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_VALUE_MASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STENCIL_WRITEMASK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STREAM_COPY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STREAM_DRAW&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STREAM_READ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STRING_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;STYLE_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SUBPIXEL_BITS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SUPPORTS_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAltGlyphDefElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAltGlyphElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAltGlyphItemElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimateColorElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimateElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimateMotionElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimateTransformElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedBoolean&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedEnumeration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedInteger&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedLengthList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedNumberList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedPreserveAspectRatio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimatedTransformList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGAnimationElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGCircleElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGClipPathElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGComponentTransferFunctionElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGCursorElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGDefsElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGDescElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGDiscardElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGElementInstance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGElementInstanceList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGEllipseElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEBlendElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEColorMatrixElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEComponentTransferElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFECompositeElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEConvolveMatrixElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEDiffuseLightingElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEDisplacementMapElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEDistantLightElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEDropShadowElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEFloodElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEFuncAElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEFuncBElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEFuncGElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEFuncRElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEGaussianBlurElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEImageElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEMergeElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEMergeNodeElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEMorphologyElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEOffsetElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFEPointLightElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFESpecularLightingElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFESpotLightElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFETileElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFETurbulenceElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFilterElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFontElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFontFaceElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFontFaceFormatElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFontFaceNameElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFontFaceSrcElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGFontFaceUriElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGForeignObjectElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGGElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGGeometryElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGGlyphElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGGlyphRefElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGGradientElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGGraphicsElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGHKernElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGImageElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGLengthList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGLineElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGLinearGradientElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGMPathElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGMarkerElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGMaskElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGMetadataElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGMissingGlyphElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGNumberList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPaint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSeg&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegArcAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegArcRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegClosePath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoCubicAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoCubicRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoCubicSmoothAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoCubicSmoothRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoQuadraticAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoQuadraticRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoQuadraticSmoothAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegCurvetoQuadraticSmoothRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegLinetoAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegLinetoHorizontalAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegLinetoHorizontalRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegLinetoRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegLinetoVerticalAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegLinetoVerticalRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegMovetoAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPathSegMovetoRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPatternElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPointList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPolygonElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPolylineElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGPreserveAspectRatio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGRadialGradientElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGRectElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGRenderingIntent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGSVGElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGScriptElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGSetElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGStopElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGStringList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGStyleElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGSwitchElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGSymbolElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTRefElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTSpanElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTextContentElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTextElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTextPathElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTextPositioningElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTitleElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGTransformList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGUnitTypes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGUseElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGVKernElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGViewElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGViewSpec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGZoomAndPan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVGZoomEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ANGLETYPE_DEG&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ANGLETYPE_GRAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ANGLETYPE_RAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ANGLETYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ANGLETYPE_UNSPECIFIED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_CHANNEL_A&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_CHANNEL_B&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_CHANNEL_G&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_CHANNEL_R&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_CHANNEL_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_COLORTYPE_CURRENTCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_COLORTYPE_RGBCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_COLORTYPE_RGBCOLOR_ICCCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_COLORTYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_EDGEMODE_DUPLICATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_EDGEMODE_NONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_EDGEMODE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_EDGEMODE_WRAP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_COLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_COLOR_BURN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_COLOR_DODGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_DARKEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_DIFFERENCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_EXCLUSION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_HARD_LIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_HUE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_LIGHTEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_LUMINOSITY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_MULTIPLY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_NORMAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_OVERLAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_SATURATION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_SCREEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_SOFT_LIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FEBLEND_MODE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOLORMATRIX_TYPE_HUEROTATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOLORMATRIX_TYPE_MATRIX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOLORMATRIX_TYPE_SATURATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOLORMATRIX_TYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPONENTTRANSFER_TYPE_GAMMA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPONENTTRANSFER_TYPE_LINEAR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPONENTTRANSFER_TYPE_TABLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPOSITE_OPERATOR_ARITHMETIC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPOSITE_OPERATOR_ATOP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPOSITE_OPERATOR_IN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPOSITE_OPERATOR_OUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPOSITE_OPERATOR_OVER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPOSITE_OPERATOR_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_FECOMPOSITE_OPERATOR_XOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_INVALID_VALUE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_CM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_EMS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_EXS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_IN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_MM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_NUMBER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_PC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_PERCENTAGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_PT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_PX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_LENGTHTYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MARKERUNITS_STROKEWIDTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MARKERUNITS_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MARKERUNITS_USERSPACEONUSE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MARKER_ORIENT_ANGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MARKER_ORIENT_AUTO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MARKER_ORIENT_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MASKTYPE_ALPHA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MASKTYPE_LUMINANCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MATRIX_NOT_INVERTABLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MEETORSLICE_MEET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MEETORSLICE_SLICE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MEETORSLICE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MORPHOLOGY_OPERATOR_DILATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MORPHOLOGY_OPERATOR_ERODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_MORPHOLOGY_OPERATOR_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_CURRENTCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_NONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_RGBCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_URI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_URI_CURRENTCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_URI_NONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_URI_RGBCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_NONE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMAXYMAX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMAXYMID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMAXYMIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMIDYMAX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMIDYMID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMIDYMIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMINYMAX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMINYMID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_PRESERVEASPECTRATIO_XMINYMIN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_SPREADMETHOD_PAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_SPREADMETHOD_REFLECT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_SPREADMETHOD_REPEAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_SPREADMETHOD_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_STITCHTYPE_NOSTITCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_STITCHTYPE_STITCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_STITCHTYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TRANSFORM_MATRIX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TRANSFORM_ROTATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TRANSFORM_SCALE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TRANSFORM_SKEWX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TRANSFORM_SKEWY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TRANSFORM_TRANSLATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TRANSFORM_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TURBULENCE_TYPE_FRACTALNOISE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TURBULENCE_TYPE_TURBULENCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_TURBULENCE_TYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_UNIT_TYPE_OBJECTBOUNDINGBOX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_UNIT_TYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_UNIT_TYPE_USERSPACEONUSE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_WRONG_TYPE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ZOOMANDPAN_DISABLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ZOOMANDPAN_MAGNIFY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SVG_ZOOMANDPAN_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SYNC_CONDITION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SYNC_FENCE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SYNC_FLAGS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SYNC_FLUSH_COMMANDS_BIT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SYNC_GPU_COMMANDS_COMPLETE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SYNC_STATUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SYNTAX_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SavedPages&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Screen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ScreenOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Script&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ScriptProcessorNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ScrollAreaEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SecurityPolicyViolationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Selection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Sensor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SensorErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ServiceWorker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ServiceWorkerContainer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ServiceWorkerRegistration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SessionDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Set&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ShadowRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SharedArrayBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SharedWorker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SimpleGestureEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SourceBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SourceBufferList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SpeechSynthesis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SpeechSynthesisErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SpeechSynthesisEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SpeechSynthesisUtterance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SpeechSynthesisVoice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StaticRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StereoPannerNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StopIteration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Storage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StorageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StorageManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;String&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StructType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StylePropertyMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StylePropertyMapReadOnly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StyleSheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;StyleSheetList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SubmitEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SubtleCrypto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Symbol&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SyncManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;SyntaxError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEMPORARY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTPATH_METHODTYPE_ALIGN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTPATH_METHODTYPE_STRETCH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTPATH_METHODTYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTPATH_SPACINGTYPE_AUTO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTPATH_SPACINGTYPE_EXACT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTPATH_SPACINGTYPE_UNKNOWN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE0&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE10&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE11&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE12&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE13&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE14&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE15&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE17&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE18&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE19&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE20&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE21&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE22&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE23&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE24&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE25&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE26&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE27&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE28&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE29&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE30&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE31&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE6&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE9&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_2D_ARRAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_BASE_LEVEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_BINDING_2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_BINDING_2D_ARRAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_BINDING_3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_BINDING_CUBE_MAP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_COMPARE_FUNC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_COMPARE_MODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_CUBE_MAP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_CUBE_MAP_NEGATIVE_X&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_CUBE_MAP_NEGATIVE_Y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_CUBE_MAP_NEGATIVE_Z&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_CUBE_MAP_POSITIVE_X&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_CUBE_MAP_POSITIVE_Y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_CUBE_MAP_POSITIVE_Z&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_IMMUTABLE_FORMAT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_IMMUTABLE_LEVELS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_MAG_FILTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_MAX_ANISOTROPY_EXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_MAX_LEVEL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_MAX_LOD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_MIN_FILTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_MIN_LOD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_WRAP_R&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_WRAP_S&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXTURE_WRAP_T&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TEXT_NODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TIMEOUT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TIMEOUT_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TIMEOUT_EXPIRED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TIMEOUT_IGNORED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TOO_LARGE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSACTION_INACTIVE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_ACTIVE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_BUFFER_MODE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_BUFFER_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_BUFFER_START&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_PAUSED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRANSFORM_FEEDBACK_VARYINGS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRIANGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRIANGLES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRIANGLE_FAN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TRIANGLE_STRIP&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_BACK_FORWARD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_MISMATCH_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_NAVIGATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_RELOAD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_RESERVED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Table&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TaskAttributionTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Text&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextDecoder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextDecoderStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextEncoder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextEncoderStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextMetrics&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextTrackCue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextTrackCueList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TextTrackList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TimeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TimeRanges&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Touch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TouchEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TouchList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TrackEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TransformStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TransitionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TreeWalker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TrustedHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TrustedScript&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TrustedScriptURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TrustedTypePolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TrustedTypePolicyFactory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TypeError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TypedObject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;U2F&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UIEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNCACHED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_ARRAY_STRIDE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BLOCK_ACTIVE_UNIFORMS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BLOCK_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BLOCK_DATA_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BLOCK_INDEX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BUFFER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BUFFER_OFFSET_ALIGNMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BUFFER_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_BUFFER_START&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_IS_ROW_MAJOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_MATRIX_STRIDE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_OFFSET&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNIFORM_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNKNOWN_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNKNOWN_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNMASKED_RENDERER_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNMASKED_VENDOR_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNORDERED_NODE_ITERATOR_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNORDERED_NODE_SNAPSHOT_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_ALIGNMENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_FLIP_Y_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_IMAGE_HEIGHT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_PREMULTIPLY_ALPHA_WEBGL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_ROW_LENGTH&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_SKIP_IMAGES&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_SKIP_PIXELS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNPACK_SKIP_ROWS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSCHEDULED_STATE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSENT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNALED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_BYTE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_10F_11F_11F_REV&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_24_8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_2_10_10_10_REV&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_5_9_9_9_REV&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_SAMPLER_2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_SAMPLER_2D_ARRAY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_SAMPLER_3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_SAMPLER_CUBE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_VEC2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_VEC3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_INT_VEC4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_NORMALIZED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_SHORT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_SHORT_4_4_4_4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_SHORT_5_5_5_1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSIGNED_SHORT_5_6_5&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UNSPECIFIED_EVENT_TYPE_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UPDATEREADY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;URIError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;URL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;URLSearchParams&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;URLUnencoded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;URL_MISMATCH_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBAlternateInterface&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBConfiguration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBConnectionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBDevice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBEndpoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBInTransferResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBInterface&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBIsochronousInTransferPacket&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBIsochronousInTransferResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBIsochronousOutTransferPacket&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBIsochronousOutTransferResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;USBOutTransferResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UTC&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Uint16Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Uint32Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Uint8Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Uint8ClampedArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UserActivation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UserMessageHandler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UserMessageHandlersNamespace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;UserProximityEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VALIDATE_STATUS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VALIDATION_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VARIABLES_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VENDOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERSION&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERSION_CHANGE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERSION_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ARRAY_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_BUFFER_BINDING&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_DIVISOR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_ENABLED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_INTEGER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_NORMALIZED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_POINTER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_SIZE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_STRIDE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_ATTRIB_ARRAY_TYPE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTEX_SHADER&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTICAL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VERTICAL_AXIS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VER_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VIEWPORT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VIEWPORT_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VRDisplay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VRDisplayCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VRDisplayEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VREyeParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VRFieldOfView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VRFrameData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VRPose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VRStageParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VTTCue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VTTRegion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ValidityState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VideoPlaybackQuality&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VideoStreamTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;VisualViewport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WAIT_FAILED&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WEBKIT_FILTER_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WEBKIT_KEYFRAMES_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WEBKIT_KEYFRAME_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WEBKIT_REGION_RULE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WRONG_DOCUMENT_ERR&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WakeLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WakeLockSentinel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WasmAnyRef&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WaveShaperNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WeakMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WeakRef&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WeakSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebAssembly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGL2RenderingContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLActiveInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLContextEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLProgram&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLRenderbuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLRenderingContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLSampler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLShader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLShaderPrecisionFormat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLTexture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLUniformLocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLVertexArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebGLVertexArrayObject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitAnimationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitBlobBuilder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitCSSFilterRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitCSSFilterValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitCSSKeyframeRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitCSSKeyframesRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitCSSMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitCSSRegionRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitCSSTransformValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitDataCue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitGamepad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitMediaKeyError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitMediaKeyMessageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitMediaKeySession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitMediaKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitMediaSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitMutationObserver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitNamespace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitPlaybackTargetAvailabilityEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitShadowRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitSourceBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitSourceBufferList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebKitTransitionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebSocket&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAlignContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAlignItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAlignSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationFillMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationIterationCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationPlayState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAnimationTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitAppearance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBackfaceVisibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBackgroundClip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBackgroundOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBackgroundSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBorderBottomLeftRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBorderBottomRightRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBorderImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBorderRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBorderTopLeftRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBorderTopRightRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxFlex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxOrdinalGroup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxOrient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxPack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitBoxSizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFlex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFlexBasis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFlexDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFlexFlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFlexGrow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFlexShrink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitFlexWrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitJustifyContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitLineClamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskClip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskComposite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskPositionX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskPositionY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskRepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitMaskSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitOrder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitPerspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitPerspectiveOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTextFillColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTextSizeAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTextStroke&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTextStrokeColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTextStrokeWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransformOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransformStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransitionDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransitionDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransitionProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitTransitionTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WebkitUserSelect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WheelEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Window&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Worker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Worklet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WritableStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;WritableStreamDefaultWriter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLHttpRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLHttpRequestEventTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLHttpRequestException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLHttpRequestProgressEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLHttpRequestUpload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLSerializer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XMLStylesheetProcessingInstruction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XPathEvaluator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XPathException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XPathExpression&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XPathNSResolver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XPathResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRBoundedReferenceSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRDOMOverlayState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRHitTestResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRHitTestSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRInputSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRInputSourceArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRInputSourceEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRInputSourcesChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRLayer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRPose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRRay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRReferenceSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRReferenceSpaceEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRRenderState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRRigidTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRSession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRSessionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRSystem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRTransientInputHitTestResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRTransientInputHitTestSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRViewerPose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRViewport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XRWebGLLayer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;XSLTProcessor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ZERO&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;_XD0M_&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;_YD0M_&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;__defineGetter__&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;__defineSetter__&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;__lookupGetter__&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;__lookupSetter__&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;__opera&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;__proto__&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;_browserjsran&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;a&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;aLink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;abbr&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;abort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;aborted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;abs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;absolute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;acceleration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;accelerationIncludingGravity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;accelerator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;accept&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;acceptCharset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;acceptNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;accessKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;accessKeyLabel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;accuracy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;acos&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;acosh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;action&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;actionURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;actions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;activated&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;active&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;activeCues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;activeElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;activeSourceBuffers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;activeSourceCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;activeTexture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;activeVRDisplays&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;actualBoundingBoxAscent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;actualBoundingBoxDescent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;actualBoundingBoxLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;actualBoundingBoxRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;add&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addBehavior&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addCandidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addColorStop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addCue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addEventListener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addFromString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addFromUri&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addIceCandidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addImport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addListener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addModule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addNamed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addPageRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addPointer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addRegion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addSearchEngine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addSourceBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addTextTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addTransceiver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addWakeLockListener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;added&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addedNodes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;additionalName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;additiveSymbols&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addons&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;address&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;addressLine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;adoptNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;adoptedStyleSheets&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;adr&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;advance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;after&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;album&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alert&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;algorithm&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;align&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;align-content&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;align-items&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;align-self&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alignContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alignItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alignSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alignmentBaseline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alinkColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;all&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allSettled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allowFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allowPaymentRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allowedDirections&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allowedFeatures&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allowedToPlay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;allowsFeature&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alpha&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;altGraphKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;altHtml&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;altKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;altLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alternate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alternateSetting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;alternates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;altitude&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;altitudeAccuracy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;amplitude&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ancestorOrigins&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;anchor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;anchorNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;anchorOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;anchors&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;and&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;angle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;angularAcceleration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;angularVelocity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animVal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animatedInstanceRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animatedNormalizedPathSegList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animatedPathSegList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animatedPoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-delay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-duration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-fill-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-iteration-count&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-name&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-play-state&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animation-timing-function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationFillMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationIterationCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationPlayState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationStartTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;animationsPaused&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;anniversary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;antialias&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;anticipatedRemoval&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;any&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;app&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appCodeName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appMinorVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appNotifications&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appearance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;append&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendChild&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendMedium&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendNamed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendWindowEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;appendWindowStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;applets&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;applicationCache&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;applicationServerKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;apply&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;applyConstraints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;applyElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;arc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;arcTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;architecture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;archive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;areas&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;arguments&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaAtomic&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaAutoComplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaBusy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaChecked&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaColCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaColIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaColSpan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaCurrent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaDisabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaExpanded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaHasPopup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaHidden&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaKeyShortcuts&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaLabel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaLevel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaLive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaModal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaMultiLine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaMultiSelectable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaPlaceholder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaPosInSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaPressed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaReadOnly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaRelevant&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaRequired&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaRoleDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaRowCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaRowIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaRowSpan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaSelected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaSetSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaSort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaValueMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaValueMin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaValueNow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ariaValueText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;arrayBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;artist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;artwork&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;as&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;asIntN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;asUintN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;asin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;asinh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;assert&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;assign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;assignedElements&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;assignedNodes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;assignedSlot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;async&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;asyncIterator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;atEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;atan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;atan2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;atanh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;atob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attachEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attachInternals&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attachShader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attachShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attachments&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attestationObject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attrChange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attrName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attributeFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attributeName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attributeNamespace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attributeOldValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attributeStyleMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attributes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;attribution&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;audioBitsPerSecond&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;audioTracks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;audioWorklet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;authenticatedSignedWrites&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;authenticatorData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;autoIncrement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;autobuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;autocapitalize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;autocomplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;autocorrect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;autofocus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;automationRate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;autoplay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;availHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;availLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;availTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;availWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;availability&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;available&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;aversion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;axes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;axis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;azimuth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;b&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;back&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backface-visibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backfaceVisibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-attachment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-blend-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-clip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-position-x&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-position-y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-repeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;background-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundAttachment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundBlendMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundClip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundFetch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundPositionX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundPositionY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundRepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;backgroundSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;badInput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;badge&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;balance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseFrequencyX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseFrequencyY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseLatency&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseLayer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baseVal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;baselineShift&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;battery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bday&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;before&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;beginElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;beginElementAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;beginPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;beginQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;beginTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;behavior&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;behaviorCookie&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;behaviorPart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;behaviorUrns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;beta&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bezierCurveTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bgColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bgProperties&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bias&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;big&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bigint64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;biguint64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;binaryType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bind&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindAttribLocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindBufferBase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindBufferRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindRenderbuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindSampler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindTexture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bindVertexArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bitness&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blendColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blendEquation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blendEquationSeparate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blendFunc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blendFuncSeparate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blitFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;block-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blockDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blockSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blockedURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bluetooth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;blur&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;body&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bodyUsed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bold&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bookmarks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;booleanValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-end-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-end-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-end-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-start-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-start-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-start-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-block-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-bottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-bottom-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-bottom-left-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-bottom-right-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-bottom-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-bottom-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-collapse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-end-end-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-end-start-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-image-outset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-image-repeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-image-slice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-image-source&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-image-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-end-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-end-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-end-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-start-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-start-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-start-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-inline-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-left&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-left-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-left-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-left-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-right&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-right-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-right-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-right-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-spacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-start-end-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-start-start-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-top&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-top-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-top-left-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-top-right-radius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-top-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-top-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;border-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockEndColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockEndStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockEndWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockStartColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockStartStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockStartWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBlockWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBottomColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBottomStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBottomWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderBoxSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderCollapse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderColorDark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderColorLight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderEndEndRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderEndStartRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderImageOutset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderImageRepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderImageSlice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderImageSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderImageWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineEndColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineEndStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineEndWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineStartColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineStartStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineStartWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderInlineWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderLeftColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderLeftStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderLeftWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderRightColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderRightStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderRightWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderSpacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderStartEndRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderStartStartRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderTopColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderTopStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderTopWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;borderWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bottomMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bound&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boundElements&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boundingClientRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boundingHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boundingLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boundingTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boundingWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bounds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boundsGeometry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;box-decoration-break&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;box-shadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;box-sizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boxDecorationBreak&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boxShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;boxSizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;brand&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;brands&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;break-after&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;break-before&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;break-inside&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;breakAfter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;breakBefore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;breakInside&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;broadcast&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;browserLanguage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;btoa&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bubbles&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;buffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bufferData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bufferDepth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bufferSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bufferSubData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;buffered&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bufferedAmount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bufferedAmountLowThreshold&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;buildID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;buildNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;button&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;buttonID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;buttons&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;byteLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;byteOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;bytesWritten&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;c&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cache&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caches&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;call&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caller&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canBeFormatted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canBeMounted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canBeShared&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canHaveChildren&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canHaveHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canInsertDTMF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canMakePayment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canPlayType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canPresent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canTrickleIceCandidates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelAndHoldAtTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelBubble&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelIdleCallback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelScheduledValues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelVideoFrameCallback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelWatchAvailability&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cancelable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;candidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canonicalUUID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;canvas&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;capabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caption&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caption-side&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;captionSide&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;capture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;captureEvents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;captureStackTrace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;captureStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caret-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caretBidiLevel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caretColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caretPositionFromPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;caretRangeFromPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cast&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;catch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;category&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cbrt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ceil&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cellIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cellPadding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cellSpacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cells&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;chOff&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;chain&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;challenge&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;changeType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;changedTouches&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;channel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;channelCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;channelCountMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;channelInterpretation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;char&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;charAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;charCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;charCodeAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;charIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;charLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;characterData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;characterDataOldValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;characterSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;characteristic&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;charging&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;chargingTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;charset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;check&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;checkEnclosure&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;checkFramebufferStatus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;checkIntersection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;checkValidity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;checked&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;childElementCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;childList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;childNodes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;children&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;chrome&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ciphertext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;city&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;claimInterface&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;claimed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;classList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;className&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;classid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearAppBadge&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearAttributes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearBufferfi&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearBufferfv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearBufferiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearBufferuiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearDepth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearHalt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearImmediate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearInterval&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearLiveSeekableRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearMarks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearMaxGCPauseAccumulator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearMeasures&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearResourceTimings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearStencil&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearTimeout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clearWatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;click&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clickCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientDataJSON&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientInformation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientRects&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientWaitSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clientY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clip-path&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clip-rule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipPathUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipboard&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clipboardData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cloneContents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cloneNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cloneRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;close&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;closePath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;closed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;closest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clz&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;clz32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cm&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cmp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;code&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;codeBase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;codePointAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;codeType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colSpan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;collapse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;collapseToEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;collapseToStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;collapsed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;collect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colno&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;color-adjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;color-interpolation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;color-interpolation-filters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colorAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colorDepth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colorInterpolation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colorInterpolationFilters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colorMask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;colorType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cols&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-count&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-fill&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-gap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-rule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-rule-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-rule-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-rule-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-span&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;column-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnFill&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnGap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnRuleColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnRuleStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnRuleWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnSpan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columnWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;columns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;command&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;commit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;commitPreferences&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;commitStyles&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;commonAncestorContainer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compact&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compareBoundaryPoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compareDocumentPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compareEndPoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compareExchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compareNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;comparePoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compatMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compatible&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compileShader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compileStreaming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;complete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;component&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;componentFromPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;composed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;composedPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;composite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compositionEndOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compositionStartOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compressedTexImage2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compressedTexImage3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compressedTexSubImage2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;compressedTexSubImage3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;computedStyleMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;concat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;conditionText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;coneInnerAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;coneOuterAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;coneOuterGain&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;configurable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;configuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;configurationName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;configurationValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;configurations&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;confirm&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;confirmComposition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;confirmSiteSpecificTrackingException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;confirmWebWideTrackingException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connectEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connectShark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connectStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connectionList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connectionSpeed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connectionState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;connections&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;console&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;consolidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;constraint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;constrictionActive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;construct&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;constructor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contactID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contain&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;containerId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;containerName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;containerSrc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;containerType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contains&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;containsNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;content&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentBoxSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentEditable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentHint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentOverflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentScriptType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentStyleType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contentWindow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;context&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contextMenu&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;contextmenu&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;continue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;continuePrimaryKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;continuous&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;control&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;controlTransferIn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;controlTransferOut&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;controller&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;controls&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;controlsList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;convertPointFromNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;convertQuadFromNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;convertRectFromNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;convertToBlob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;convertToSpecifiedUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cookie&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cookieEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;coords&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;copyBufferSubData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;copyFromChannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;copyTexImage2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;copyTexSubImage2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;copyTexSubImage3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;copyToChannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;copyWithin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;correspondingElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;correspondingUseElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;corruptedVideoFrames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cos&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cosh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;count&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;countReset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;counter-increment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;counter-reset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;counter-set&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;counterIncrement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;counterReset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;counterSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;country&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cpuClass&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cpuSleepAllowed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;create&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createAnalyser&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createAnswer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createAttribute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createAttributeNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createBiquadFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createBufferSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createCDATASection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createCSSStyleSheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createCaption&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createChannelMerger&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createChannelSplitter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createComment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createConstantSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createContextualFragment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createControlRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createConvolver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDTMFSender&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDataChannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDelayNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDocumentFragment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDocumentType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createDynamicsCompressor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createElementNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createEntityReference&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createEventObject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createExpression&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createGain&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createGainNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createHTMLDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createIIRFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createImageBitmap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createImageData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createJavaScriptNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createLinearGradient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createMediaElementSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createMediaKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createMediaStreamDestination&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createMediaStreamSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createMediaStreamTrackSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createMutableFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createNSResolver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createNodeIterator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createNotification&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createObjectStore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createObjectURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createOffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createOscillator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createPanner&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createPattern&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createPeriodicWave&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createPolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createPopup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createProcessingInstruction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createProgram&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createRadialGradient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createRangeCollection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createReader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createRenderbuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegArcAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegArcRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegClosePath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoCubicAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoCubicRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoCubicSmoothAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoCubicSmoothRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoQuadraticAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoQuadraticRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoQuadraticSmoothAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegCurvetoQuadraticSmoothRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegLinetoAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegLinetoHorizontalAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegLinetoHorizontalRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegLinetoRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegLinetoVerticalAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegLinetoVerticalRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegMovetoAbs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPathSegMovetoRel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSVGTransformFromMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSampler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createScript&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createScriptProcessor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createScriptURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createSession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createShader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createShadowRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createStereoPanner&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createStyleSheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTBody&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTFoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTHead&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTextNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTextRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTexture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTouch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTouchList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createTreeWalker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createVertexArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;createWaveShaper&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;creationTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;credentials&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;crossOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;crossOriginIsolated&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;crypto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;csi&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;csp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cssFloat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cssRules&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cssText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cssValueType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ctrlKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ctrlLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cullFace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentLocalDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentPage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentRemoteDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentScale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentScript&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentSrc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentTranslate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;currentView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cursor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;curve&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;customElements&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;customError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cx&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;cy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;d&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataFld&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataFormatAs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataLoss&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataLossMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataPageSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataSrc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataTransfer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;database&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;databases&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dataset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dateTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;db&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;debug&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;debuggerEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;declare&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decodeAudioData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decodeURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decodeURIComponent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decodedBodySize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decoding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decodingInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;decrypt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;default&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultCharset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultChecked&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultMuted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultPlaybackRate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultPolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultPrevented&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultSelected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultStatus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defaultstatus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;define&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defineMagicFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defineMagicVariable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defineProperties&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;defineProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deg&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delayTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delegatesFocus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteCaption&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteCell&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteContents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteDatabase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteFromDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteMedium&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteObjectStore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteProgram&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteRenderbuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteRow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteSampler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteShader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteTFoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteTHead&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteTexture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deleteVertexArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deliverChangeRecords&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delivery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deliveryInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deliveryStatus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deliveryTimestamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;delta&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deltaMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deltaX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deltaY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deltaZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dependentLocality&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;depthFar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;depthFunc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;depthMask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;depthNear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;depthRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deref&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deriveBits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deriveKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;description&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deselectAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;designMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;desiredSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;destination&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;destinationURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;detach&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;detachEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;detachShader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;detail&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;details&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;detect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;detune&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;device&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceClass&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceMemory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;devicePixelContentBoxSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;devicePixelRatio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceProtocol&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceSubclass&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceVersionMajor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceVersionMinor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceVersionSubminor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceXDPI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;deviceYDPI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;didTimeout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;diffuseConstant&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;digest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dimensions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dir&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dirName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dirxml&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disablePictureInPicture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disableRemotePlayback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disableVertexAttribArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dischargingTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disconnect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disconnectShark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dispatchEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;display&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;displayId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;displayName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;disposition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;distanceModel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;div&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;divisor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;djsapi&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;djsproxy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;doImport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;doNotTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;doScroll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;doctype&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;document&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;documentElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;documentMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;documentURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dolphin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dolphinGameCenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dolphininfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dolphinmeta&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domComplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domContentLoadedEventEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domContentLoadedEventStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domInteractive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domLoading&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domOverlayState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domain&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domainLookupEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;domainLookupStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dominant-baseline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dominantBaseline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;done&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dopplerFactor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dotAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;downDegrees&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;downlink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;download&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;downloadTotal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;downloaded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dpcm&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dpi&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dppx&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dragDrop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;draggable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawArrays&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawArraysInstanced&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawArraysInstancedANGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawBuffers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawCustomFocusRing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawElements&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawElementsInstanced&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawElementsInstancedANGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawFocusIfNeeded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawImageFromRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawRangeElements&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawSystemFocusRing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawingBufferHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;drawingBufferWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dropEffect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;droppedVideoFrames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dropzone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dtmf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dump&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dumpProfile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;duplicate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;durability&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;duration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dvname&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dvnum&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dx&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dynsrc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;e&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;edgeMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;effect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;effectAllowed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;effectiveDirective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;effectiveType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;elapsedTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;element&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;elementFromPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;elementTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;elements&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;elementsFromPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;elevation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ellipse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;em&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;email&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;embeds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;emma&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;empty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;empty-cells&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;emptyCells&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;emptyHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;emptyScript&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;emulatedPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enableBackground&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enableDelegations&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enableStyleSheetsForSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enableVertexAttribArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enabledPlugin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encodeInto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encodeURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encodeURIComponent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encodedBodySize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encoding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encodingInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;encrypt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enctype&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endContainer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endElementAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endOfStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ended&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endpoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endpointNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endpoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;endsWith&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enterKeyHint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;entities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;entries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;entryType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enumerable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enumerate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enumerateDevices&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;enumerateEditable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;environmentBlendMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;equals&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;error&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;errorCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;errorDetail&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;errorText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;escape&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;estimate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;eval&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;evaluate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;event&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;eventPhase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;every&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exception&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exec&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;execCommand&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;execCommandShowHelp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;execScript&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exitFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exitPictureInPicture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exitPointerLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exitPresent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expand&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expandEntityReferences&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expando&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expansion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expiration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expirationTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expires&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expiryDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;explicitOriginalTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;expm1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exponent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exponentialRampToValueAtTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exportKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;exports&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;extend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;extensions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;extentNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;extentOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;external&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;externalResourcesRequired&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;extractContents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;extractable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;eye&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;face&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;factoryReset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;failureReason&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fallback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;family&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;familyName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;farthestViewportElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fastSeek&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fatal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;featureId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;featurePolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;featureSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;features&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fenceSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fetch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fetchStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fftSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fgColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fieldOfView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;file&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fileCreatedDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fileHandle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fileModifiedDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fileName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fileSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fileUpdatedDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;filename&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;files&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;filesystem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fill&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fill-opacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fill-rule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fillLightMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fillOpacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fillRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fillRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fillStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fillText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;filter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;filterResX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;filterResY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;filterUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;filters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;finally&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;find&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;findIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;findRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;findText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;finish&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;finished&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fireEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;firesTouchEvents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;firstChild&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;firstElementChild&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;firstPage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fixed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flags&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flatMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flex-basis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flex-direction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flex-flow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flex-grow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flex-shrink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flex-wrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flexBasis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flexDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flexFlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flexGrow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flexShrink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flexWrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flipX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flipY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;float&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;float32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;float64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flood-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flood-opacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;floodColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;floodOpacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;floor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;flush&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;focus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;focusNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;focusOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-family&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-feature-settings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-kerning&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-language-override&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-optical-sizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-size-adjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-stretch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-synthesis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variant&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variant-alternates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variant-caps&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variant-east-asian&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variant-ligatures&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variant-numeric&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variant-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-variation-settings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;font-weight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontFamily&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontFeatureSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontKerning&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontLanguageOverride&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontOpticalSizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontSizeAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontSmoothingEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontStretch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontSynthesis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariant&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariantAlternates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariantCaps&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariantEastAsian&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariantLigatures&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariantNumeric&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariantPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontVariationSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontWeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontcolor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontfaces&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fonts&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fontsize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;for&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;forEach&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;force&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;forceRedraw&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;form&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;formAction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;formData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;formEnctype&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;formMethod&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;formNoValidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;formTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;format&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;formatToParts&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;forms&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;forward&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;forwardX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;forwardY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;forwardZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;foundation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fr&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fragmentDirective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frameBorder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frameElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frameSpacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;framebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;framebufferHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;framebufferRenderbuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;framebufferTexture2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;framebufferTextureLayer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;framebufferWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;freeSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;freeze&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frequency&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frequencyBinCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;from&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromCharCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromCodePoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromEntries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromFloat32Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromFloat64Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromQuad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fromRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;frontFace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fround&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fullPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fullVersionList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fullscreenElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fullscreenEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fx&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;fy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gain&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gamepad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gamma&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gatheringState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gatt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;genderIdentity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;generateCertificate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;generateKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;generateMipmap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;generateRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;geolocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gestureObject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;get&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getActiveAttrib&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getActiveUniform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getActiveUniformBlockName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getActiveUniformBlockParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getActiveUniforms&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAdjacentText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAllKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAllResponseHeaders&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAllowlistForFeature&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAnimations&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAsFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAsString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttachedShaders&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttribLocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttribute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttributeNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttributeNames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttributeNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttributeNodeNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAttributeType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAudioTracks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getAvailability&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBBox&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBattery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBigInt64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBigUint64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBlob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBookmark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBoundingClientRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBounds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBoxQuads&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBufferParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getBufferSubData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getByteFrequencyData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getByteTimeDomainData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCSSCanvasContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCTM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCandidateWindowClientRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCanonicalLocales&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getChannelData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCharNumAtPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCharacteristic&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCharacteristics&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getClientExtensionResults&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getClientRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getClientRects&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCoalescedEvents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCompositionAlternatives&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getComputedStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getComputedTextLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getComputedTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getConfiguration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getConstraints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getContextAttributes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getContributingSources&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCounterValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCueAsHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCueById&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCurrentPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getCurrentTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDatabaseNames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDefaultComputedStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDescriptor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDescriptors&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDestinationInsertionPoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDevices&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDirectory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDisplayMedia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getDistributedNodes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getEditable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getElementById&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getElementsByClassName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getElementsByName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getElementsByTagName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getElementsByTagNameNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getEnclosureList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getEndPositionOfChar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getEntries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getEntriesByName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getEntriesByType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getExtension&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getExtentOfChar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getEyeParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFeature&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFiles&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFilesAndDirectories&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFingerprints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFloat32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFloat64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFloatFrequencyData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFloatTimeDomainData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFloatValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFragDataLocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFrameData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFramebufferAttachmentParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFrequencyResponse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getFullYear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getGamepads&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getHighEntropyValues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getHitTestResults&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getHitTestResultsForTransientInput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getHours&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getIdentityAssertion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getIds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getImageData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getIndexedParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getInstalledRelatedApps&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getInt16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getInt32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getInt8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getInternalformatParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getIntersectionList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getKeyframes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getLayers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getLayoutMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getLineDash&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getLocalCandidates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getLocalParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getLocalStreams&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMarks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMatchedCSSRules&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMaxGCPauseSinceClear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMeasures&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMetadata&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMilliseconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMinutes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getModifierState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getMonth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getNamedItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getNamedItemNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getNativeFramebufferScaleFactor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getNotifications&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getNotifier&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getNumberOfChars&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOffsetReferenceSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOutputTimestamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOverrideHistoryNavigationMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOverrideStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOwnPropertyDescriptor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOwnPropertyDescriptors&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOwnPropertyNames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getOwnPropertySymbols&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getParent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPathSegAtLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPhotoCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPhotoSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPointAtLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPredictedEvents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPreference&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPreferenceDefault&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPresentationAttribute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPreventDefault&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPrimaryService&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPrimaryServices&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getProgramInfoLog&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getProgramParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPropertyCSSValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPropertyPriority&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPropertyShorthand&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPropertyType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPropertyValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getPrototypeOf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getQueryParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRGBColorValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRandomValues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRangeAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getReader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getReceivers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRectValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRegistration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRegistrations&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRemoteCandidates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRemoteCertificates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRemoteParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRemoteStreams&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRenderbufferParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getResponseHeader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRootNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getRotationOfChar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSVGDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSamplerParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getScreenCTM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSeconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSelectedCandidatePair&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSelection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSenders&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getService&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getShaderInfoLog&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getShaderParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getShaderPrecisionFormat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getShaderSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSimpleDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSiteIcons&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSources&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSpeculativeParserUrls&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getStartPositionOfChar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getStartTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getStats&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getStatusForPolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getStorageUpdates&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getStreamById&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getStringValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSubStringLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSubscription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSupportedConstraints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSupportedExtensions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSupportedFormats&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSyncParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getSynchronizationSources&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTags&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTargetRanges&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTexParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTimezoneOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTotalLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTrackById&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTracks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTransceivers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTransformFeedbackVarying&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTransformToElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTransports&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getTypeMapping&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCDay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCFullYear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCHours&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCMilliseconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCMinutes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCMonth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUTCSeconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUint16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUint32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUint8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUniform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUniformBlockIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUniformIndices&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUniformLocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getUserMedia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVRDisplays&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getValues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVarDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVariableValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVertexAttrib&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVertexAttribOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVideoPlaybackQuality&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVideoTracks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getViewerPose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getViewport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getVoices&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getWakeLockState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getWriter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;getYear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;givenName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;global&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;globalAlpha&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;globalCompositeOperation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;globalThis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;glyphOrientationHorizontal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;glyphOrientationVertical&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;glyphRef&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;go&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grabFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gradientTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gradientUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grammars&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;green&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-area&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-auto-columns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-auto-flow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-auto-rows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-column&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-column-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-column-gap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-column-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-gap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-row&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-row-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-row-gap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-row-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-template&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-template-areas&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-template-columns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;grid-template-rows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridArea&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridAutoColumns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridAutoFlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridAutoRows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridColumn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridColumnEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridColumnGap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridColumnStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridGap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridRow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridRowEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridRowGap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridRowStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridTemplate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridTemplateAreas&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridTemplateColumns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gridTemplateRows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;gripSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;group&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;groupCollapsed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;groupEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;groupId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hadRecentInput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hand&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;handedness&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hapticActuators&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hardwareConcurrency&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;has&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasAttribute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasAttributeNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasAttributes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasBeenActive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasChildNodes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasComposition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasEnrolledInstrument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasExtension&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasExternalDisplay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasFeature&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasFocus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasInstance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasLayout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasOwnProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasPointerCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasReading&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hasStorageAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hash&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;head&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;headers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;heading&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;height&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hidden&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hide&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hideFocus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;high&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;highWaterMark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;history&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;honorificPrefix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;honorificSuffix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;horizontalOverflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;host&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hostCandidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hostname&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;href&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hrefTranslate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hreflang&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hspace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;html5TagCheckInerface&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;htmlFor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;htmlText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;httpEquiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;httpRequestStatusCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hwTimestamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hyphens&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;hypot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iccId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iceConnectionState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iceGatheringState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iceTransport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;icon&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iconURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;id&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;identifier&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;identity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;idpLoginUrl&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ignoreBOM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ignoreCase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ignoreDepthValues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;image-orientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;image-rendering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageRendering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageSizes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageSmoothingEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageSmoothingQuality&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageSrcset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imageWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;images&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ime-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imeMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;implementation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;importKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;importNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;importStylesheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imports&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;impp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;imul&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;in&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;in1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;in2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inBandMetadataTrackDispatchType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;includes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;incremental&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;indeterminate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;index&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;indexNames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;indexOf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;indexedDB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;indicate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inert&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inertiaDestinationX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inertiaDestinationY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;info&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;init&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initAnimationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initBeforeLoadEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initClipboardEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initCloseEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initCommandEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initCompositionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initCustomEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initDataType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initDeviceMotionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initDeviceOrientationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initDragEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initErrorEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initFocusEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initGestureEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initHashChangeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initKeyEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initKeyboardEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initMSManipulationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initMessageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initMouseEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initMouseScrollEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initMouseWheelEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initMutationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initNSMouseEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initOverflowEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initPageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initPageTransitionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initPointerEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initPopStateEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initProgressEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initScrollAreaEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initSimpleGestureEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initStorageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initTextEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initTimeEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initTouchEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initTransitionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initUIEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initWebKitAnimationEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initWebKitTransitionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initWebKitWheelEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initWheelEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initialTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initialize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;initiatorType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inline-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inlineSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inlineVerticalFieldOfView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inner&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;innerHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;innerHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;innerText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;innerWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;input&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputEncoding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputMethod&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputSources&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inputs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertAdjacentElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertAdjacentHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertAdjacentText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertBefore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertCell&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertDTMF&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertItemBefore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertRow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insertRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inset-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inset-block-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inset-block-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inset-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inset-inline-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inset-inline-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insetBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insetBlockEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insetBlockStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insetInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insetInlineEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;insetInlineStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;installing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;instanceRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;instantiate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;instantiateStreaming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;instruments&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;int16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;int32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;int8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;integrity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interactionMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;intercept&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interfaceClass&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interfaceName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interfaceNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interfaceProtocol&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interfaceSubclass&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interfaces&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interimResults&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;internalSubset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interpretation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;intersectionRatio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;intersectionRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;intersectsNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;interval&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;invalidIteratorState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;invalidateFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;invalidateSubFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;inverse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;invertSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;is&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;is2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isActive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isAlternate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isBingCurrentSearchDefault&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isCandidateWindowVisible&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isChar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isCollapsed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isComposing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isConcatSpreadable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isConnected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isContentEditable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isContentHandlerRegistered&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isContextLost&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isDefaultNamespace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isDirectory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isDisabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isEqual&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isEqualNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isExtensible&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isExternalCTAP2SecurityKeySupported&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isFinite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isFramebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isFrozen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isGenerator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isHistoryNavigation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isIdentity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isInjected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isInteger&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isIntersecting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isLockFree&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isMultiLine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isNaN&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isOpen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPointInFill&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPointInPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPointInRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPointInStroke&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPrefAlternate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPresenting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPrimary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isProgram&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPropertyImplicit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isProtocolHandlerRegistered&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isPrototypeOf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isQuery&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isRenderbuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSafeInteger&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSameNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSampler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isScript&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isScriptURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSealed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSecureContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSessionSupported&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isShader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSupported&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isTextEdit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isTexture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isTrusted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isTypeSupported&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isUserVerifyingPlatformAuthenticatorAvailable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isVertexArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isVisible&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isochronousTransferIn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isochronousTransferOut&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;isolation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;italics&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;item&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;itemId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;itemProp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;itemRef&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;itemScope&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;itemType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;itemValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;items&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iterateNext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iterationComposite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;iterator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;javaEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;jobTitle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;join&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;json&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;justify-content&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;justify-items&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;justify-self&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;justifyContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;justifyItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;justifySelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;k1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;k2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;k3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;k4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;kHz&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keepalive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;kernelMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;kernelUnitLengthX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;kernelUnitLengthY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;kerning&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;key&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyFor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyIdentifier&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyLightEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyLocation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyStatuses&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keySystem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyUsage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keyboard&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;keytype&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;kind&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;knee&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;label&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;labels&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lang&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;language&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;languages&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;largeArcFlag&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastChild&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastElementChild&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastEventId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastIndexOf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastInputTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastMatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastMessageSubject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastMessageType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastModified&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastModifiedDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastPage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastParen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lastStyleSheetSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;latitude&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layerX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layerY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layoutFlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layoutGrid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layoutGridChar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layoutGridLine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layoutGridMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;layoutGridType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lbound&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;left&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;leftContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;leftDegrees&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;leftMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;leftProjectionMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;leftViewMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;length&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lengthAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lengthComputable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;letter-spacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;letterSpacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;level&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lighting-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lightingColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;limitingConeAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;line&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;line-break&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;line-height&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineBreak&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineCap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineDashOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineJoin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;linearAcceleration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;linearRampToValueAtTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;linearVelocity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lineno&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lines&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;link&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;linkColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;linkProgram&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;links&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;list&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;list-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;list-style-image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;list-style-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;list-style-type&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;listStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;listStyleImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;listStylePosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;listStyleType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;listener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loadEventEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loadEventStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loadTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loadTimes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loaded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loading&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;localDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;localName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;localService&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;localStorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;locale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;localeCompare&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;location&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;locationbar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;locked&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lockedFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;locks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;log&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;log10&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;log1p&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;log2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;logicalXDPI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;logicalYDPI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;longDesc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;longitude&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lookupNamespaceURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lookupPrefix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loopEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;loopStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;looping&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;low&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lower&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lowerBound&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lowerOpen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;lowsrc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m11&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m12&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m13&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m14&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m21&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m22&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m23&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m24&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m31&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m33&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m34&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m41&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m42&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m43&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;m44&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;makeXRCompatible&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;manifest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;manufacturer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;manufacturerName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;map&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mapping&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-block-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-block-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-bottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-inline-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-inline-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-left&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-right&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;margin-top&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginBlockEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginBlockStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginInlineEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginInlineStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marginWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marker-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marker-mid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marker-offset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marker-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;markerEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;markerHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;markerMid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;markerOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;markerStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;markerUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;markerWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;marks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-clip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-composite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-image&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-position-x&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-position-y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-repeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mask-type&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskClip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskComposite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskContentUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskPositionX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskPositionY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskRepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maskUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;match&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;matchAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;matchMedia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;matchMedium&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;matches&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;matrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;matrixTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;max&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;max-block-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;max-height&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;max-inline-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;max-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxActions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxAlternatives&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxBlockSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxChannelCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxChannels&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxConnectionsPerServer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxDecibels&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxDistance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxInlineSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxLayers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxMessageSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxPacketLifeTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxRetransmits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxTouchPoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;maxWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;measure&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;measureText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;media&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaDevices&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaGroup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaSession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mediaText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;meetOrSlice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;memory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;menubar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mergeAttributes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;message&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;messageClass&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;messageHandlers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;messageType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;metaKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;metadata&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;method&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;methodDetails&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;methodName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mimeType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mimeTypes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;min&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;min-block-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;min-height&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;min-inline-size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;min-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;minBlockSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;minDecibels&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;minHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;minInlineSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;minLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;minValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;minWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;miterLimit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mix-blend-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mixBlendMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mm&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mobile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;model&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;modify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;move&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveBy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveFirst&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveFocusDown&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveFocusLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveFocusRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveFocusUp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveNext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveRow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveToBookmark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveToElementText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;moveToPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;movementX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;movementY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozAdd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozAnimationStartTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozAnon&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozApps&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozAudioCaptured&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozAudioChannelType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozAutoplayEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCancelAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCancelFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCancelRequestAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCaptureStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCaptureStreamUntilEnded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozClearDataAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozContact&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozContacts&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCreateFileHandle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCurrentTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCurrentTransformInverse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozCursor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozDash&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozDashOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozDecodedFrames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozExitPointerLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozFillRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozFragmentEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozFrameDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozFullScreenElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozFullScreenEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozGetAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozGetAllKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozGetAsFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozGetDataAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozGetMetadata&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozGetUserMedia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozHasAudio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozHasItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozHidden&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozImageSmoothingEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozIndexedDB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozInnerScreenX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozInnerScreenY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozInputSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozIsTextField&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozItemCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozLockOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozMatchesSelector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozMovementX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozMovementY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozOpaque&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPaintCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPaintedFrames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozParsedFrames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPointerLockElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPresentedFrames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPreservesPitch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPressure&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozPrintCallback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozRTCIceCandidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozRTCPeerConnection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozRTCSessionDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozRemove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozRequestAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozRequestFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozRequestPointerLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozSetDataAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozSetImageElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozSourceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozSrcObject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozSystem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozTCPSocket&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozTextStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozTypesAt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozUnlockOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozUserCancelled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mozVisibilityState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ms&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationFillMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationIterationCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationPlayState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationStartTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msAnimationTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msBackfaceVisibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msBlockProgression&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msCSSOMElementFloatMetrics&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msCaching&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msCachingEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msCancelRequestAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msCapsLockWarningOff&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msClearImmediate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msClose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomChaining&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomFactor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomLimit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomLimitMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomLimitMin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomSnap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomSnapPoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZoomSnapType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msContentZooming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msConvertURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msCrypto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msDoNotTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msElementsFromPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msElementsFromRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msExitFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msExtendedCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFillRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFirstPaint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexFlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexItemAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexLinePack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexNegative&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexOrder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexPack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexPositive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexPreferredSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlexWrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlowFrom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFlowInto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFontFeatureSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFullscreenElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msFullscreenEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGetInputContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGetRegionContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGetUntransformedBounds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGraphicsTrustStatus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridColumn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridColumnAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridColumnSpan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridColumns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridRow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridRowAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridRowSpan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msGridRows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msHidden&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msHighContrastAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msHyphenateLimitChars&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msHyphenateLimitLines&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msHyphenateLimitZone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msHyphens&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msImageSmoothingEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msImeAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msIndexedDB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msInterpolationMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msIsStaticHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msKeySystem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msLaunchUri&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msLockOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msManipulationViewsEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msMatchMedia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msMatchesSelector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msMaxTouchPoints&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msOverflowStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msPerspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msPerspectiveOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msPlayToDisabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msPlayToPreferredSourceUri&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msPlayToPrimary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msPointerEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msRegionOverflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msReleasePointerCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msRequestAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msRequestFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msSaveBlob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msSaveOrOpenBlob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollChaining&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollLimit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollLimitXMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollLimitXMin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollLimitYMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollLimitYMin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollRails&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollSnapPointsX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollSnapPointsY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollSnapType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollSnapX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollSnapY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msScrollTranslation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msSetImmediate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msSetMediaKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msSetPointerCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTextCombineHorizontal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTextSizeAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msToBlob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTouchAction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTouchSelect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTraceAsyncCallbackCompleted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTraceAsyncCallbackStarting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTraceAsyncOperationCompleted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTraceAsyncOperationStarting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransformOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransformStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransitionDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransitionDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransitionProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msTransitionTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msUnlockOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msUpdateAsyncCallbackRelation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msUserSelect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msVisibilityState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msWrapFlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msWrapMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msWrapThrough&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msWriteProfilerMark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msZoom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;msZoomTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mul&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;multiEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;multiSelectionObj&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;multiline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;multiple&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;multiply&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;multiplySelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;mutableFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;muted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;n&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;name&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nameProp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;namedItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;namedRecordset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;names&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;namespaceURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;namespaces&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;naturalHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;naturalWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;navigate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;navigation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;navigationMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;navigationPreload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;navigationStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;navigator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;near&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nearestViewportElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;negative&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;negotiated&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;netscape&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;networkState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;newScale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;newTranslate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;newURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;newValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;newValueSpecifiedUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;newVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;newhome&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;next&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nextElementSibling&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nextHopProtocol&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nextNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nextPage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nextSibling&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nickname&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noHref&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noModule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noResize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noShade&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noValidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noWrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;node&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nodeName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nodeType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nodeValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;nonce&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;normalize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;normalizedPathSegList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;notationName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;notations&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;note&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noteGrainOn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noteOff&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;noteOn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;notify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;now&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;numOctaves&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;number&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;numberOfChannels&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;numberOfInputs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;numberOfItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;numberOfOutputs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;numberValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oMatchesSelector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;object&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;object-fit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;object-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;objectFit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;objectPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;objectStore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;objectStoreNames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;objectType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;observe&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;of&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offscreenBuffering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offset-anchor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offset-distance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offset-path&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offset-rotate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetAnchor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetDistance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetParent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetPath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetRotate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;offsetY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ok&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oldURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oldValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oldVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;olderShadowRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onLine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onabort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onabsolutedeviceorientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onactivate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onactive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onaddsourcebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onaddstream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onaddtrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onafterprint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onafterscriptexecute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onafterupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onanimationcancel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onanimationend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onanimationiteration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onanimationstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onappinstalled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onaudioend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onaudioprocess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onaudiostart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onautocomplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onautocompleteerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onauxclick&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforeactivate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforecopy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforecut&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforedeactivate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforeeditfocus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforeinstallprompt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforepaste&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforeprint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforescriptexecute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforeunload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforeupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbeforexrselect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbegin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onblocked&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onblur&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbounce&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onboundary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onbufferedamountlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncached&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncancel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncandidatewindowhide&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncandidatewindowshow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncandidatewindowupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncanplay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncanplaythrough&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;once&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncellchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncharacteristicvaluechanged&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onchargingchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onchargingtimechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onchecking&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onclick&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onclose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onclosing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncompassneedscalibration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncomplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onconnect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onconnecting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onconnectionavailable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onconnectionstatechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncontextmenu&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncontrollerchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncontrolselect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncopy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncuechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oncut&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondataavailable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondatachannel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondatasetchanged&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondatasetcomplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondblclick&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondeactivate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondevicechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondevicelight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondevicemotion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondeviceorientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondeviceorientationabsolute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondeviceproximity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondischargingtimechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondisconnect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondisplay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondownloading&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondrag&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondragend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondragenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondragexit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondragleave&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondragover&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondragstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondrop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ondurationchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onemptied&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onencrypted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onended&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onenterpictureinpicture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onerrorupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onexit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfilterchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfinish&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfocus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfocusin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfocusout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onformdata&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfreeze&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfullscreenchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onfullscreenerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ongatheringstatechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ongattserverdisconnected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ongesturechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ongestureend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ongesturestart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ongotpointercapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onhashchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onhelp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onicecandidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onicecandidateerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oniceconnectionstatechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onicegatheringstatechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oninactive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oninput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oninputsourceschange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oninvalid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onkeydown&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onkeypress&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onkeystatuseschange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onkeyup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onlanguagechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onlayoutcomplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onleavepictureinpicture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onlevelchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onloadeddata&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onloadedmetadata&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onloadend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onloading&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onloadingdone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onloadingerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onloadstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onlosecapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onlostpointercapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;only&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmessageerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmidimessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmousedown&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmouseenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmouseleave&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmousemove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmouseout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmouseover&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmouseup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmousewheel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmoveend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmovestart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmozfullscreenchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmozfullscreenerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmozorientationchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmozpointerlockchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmozpointerlockerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmscontentzoom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsfullscreenchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsfullscreenerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsgesturechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsgesturedoubletap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsgestureend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsgesturehold&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsgesturestart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsgesturetap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsgotpointercapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsinertiastart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmslostpointercapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsmanipulationstatechanged&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsneedkey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsorientationchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointercancel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointerdown&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointerenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointerhover&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointerleave&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointermove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointerout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointerover&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmspointerup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmssitemodejumplistitemremoved&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmsthumbnailclick&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onmute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onnegotiationneeded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onnomatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onnoupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onobsolete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onoffline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ononline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onopen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onorientationchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpagechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpagehide&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpageshow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpaste&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpause&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpayerdetailchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpaymentmethodchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onplay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onplaying&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpluginstreamstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointercancel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerdown&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerleave&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerlockchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerlockerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointermove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerover&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerrawupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpointerup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpopstate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onprocessorerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onprogress&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onpropertychange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onratechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onreading&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onreadystatechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onrejectionhandled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onrelease&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onremove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onremovesourcebuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onremovestream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onremovetrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onrepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onreset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onresize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onresizeend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onresizestart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onresourcetimingbufferfull&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onresult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onresume&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onrowenter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onrowexit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onrowsdelete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onrowsinserted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onscroll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsearch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsecuritypolicyviolation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onseeked&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onseeking&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onselect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onselectedcandidatepairchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onselectend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onselectionchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onselectstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onshippingaddresschange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onshippingoptionchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onshow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsignalingstatechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsoundend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsoundstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsourceclose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsourceclosed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsourceended&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsourceopen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onspeechend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onspeechstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsqueeze&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsqueezeend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsqueezestart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onstalled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onstatechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onstop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onstorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onstoragecommit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsubmit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsuccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onsuspend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onterminate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontextinput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontimeout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontimeupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontoggle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontonechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontouchcancel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontouchend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontouchmove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontouchstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontransitioncancel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontransitionend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontransitionrun&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ontransitionstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onunhandledrejection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onunload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onunmute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onupdate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onupdateend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onupdatefound&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onupdateready&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onupdatestart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onupgradeneeded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onuserproximity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onversionchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvisibilitychange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvoiceschanged&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvolumechange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvrdisplayactivate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvrdisplayconnect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvrdisplaydeactivate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvrdisplaydisconnect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onvrdisplaypresentchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwaiting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwaitingforkey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwarning&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitanimationend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitanimationiteration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitanimationstart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitcurrentplaybacktargetiswirelesschanged&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitfullscreenchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitfullscreenerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitkeyadded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitkeyerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitkeymessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitneedkey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitorientationchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitplaybacktargetavailabilitychanged&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitpointerlockchange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitpointerlockerror&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkitresourcetimingbufferfull&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwebkittransitionend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onwheel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;onzoom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;opacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;open&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;openCursor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;openDatabase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;openKeyCursor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;opened&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;opener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;opera&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;operationType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;operator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;opr&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;optimum&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;options&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;or&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;order&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orderX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orderY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ordered&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;org&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;organization&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orientAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orientType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orientationX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orientationY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orientationZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;originalPolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;originalTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;orphans&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oscpu&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outerHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outerHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outerText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outerWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outline-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outline-offset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outline-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outline-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outlineColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outlineOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outlineStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outlineWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outputBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outputChannelCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outputLatency&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;outputs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflow-anchor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflow-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflow-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflow-wrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflow-x&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflow-y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflowAnchor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflowBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflowInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflowWrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflowX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overflowY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overrideMimeType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;oversample&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscroll-behavior&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscroll-behavior-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscroll-behavior-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscroll-behavior-x&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscroll-behavior-y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscrollBehavior&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscrollBehaviorBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscrollBehaviorInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscrollBehaviorX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;overscrollBehaviorY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ownKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ownerDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ownerElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ownerNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ownerRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ownerSVGElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;owningElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;p1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;p2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;p3&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;p4&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;packetSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;packets&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-block-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-block-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-bottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-inline-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-inline-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-left&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-right&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;padding-top&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingBlockEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingBlockStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingInlineEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingInlineStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paddingTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;page&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;page-break-after&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;page-break-before&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;page-break-inside&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageBreakAfter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageBreakBefore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageBreakInside&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageXOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pageYOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pages&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paint-order&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paintOrder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paintRequests&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paintType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paintWorklet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;palette&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;panningModel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parameterData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parentElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parentNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parentRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parentStyleSheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parentTextEdit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parentWindow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parseAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parseFloat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parseFromString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;parseInt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;part&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;participants&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;passive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;password&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pasteHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;path&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pathLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pathSegList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pathSegType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pathSegTypeAsLetter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pathname&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pattern&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;patternContentUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;patternMismatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;patternTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;patternUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pause&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pauseAnimations&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pauseOnExit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pauseProfilers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pauseTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paused&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;payerEmail&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;payerName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;payerPhone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;paymentManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;peerIdentity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pending&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pendingLocalDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pendingRemoteDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;percent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;performance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;periodicSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;permission&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;permissionState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;permissions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;persist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;persisted&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;personalbar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;perspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;perspective-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;perspectiveOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;phone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;phoneticFamilyName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;phoneticGivenName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;photo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pictureInPictureElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pictureInPictureEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pictureInPictureWindow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ping&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pipeThrough&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pipeTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pitch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelDepth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelStorei&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelUnitToMillimeterX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelUnitToMillimeterY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pixelWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;place-content&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;place-items&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;place-self&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;placeContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;placeItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;placeSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;placeholder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;platformVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;platform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;platforms&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;play&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;playEffect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;playState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;playbackRate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;playbackState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;playbackTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;played&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;playoutDelayHint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;playsInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;plugins&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pluginspage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pname&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointer-events&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointerBeforeReferenceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointerEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointerEvents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointerId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointerLockElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointerType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;points&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointsAtX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointsAtY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pointsAtZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;polygonOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;populateMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;popupWindowFeatures&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;popupWindowName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;popupWindowURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;port&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;port1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;port2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ports&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;posBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;posHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;posLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;posRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;posTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;posWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;positionAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;positionX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;positionY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;positionZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;postError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;postMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;postalCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;poster&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;powerEfficient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;powerOff&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preMultiplySelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;precision&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preferredStyleSheetSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preferredStylesheetSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;prefix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;prepend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;presentation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preserveAlpha&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preserveAspectRatio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preserveAspectRatioString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pressed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pressure&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;prevValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preventDefault&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preventExtensions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;preventSilentAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;previousElementSibling&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;previousNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;previousPage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;previousRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;previousScale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;previousSibling&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;previousTranslate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;primaryKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;primitiveType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;primitiveUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;principals&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;print&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;priority&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;privateKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;probablySupportsContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;process&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;processIceMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;processingEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;processingStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;processorOptions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;product&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;productId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;productName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;productSub&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;profile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;profileEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;profiles&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;projectionMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;promise&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;prompt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;properties&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;propertyIsEnumerable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;propertyName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;protocol&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;protocolLong&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;prototype&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;provider&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pseudoClass&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pseudoElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;publicId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;publicKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;published&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pulse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;push&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pushManager&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pushNotification&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;pushState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;put&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;putImageData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;px&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;quadraticCurveTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;qualifier&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;quaternion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;query&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;queryCommandEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;queryCommandIndeterm&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;queryCommandState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;queryCommandSupported&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;queryCommandText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;queryCommandValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;querySelector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;querySelectorAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;queueMicrotask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;quote&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;quotes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;r&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;r1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;r2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;race&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rad&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;radiogroup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;radiusX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;radiusY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;random&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;range&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rangeCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rangeMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rangeMin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rangeOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rangeOverflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rangeParent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rangeUnderflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ratio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;raw&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rawId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;read&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readAsArrayBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readAsBinaryString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readAsBlob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readAsDataURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readAsText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readEntries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readOnly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readPixels&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readReportRequested&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ready&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;readyState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reason&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reboot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;receivedAlert&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;receiver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;receivers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;recipient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reconnect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;recordNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;recordsAvailable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;recordset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;red&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;redEyeReduction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;redirect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;redirectCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;redirectEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;redirectStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;redirected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reduce&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reduceRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reduction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;refDistance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;refX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;refY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;referenceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;referenceSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;referrer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;referrerPolicy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;refresh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;region&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;regionAnchorX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;regionAnchorY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;regionId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;regions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;register&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;registerContentHandler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;registerElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;registerProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;registerProtocolHandler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;relList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;relatedAddress&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;relatedNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;relatedPort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;relatedTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;release&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;releaseCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;releaseEvents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;releaseInterface&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;releaseLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;releasePointerCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;releaseShaderCompiler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reliable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reliableWrite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;remainingSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;remote&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;remoteDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;remove&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeAllRanges&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeAttribute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeAttributeNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeAttributeNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeBehavior&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeChild&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeCue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeEventListener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeImport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeListener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeNamedItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeNamedItemNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeRegion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeRule&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeSiteSpecificTrackingException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeSourceBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeVariable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeWakeLockListener&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removeWebWideTrackingException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;removedNodes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderbufferStorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderbufferStorageMultisample&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderedBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renderingMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;renotify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;repeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceAdjacentText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceChild&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceChildren&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceTrack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceWholeText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;replaceWith&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reportValidity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;request&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestAutocomplete&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestDevice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestHitTestSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestHitTestSourceForTransientInput&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestIdleCallback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestMIDIAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestMediaKeySystemAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestPermission&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestPictureInPicture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestPointerLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestPresent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestReferenceSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestSession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestStorageAccess&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestSubmit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestVideoFrameCallback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requestingWindow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requireInteraction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;required&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requiredExtensions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;requiredFeatures&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resetPose&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resetTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resizeBy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resizeTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resolve&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;response&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseBody&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseReady&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;responseXML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;restartIce&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;restore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;result&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resultIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resultType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;results&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resume&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resumeProfilers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;resumeTransformFeedback&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;retry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;returnValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rev&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reverse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;reversed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;revocable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;revokeObjectURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rgbColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;right&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rightContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rightDegrees&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rightMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rightProjectionMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rightViewMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;role&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rolloffFactor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;root&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rootBounds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rootElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rootMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotateAxisAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotateAxisAngleSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotateFromVector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotateFromVectorSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotateSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotationAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rotationRate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;round&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;row-gap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rowGap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rowIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rowSpan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rtcpTransport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rtt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ruby-align&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ruby-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rubyAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rubyOverhang&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rubyPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rules&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;runtime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;runtimeStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;rx&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;s&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;safari&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sample&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sampleCoverage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sampleRate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;samplerParameterf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;samplerParameteri&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sandbox&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;save&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;saveData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scale3d&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scale3dSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scaleNonUniform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scaleNonUniformSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scaleSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scheme&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scissor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scope&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scopeName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scoped&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenBrightness&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenPixelToMillimeterX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenPixelToMillimeterY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;screenY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scriptURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scripts&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-behavior&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-block-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-block-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-bottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-inline-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-inline-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-left&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-right&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-margin-top&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-block&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-block-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-block-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-bottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-inline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-inline-end&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-inline-start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-left&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-right&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-padding-top&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-snap-align&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scroll-snap-type&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollAmount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollBehavior&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollBy&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollByLines&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollByPages&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollIntoView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollIntoViewIfNeeded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollLeftMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginBlockEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginBlockStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginInlineEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginInlineStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMarginTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMaxX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollMaxY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPadding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingBlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingBlockEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingBlockStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingBottom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingInline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingInlineEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingInlineStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollPaddingTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollRestoration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollSnapAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollSnapType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollTo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollTop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollTopMax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbar-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbar-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbar3dLightColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarArrowColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarBaseColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarDarkShadowColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarFaceColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarHighlightColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarShadowColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarTrackColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbarWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollbars&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrolling&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;scrollingElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sctp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sctpCauseCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sdp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sdpLineNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sdpMLineIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sdpMid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;seal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;search&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;searchBox&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;searchBoxJavaBridge_&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;searchParams&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sectionRowIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;secureConnectionStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;security&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;seed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;seekToNextFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;seekable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;seeking&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;select&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectAllChildren&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectAlternateInterface&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectConfiguration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectNodeContents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectNodes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectSingleNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectSubString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selected&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectedIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectedOptions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectedStyleSheetSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectedStylesheetSet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectionDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectionEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectionStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;selectorText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;self&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;send&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sendAsBinary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sendBeacon&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sender&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sentAlert&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sentTimestamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;separator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;serialNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;serializeToString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;serverTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;service&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;serviceWorker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;session&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sessionId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sessionStorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;set&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setActionHandler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setActive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setAlpha&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setAppBadge&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setAttribute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setAttributeNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setAttributeNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setAttributeNodeNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setBaseAndExtent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setBigInt64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setBigUint64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setBingCurrentSearchDefault&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setCodecPreferences&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setCompositeOperation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setConfiguration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setCurrentTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setCustomValidity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setDragImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setEndAfter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setEndBefore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setEndPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setFillColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setFilterRes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setFloat32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setFloat64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setFloatValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setFormValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setFullYear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setHeaderValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setHours&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setIdentityProvider&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setImmediate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setInt16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setInt32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setInt8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setInterval&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setKeyframes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setLineCap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setLineDash&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setLineJoin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setLineWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setLiveSeekableRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setLocalDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setMatrixValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setMediaKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setMilliseconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setMinutes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setMiterLimit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setMonth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setNamedItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setNamedItemNS&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setNonUserCodeExceptions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setOrientToAngle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setOrientToAuto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setOverrideHistoryNavigationMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setPaint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setParameter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setPeriodicWave&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setPointerCapture&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setPositionState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setPreference&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setPrototypeOf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setRGBColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setRGBColorICCColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setRangeText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setRemoteDescription&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setRequestHeader&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setResizable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setResourceTimingBufferSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setRotate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setScale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setSeconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setSelectionRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setServerCertificate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setSinkId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setSkewX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setSkewY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setStartAfter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setStartBefore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setStdDeviation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setStreams&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setStringValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setStrokeColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setSuggestResult&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setTargetAtTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setTargetValueAtTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setTimeout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setTranslate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUTCDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUTCFullYear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUTCHours&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUTCMilliseconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUTCMinutes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUTCMonth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUTCSeconds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUint16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUint32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUint8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setUri&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setValidity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setValueAtTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setValueCurveAtTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setVariable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setVelocity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;setYear&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;settingName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;settingValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shaderSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shadowBlur&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shadowColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shadowOffsetX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shadowOffsetY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shadowRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shape&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shape-image-threshold&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shape-margin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shape-outside&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shape-rendering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shapeImageThreshold&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shapeMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shapeOutside&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shapeRendering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shift&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shiftKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shiftLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shippingAddress&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shippingOption&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;shippingType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;show&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;showHelp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;showModal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;showModalDialog&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;showModelessDialog&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;showNotification&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sidebar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;signal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;signalingState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;signature&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;silent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;singleNodeValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sinh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sinkId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sittingToStandingTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;size&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sizeToContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sizeX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sizeZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sizes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;skewX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;skewXSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;skewY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;skewYSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;slice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;slope&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;slot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;small&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;smil&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;smooth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;smoothingTimeConstant&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;snapToLines&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;snapshotItem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;snapshotLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;some&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sortingCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;source&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sourceBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sourceBuffers&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sourceCapabilities&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sourceFile&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sourceIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sources&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;spacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;span&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;speak&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;speakAs&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;speaking&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;species&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;specified&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;specularConstant&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;specularExponent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;speechSynthesis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;speed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;speedOfSound&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;spellcheck&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;splice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;split&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;splitText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;spreadMethod&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sqrt&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;src&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;srcElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;srcFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;srcObject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;srcUrn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;srcdoc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;srclang&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;srcset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stackTraceLimit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stacktrace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stageParameters&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;standalone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;standby&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;start&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startContainer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startIce&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startMessages&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startNotifications&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startProfiling&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startRendering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startShark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;startsWith&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;state&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;status&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;statusCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;statusMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;statusText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;statusbar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stdDeviationX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stdDeviationY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stencilFunc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stencilFuncSeparate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stencilMask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stencilMaskSeparate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stencilOp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stencilOpSeparate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;step&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stepDown&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stepMismatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stepUp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sticky&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stitchTiles&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stop&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stop-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stop-opacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopImmediatePropagation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopNotifications&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopOpacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopProfiling&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopPropagation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopShark&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stopped&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;storage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;storageArea&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;storageName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;storageStatus&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;store&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;storeSiteSpecificTrackingException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;storeWebWideTrackingException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stpVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;streams&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stretch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strike&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;string&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stringValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stringify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke-dashoffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke-linecap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke-linejoin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke-miterlimit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke-opacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;stroke-width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeDasharray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeDashoffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeLinecap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeLinejoin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeMiterlimit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeOpacity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeRect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;strokeWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;styleFloat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;styleMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;styleMedia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;styleSheet&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;styleSheetSets&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;styleSheets&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sub&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;subarray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;subject&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;submit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;submitFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;submitter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;subscribe&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;substr&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;substring&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;substringData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;subtle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;subtree&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;suffix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;suffixes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;summary&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;supported&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;supportedContentEncodings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;supportedEntryTypes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;supports&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;supportsSession&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;surfaceScale&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;surroundContents&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;suspend&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;suspendRedraw&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;swapCache&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;swapNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sweepFlag&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;symbols&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sysexEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;system&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;systemCode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;systemId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;systemLanguage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;systemXDPI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;systemYDPI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tBodies&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tFoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tHead&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tabIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;table&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;table-layout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tableLayout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tableValues&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tag&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tagName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tagUrn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tags&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;taintEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;takePhoto&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;takeRecords&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tangentialPressure&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tanh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;target&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;targetElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;targetRayMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;targetRaySpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;targetTouches&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;targetX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;targetY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tcpType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tee&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tel&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;terminate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;test&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texImage2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texImage3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texParameterf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texParameteri&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texStorage2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texStorage3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texSubImage2D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;texSubImage3D&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-align&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-align-last&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-anchor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-combine-upright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-decoration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-decoration-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-decoration-line&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-decoration-skip-ink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-decoration-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-decoration-thickness&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-emphasis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-emphasis-color&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-emphasis-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-emphasis-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-indent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-justify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-orientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-overflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-rendering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-shadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-transform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-underline-offset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;text-underline-position&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textAlignLast&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textAnchor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textAutospace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textBaseline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textCombineUpright&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecoration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationBlink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationLine&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationLineThrough&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationNone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationOverline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationSkipInk&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationThickness&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textDecorationUnderline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textEmphasis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textEmphasisColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textEmphasisPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textEmphasisStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textIndent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textJustify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textJustifyTrim&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textKashida&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textKashidaSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textLength&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textOverflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textRendering&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textTracks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textUnderlineOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;textUnderlinePosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;then&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;threadId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;threshold&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;thresholds&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tiltX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tiltY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;time&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timeEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timeLog&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timeOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timeRemaining&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timeStamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timecode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timeline&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timelineTime&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timeout&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timestamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timestampOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;timing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;title&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;to&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toArray&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toBlob&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toDataURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toDateString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toExponential&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toFixed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toFloat32Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toFloat64Array&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toGMTString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toISOString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toJSON&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toLocaleDateString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toLocaleFormat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toLocaleLowerCase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toLocaleString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toLocaleTimeString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toLocaleUpperCase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toLowerCase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toMatrix&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toMethod&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toPrecision&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toPrimitive&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toSdp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toStaticHTML&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toStringTag&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toSum&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toTimeString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toUTCString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toUpperCase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toggle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toggleAttribute&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toggleLongPressEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toneBuffer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tooLong&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;tooShort&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;toolbar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;top&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;topMargin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;total&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;totalFrameDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;totalVideoFrames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;touch-action&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;touchAction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;touched&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;touches&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;track&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trackVisibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transaction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transactions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transceiver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transferControlToOffscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transferFromImageBitmap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transferImageBitmap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transferIn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transferOut&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transferSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transferToImageBitmap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transform-box&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transform-origin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transform-style&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformBox&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformFeedbackVaryings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformPoint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformToDocument&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transformToFragment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transition-delay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transition-duration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transition-property&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transition-timing-function&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transitionDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transitionDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transitionProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transitionTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;translate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;translateSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;translationX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;translationY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;transport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trim&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trimEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trimLeft&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trimRight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trimStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trueSpeed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trunc&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;truncate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;trustedTypes&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;turn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;twist&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;type&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;typeDetail&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;typeMismatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;typeMustMatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;types&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;u2f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;ubound&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uint16&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uint32&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uint8&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uint8Clamped&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;undefined&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unescape&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uneval&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unicode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unicode-bidi&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unicodeBidi&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unicodeRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform1f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform1fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform1i&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform1iv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform1ui&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform1uiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform2f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform2fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform2i&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform2iv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform2ui&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform2uiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform3f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform3fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform3i&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform3iv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform3ui&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform3uiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform4f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform4fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform4i&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform4iv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform4ui&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniform4uiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformBlockBinding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix2fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix2x3fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix2x4fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix3fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix3x2fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix3x4fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix4fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix4x2fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniformMatrix4x3fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unique&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniqueID&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uniqueNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unit&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unitType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;units&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unloadEventEnd&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unloadEventStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unlock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unmount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unobserve&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unpause&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unpauseAnimations&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unreadCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unregister&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unregisterContentHandler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unregisterProtocolHandler&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unscopables&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unselectable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unshift&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unsubscribe&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unsuspendRedraw&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unsuspendRedrawAll&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unwatch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;unwrapKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upDegrees&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upZ&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;update&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateCommands&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateIce&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateInterval&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updatePlaybackRate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateRenderState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateTiming&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateViaCache&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updateWith&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updated&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;updating&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upgrade&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upload&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uploadTotal&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uploaded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upper&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upperBound&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;upperOpen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uri&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;url&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;urn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;urns&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;usages&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;usb&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;usbVersionMajor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;usbVersionMinor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;usbVersionSubminor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;useCurrentView&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;useMap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;useProgram&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;usedSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;user-select&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userActivation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userAgent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userAgentData&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userChoice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userHandle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userHint&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userLanguage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userSelect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;userVisibleOnly&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;username&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;usernameFragment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;utterance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;uuid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;v8BreakIterator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vLink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valid&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;validate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;validateProgram&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;validationMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;validity&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;value&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueAsDate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueAsNumber&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueAsString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueInSpecifiedUnits&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueMissing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueOf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;valueType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;values&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;variable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;variant&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;variationSettings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vector-effect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vectorEffect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;velocityAngular&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;velocityExpansion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;velocityX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;velocityY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vendor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vendorId&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vendorSub&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;verify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;version&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib1f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib1fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib2f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib2fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib3f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib3fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib4f&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttrib4fv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribDivisor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribDivisorANGLE&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribI4i&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribI4iv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribI4ui&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribI4uiv&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribIPointer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertexAttribPointer&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertical&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vertical-align&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;verticalAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;verticalOverflow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vh&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vibrate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vibrationActuator&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;videoBitsPerSecond&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;videoHeight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;videoTracks&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;videoWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;view&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewBox&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewBoxString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewTarget&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewTargetString&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewportAnchorX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewportAnchorY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;viewportElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;views&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;violatedDirective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;visibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;visibilityState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;visible&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;visualViewport&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vlinkColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vmax&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vmin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;voice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;voiceURI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;volume&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vrml&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vspace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;vw&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;w&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wait&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;waitSync&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;waiting&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wake&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wakeLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wand&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;warn&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wasClean&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wasDiscarded&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;watch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;watchAvailability&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;watchPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webdriver&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAddKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAlignContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAlignItems&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAlignSelf&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationFillMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationIterationCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationPlayState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAnimationTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAppearance&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAudioContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAudioDecodedByteCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitAudioPannerNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackfaceVisibility&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackground&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundAttachment&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundClip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundPositionX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundPositionY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundRepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackgroundSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBackingStorePixelRatio&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderBottomLeftRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderBottomRightRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderImageOutset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderImageRepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderImageSlice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderImageSource&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderImageWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderTopLeftRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBorderTopRightRadius&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxAlign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxFlex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxOrdinalGroup&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxOrient&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxPack&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxShadow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitBoxSizing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitCancelAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitCancelFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitCancelKeyRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitCancelRequestAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitClearResourceTimings&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitClosedCaptionsVisible&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitConvertPointFromNodeToPage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitConvertPointFromPageToNode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitCreateShadowRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitCurrentFullScreenElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitCurrentPlaybackTargetIsWireless&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitDecodedFrameCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitDirectionInvertedFromDevice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitDisplayingFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitDroppedFrameCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitEnterFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitEnterFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitEntries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitExitFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitExitFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitExitPointerLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFilter&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFlex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFlexBasis&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFlexDirection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFlexFlow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFlexGrow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFlexShrink&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFlexWrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFullScreenKeyboardInputAllowed&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFullscreenElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitFullscreenEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGenerateKeyRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetAsEntry&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetDatabaseNames&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetEntries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetEntriesByName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetEntriesByType&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetFlowByName&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetGamepads&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetImageDataHD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetNamedFlows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetRegionFlowRanges&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitGetUserMedia&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitHasClosedCaptions&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitHidden&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBCursor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBDatabase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBDatabaseError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBDatabaseException&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBFactory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBKeyRange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBObjectStore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBRequest&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIDBTransaction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitImageSmoothingEnabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIndexedDB&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitInitMessageEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitIsFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitJustifyContent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitLineClamp&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitLineDashOffset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitLockOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMask&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskClip&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskComposite&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskImage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskPosition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskPositionX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskPositionY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskRepeat&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMaskSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMatchesSelector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitMediaStream&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitNotifications&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitOfflineAudioContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitOrder&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPeerConnection00&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPersistentStorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPerspective&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPerspectiveOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPointerLockElement&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPostMessage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPreservesPitch&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitPutImageDataHD&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRTCPeerConnection&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRegionOverset&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRelativePath&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRequestAnimationFrame&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRequestFileSystem&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRequestFullScreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRequestFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitRequestPointerLock&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitResolveLocalFileSystemURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSetMediaKeys&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSetResourceTimingBufferSize&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitShadowRoot&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitShowPlaybackTargetPicker&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSlice&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSpeechGrammar&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSpeechGrammarList&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSpeechRecognition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSpeechRecognitionError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSpeechRecognitionEvent&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitStorageInfo&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitSupportsFullscreen&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTemporaryStorage&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTextFillColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTextSizeAdjust&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTextStroke&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTextStrokeColor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTextStrokeWidth&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransform&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransformOrigin&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransformStyle&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransition&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransitionDelay&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransitionDuration&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransitionProperty&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitTransitionTimingFunction&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitURL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitUnlockOrientation&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitUserSelect&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitVideoDecodedByteCount&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitVisibilityState&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitWirelessVideoPlaybackDisabled&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitdirectory&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webkitdropzone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;webstore&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;weight&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;whatToShow&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wheelDelta&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wheelDeltaX&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wheelDeltaY&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;whenDefined&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;which&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;white-space&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;whiteSpace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wholeText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;widows&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;will-change&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;willChange&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;willValidate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;window&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;withCredentials&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;word-break&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;word-spacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;word-wrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wordBreak&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wordSpacing&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wordWrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;workerStart&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wow64&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wrap&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;wrapKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writable&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writableAuxiliaries&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;write&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writeText&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writeValue&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writeWithoutResponse&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writeln&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writing-mode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;writingMode&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;x1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;x2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xChannelSelector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xmlEncoding&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xmlStandalone&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xmlVersion&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xmlbase&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xmllang&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xmlspace&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xor&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;xr&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;y&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;y1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;y2&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;yChannelSelector&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;yandex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;z&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;z-index&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;zIndex&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;zoom&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;zoomAndPan&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;zoomRectScreen&quot;</span><span class="s0">,</span>
<span class="s0">];</span>

<span class="s3">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">function </span><span class="s0">find_builtins(reserved) {</span>
    <span class="s0">domprops.forEach(add);</span>

    <span class="s3">// Compatibility fix for some standard defined globals not defined on every js environment</span>
    <span class="s1">var </span><span class="s0">new_globals = [</span><span class="s2">&quot;Symbol&quot;</span><span class="s0">, </span><span class="s2">&quot;Map&quot;</span><span class="s0">, </span><span class="s2">&quot;Promise&quot;</span><span class="s0">, </span><span class="s2">&quot;Proxy&quot;</span><span class="s0">, </span><span class="s2">&quot;Reflect&quot;</span><span class="s0">, </span><span class="s2">&quot;Set&quot;</span><span class="s0">, </span><span class="s2">&quot;WeakMap&quot;</span><span class="s0">, </span><span class="s2">&quot;WeakSet&quot;</span><span class="s0">];</span>
    <span class="s1">var </span><span class="s0">objects = {};</span>
    <span class="s1">var </span><span class="s0">global_ref = </span><span class="s1">typeof </span><span class="s0">global === </span><span class="s2">&quot;object&quot; </span><span class="s0">? global : self;</span>

    <span class="s0">new_globals.forEach(</span><span class="s1">function </span><span class="s0">(new_global) {</span>
        <span class="s0">objects[new_global] = global_ref[new_global] || </span><span class="s1">function</span><span class="s0">() {};</span>
    <span class="s0">});</span>

    <span class="s0">[</span>
        <span class="s2">&quot;null&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;true&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;false&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;NaN&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Infinity&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;-Infinity&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;undefined&quot;</span><span class="s0">,</span>
    <span class="s0">].forEach(add);</span>
    <span class="s0">[ Object, Array, Function, Number,</span>
      <span class="s0">String, Boolean, Error, Math,</span>
      <span class="s0">Date, RegExp, objects.Symbol, ArrayBuffer,</span>
      <span class="s0">DataView, decodeURI, decodeURIComponent,</span>
      <span class="s0">encodeURI, encodeURIComponent, eval, EvalError,</span>
      <span class="s0">Float32Array, Float64Array, Int8Array, Int16Array,</span>
      <span class="s0">Int32Array, isFinite, isNaN, JSON, objects.Map, parseFloat,</span>
      <span class="s0">parseInt, objects.Promise, objects.Proxy, RangeError, ReferenceError,</span>
      <span class="s0">objects.Reflect, objects.Set, SyntaxError, TypeError, Uint8Array,</span>
      <span class="s0">Uint8ClampedArray, Uint16Array, Uint32Array, URIError,</span>
      <span class="s0">objects.WeakMap, objects.WeakSet</span>
    <span class="s0">].forEach(</span><span class="s1">function</span><span class="s0">(ctor) {</span>
        <span class="s0">Object.getOwnPropertyNames(ctor).map(add);</span>
        <span class="s1">if </span><span class="s0">(ctor.prototype) {</span>
            <span class="s0">Object.getOwnPropertyNames(ctor.prototype).map(add);</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">function </span><span class="s0">add(name) {</span>
        <span class="s0">reserved.add(name);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">reserve_quoted_keys(ast, reserved) {</span>
    <span class="s1">function </span><span class="s0">add(name) {</span>
        <span class="s0">push_uniq(reserved, name);</span>
    <span class="s0">}</span>

    <span class="s0">ast.walk(</span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal &amp;&amp; node.quote) {</span>
            <span class="s0">add(node.key);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectProperty &amp;&amp; node.quote) {</span>
            <span class="s0">add(node.key.name);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sub) {</span>
            <span class="s0">addStrings(node.property, add);</span>
        <span class="s0">}</span>
    <span class="s0">}));</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">addStrings(node, add) {</span>
    <span class="s0">node.walk(</span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
            <span class="s0">addStrings(node.tail_node(), add);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_String) {</span>
            <span class="s0">add(node.value);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Conditional) {</span>
            <span class="s0">addStrings(node.consequent, add);</span>
            <span class="s0">addStrings(node.alternative, add);</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}));</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">mangle_private_properties(ast, options) {</span>
    <span class="s1">var </span><span class="s0">cprivate = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">private_cache = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">var </span><span class="s0">nth_identifier = options.nth_identifier || base54;</span>

    <span class="s0">ast =  ast.transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_ClassPrivateProperty</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateMethod</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateGetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateSetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateIn</span>
        <span class="s0">) {</span>
            <span class="s0">node.key.name = mangle_private(node.key.name);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_DotHash) {</span>
            <span class="s0">node.property = mangle_private(node.property);</span>
        <span class="s0">}</span>
    <span class="s0">}));</span>
    <span class="s1">return </span><span class="s0">ast;</span>

    <span class="s1">function </span><span class="s0">mangle_private(name) {</span>
        <span class="s0">let mangled = private_cache.get(name);</span>
        <span class="s1">if </span><span class="s0">(!mangled) {</span>
            <span class="s0">mangled = nth_identifier.get(++cprivate);</span>
            <span class="s0">private_cache.set(name, mangled);</span>
        <span class="s0">}</span>

        <span class="s1">return </span><span class="s0">mangled;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">find_annotated_props(ast) {</span>
    <span class="s1">var </span><span class="s0">annotated_props = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s0">walk(ast, node =&gt; {</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_ClassPrivateProperty</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateMethod</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateGetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateSetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_DotHash</span>
        <span class="s0">) ; </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">node.key == </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; has_annotation(node, _MANGLEPROP)) {</span>
                <span class="s0">annotated_props.add(node.key);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectProperty) {</span>
            <span class="s3">// setter or getter, since KeyVal is handled above</span>
            <span class="s1">if </span><span class="s0">(has_annotation(node, _MANGLEPROP)) {</span>
                <span class="s0">annotated_props.add(node.key.name);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Dot) {</span>
            <span class="s1">if </span><span class="s0">(has_annotation(node, _MANGLEPROP)) {</span>
                <span class="s0">annotated_props.add(node.property);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sub) {</span>
            <span class="s1">if </span><span class="s0">(node.property </span><span class="s1">instanceof </span><span class="s0">AST_String &amp;&amp; has_annotation(node, _MANGLEPROP)) {</span>
                <span class="s0">annotated_props.add(node.property.value);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">annotated_props;</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">mangle_properties(ast, options, annotated_props = find_annotated_props(ast)) {</span>
    <span class="s0">options = defaults(options, {</span>
        <span class="s0">builtins: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">cache: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">debug: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">keep_quoted: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">nth_identifier: base54,</span>
        <span class="s0">only_cache: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">regex: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">reserved: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">undeclared: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">only_annotated: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s1">var </span><span class="s0">nth_identifier = options.nth_identifier;</span>

    <span class="s1">var </span><span class="s0">reserved_option = options.reserved;</span>
    <span class="s1">if </span><span class="s0">(!Array.isArray(reserved_option)) reserved_option = [reserved_option];</span>
    <span class="s1">var </span><span class="s0">reserved = </span><span class="s1">new </span><span class="s0">Set(reserved_option);</span>
    <span class="s1">if </span><span class="s0">(!options.builtins) find_builtins(reserved);</span>

    <span class="s1">var </span><span class="s0">cname = -</span><span class="s4">1</span><span class="s0">;</span>

    <span class="s1">var </span><span class="s0">cache;</span>
    <span class="s1">if </span><span class="s0">(options.cache) {</span>
        <span class="s0">cache = options.cache.props;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">cache = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">only_annotated = options.only_annotated;</span>
    <span class="s1">var </span><span class="s0">regex = options.regex &amp;&amp; </span><span class="s1">new </span><span class="s0">RegExp(options.regex);</span>

    <span class="s3">// note debug is either false (disabled), or a string of the debug suffix to use (enabled).</span>
    <span class="s3">// note debug may be enabled as an empty string, which is falsey. Also treat passing 'true'</span>
    <span class="s3">// the same as passing an empty string.</span>
    <span class="s1">var </span><span class="s0">debug = options.debug !== </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">var </span><span class="s0">debug_name_suffix;</span>
    <span class="s1">if </span><span class="s0">(debug) {</span>
        <span class="s0">debug_name_suffix = (options.debug === </span><span class="s1">true </span><span class="s0">? </span><span class="s2">&quot;&quot; </span><span class="s0">: options.debug);</span>
    <span class="s0">}</span>

    <span class="s1">var </span><span class="s0">names_to_mangle = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">var </span><span class="s0">unmangleable = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s3">// Track each already-mangled name to prevent nth_identifier from generating</span>
    <span class="s3">// the same name.</span>
    <span class="s0">cache.forEach((mangled_name) =&gt; unmangleable.add(mangled_name));</span>

    <span class="s1">var </span><span class="s0">keep_quoted = !!options.keep_quoted;</span>

    <span class="s3">// step 1: find candidates to mangle</span>
    <span class="s0">ast.walk(</span><span class="s1">new </span><span class="s0">TreeWalker(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_ClassPrivateProperty</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateMethod</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateGetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateSetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_DotHash</span>
        <span class="s0">) ; </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">node.key == </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; (!keep_quoted || !node.quote)) {</span>
                <span class="s0">add(node.key);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectProperty) {</span>
            <span class="s3">// setter or getter, since KeyVal is handled above</span>
            <span class="s1">if </span><span class="s0">(!keep_quoted || !node.quote) {</span>
                <span class="s0">add(node.key.name);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Dot) {</span>
            <span class="s1">var </span><span class="s0">declared = !!options.undeclared;</span>
            <span class="s1">if </span><span class="s0">(!declared) {</span>
                <span class="s1">var </span><span class="s0">root = node;</span>
                <span class="s1">while </span><span class="s0">(root.expression) {</span>
                    <span class="s0">root = root.expression;</span>
                <span class="s0">}</span>
                <span class="s0">declared = !(root.thedef &amp;&amp; root.thedef.undeclared);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(declared &amp;&amp;</span>
                <span class="s0">(!keep_quoted || !node.quote)) {</span>
                <span class="s0">add(node.property);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sub) {</span>
            <span class="s1">if </span><span class="s0">(!keep_quoted) {</span>
                <span class="s0">addStrings(node.property, add);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
            <span class="s0">&amp;&amp; node.expression.print_to_string() == </span><span class="s2">&quot;Object.defineProperty&quot;</span><span class="s0">) {</span>
            <span class="s0">addStrings(node.args[</span><span class="s4">1</span><span class="s0">], add);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; node.operator === </span><span class="s2">&quot;in&quot;</span><span class="s0">) {</span>
            <span class="s0">addStrings(node.left, add);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_String &amp;&amp; has_annotation(node, _KEY)) {</span>
            <span class="s0">add(node.value);</span>
        <span class="s0">}</span>
    <span class="s0">}));</span>

    <span class="s3">// step 2: transform the tree, renaming properties</span>
    <span class="s1">return </span><span class="s0">ast.transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
        <span class="s1">if </span><span class="s0">(</span>
            <span class="s0">node </span><span class="s1">instanceof </span><span class="s0">AST_ClassPrivateProperty</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateMethod</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateGetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_PrivateSetter</span>
            <span class="s0">|| node </span><span class="s1">instanceof </span><span class="s0">AST_DotHash</span>
        <span class="s0">) ; </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectKeyVal) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">node.key == </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; (!keep_quoted || !node.quote)) {</span>
                <span class="s0">node.key = mangle(node.key);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_ObjectProperty) {</span>
            <span class="s3">// setter, getter, method or class field</span>
            <span class="s1">if </span><span class="s0">(!keep_quoted || !node.quote) {</span>
                <span class="s0">node.key.name = mangle(node.key.name);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Dot) {</span>
            <span class="s1">if </span><span class="s0">(!keep_quoted || !node.quote) {</span>
                <span class="s0">node.property = mangle(node.property);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!keep_quoted &amp;&amp; node </span><span class="s1">instanceof </span><span class="s0">AST_Sub) {</span>
            <span class="s0">node.property = mangleStrings(node.property);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Call</span>
            <span class="s0">&amp;&amp; node.expression.print_to_string() == </span><span class="s2">&quot;Object.defineProperty&quot;</span><span class="s0">) {</span>
            <span class="s0">node.args[</span><span class="s4">1</span><span class="s0">] = mangleStrings(node.args[</span><span class="s4">1</span><span class="s0">]);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Binary &amp;&amp; node.operator === </span><span class="s2">&quot;in&quot;</span><span class="s0">) {</span>
            <span class="s0">node.left = mangleStrings(node.left);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_String &amp;&amp; has_annotation(node, _KEY)) {</span>
            <span class="s3">// Clear _KEY annotation to prevent double mangling</span>
            <span class="s0">clear_annotation(node, _KEY);</span>
            <span class="s0">node.value = mangle(node.value);</span>
        <span class="s0">}</span>
    <span class="s0">}));</span>

    <span class="s3">// only function declarations after this line</span>

    <span class="s1">function </span><span class="s0">can_mangle(name) {</span>
        <span class="s1">if </span><span class="s0">(unmangleable.has(name)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(reserved.has(name)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(options.only_cache) {</span>
            <span class="s1">return </span><span class="s0">cache.has(name);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(/^-?[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">]+(\.[</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">]+)?(e[+-][</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">]+)?$/.test(name)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">should_mangle(name) {</span>
        <span class="s1">if </span><span class="s0">(only_annotated &amp;&amp; !annotated_props.has(name)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(regex &amp;&amp; !regex.test(name)) {</span>
            <span class="s1">return </span><span class="s0">annotated_props.has(name);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(reserved.has(name)) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">cache.has(name)</span>
            <span class="s0">|| names_to_mangle.has(name);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">add(name) {</span>
        <span class="s1">if </span><span class="s0">(can_mangle(name)) {</span>
            <span class="s0">names_to_mangle.add(name);</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(!should_mangle(name)) {</span>
            <span class="s0">unmangleable.add(name);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">mangle(name) {</span>
        <span class="s1">if </span><span class="s0">(!should_mangle(name)) {</span>
            <span class="s1">return </span><span class="s0">name;</span>
        <span class="s0">}</span>

        <span class="s1">var </span><span class="s0">mangled = cache.get(name);</span>
        <span class="s1">if </span><span class="s0">(!mangled) {</span>
            <span class="s1">if </span><span class="s0">(debug) {</span>
                <span class="s3">// debug mode: use a prefix and suffix to preserve readability, e.g. o.foo -&gt; o._$foo$NNN_.</span>
                <span class="s1">var </span><span class="s0">debug_mangled = </span><span class="s2">&quot;_$&quot; </span><span class="s0">+ name + </span><span class="s2">&quot;$&quot; </span><span class="s0">+ debug_name_suffix + </span><span class="s2">&quot;_&quot;</span><span class="s0">;</span>

                <span class="s1">if </span><span class="s0">(can_mangle(debug_mangled)) {</span>
                    <span class="s0">mangled = debug_mangled;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>

            <span class="s3">// either debug mode is off, or it is on and we could not use the mangled name</span>
            <span class="s1">if </span><span class="s0">(!mangled) {</span>
                <span class="s1">do </span><span class="s0">{</span>
                    <span class="s0">mangled = nth_identifier.get(++cname);</span>
                <span class="s0">} </span><span class="s1">while </span><span class="s0">(!can_mangle(mangled));</span>
            <span class="s0">}</span>

            <span class="s0">cache.set(name, mangled);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mangled;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">mangleStrings(node) {</span>
        <span class="s1">return </span><span class="s0">node.transform(</span><span class="s1">new </span><span class="s0">TreeTransformer(</span><span class="s1">function</span><span class="s0">(node) {</span>
            <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Sequence) {</span>
                <span class="s1">var </span><span class="s0">last = node.expressions.length - </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">node.expressions[last] = mangleStrings(node.expressions[last]);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_String) {</span>
                <span class="s3">// Clear _KEY annotation to prevent double mangling</span>
                <span class="s0">clear_annotation(node, _KEY);</span>
                <span class="s0">node.value = mangle(node.value);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Conditional) {</span>
                <span class="s0">node.consequent = mangleStrings(node.consequent);</span>
                <span class="s0">node.alternative = mangleStrings(node.alternative);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">node;</span>
        <span class="s0">}));</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s3">// to/from base64 functions</span>
<span class="s3">// Prefer built-in Buffer, if available, then use hack</span>
<span class="s3">// https://developer.mozilla.org/en-US/docs/Glossary/Base64#The_Unicode_Problem</span>
<span class="s1">var </span><span class="s0">to_ascii = </span><span class="s1">typeof </span><span class="s0">Buffer !== </span><span class="s2">&quot;undefined&quot;</span>
    <span class="s0">? (b64) =&gt; Buffer.from(b64, </span><span class="s2">&quot;base64&quot;</span><span class="s0">).toString()</span>
    <span class="s0">: (b64) =&gt; decodeURIComponent(escape(atob(b64)));</span>
<span class="s1">var </span><span class="s0">to_base64 = </span><span class="s1">typeof </span><span class="s0">Buffer !== </span><span class="s2">&quot;undefined&quot;</span>
    <span class="s0">? (str) =&gt; Buffer.from(str).toString(</span><span class="s2">&quot;base64&quot;</span><span class="s0">)</span>
    <span class="s0">: (str) =&gt; btoa(unescape(encodeURIComponent(str)));</span>

<span class="s1">function </span><span class="s0">read_source_map(code) {</span>
    <span class="s1">var </span><span class="s0">match = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/</span><span class="s4">0</span><span class="s0">-</span><span class="s4">9</span><span class="s0">A-Za-z]*=*)\s*$/.exec(code);</span>
    <span class="s1">if </span><span class="s0">(!match) {</span>
        <span class="s0">console.warn(</span><span class="s2">&quot;inline source map not found&quot;</span><span class="s0">);</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">to_ascii(match[</span><span class="s4">2</span><span class="s0">]);</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">set_shorthand(name, options, keys) {</span>
    <span class="s1">if </span><span class="s0">(options[name]) {</span>
        <span class="s0">keys.forEach(</span><span class="s1">function</span><span class="s0">(key) {</span>
            <span class="s1">if </span><span class="s0">(options[key]) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options[key] != </span><span class="s2">&quot;object&quot;</span><span class="s0">) options[key] = {};</span>
                <span class="s1">if </span><span class="s0">(!(name </span><span class="s1">in </span><span class="s0">options[key])) options[key][name] = options[name];</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">init_cache(cache) {</span>
    <span class="s1">if </span><span class="s0">(!cache) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s2">&quot;props&quot; </span><span class="s1">in </span><span class="s0">cache)) {</span>
        <span class="s0">cache.props = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!(cache.props </span><span class="s1">instanceof </span><span class="s0">Map)) {</span>
        <span class="s0">cache.props = map_from_object(cache.props);</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">cache_to_json(cache) {</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">props: map_to_object(cache.props)</span>
    <span class="s0">};</span>
<span class="s0">}</span>

<span class="s1">function </span><span class="s0">log_input(files, options, fs, debug_folder) {</span>
    <span class="s1">if </span><span class="s0">(!(fs &amp;&amp; fs.writeFileSync &amp;&amp; fs.mkdirSync)) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">fs.mkdirSync(debug_folder);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
        <span class="s1">if </span><span class="s0">(e.code !== </span><span class="s2">&quot;EEXIST&quot;</span><span class="s0">) </span><span class="s1">throw </span><span class="s0">e;</span>
    <span class="s0">}</span>

    <span class="s0">const log_path = `${debug_folder}/terser-debug-${(Math.random() * </span><span class="s4">9999999</span><span class="s0">) | </span><span class="s4">0</span><span class="s0">}.log`;</span>

    <span class="s0">options = options || {};</span>

    <span class="s0">const options_str = JSON.stringify(options, (_key, thing) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">thing === </span><span class="s2">&quot;function&quot;</span><span class="s0">) </span><span class="s1">return </span><span class="s2">&quot;[Function &quot; </span><span class="s0">+ thing.toString() + </span><span class="s2">&quot;]&quot;</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(thing </span><span class="s1">instanceof </span><span class="s0">RegExp) </span><span class="s1">return </span><span class="s2">&quot;[RegExp &quot; </span><span class="s0">+ thing.toString() + </span><span class="s2">&quot;]&quot;</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">thing;</span>
    <span class="s0">}, </span><span class="s4">4</span><span class="s0">);</span>

    <span class="s0">const files_str = (file) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">file === </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp; options.parse &amp;&amp; options.parse.spidermonkey) {</span>
            <span class="s1">return </span><span class="s0">JSON.stringify(file, </span><span class="s1">null</span><span class="s0">, </span><span class="s4">2</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">file === </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">Object.keys(file)</span>
                <span class="s0">.map((key) =&gt; key + </span><span class="s2">&quot;: &quot; </span><span class="s0">+ files_str(file[key]))</span>
                <span class="s0">.join(</span><span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">&quot;</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">file === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s2">&quot;```</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s0">+ file + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">```&quot;</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">file; </span><span class="s3">// What do?</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s0">fs.writeFileSync(log_path, </span><span class="s2">&quot;Options: </span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s0">+ options_str + </span><span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Input files:</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s0">+ files_str(files) + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
<span class="s0">}</span>

<span class="s0">async </span><span class="s1">function </span><span class="s0">minify(files, options, _fs_module) {</span>
    <span class="s1">if </span><span class="s0">(</span>
        <span class="s0">_fs_module</span>
        <span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">process === </span><span class="s2">&quot;object&quot;</span>
        <span class="s0">&amp;&amp; process.env</span>
        <span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">process.env.TERSER_DEBUG_DIR === </span><span class="s2">&quot;string&quot;</span>
    <span class="s0">) {</span>
        <span class="s0">log_input(files, options, _fs_module, process.env.TERSER_DEBUG_DIR);</span>
    <span class="s0">}</span>

    <span class="s0">options = defaults(options, {</span>
        <span class="s0">compress: {},</span>
        <span class="s0">ecma: undefined,</span>
        <span class="s0">enclose: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">ie8: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">keep_classnames: undefined,</span>
        <span class="s0">keep_fnames: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">mangle: {},</span>
        <span class="s0">module: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">nameCache: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">output: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">format: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">parse: {},</span>
        <span class="s0">rename: undefined,</span>
        <span class="s0">safari10: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">sourceMap: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">spidermonkey: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">timings: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">toplevel: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">warnings: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">wrap: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s1">var </span><span class="s0">timings = options.timings &amp;&amp; {</span>
        <span class="s0">start: Date.now()</span>
    <span class="s0">};</span>
    <span class="s1">if </span><span class="s0">(options.keep_classnames === undefined) {</span>
        <span class="s0">options.keep_classnames = options.keep_fnames;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.rename === undefined) {</span>
        <span class="s0">options.rename = options.compress &amp;&amp; options.mangle;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.output &amp;&amp; options.format) {</span>
        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Please only specify either output or format option, preferrably format.&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">options.format = options.format || options.output || {};</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;ecma&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;parse&quot;</span><span class="s0">, </span><span class="s2">&quot;compress&quot;</span><span class="s0">, </span><span class="s2">&quot;format&quot; </span><span class="s0">]);</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;ie8&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;compress&quot;</span><span class="s0">, </span><span class="s2">&quot;mangle&quot;</span><span class="s0">, </span><span class="s2">&quot;format&quot; </span><span class="s0">]);</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;keep_classnames&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;compress&quot;</span><span class="s0">, </span><span class="s2">&quot;mangle&quot; </span><span class="s0">]);</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;keep_fnames&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;compress&quot;</span><span class="s0">, </span><span class="s2">&quot;mangle&quot; </span><span class="s0">]);</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;module&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;parse&quot;</span><span class="s0">, </span><span class="s2">&quot;compress&quot;</span><span class="s0">, </span><span class="s2">&quot;mangle&quot; </span><span class="s0">]);</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;safari10&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;mangle&quot;</span><span class="s0">, </span><span class="s2">&quot;format&quot; </span><span class="s0">]);</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;toplevel&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;compress&quot;</span><span class="s0">, </span><span class="s2">&quot;mangle&quot; </span><span class="s0">]);</span>
    <span class="s0">set_shorthand(</span><span class="s2">&quot;warnings&quot;</span><span class="s0">, options, [ </span><span class="s2">&quot;compress&quot; </span><span class="s0">]); </span><span class="s3">// legacy</span>
    <span class="s1">var </span><span class="s0">quoted_props;</span>
    <span class="s1">if </span><span class="s0">(options.mangle) {</span>
        <span class="s0">options.mangle = defaults(options.mangle, {</span>
            <span class="s0">cache: options.nameCache &amp;&amp; (options.nameCache.vars || {}),</span>
            <span class="s0">eval: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">ie8: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">keep_classnames: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">keep_fnames: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">module: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">nth_identifier: base54,</span>
            <span class="s0">properties: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">reserved: [],</span>
            <span class="s0">safari10: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">toplevel: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(options.mangle.properties) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options.mangle.properties != </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
                <span class="s0">options.mangle.properties = {};</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(options.mangle.properties.keep_quoted) {</span>
                <span class="s0">quoted_props = options.mangle.properties.reserved;</span>
                <span class="s1">if </span><span class="s0">(!Array.isArray(quoted_props)) quoted_props = [];</span>
                <span class="s0">options.mangle.properties.reserved = quoted_props;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(options.nameCache &amp;&amp; !(</span><span class="s2">&quot;cache&quot; </span><span class="s1">in </span><span class="s0">options.mangle.properties)) {</span>
                <span class="s0">options.mangle.properties.cache = options.nameCache.props || {};</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">init_cache(options.mangle.cache);</span>
        <span class="s0">init_cache(options.mangle.properties.cache);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.sourceMap) {</span>
        <span class="s0">options.sourceMap = defaults(options.sourceMap, {</span>
            <span class="s0">asObject: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">content: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">filename: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">includeSources: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">root: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">url: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">}, </span><span class="s1">true</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">// -- Parse phase --</span>
    <span class="s1">if </span><span class="s0">(timings) timings.parse = Date.now();</span>
    <span class="s1">var </span><span class="s0">toplevel;</span>
    <span class="s1">if </span><span class="s0">(files </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) {</span>
        <span class="s0">toplevel = files;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">files == </span><span class="s2">&quot;string&quot; </span><span class="s0">|| (options.parse.spidermonkey &amp;&amp; !Array.isArray(files))) {</span>
            <span class="s0">files = [ files ];</span>
        <span class="s0">}</span>
        <span class="s0">options.parse = options.parse || {};</span>
        <span class="s0">options.parse.toplevel = </span><span class="s1">null</span><span class="s0">;</span>

        <span class="s1">if </span><span class="s0">(options.parse.spidermonkey) {</span>
            <span class="s0">options.parse.toplevel = AST_Node.from_mozilla_ast(Object.keys(files).reduce(</span><span class="s1">function</span><span class="s0">(toplevel, name) {</span>
                <span class="s1">if </span><span class="s0">(!toplevel) </span><span class="s1">return </span><span class="s0">files[name];</span>
                <span class="s0">toplevel.body = toplevel.body.concat(files[name].body);</span>
                <span class="s1">return </span><span class="s0">toplevel;</span>
            <span class="s0">}, </span><span class="s1">null</span><span class="s0">));</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">delete </span><span class="s0">options.parse.spidermonkey;</span>

            <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">files) </span><span class="s1">if </span><span class="s0">(HOP(files, name)) {</span>
                <span class="s0">options.parse.filename = name;</span>
                <span class="s0">options.parse.toplevel = parse(files[name], options.parse);</span>
                <span class="s1">if </span><span class="s0">(options.sourceMap &amp;&amp; options.sourceMap.content == </span><span class="s2">&quot;inline&quot;</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(Object.keys(files).length &gt; </span><span class="s4">1</span><span class="s0">)</span>
                        <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;inline source map only works with singular input&quot;</span><span class="s0">);</span>
                    <span class="s0">options.sourceMap.content = read_source_map(files[name]);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>

        <span class="s0">toplevel = options.parse.toplevel;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(quoted_props &amp;&amp; options.mangle.properties.keep_quoted !== </span><span class="s2">&quot;strict&quot;</span><span class="s0">) {</span>
        <span class="s0">reserve_quoted_keys(toplevel, quoted_props);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">annotated_props;</span>
    <span class="s1">if </span><span class="s0">(options.mangle &amp;&amp; options.mangle.properties) {</span>
        <span class="s0">annotated_props = find_annotated_props(toplevel);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.wrap) {</span>
        <span class="s0">toplevel = toplevel.wrap_commonjs(options.wrap);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.enclose) {</span>
        <span class="s0">toplevel = toplevel.wrap_enclose(options.enclose);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(timings) timings.rename = Date.now();</span>

    <span class="s3">// -- Compress phase --</span>
    <span class="s1">if </span><span class="s0">(timings) timings.compress = Date.now();</span>
    <span class="s1">if </span><span class="s0">(options.compress) {</span>
        <span class="s0">toplevel = </span><span class="s1">new </span><span class="s0">Compressor(options.compress, {</span>
            <span class="s0">mangle_options: options.mangle</span>
        <span class="s0">}).compress(toplevel);</span>
    <span class="s0">}</span>

    <span class="s3">// -- Mangle phase --</span>
    <span class="s1">if </span><span class="s0">(timings) timings.scope = Date.now();</span>
    <span class="s1">if </span><span class="s0">(options.mangle) toplevel.figure_out_scope(options.mangle);</span>
    <span class="s1">if </span><span class="s0">(timings) timings.mangle = Date.now();</span>
    <span class="s1">if </span><span class="s0">(options.mangle) {</span>
        <span class="s0">toplevel.compute_char_frequency(options.mangle);</span>
        <span class="s0">toplevel.mangle_names(options.mangle);</span>
        <span class="s0">toplevel = mangle_private_properties(toplevel, options.mangle);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(timings) timings.properties = Date.now();</span>
    <span class="s1">if </span><span class="s0">(options.mangle &amp;&amp; options.mangle.properties) {</span>
        <span class="s0">toplevel = mangle_properties(toplevel, options.mangle.properties, annotated_props);</span>
    <span class="s0">}</span>

    <span class="s3">// Format phase</span>
    <span class="s1">if </span><span class="s0">(timings) timings.format = Date.now();</span>
    <span class="s1">var </span><span class="s0">result = {};</span>
    <span class="s1">if </span><span class="s0">(options.format.ast) {</span>
        <span class="s0">result.ast = toplevel;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.format.spidermonkey) {</span>
        <span class="s0">result.ast = toplevel.to_mozilla_ast();</span>
    <span class="s0">}</span>
    <span class="s0">let format_options;</span>
    <span class="s1">if </span><span class="s0">(!HOP(options.format, </span><span class="s2">&quot;code&quot;</span><span class="s0">) || options.format.code) {</span>
        <span class="s3">// Make a shallow copy so that we can modify without mutating the user's input.</span>
        <span class="s0">format_options = {...options.format};</span>
        <span class="s1">if </span><span class="s0">(!format_options.ast) {</span>
            <span class="s3">// Destroy stuff to save RAM. (unless the deprecated `ast` option is on)</span>
            <span class="s0">format_options._destroy_ast = </span><span class="s1">true</span><span class="s0">;</span>

            <span class="s0">walk(toplevel, node =&gt; {</span>
                <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Scope) {</span>
                    <span class="s0">node.variables = undefined;</span>
                    <span class="s0">node.enclosed = undefined;</span>
                    <span class="s0">node.parent_scope = undefined;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(node.block_scope) {</span>
                    <span class="s0">node.block_scope.variables = undefined;</span>
                    <span class="s0">node.block_scope.enclosed = undefined;</span>
                    <span class="s0">node.parent_scope = undefined;</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(options.sourceMap) {</span>
            <span class="s1">if </span><span class="s0">(options.sourceMap.includeSources &amp;&amp; files </span><span class="s1">instanceof </span><span class="s0">AST_Toplevel) {</span>
                <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;original source content unavailable&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">format_options.source_map = await SourceMap({</span>
                <span class="s0">file: options.sourceMap.filename,</span>
                <span class="s0">orig: options.sourceMap.content,</span>
                <span class="s0">root: options.sourceMap.root,</span>
                <span class="s0">files: options.sourceMap.includeSources ? files : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">delete </span><span class="s0">format_options.ast;</span>
        <span class="s1">delete </span><span class="s0">format_options.code;</span>
        <span class="s1">delete </span><span class="s0">format_options.spidermonkey;</span>
        <span class="s1">var </span><span class="s0">stream = OutputStream(format_options);</span>
        <span class="s0">toplevel.print(stream);</span>
        <span class="s0">result.code = stream.get();</span>
        <span class="s1">if </span><span class="s0">(options.sourceMap) {</span>
            <span class="s0">Object.defineProperty(result, </span><span class="s2">&quot;map&quot;</span><span class="s0">, {</span>
                <span class="s0">configurable: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">get() {</span>
                    <span class="s0">const map = format_options.source_map.getEncoded();</span>
                    <span class="s1">return </span><span class="s0">(result.map = options.sourceMap.asObject ? map : JSON.stringify(map));</span>
                <span class="s0">},</span>
                <span class="s0">set(value) {</span>
                    <span class="s0">Object.defineProperty(result, </span><span class="s2">&quot;map&quot;</span><span class="s0">, {</span>
                        <span class="s0">value,</span>
                        <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s0">result.decoded_map = format_options.source_map.getDecoded();</span>
            <span class="s1">if </span><span class="s0">(options.sourceMap.url == </span><span class="s2">&quot;inline&quot;</span><span class="s0">) {</span>
                <span class="s1">var </span><span class="s0">sourceMap = </span><span class="s1">typeof </span><span class="s0">result.map === </span><span class="s2">&quot;object&quot; </span><span class="s0">? JSON.stringify(result.map) : result.map;</span>
                <span class="s0">result.code += </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">//# sourceMappingURL=data:application/json;charset=utf-8;base64,&quot; </span><span class="s0">+ to_base64(sourceMap);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(options.sourceMap.url) {</span>
                <span class="s0">result.code += </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">//# sourceMappingURL=&quot; </span><span class="s0">+ options.sourceMap.url;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(options.nameCache &amp;&amp; options.mangle) {</span>
        <span class="s1">if </span><span class="s0">(options.mangle.cache) options.nameCache.vars = cache_to_json(options.mangle.cache);</span>
        <span class="s1">if </span><span class="s0">(options.mangle.properties &amp;&amp; options.mangle.properties.cache) {</span>
            <span class="s0">options.nameCache.props = cache_to_json(options.mangle.properties.cache);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(format_options &amp;&amp; format_options.source_map) {</span>
        <span class="s0">format_options.source_map.destroy();</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(timings) {</span>
        <span class="s0">timings.end = Date.now();</span>
        <span class="s0">result.timings = {</span>
            <span class="s0">parse: </span><span class="s4">1</span><span class="s0">e-3 * (timings.rename - timings.parse),</span>
            <span class="s0">rename: </span><span class="s4">1</span><span class="s0">e-3 * (timings.compress - timings.rename),</span>
            <span class="s0">compress: </span><span class="s4">1</span><span class="s0">e-3 * (timings.scope - timings.compress),</span>
            <span class="s0">scope: </span><span class="s4">1</span><span class="s0">e-3 * (timings.mangle - timings.scope),</span>
            <span class="s0">mangle: </span><span class="s4">1</span><span class="s0">e-3 * (timings.properties - timings.mangle),</span>
            <span class="s0">properties: </span><span class="s4">1</span><span class="s0">e-3 * (timings.format - timings.properties),</span>
            <span class="s0">format: </span><span class="s4">1</span><span class="s0">e-3 * (timings.end - timings.format),</span>
            <span class="s0">total: </span><span class="s4">1</span><span class="s0">e-3 * (timings.end - timings.start)</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s0">async </span><span class="s1">function </span><span class="s0">run_cli({ program, packageJson, fs, path }) {</span>
    <span class="s0">const skip_keys = </span><span class="s1">new </span><span class="s0">Set([ </span><span class="s2">&quot;cname&quot;</span><span class="s0">, </span><span class="s2">&quot;parent_scope&quot;</span><span class="s0">, </span><span class="s2">&quot;scope&quot;</span><span class="s0">, </span><span class="s2">&quot;uses_eval&quot;</span><span class="s0">, </span><span class="s2">&quot;uses_with&quot; </span><span class="s0">]);</span>
    <span class="s1">var </span><span class="s0">files = {};</span>
    <span class="s1">var </span><span class="s0">options = {</span>
        <span class="s0">compress: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">mangle: </span><span class="s1">false</span>
    <span class="s0">};</span>
    <span class="s0">const default_options = await _default_options();</span>
    <span class="s0">program.version(packageJson.name + </span><span class="s2">&quot; &quot; </span><span class="s0">+ packageJson.version);</span>
    <span class="s0">program.parseArgv = program.parse;</span>
    <span class="s0">program.parse = undefined;</span>

    <span class="s1">if </span><span class="s0">(process.argv.includes(</span><span class="s2">&quot;ast&quot;</span><span class="s0">)) program.helpInformation = describe_ast;</span>
    <span class="s1">else if </span><span class="s0">(process.argv.includes(</span><span class="s2">&quot;options&quot;</span><span class="s0">)) program.helpInformation = </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">var </span><span class="s0">text = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">option </span><span class="s1">in </span><span class="s0">default_options) {</span>
            <span class="s0">text.push(</span><span class="s2">&quot;--&quot; </span><span class="s0">+ (option === </span><span class="s2">&quot;sourceMap&quot; </span><span class="s0">? </span><span class="s2">&quot;source-map&quot; </span><span class="s0">: option) + </span><span class="s2">&quot; options:&quot;</span><span class="s0">);</span>
            <span class="s0">text.push(format_object(default_options[option]));</span>
            <span class="s0">text.push(</span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">text.join(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
    <span class="s0">};</span>

    <span class="s0">program.option(</span><span class="s2">&quot;-p, --parse &lt;options&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;Specify parser options.&quot;</span><span class="s0">, parse_js());</span>
    <span class="s0">program.option(</span><span class="s2">&quot;-c, --compress [options]&quot;</span><span class="s0">, </span><span class="s2">&quot;Enable compressor/specify compressor options.&quot;</span><span class="s0">, parse_js());</span>
    <span class="s0">program.option(</span><span class="s2">&quot;-m, --mangle [options]&quot;</span><span class="s0">, </span><span class="s2">&quot;Mangle names/specify mangler options.&quot;</span><span class="s0">, parse_js());</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--mangle-props [options]&quot;</span><span class="s0">, </span><span class="s2">&quot;Mangle properties/specify mangler options.&quot;</span><span class="s0">, parse_js());</span>
    <span class="s0">program.option(</span><span class="s2">&quot;-f, --format [options]&quot;</span><span class="s0">, </span><span class="s2">&quot;Format options.&quot;</span><span class="s0">, parse_js());</span>
    <span class="s0">program.option(</span><span class="s2">&quot;-b, --beautify [options]&quot;</span><span class="s0">, </span><span class="s2">&quot;Alias for --format.&quot;</span><span class="s0">, parse_js());</span>
    <span class="s0">program.option(</span><span class="s2">&quot;-o, --output &lt;file&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;Output file (default STDOUT).&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--comments [filter]&quot;</span><span class="s0">, </span><span class="s2">&quot;Preserve copyright comments in the output.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--config-file &lt;file&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;Read minify() options from JSON file.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;-d, --define &lt;expr&gt;[=value]&quot;</span><span class="s0">, </span><span class="s2">&quot;Global definitions.&quot;</span><span class="s0">, parse_js(</span><span class="s2">&quot;define&quot;</span><span class="s0">));</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--ecma &lt;version&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;Specify ECMAScript release: 5, 2015, 2016 or 2017...&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;-e, --enclose [arg[,...][:value[,...]]]&quot;</span><span class="s0">, </span><span class="s2">&quot;Embed output in a big function with configurable arguments and values.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--ie8&quot;</span><span class="s0">, </span><span class="s2">&quot;Support non-standard Internet Explorer 8.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--keep-classnames&quot;</span><span class="s0">, </span><span class="s2">&quot;Do not mangle/drop class names.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--keep-fnames&quot;</span><span class="s0">, </span><span class="s2">&quot;Do not mangle/drop function names. Useful for code relying on Function.prototype.name.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--module&quot;</span><span class="s0">, </span><span class="s2">&quot;Input is an ES6 module&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--name-cache &lt;file&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;File to hold mangled name mappings.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--rename&quot;</span><span class="s0">, </span><span class="s2">&quot;Force symbol expansion.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--no-rename&quot;</span><span class="s0">, </span><span class="s2">&quot;Disable symbol expansion.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--safari10&quot;</span><span class="s0">, </span><span class="s2">&quot;Support non-standard Safari 10.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--source-map [options]&quot;</span><span class="s0">, </span><span class="s2">&quot;Enable source map/specify source map options.&quot;</span><span class="s0">, parse_js());</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--timings&quot;</span><span class="s0">, </span><span class="s2">&quot;Display operations run time on STDERR.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--toplevel&quot;</span><span class="s0">, </span><span class="s2">&quot;Compress and/or mangle variables in toplevel scope.&quot;</span><span class="s0">);</span>
    <span class="s0">program.option(</span><span class="s2">&quot;--wrap &lt;name&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;Embed everything as a function with “exports” corresponding to “name” globally.&quot;</span><span class="s0">);</span>
    <span class="s0">program.arguments(</span><span class="s2">&quot;[files...]&quot;</span><span class="s0">).parseArgv(process.argv);</span>
    <span class="s1">if </span><span class="s0">(program.configFile) {</span>
        <span class="s0">options = JSON.parse(read_file(program.configFile));</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!program.output &amp;&amp; program.sourceMap &amp;&amp; program.sourceMap.url != </span><span class="s2">&quot;inline&quot;</span><span class="s0">) {</span>
        <span class="s0">fatal(</span><span class="s2">&quot;ERROR: cannot write source map to STDOUT&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">[</span>
        <span class="s2">&quot;compress&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;enclose&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;ie8&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;mangle&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;module&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;safari10&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;sourceMap&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;toplevel&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;wrap&quot;</span>
    <span class="s0">].forEach(</span><span class="s1">function</span><span class="s0">(name) {</span>
        <span class="s1">if </span><span class="s0">(name </span><span class="s1">in </span><span class="s0">program) {</span>
            <span class="s0">options[name] = program[name];</span>
        <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;ecma&quot; </span><span class="s1">in </span><span class="s0">program) {</span>
        <span class="s1">if </span><span class="s0">(program.ecma != (program.ecma | </span><span class="s4">0</span><span class="s0">)) fatal(</span><span class="s2">&quot;ERROR: ecma must be an integer&quot;</span><span class="s0">);</span>
        <span class="s0">const ecma = program.ecma | </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(ecma &gt; </span><span class="s4">5 </span><span class="s0">&amp;&amp; ecma &lt; </span><span class="s4">2015</span><span class="s0">)</span>
            <span class="s0">options.ecma = ecma + </span><span class="s4">2009</span><span class="s0">;</span>
        <span class="s1">else</span>
            <span class="s0">options.ecma = ecma;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.format || program.beautify) {</span>
        <span class="s0">const chosenOption = program.format || program.beautify;</span>
        <span class="s0">options.format = </span><span class="s1">typeof </span><span class="s0">chosenOption === </span><span class="s2">&quot;object&quot; </span><span class="s0">? chosenOption : {};</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.comments) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options.format != </span><span class="s2">&quot;object&quot;</span><span class="s0">) options.format = {};</span>
        <span class="s0">options.format.comments = </span><span class="s1">typeof </span><span class="s0">program.comments == </span><span class="s2">&quot;string&quot; </span><span class="s0">? (program.comments == </span><span class="s2">&quot;false&quot; </span><span class="s0">? </span><span class="s1">false </span><span class="s0">: program.comments) : </span><span class="s2">&quot;some&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.define) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options.compress != </span><span class="s2">&quot;object&quot;</span><span class="s0">) options.compress = {};</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options.compress.global_defs != </span><span class="s2">&quot;object&quot;</span><span class="s0">) options.compress.global_defs = {};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">expr </span><span class="s1">in </span><span class="s0">program.define) {</span>
            <span class="s0">options.compress.global_defs[expr] = program.define[expr];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.keepClassnames) {</span>
        <span class="s0">options.keep_classnames = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.keepFnames) {</span>
        <span class="s0">options.keep_fnames = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.mangleProps) {</span>
        <span class="s1">if </span><span class="s0">(program.mangleProps.domprops) {</span>
            <span class="s1">delete </span><span class="s0">program.mangleProps.domprops;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">program.mangleProps != </span><span class="s2">&quot;object&quot;</span><span class="s0">) program.mangleProps = {};</span>
            <span class="s1">if </span><span class="s0">(!Array.isArray(program.mangleProps.reserved)) program.mangleProps.reserved = [];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">options.mangle != </span><span class="s2">&quot;object&quot;</span><span class="s0">) options.mangle = {};</span>
        <span class="s0">options.mangle.properties = program.mangleProps;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.nameCache) {</span>
        <span class="s0">options.nameCache = JSON.parse(read_file(program.nameCache, </span><span class="s2">&quot;{}&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.output == </span><span class="s2">&quot;ast&quot;</span><span class="s0">) {</span>
        <span class="s0">options.format = {</span>
            <span class="s0">ast: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">code: </span><span class="s1">false</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(program.parse) {</span>
        <span class="s1">if </span><span class="s0">(!program.parse.acorn &amp;&amp; !program.parse.spidermonkey) {</span>
            <span class="s0">options.parse = program.parse;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(program.sourceMap &amp;&amp; program.sourceMap.content == </span><span class="s2">&quot;inline&quot;</span><span class="s0">) {</span>
            <span class="s0">fatal(</span><span class="s2">&quot;ERROR: inline source map only works with built-in parser&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(~program.rawArgs.indexOf(</span><span class="s2">&quot;--rename&quot;</span><span class="s0">)) {</span>
        <span class="s0">options.rename = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!program.rename) {</span>
        <span class="s0">options.rename = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s0">let convert_path = name =&gt; name;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">program.sourceMap == </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">&quot;base&quot; </span><span class="s1">in </span><span class="s0">program.sourceMap) {</span>
        <span class="s0">convert_path = </span><span class="s1">function</span><span class="s0">() {</span>
            <span class="s1">var </span><span class="s0">base = program.sourceMap.base;</span>
            <span class="s1">delete </span><span class="s0">options.sourceMap.base;</span>
            <span class="s1">return function</span><span class="s0">(name) {</span>
                <span class="s1">return </span><span class="s0">path.relative(base, name);</span>
            <span class="s0">};</span>
        <span class="s0">}();</span>
    <span class="s0">}</span>

    <span class="s0">let filesList;</span>
    <span class="s1">if </span><span class="s0">(options.files &amp;&amp; options.files.length) {</span>
        <span class="s0">filesList = options.files;</span>

        <span class="s1">delete </span><span class="s0">options.files;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(program.args.length) {</span>
        <span class="s0">filesList = program.args;</span>
    <span class="s0">}</span>

    <span class="s1">if </span><span class="s0">(filesList) {</span>
        <span class="s0">simple_glob(filesList).forEach(</span><span class="s1">function</span><span class="s0">(name) {</span>
            <span class="s0">files[convert_path(name)] = read_file(name);</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">await </span><span class="s1">new </span><span class="s0">Promise((resolve) =&gt; {</span>
            <span class="s1">var </span><span class="s0">chunks = [];</span>
            <span class="s0">process.stdin.setEncoding(</span><span class="s2">&quot;utf8&quot;</span><span class="s0">);</span>
            <span class="s0">process.stdin.on(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">(chunk) {</span>
                <span class="s0">chunks.push(chunk);</span>
            <span class="s0">}).on(</span><span class="s2">&quot;end&quot;</span><span class="s0">, </span><span class="s1">function</span><span class="s0">() {</span>
                <span class="s0">files = [ chunks.join(</span><span class="s2">&quot;&quot;</span><span class="s0">) ];</span>
                <span class="s0">resolve();</span>
            <span class="s0">});</span>
            <span class="s0">process.stdin.resume();</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s0">await run_cli();</span>

    <span class="s1">function </span><span class="s0">convert_ast(fn) {</span>
        <span class="s1">return </span><span class="s0">AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, </span><span class="s1">null</span><span class="s0">));</span>
    <span class="s0">}</span>

    <span class="s0">async </span><span class="s1">function </span><span class="s0">run_cli() {</span>
        <span class="s1">var </span><span class="s0">content = program.sourceMap &amp;&amp; program.sourceMap.content;</span>
        <span class="s1">if </span><span class="s0">(content &amp;&amp; content !== </span><span class="s2">&quot;inline&quot;</span><span class="s0">) {</span>
            <span class="s0">options.sourceMap.content = read_file(content, content);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(program.timings) options.timings = </span><span class="s1">true</span><span class="s0">;</span>

        <span class="s1">try </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(program.parse) {</span>
                <span class="s1">if </span><span class="s0">(program.parse.acorn) {</span>
                    <span class="s0">files = convert_ast(</span><span class="s1">function</span><span class="s0">(toplevel, name) {</span>
                        <span class="s1">return </span><span class="s0">require(</span><span class="s2">&quot;acorn&quot;</span><span class="s0">).parse(files[name], {</span>
                            <span class="s0">ecmaVersion: </span><span class="s4">2018</span><span class="s0">,</span>
                            <span class="s0">locations: </span><span class="s1">true</span><span class="s0">,</span>
                            <span class="s0">program: toplevel,</span>
                            <span class="s0">sourceFile: name,</span>
                            <span class="s0">sourceType: options.module || program.parse.module ? </span><span class="s2">&quot;module&quot; </span><span class="s0">: </span><span class="s2">&quot;script&quot;</span>
                        <span class="s0">});</span>
                    <span class="s0">});</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(program.parse.spidermonkey) {</span>
                    <span class="s0">files = convert_ast(</span><span class="s1">function</span><span class="s0">(toplevel, name) {</span>
                        <span class="s1">var </span><span class="s0">obj = JSON.parse(files[name]);</span>
                        <span class="s1">if </span><span class="s0">(!toplevel) </span><span class="s1">return </span><span class="s0">obj;</span>
                        <span class="s0">toplevel.body = toplevel.body.concat(obj.body);</span>
                        <span class="s1">return </span><span class="s0">toplevel;</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) {</span>
            <span class="s0">fatal(ex);</span>
        <span class="s0">}</span>

        <span class="s0">let result;</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">result = await minify(files, options, fs);</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) {</span>
            <span class="s1">if </span><span class="s0">(ex.name == </span><span class="s2">&quot;SyntaxError&quot;</span><span class="s0">) {</span>
                <span class="s0">print_error(</span><span class="s2">&quot;Parse error at &quot; </span><span class="s0">+ ex.filename + </span><span class="s2">&quot;:&quot; </span><span class="s0">+ ex.line + </span><span class="s2">&quot;,&quot; </span><span class="s0">+ ex.col);</span>
                <span class="s1">var </span><span class="s0">col = ex.col;</span>
                <span class="s1">var </span><span class="s0">lines = files[ex.filename].split(/\r?\n/);</span>
                <span class="s1">var </span><span class="s0">line = lines[ex.line - </span><span class="s4">1</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">(!line &amp;&amp; !col) {</span>
                    <span class="s0">line = lines[ex.line - </span><span class="s4">2</span><span class="s0">];</span>
                    <span class="s0">col = line.length;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(line) {</span>
                    <span class="s1">var </span><span class="s0">limit = </span><span class="s4">70</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(col &gt; limit) {</span>
                        <span class="s0">line = line.slice(col - limit);</span>
                        <span class="s0">col = limit;</span>
                    <span class="s0">}</span>
                    <span class="s0">print_error(line.slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">80</span><span class="s0">));</span>
                    <span class="s0">print_error(line.slice(</span><span class="s4">0</span><span class="s0">, col).replace(/\S/g, </span><span class="s2">&quot; &quot;</span><span class="s0">) + </span><span class="s2">&quot;^&quot;</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(ex.defs) {</span>
                <span class="s0">print_error(</span><span class="s2">&quot;Supported options:&quot;</span><span class="s0">);</span>
                <span class="s0">print_error(format_object(ex.defs));</span>
            <span class="s0">}</span>
            <span class="s0">fatal(ex);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>

        <span class="s1">if </span><span class="s0">(program.output == </span><span class="s2">&quot;ast&quot;</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(!options.compress &amp;&amp; !options.mangle) {</span>
                <span class="s0">result.ast.figure_out_scope({});</span>
            <span class="s0">}</span>
            <span class="s0">console.log(JSON.stringify(result.ast, </span><span class="s1">function</span><span class="s0">(key, value) {</span>
                <span class="s1">if </span><span class="s0">(value) </span><span class="s1">switch </span><span class="s0">(key) {</span>
                  <span class="s1">case </span><span class="s2">&quot;thedef&quot;</span><span class="s0">:</span>
                    <span class="s1">return </span><span class="s0">symdef(value);</span>
                  <span class="s1">case </span><span class="s2">&quot;enclosed&quot;</span><span class="s0">:</span>
                    <span class="s1">return </span><span class="s0">value.length ? value.map(symdef) : undefined;</span>
                  <span class="s1">case </span><span class="s2">&quot;variables&quot;</span><span class="s0">:</span>
                  <span class="s1">case </span><span class="s2">&quot;globals&quot;</span><span class="s0">:</span>
                    <span class="s1">return </span><span class="s0">value.size ? collect_from_map(value, symdef) : undefined;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(skip_keys.has(key)) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_Token) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">Map) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_Node) {</span>
                    <span class="s1">var </span><span class="s0">result = {</span>
                        <span class="s0">_class: </span><span class="s2">&quot;AST_&quot; </span><span class="s0">+ value.TYPE</span>
                    <span class="s0">};</span>
                    <span class="s1">if </span><span class="s0">(value.block_scope) {</span>
                        <span class="s0">result.variables = value.block_scope.variables;</span>
                        <span class="s0">result.enclosed = value.block_scope.enclosed;</span>
                    <span class="s0">}</span>
                    <span class="s0">value.CTOR.PROPS.forEach(</span><span class="s1">function</span><span class="s0">(prop) {</span>
                        <span class="s1">if </span><span class="s0">(prop !== </span><span class="s2">&quot;block_scope&quot;</span><span class="s0">) {</span>
                            <span class="s0">result[prop] = value[prop];</span>
                        <span class="s0">}</span>
                    <span class="s0">});</span>
                    <span class="s1">return </span><span class="s0">result;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">value;</span>
            <span class="s0">}, </span><span class="s4">2</span><span class="s0">));</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(program.output == </span><span class="s2">&quot;spidermonkey&quot;</span><span class="s0">) {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">const minified = await minify(</span>
                    <span class="s0">result.code,</span>
                    <span class="s0">{</span>
                        <span class="s0">compress: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">mangle: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">format: {</span>
                            <span class="s0">ast: </span><span class="s1">true</span><span class="s0">,</span>
                            <span class="s0">code: </span><span class="s1">false</span>
                        <span class="s0">}</span>
                    <span class="s0">},</span>
                    <span class="s0">fs</span>
                <span class="s0">);</span>
                <span class="s0">console.log(JSON.stringify(minified.ast.to_mozilla_ast(), </span><span class="s1">null</span><span class="s0">, </span><span class="s4">2</span><span class="s0">));</span>
            <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) {</span>
                <span class="s0">fatal(ex);</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(program.output) {</span>
            <span class="s0">fs.writeFileSync(program.output, result.code);</span>
            <span class="s1">if </span><span class="s0">(options.sourceMap &amp;&amp; options.sourceMap.url !== </span><span class="s2">&quot;inline&quot; </span><span class="s0">&amp;&amp; result.map) {</span>
                <span class="s0">fs.writeFileSync(program.output + </span><span class="s2">&quot;.map&quot;</span><span class="s0">, result.map);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">console.log(result.code);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(program.nameCache) {</span>
            <span class="s0">fs.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(result.timings) </span><span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">phase </span><span class="s1">in </span><span class="s0">result.timings) {</span>
            <span class="s0">print_error(</span><span class="s2">&quot;- &quot; </span><span class="s0">+ phase + </span><span class="s2">&quot;: &quot; </span><span class="s0">+ result.timings[phase].toFixed(</span><span class="s4">3</span><span class="s0">) + </span><span class="s2">&quot;s&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">fatal(message) {</span>
        <span class="s1">if </span><span class="s0">(message </span><span class="s1">instanceof </span><span class="s0">Error) message = message.stack.replace(/^\S*?Error:/, </span><span class="s2">&quot;ERROR:&quot;</span><span class="s0">);</span>
        <span class="s0">print_error(message);</span>
        <span class="s0">process.exit(</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">// A file glob function that only supports &quot;*&quot; and &quot;?&quot; wildcards in the basename.</span>
    <span class="s3">// Example: &quot;foo/bar/*baz??.*.js&quot;</span>
    <span class="s3">// Argument `glob` may be a string or an array of strings.</span>
    <span class="s3">// Returns an array of strings. Garbage in, garbage out.</span>
    <span class="s1">function </span><span class="s0">simple_glob(glob) {</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(glob)) {</span>
            <span class="s1">return </span><span class="s0">[].concat.apply([], glob.map(simple_glob));</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(glob &amp;&amp; glob.match(/[*?]/)) {</span>
            <span class="s1">var </span><span class="s0">dir = path.dirname(glob);</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s1">var </span><span class="s0">entries = fs.readdirSync(dir);</span>
            <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) {}</span>
            <span class="s1">if </span><span class="s0">(entries) {</span>
                <span class="s1">var </span><span class="s0">pattern = </span><span class="s2">&quot;^&quot; </span><span class="s0">+ path.basename(glob)</span>
                    <span class="s0">.replace(/[.+^$[\]\\(){}]/g, </span><span class="s2">&quot;</span><span class="s5">\\</span><span class="s2">$&amp;&quot;</span><span class="s0">)</span>
                    <span class="s0">.replace(/\*/g, </span><span class="s2">&quot;[^/</span><span class="s5">\\\\</span><span class="s2">]*&quot;</span><span class="s0">)</span>
                    <span class="s0">.replace(/\?/g, </span><span class="s2">&quot;[^/</span><span class="s5">\\\\</span><span class="s2">]&quot;</span><span class="s0">) + </span><span class="s2">&quot;$&quot;</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">mod = process.platform === </span><span class="s2">&quot;win32&quot; </span><span class="s0">? </span><span class="s2">&quot;i&quot; </span><span class="s0">: </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                <span class="s1">var </span><span class="s0">rx = </span><span class="s1">new </span><span class="s0">RegExp(pattern, mod);</span>
                <span class="s1">var </span><span class="s0">results = entries.filter(</span><span class="s1">function</span><span class="s0">(name) {</span>
                    <span class="s1">return </span><span class="s0">rx.test(name);</span>
                <span class="s0">}).map(</span><span class="s1">function</span><span class="s0">(name) {</span>
                    <span class="s1">return </span><span class="s0">path.join(dir, name);</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(results.length) </span><span class="s1">return </span><span class="s0">results;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">[ glob ];</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">read_file(path, default_value) {</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">fs.readFileSync(path, </span><span class="s2">&quot;utf8&quot;</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">catch </span><span class="s0">(ex) {</span>
            <span class="s1">if </span><span class="s0">((ex.code == </span><span class="s2">&quot;ENOENT&quot; </span><span class="s0">|| ex.code == </span><span class="s2">&quot;ENAMETOOLONG&quot;</span><span class="s0">) &amp;&amp; default_value != </span><span class="s1">null</span><span class="s0">) </span><span class="s1">return </span><span class="s0">default_value;</span>
            <span class="s0">fatal(ex);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">parse_js(flag) {</span>
        <span class="s1">return function</span><span class="s0">(value, options) {</span>
            <span class="s0">options = options || {};</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">walk(parse(value, { expression: </span><span class="s1">true </span><span class="s0">}), node =&gt; {</span>
                    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Assign) {</span>
                        <span class="s1">var </span><span class="s0">name = node.left.print_to_string();</span>
                        <span class="s1">var </span><span class="s0">value = node.right;</span>
                        <span class="s1">if </span><span class="s0">(flag) {</span>
                            <span class="s0">options[name] = value;</span>
                        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_Array) {</span>
                            <span class="s0">options[name] = value.elements.map(to_string);</span>
                        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(value </span><span class="s1">instanceof </span><span class="s0">AST_RegExp) {</span>
                            <span class="s0">value = value.value;</span>
                            <span class="s0">options[name] = </span><span class="s1">new </span><span class="s0">RegExp(value.source, value.flags);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s0">options[name] = to_string(value);</span>
                        <span class="s0">}</span>
                        <span class="s1">return true</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(node </span><span class="s1">instanceof </span><span class="s0">AST_Symbol || node </span><span class="s1">instanceof </span><span class="s0">AST_PropAccess) {</span>
                        <span class="s1">var </span><span class="s0">name = node.print_to_string();</span>
                        <span class="s0">options[name] = </span><span class="s1">true</span><span class="s0">;</span>
                        <span class="s1">return true</span><span class="s0">;</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(!(node </span><span class="s1">instanceof </span><span class="s0">AST_Sequence)) </span><span class="s1">throw </span><span class="s0">node;</span>

                    <span class="s1">function </span><span class="s0">to_string(value) {</span>
                        <span class="s1">return </span><span class="s0">value </span><span class="s1">instanceof </span><span class="s0">AST_Constant ? value.getValue() : value.print_to_string({</span>
                            <span class="s0">quote_keys: </span><span class="s1">true</span>
                        <span class="s0">});</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
            <span class="s0">} </span><span class="s1">catch</span><span class="s0">(ex) {</span>
                <span class="s1">if </span><span class="s0">(flag) {</span>
                    <span class="s0">fatal(</span><span class="s2">&quot;Error parsing arguments for '&quot; </span><span class="s0">+ flag + </span><span class="s2">&quot;': &quot; </span><span class="s0">+ value);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">options[value] = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">options;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">symdef(def) {</span>
        <span class="s1">var </span><span class="s0">ret = (</span><span class="s4">1</span><span class="s0">e6 + def.id) + </span><span class="s2">&quot; &quot; </span><span class="s0">+ def.name;</span>
        <span class="s1">if </span><span class="s0">(def.mangled_name) ret += </span><span class="s2">&quot; &quot; </span><span class="s0">+ def.mangled_name;</span>
        <span class="s1">return </span><span class="s0">ret;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">collect_from_map(map, callback) {</span>
        <span class="s1">var </span><span class="s0">result = [];</span>
        <span class="s0">map.forEach(</span><span class="s1">function </span><span class="s0">(def) {</span>
            <span class="s0">result.push(callback(def));</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">format_object(obj) {</span>
        <span class="s1">var </span><span class="s0">lines = [];</span>
        <span class="s1">var </span><span class="s0">padding = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s0">Object.keys(obj).map(</span><span class="s1">function</span><span class="s0">(name) {</span>
            <span class="s1">if </span><span class="s0">(padding.length &lt; name.length) padding = Array(name.length + </span><span class="s4">1</span><span class="s0">).join(</span><span class="s2">&quot; &quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">[ name, JSON.stringify(obj[name]) ];</span>
        <span class="s0">}).forEach(</span><span class="s1">function</span><span class="s0">(tokens) {</span>
            <span class="s0">lines.push(</span><span class="s2">&quot;  &quot; </span><span class="s0">+ tokens[</span><span class="s4">0</span><span class="s0">] + padding.slice(tokens[</span><span class="s4">0</span><span class="s0">].length - </span><span class="s4">2</span><span class="s0">) + tokens[</span><span class="s4">1</span><span class="s0">]);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">lines.join(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">print_error(msg) {</span>
        <span class="s0">process.stderr.write(msg);</span>
        <span class="s0">process.stderr.write(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">describe_ast() {</span>
        <span class="s1">var </span><span class="s0">out = OutputStream({ beautify: </span><span class="s1">true </span><span class="s0">});</span>
        <span class="s1">function </span><span class="s0">doitem(ctor) {</span>
            <span class="s0">out.print(</span><span class="s2">&quot;AST_&quot; </span><span class="s0">+ ctor.TYPE);</span>
            <span class="s0">const props = ctor.SELF_PROPS.filter(prop =&gt; !/^\$/.test(prop));</span>

            <span class="s1">if </span><span class="s0">(props.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">out.space();</span>
                <span class="s0">out.with_parens(</span><span class="s1">function</span><span class="s0">() {</span>
                    <span class="s0">props.forEach(</span><span class="s1">function</span><span class="s0">(prop, i) {</span>
                        <span class="s1">if </span><span class="s0">(i) out.space();</span>
                        <span class="s0">out.print(prop);</span>
                    <span class="s0">});</span>
                <span class="s0">});</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(ctor.documentation) {</span>
                <span class="s0">out.space();</span>
                <span class="s0">out.print_string(ctor.documentation);</span>
            <span class="s0">}</span>

            <span class="s1">if </span><span class="s0">(ctor.SUBCLASSES.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">out.space();</span>
                <span class="s0">out.with_block(</span><span class="s1">function</span><span class="s0">() {</span>
                    <span class="s0">ctor.SUBCLASSES.forEach(</span><span class="s1">function</span><span class="s0">(ctor) {</span>
                        <span class="s0">out.indent();</span>
                        <span class="s0">doitem(ctor);</span>
                        <span class="s0">out.newline();</span>
                    <span class="s0">});</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">doitem(AST_Node);</span>
        <span class="s1">return </span><span class="s0">out + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">async </span><span class="s1">function </span><span class="s0">_default_options() {</span>
    <span class="s0">const defs = {};</span>

    <span class="s0">Object.keys(infer_options({ </span><span class="s4">0</span><span class="s0">: </span><span class="s4">0 </span><span class="s0">})).forEach((component) =&gt; {</span>
        <span class="s0">const options = infer_options({</span>
            <span class="s0">[component]: {</span><span class="s4">0</span><span class="s0">: </span><span class="s4">0</span><span class="s0">}</span>
        <span class="s0">});</span>

        <span class="s1">if </span><span class="s0">(options) defs[component] = options;</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">defs;</span>
<span class="s0">}</span>

<span class="s0">async </span><span class="s1">function </span><span class="s0">infer_options(options) {</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">await minify(</span><span class="s2">&quot;&quot;</span><span class="s0">, options);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
        <span class="s1">return </span><span class="s0">error.defs;</span>
    <span class="s0">}</span>
<span class="s0">}</span>

<span class="s0">exports._default_options = _default_options;</span>
<span class="s0">exports._run_cli = run_cli;</span>
<span class="s0">exports.minify = minify;</span>

<span class="s0">}));</span>
</pre>
</body>
</html>
<html>
<head>
<title>valid-jsdoc.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
valid-jsdoc.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * @fileoverview Validates JSDoc comments are syntactically correct 
 * @author Nicholas C. Zakas 
 * @deprecated in ESLint v5.10.0 
 */</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s1">const doctrine = require(</span><span class="s2">&quot;doctrine&quot;</span><span class="s1">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** @type {import('../shared/types').Rule} */</span>
<span class="s1">module.exports = {</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s2">&quot;suggestion&quot;</span><span class="s1">,</span>

        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s2">&quot;Enforce valid JSDoc comments&quot;</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">url: </span><span class="s2">&quot;https://eslint.org/docs/latest/rules/valid-jsdoc&quot;</span>
        <span class="s1">},</span>

        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">prefer: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                        <span class="s1">additionalProperties: {</span>
                            <span class="s1">type: </span><span class="s2">&quot;string&quot;</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">preferType: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;object&quot;</span><span class="s1">,</span>
                        <span class="s1">additionalProperties: {</span>
                            <span class="s1">type: </span><span class="s2">&quot;string&quot;</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">requireReturn: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;boolean&quot;</span><span class="s1">,</span>
                        <span class="s3">default</span><span class="s1">: </span><span class="s3">true</span>
                    <span class="s1">},</span>
                    <span class="s1">requireParamDescription: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;boolean&quot;</span><span class="s1">,</span>
                        <span class="s3">default</span><span class="s1">: </span><span class="s3">true</span>
                    <span class="s1">},</span>
                    <span class="s1">requireReturnDescription: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;boolean&quot;</span><span class="s1">,</span>
                        <span class="s3">default</span><span class="s1">: </span><span class="s3">true</span>
                    <span class="s1">},</span>
                    <span class="s1">matchDescription: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;string&quot;</span>
                    <span class="s1">},</span>
                    <span class="s1">requireReturnType: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;boolean&quot;</span><span class="s1">,</span>
                        <span class="s3">default</span><span class="s1">: </span><span class="s3">true</span>
                    <span class="s1">},</span>
                    <span class="s1">requireParamType: {</span>
                        <span class="s1">type: </span><span class="s2">&quot;boolean&quot;</span><span class="s1">,</span>
                        <span class="s3">default</span><span class="s1">: </span><span class="s3">true</span>
                    <span class="s1">}</span>
                <span class="s1">},</span>
                <span class="s1">additionalProperties: </span><span class="s3">false</span>
            <span class="s1">}</span>
        <span class="s1">],</span>

        <span class="s1">fixable: </span><span class="s2">&quot;code&quot;</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">unexpectedTag: </span><span class="s2">&quot;Unexpected @{{title}} tag; function has no return statement.&quot;</span><span class="s1">,</span>
            <span class="s1">expected: </span><span class="s2">&quot;Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.&quot;</span><span class="s1">,</span>
            <span class="s1">use: </span><span class="s2">&quot;Use @{{name}} instead.&quot;</span><span class="s1">,</span>
            <span class="s1">useType: </span><span class="s2">&quot;Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.&quot;</span><span class="s1">,</span>
            <span class="s1">syntaxError: </span><span class="s2">&quot;JSDoc syntax error.&quot;</span><span class="s1">,</span>
            <span class="s1">missingBrace: </span><span class="s2">&quot;JSDoc type missing brace.&quot;</span><span class="s1">,</span>
            <span class="s1">missingParamDesc: </span><span class="s2">&quot;Missing JSDoc parameter description for '{{name}}'.&quot;</span><span class="s1">,</span>
            <span class="s1">missingParamType: </span><span class="s2">&quot;Missing JSDoc parameter type for '{{name}}'.&quot;</span><span class="s1">,</span>
            <span class="s1">missingReturnType: </span><span class="s2">&quot;Missing JSDoc return type.&quot;</span><span class="s1">,</span>
            <span class="s1">missingReturnDesc: </span><span class="s2">&quot;Missing JSDoc return description.&quot;</span><span class="s1">,</span>
            <span class="s1">missingReturn: </span><span class="s2">&quot;Missing JSDoc @{{returns}} for function.&quot;</span><span class="s1">,</span>
            <span class="s1">missingParam: </span><span class="s2">&quot;Missing JSDoc for parameter '{{name}}'.&quot;</span><span class="s1">,</span>
            <span class="s1">duplicateParam: </span><span class="s2">&quot;Duplicate JSDoc parameter '{{name}}'.&quot;</span><span class="s1">,</span>
            <span class="s1">unsatisfiedDesc: </span><span class="s2">&quot;JSDoc description does not satisfy the regex pattern.&quot;</span>
        <span class="s1">},</span>

        <span class="s1">deprecated: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s1">replacedBy: []</span>
    <span class="s1">},</span>

    <span class="s1">create(context) {</span>

        <span class="s1">const options = context.options[</span><span class="s4">0</span><span class="s1">] || {},</span>
            <span class="s1">prefer = options.prefer || {},</span>
            <span class="s1">sourceCode = context.sourceCode,</span>

            <span class="s0">// these both default to true, so you have to explicitly make them false</span>
            <span class="s1">requireReturn = options.requireReturn !== </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">requireParamDescription = options.requireParamDescription !== </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">requireReturnDescription = options.requireReturnDescription !== </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">requireReturnType = options.requireReturnType !== </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">requireParamType = options.requireParamType !== </span><span class="s3">false</span><span class="s1">,</span>
            <span class="s1">preferType = options.preferType || {},</span>
            <span class="s1">checkPreferType = Object.keys(preferType).length !== </span><span class="s4">0</span><span class="s1">;</span>

        <span class="s0">//--------------------------------------------------------------------------</span>
        <span class="s0">// Helpers</span>
        <span class="s0">//--------------------------------------------------------------------------</span>

        <span class="s0">// Using a stack to store if a function returns or not (handling nested functions)</span>
        <span class="s1">const fns = [];</span>

        <span class="s0">/** 
         * Check if node type is a Class 
         * @param {ASTNode} node node to check. 
         * @returns {boolean} True is its a class 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">isTypeClass(node) {</span>
            <span class="s3">return </span><span class="s1">node.type === </span><span class="s2">&quot;ClassExpression&quot; </span><span class="s1">|| node.type === </span><span class="s2">&quot;ClassDeclaration&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * When parsing a new function, store it in our function stack. 
         * @param {ASTNode} node A function node to check. 
         * @returns {void} 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">startFunction(node) {</span>
            <span class="s1">fns.push({</span>
                <span class="s1">returnPresent: (node.type === </span><span class="s2">&quot;ArrowFunctionExpression&quot; </span><span class="s1">&amp;&amp; node.body.type !== </span><span class="s2">&quot;BlockStatement&quot;</span><span class="s1">) ||</span>
                    <span class="s1">isTypeClass(node) || node.async</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Indicate that return has been found in the current function. 
         * @param {ASTNode} node The return node. 
         * @returns {void} 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">addReturn(node) {</span>
            <span class="s1">const functionState = fns[fns.length - </span><span class="s4">1</span><span class="s1">];</span>

            <span class="s3">if </span><span class="s1">(functionState &amp;&amp; node.argument !== </span><span class="s3">null</span><span class="s1">) {</span>
                <span class="s1">functionState.returnPresent = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check if return tag type is void or undefined 
         * @param {Object} tag JSDoc tag 
         * @returns {boolean} True if its of type void or undefined 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">isValidReturnType(tag) {</span>
            <span class="s3">return </span><span class="s1">tag.type === </span><span class="s3">null </span><span class="s1">|| tag.type.name === </span><span class="s2">&quot;void&quot; </span><span class="s1">|| tag.type.type === </span><span class="s2">&quot;UndefinedLiteral&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Check if type should be validated based on some exceptions 
         * @param {Object} type JSDoc tag 
         * @returns {boolean} True if it can be validated 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">canTypeBeValidated(type) {</span>
            <span class="s3">return </span><span class="s1">type !== </span><span class="s2">&quot;UndefinedLiteral&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// {undefined} as there is no name property available.</span>
                   <span class="s1">type !== </span><span class="s2">&quot;NullLiteral&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// {null}</span>
                   <span class="s1">type !== </span><span class="s2">&quot;NullableLiteral&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// {?}</span>
                   <span class="s1">type !== </span><span class="s2">&quot;FunctionType&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// {function(a)}</span>
                   <span class="s1">type !== </span><span class="s2">&quot;AllLiteral&quot;</span><span class="s1">; </span><span class="s0">// {*}</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Extract the current and expected type based on the input type object 
         * @param {Object} type JSDoc tag 
         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and 
         * the expected name of the annotation 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">getCurrentExpectedTypes(type) {</span>
            <span class="s1">let currentType;</span>

            <span class="s3">if </span><span class="s1">(type.name) {</span>
                <span class="s1">currentType = type;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type.expression) {</span>
                <span class="s1">currentType = type.expression;</span>
            <span class="s1">}</span>

            <span class="s3">return </span><span class="s1">{</span>
                <span class="s1">currentType,</span>
                <span class="s1">expectedTypeName: currentType &amp;&amp; preferType[currentType.name]</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Gets the location of a JSDoc node in a file 
         * @param {Token} jsdocComment The comment that this node is parsed from 
         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment 
         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag 
         */</span>
        <span class="s3">function </span><span class="s1">getAbsoluteRange(jsdocComment, parsedJsdocNode) {</span>
            <span class="s3">return </span><span class="s1">{</span>
                <span class="s1">start: sourceCode.getLocFromIndex(jsdocComment.range[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">2 </span><span class="s1">+ parsedJsdocNode.range[</span><span class="s4">0</span><span class="s1">]),</span>
                <span class="s1">end: sourceCode.getLocFromIndex(jsdocComment.range[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">2 </span><span class="s1">+ parsedJsdocNode.range[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">};</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Validate type for a given JSDoc node 
         * @param {Object} jsdocNode JSDoc node 
         * @param {Object} type JSDoc tag 
         * @returns {void} 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">validateType(jsdocNode, type) {</span>
            <span class="s3">if </span><span class="s1">(!type || !canTypeBeValidated(type.type)) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">const typesToCheck = [];</span>
            <span class="s1">let elements = [];</span>

            <span class="s3">switch </span><span class="s1">(type.type) {</span>
                <span class="s3">case </span><span class="s2">&quot;TypeApplication&quot;</span><span class="s1">: </span><span class="s0">// {Array.&lt;String&gt;}</span>
                    <span class="s1">elements = type.applications[</span><span class="s4">0</span><span class="s1">].type === </span><span class="s2">&quot;UnionType&quot; </span><span class="s1">? type.applications[</span><span class="s4">0</span><span class="s1">].elements : type.applications;</span>
                    <span class="s1">typesToCheck.push(getCurrentExpectedTypes(type));</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s2">&quot;RecordType&quot;</span><span class="s1">: </span><span class="s0">// {{20:String}}</span>
                    <span class="s1">elements = type.fields;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s2">&quot;UnionType&quot;</span><span class="s1">: </span><span class="s0">// {String|number|Test}</span>
                <span class="s3">case </span><span class="s2">&quot;ArrayType&quot;</span><span class="s1">: </span><span class="s0">// {[String, number, Test]}</span>
                    <span class="s1">elements = type.elements;</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">case </span><span class="s2">&quot;FieldType&quot;</span><span class="s1">: </span><span class="s0">// Array.&lt;{count: number, votes: number}&gt;</span>
                    <span class="s3">if </span><span class="s1">(type.value) {</span>
                        <span class="s1">typesToCheck.push(getCurrentExpectedTypes(type.value));</span>
                    <span class="s1">}</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s3">default</span><span class="s1">:</span>
                    <span class="s1">typesToCheck.push(getCurrentExpectedTypes(type));</span>
            <span class="s1">}</span>

            <span class="s1">elements.forEach(validateType.bind(</span><span class="s3">null</span><span class="s1">, jsdocNode));</span>

            <span class="s1">typesToCheck.forEach(typeToCheck =&gt; {</span>
                <span class="s3">if </span><span class="s1">(typeToCheck.expectedTypeName &amp;&amp;</span>
                    <span class="s1">typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {</span>
                    <span class="s1">context.report({</span>
                        <span class="s1">node: jsdocNode,</span>
                        <span class="s1">messageId: </span><span class="s2">&quot;useType&quot;</span><span class="s1">,</span>
                        <span class="s1">loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),</span>
                        <span class="s1">data: {</span>
                            <span class="s1">currentTypeName: typeToCheck.currentType.name,</span>
                            <span class="s1">expectedTypeName: typeToCheck.expectedTypeName</span>
                        <span class="s1">},</span>
                        <span class="s1">fix(fixer) {</span>
                            <span class="s3">return </span><span class="s1">fixer.replaceTextRange(</span>
                                <span class="s1">typeToCheck.currentType.range.map(indexInComment =&gt; jsdocNode.range[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">2 </span><span class="s1">+ indexInComment),</span>
                                <span class="s1">typeToCheck.expectedTypeName</span>
                            <span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Validate the JSDoc node and output warnings if anything is wrong. 
         * @param {ASTNode} node The AST node to check. 
         * @returns {void} 
         * @private 
         */</span>
        <span class="s3">function </span><span class="s1">checkJSDoc(node) {</span>
            <span class="s1">const jsdocNode = sourceCode.getJSDocComment(node),</span>
                <span class="s1">functionData = fns.pop(),</span>
                <span class="s1">paramTagsByName = Object.create(</span><span class="s3">null</span><span class="s1">),</span>
                <span class="s1">paramTags = [];</span>
            <span class="s1">let hasReturns = </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">returnsTag,</span>
                <span class="s1">hasConstructor = </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">isInterface = </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">isOverride = </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">isAbstract = </span><span class="s3">false</span><span class="s1">;</span>

            <span class="s0">// make sure only to validate JSDoc comments</span>
            <span class="s3">if </span><span class="s1">(jsdocNode) {</span>
                <span class="s1">let jsdoc;</span>

                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s1">jsdoc = doctrine.parse(jsdocNode.value, {</span>
                        <span class="s1">strict: </span><span class="s3">true</span><span class="s1">,</span>
                        <span class="s1">unwrap: </span><span class="s3">true</span><span class="s1">,</span>
                        <span class="s1">sloppy: </span><span class="s3">true</span><span class="s1">,</span>
                        <span class="s1">range: </span><span class="s3">true</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(ex) {</span>

                    <span class="s3">if </span><span class="s1">(/braces/iu.test(ex.message)) {</span>
                        <span class="s1">context.report({ node: jsdocNode, messageId: </span><span class="s2">&quot;missingBrace&quot; </span><span class="s1">});</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">context.report({ node: jsdocNode, messageId: </span><span class="s2">&quot;syntaxError&quot; </span><span class="s1">});</span>
                    <span class="s1">}</span>

                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">jsdoc.tags.forEach(tag =&gt; {</span>

                    <span class="s3">switch </span><span class="s1">(tag.title.toLowerCase()) {</span>

                        <span class="s3">case </span><span class="s2">&quot;param&quot;</span><span class="s1">:</span>
                        <span class="s3">case </span><span class="s2">&quot;arg&quot;</span><span class="s1">:</span>
                        <span class="s3">case </span><span class="s2">&quot;argument&quot;</span><span class="s1">:</span>
                            <span class="s1">paramTags.push(tag);</span>
                            <span class="s3">break</span><span class="s1">;</span>

                        <span class="s3">case </span><span class="s2">&quot;return&quot;</span><span class="s1">:</span>
                        <span class="s3">case </span><span class="s2">&quot;returns&quot;</span><span class="s1">:</span>
                            <span class="s1">hasReturns = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s1">returnsTag = tag;</span>
                            <span class="s3">break</span><span class="s1">;</span>

                        <span class="s3">case </span><span class="s2">&quot;constructor&quot;</span><span class="s1">:</span>
                        <span class="s3">case </span><span class="s2">&quot;class&quot;</span><span class="s1">:</span>
                            <span class="s1">hasConstructor = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s3">break</span><span class="s1">;</span>

                        <span class="s3">case </span><span class="s2">&quot;override&quot;</span><span class="s1">:</span>
                        <span class="s3">case </span><span class="s2">&quot;inheritdoc&quot;</span><span class="s1">:</span>
                            <span class="s1">isOverride = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s3">break</span><span class="s1">;</span>

                        <span class="s3">case </span><span class="s2">&quot;abstract&quot;</span><span class="s1">:</span>
                        <span class="s3">case </span><span class="s2">&quot;virtual&quot;</span><span class="s1">:</span>
                            <span class="s1">isAbstract = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s3">break</span><span class="s1">;</span>

                        <span class="s3">case </span><span class="s2">&quot;interface&quot;</span><span class="s1">:</span>
                            <span class="s1">isInterface = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s3">break</span><span class="s1">;</span>

                        <span class="s0">// no default</span>
                    <span class="s1">}</span>

                    <span class="s0">// check tag preferences</span>
                    <span class="s3">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(prefer, tag.title) &amp;&amp; tag.title !== prefer[tag.title]) {</span>
                        <span class="s1">const entireTagRange = getAbsoluteRange(jsdocNode, tag);</span>

                        <span class="s1">context.report({</span>
                            <span class="s1">node: jsdocNode,</span>
                            <span class="s1">messageId: </span><span class="s2">&quot;use&quot;</span><span class="s1">,</span>
                            <span class="s1">loc: {</span>
                                <span class="s1">start: entireTagRange.start,</span>
                                <span class="s1">end: {</span>
                                    <span class="s1">line: entireTagRange.start.line,</span>
                                    <span class="s1">column: entireTagRange.start.column + `@${tag.title}`.length</span>
                                <span class="s1">}</span>
                            <span class="s1">},</span>
                            <span class="s1">data: { name: prefer[tag.title] },</span>
                            <span class="s1">fix(fixer) {</span>
                                <span class="s3">return </span><span class="s1">fixer.replaceTextRange(</span>
                                    <span class="s1">[</span>
                                        <span class="s1">jsdocNode.range[</span><span class="s4">0</span><span class="s1">] + tag.range[</span><span class="s4">0</span><span class="s1">] + </span><span class="s4">3</span><span class="s1">,</span>
                                        <span class="s1">jsdocNode.range[</span><span class="s4">0</span><span class="s1">] + tag.range[</span><span class="s4">0</span><span class="s1">] + tag.title.length + </span><span class="s4">3</span>
                                    <span class="s1">],</span>
                                    <span class="s1">prefer[tag.title]</span>
                                <span class="s1">);</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>

                    <span class="s0">// validate the types</span>
                    <span class="s3">if </span><span class="s1">(checkPreferType &amp;&amp; tag.type) {</span>
                        <span class="s1">validateType(jsdocNode, tag.type);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>

                <span class="s1">paramTags.forEach(param =&gt; {</span>
                    <span class="s3">if </span><span class="s1">(requireParamType &amp;&amp; !param.type) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: jsdocNode,</span>
                            <span class="s1">messageId: </span><span class="s2">&quot;missingParamType&quot;</span><span class="s1">,</span>
                            <span class="s1">loc: getAbsoluteRange(jsdocNode, param),</span>
                            <span class="s1">data: { name: param.name }</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(!param.description &amp;&amp; requireParamDescription) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: jsdocNode,</span>
                            <span class="s1">messageId: </span><span class="s2">&quot;missingParamDesc&quot;</span><span class="s1">,</span>
                            <span class="s1">loc: getAbsoluteRange(jsdocNode, param),</span>
                            <span class="s1">data: { name: param.name }</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(paramTagsByName[param.name]) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: jsdocNode,</span>
                            <span class="s1">messageId: </span><span class="s2">&quot;duplicateParam&quot;</span><span class="s1">,</span>
                            <span class="s1">loc: getAbsoluteRange(jsdocNode, param),</span>
                            <span class="s1">data: { name: param.name }</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!param.name.includes(</span><span class="s2">&quot;.&quot;</span><span class="s1">)) {</span>
                        <span class="s1">paramTagsByName[param.name] = param;</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>

                <span class="s3">if </span><span class="s1">(hasReturns) {</span>
                    <span class="s3">if </span><span class="s1">(!requireReturn &amp;&amp; !functionData.returnPresent &amp;&amp; (returnsTag.type === </span><span class="s3">null </span><span class="s1">|| !isValidReturnType(returnsTag)) &amp;&amp; !isAbstract) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: jsdocNode,</span>
                            <span class="s1">messageId: </span><span class="s2">&quot;unexpectedTag&quot;</span><span class="s1">,</span>
                            <span class="s1">loc: getAbsoluteRange(jsdocNode, returnsTag),</span>
                            <span class="s1">data: {</span>
                                <span class="s1">title: returnsTag.title</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">if </span><span class="s1">(requireReturnType &amp;&amp; !returnsTag.type) {</span>
                            <span class="s1">context.report({ node: jsdocNode, messageId: </span><span class="s2">&quot;missingReturnType&quot; </span><span class="s1">});</span>
                        <span class="s1">}</span>

                        <span class="s3">if </span><span class="s1">(!isValidReturnType(returnsTag) &amp;&amp; !returnsTag.description &amp;&amp; requireReturnDescription) {</span>
                            <span class="s1">context.report({ node: jsdocNode, messageId: </span><span class="s2">&quot;missingReturnDesc&quot; </span><span class="s1">});</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s0">// check for functions missing @returns</span>
                <span class="s3">if </span><span class="s1">(!isOverride &amp;&amp; !hasReturns &amp;&amp; !hasConstructor &amp;&amp; !isInterface &amp;&amp;</span>
                    <span class="s1">node.parent.kind !== </span><span class="s2">&quot;get&quot; </span><span class="s1">&amp;&amp; node.parent.kind !== </span><span class="s2">&quot;constructor&quot; </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">node.parent.kind !== </span><span class="s2">&quot;set&quot; </span><span class="s1">&amp;&amp; !isTypeClass(node)) {</span>
                    <span class="s3">if </span><span class="s1">(requireReturn || (functionData.returnPresent &amp;&amp; !node.async)) {</span>
                        <span class="s1">context.report({</span>
                            <span class="s1">node: jsdocNode,</span>
                            <span class="s1">messageId: </span><span class="s2">&quot;missingReturn&quot;</span><span class="s1">,</span>
                            <span class="s1">data: {</span>
                                <span class="s1">returns: prefer.returns || </span><span class="s2">&quot;returns&quot;</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s0">// check the parameters</span>
                <span class="s1">const jsdocParamNames = Object.keys(paramTagsByName);</span>

                <span class="s3">if </span><span class="s1">(node.params) {</span>
                    <span class="s1">node.params.forEach((param, paramsIndex) =&gt; {</span>
                        <span class="s1">const bindingParam = param.type === </span><span class="s2">&quot;AssignmentPattern&quot;</span>
                            <span class="s1">? param.left</span>
                            <span class="s1">: param;</span>

                        <span class="s0">// TODO(nzakas): Figure out logical things to do with destructured, default, rest params</span>
                        <span class="s3">if </span><span class="s1">(bindingParam.type === </span><span class="s2">&quot;Identifier&quot;</span><span class="s1">) {</span>
                            <span class="s1">const name = bindingParam.name;</span>

                            <span class="s3">if </span><span class="s1">(jsdocParamNames[paramsIndex] &amp;&amp; (name !== jsdocParamNames[paramsIndex])) {</span>
                                <span class="s1">context.report({</span>
                                    <span class="s1">node: jsdocNode,</span>
                                    <span class="s1">messageId: </span><span class="s2">&quot;expected&quot;</span><span class="s1">,</span>
                                    <span class="s1">loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),</span>
                                    <span class="s1">data: {</span>
                                        <span class="s1">name,</span>
                                        <span class="s1">jsdocName: jsdocParamNames[paramsIndex]</span>
                                    <span class="s1">}</span>
                                <span class="s1">});</span>
                            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(!paramTagsByName[name] &amp;&amp; !isOverride) {</span>
                                <span class="s1">context.report({</span>
                                    <span class="s1">node: jsdocNode,</span>
                                    <span class="s1">messageId: </span><span class="s2">&quot;missingParam&quot;</span><span class="s1">,</span>
                                    <span class="s1">data: {</span>
                                        <span class="s1">name</span>
                                    <span class="s1">}</span>
                                <span class="s1">});</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>

                <span class="s3">if </span><span class="s1">(options.matchDescription) {</span>
                    <span class="s1">const regex = </span><span class="s3">new </span><span class="s1">RegExp(options.matchDescription, </span><span class="s2">&quot;u&quot;</span><span class="s1">);</span>

                    <span class="s3">if </span><span class="s1">(!regex.test(jsdoc.description)) {</span>
                        <span class="s1">context.report({ node: jsdocNode, messageId: </span><span class="s2">&quot;unsatisfiedDesc&quot; </span><span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

            <span class="s1">}</span>

        <span class="s1">}</span>

        <span class="s0">//--------------------------------------------------------------------------</span>
        <span class="s0">// Public</span>
        <span class="s0">//--------------------------------------------------------------------------</span>

        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">ArrowFunctionExpression: startFunction,</span>
            <span class="s1">FunctionExpression: startFunction,</span>
            <span class="s1">FunctionDeclaration: startFunction,</span>
            <span class="s1">ClassExpression: startFunction,</span>
            <span class="s1">ClassDeclaration: startFunction,</span>
            <span class="s2">&quot;ArrowFunctionExpression:exit&quot;</span><span class="s1">: checkJSDoc,</span>
            <span class="s2">&quot;FunctionExpression:exit&quot;</span><span class="s1">: checkJSDoc,</span>
            <span class="s2">&quot;FunctionDeclaration:exit&quot;</span><span class="s1">: checkJSDoc,</span>
            <span class="s2">&quot;ClassExpression:exit&quot;</span><span class="s1">: checkJSDoc,</span>
            <span class="s2">&quot;ClassDeclaration:exit&quot;</span><span class="s1">: checkJSDoc,</span>
            <span class="s1">ReturnStatement: addReturn</span>
        <span class="s1">};</span>

    <span class="s1">}</span>
<span class="s1">};</span>
</pre>
</body>
</html>
<html>
<head>
<title>ScrollView.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ScrollView.js</font>
</center></td></tr></table>
<pre><span class="s0">/** 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 * 
 * @format 
 * @flow strict-local 
 */</span>

<span class="s1">import type {HostComponent} from </span><span class="s2">'../../Renderer/shims/ReactNativeTypes'</span><span class="s1">;</span>
<span class="s1">import type {EdgeInsetsProp} from </span><span class="s2">'../../StyleSheet/EdgeInsetsPropType'</span><span class="s1">;</span>
<span class="s1">import type {PointProp} from </span><span class="s2">'../../StyleSheet/PointPropType'</span><span class="s1">;</span>
<span class="s1">import type {ViewStyleProp} from </span><span class="s2">'../../StyleSheet/StyleSheet'</span><span class="s1">;</span>
<span class="s1">import type {ColorValue} from </span><span class="s2">'../../StyleSheet/StyleSheet'</span><span class="s1">;</span>
<span class="s1">import type {</span>
  <span class="s1">LayoutEvent,</span>
  <span class="s1">PressEvent,</span>
  <span class="s1">ScrollEvent,</span>
<span class="s1">} from </span><span class="s2">'../../Types/CoreEventTypes'</span><span class="s1">;</span>
<span class="s1">import type {EventSubscription} from </span><span class="s2">'../../vendor/emitter/EventEmitter'</span><span class="s1">;</span>
<span class="s1">import type {KeyboardEvent, KeyboardMetrics} from </span><span class="s2">'../Keyboard/Keyboard'</span><span class="s1">;</span>
<span class="s1">import type {ViewProps} from </span><span class="s2">'../View/ViewPropTypes'</span><span class="s1">;</span>
<span class="s1">import type {Props as ScrollViewStickyHeaderProps} from </span><span class="s2">'./ScrollViewStickyHeader'</span><span class="s1">;</span>

<span class="s1">import AnimatedImplementation from </span><span class="s2">'../../Animated/AnimatedImplementation'</span><span class="s1">;</span>
<span class="s1">import FrameRateLogger from </span><span class="s2">'../../Interaction/FrameRateLogger'</span><span class="s1">;</span>
<span class="s1">import {findNodeHandle} from </span><span class="s2">'../../ReactNative/RendererProxy'</span><span class="s1">;</span>
<span class="s1">import UIManager from </span><span class="s2">'../../ReactNative/UIManager'</span><span class="s1">;</span>
<span class="s1">import flattenStyle from </span><span class="s2">'../../StyleSheet/flattenStyle'</span><span class="s1">;</span>
<span class="s1">import splitLayoutProps from </span><span class="s2">'../../StyleSheet/splitLayoutProps'</span><span class="s1">;</span>
<span class="s1">import StyleSheet from </span><span class="s2">'../../StyleSheet/StyleSheet'</span><span class="s1">;</span>
<span class="s1">import Dimensions from </span><span class="s2">'../../Utilities/Dimensions'</span><span class="s1">;</span>
<span class="s1">import dismissKeyboard from </span><span class="s2">'../../Utilities/dismissKeyboard'</span><span class="s1">;</span>
<span class="s1">import Platform from </span><span class="s2">'../../Utilities/Platform'</span><span class="s1">;</span>
<span class="s1">import Keyboard from </span><span class="s2">'../Keyboard/Keyboard'</span><span class="s1">;</span>
<span class="s1">import TextInputState from </span><span class="s2">'../TextInput/TextInputState'</span><span class="s1">;</span>
<span class="s1">import View from </span><span class="s2">'../View/View'</span><span class="s1">;</span>
<span class="s1">import AndroidHorizontalScrollContentViewNativeComponent from </span><span class="s2">'./AndroidHorizontalScrollContentViewNativeComponent'</span><span class="s1">;</span>
<span class="s1">import AndroidHorizontalScrollViewNativeComponent from </span><span class="s2">'./AndroidHorizontalScrollViewNativeComponent'</span><span class="s1">;</span>
<span class="s1">import processDecelerationRate from </span><span class="s2">'./processDecelerationRate'</span><span class="s1">;</span>
<span class="s1">import ScrollContentViewNativeComponent from </span><span class="s2">'./ScrollContentViewNativeComponent'</span><span class="s1">;</span>
<span class="s1">import Commands from </span><span class="s2">'./ScrollViewCommands'</span><span class="s1">;</span>
<span class="s1">import ScrollViewContext, {HORIZONTAL, VERTICAL} from </span><span class="s2">'./ScrollViewContext'</span><span class="s1">;</span>
<span class="s1">import ScrollViewNativeComponent from </span><span class="s2">'./ScrollViewNativeComponent'</span><span class="s1">;</span>
<span class="s1">import ScrollViewStickyHeader from </span><span class="s2">'./ScrollViewStickyHeader'</span><span class="s1">;</span>
<span class="s1">import invariant from </span><span class="s2">'invariant'</span><span class="s1">;</span>
<span class="s1">import memoize from </span><span class="s2">'memoize-one'</span><span class="s1">;</span>
<span class="s1">import nullthrows from </span><span class="s2">'nullthrows'</span><span class="s1">;</span>
<span class="s1">import * as React from </span><span class="s2">'react'</span><span class="s1">;</span>

<span class="s3">if </span><span class="s1">(Platform.OS === </span><span class="s2">'ios'</span><span class="s1">) {</span>
  <span class="s1">require(</span><span class="s2">'../../Renderer/shims/ReactNative'</span><span class="s1">); </span><span class="s0">// Force side effects to prevent T55744311</span>
<span class="s1">}</span>

<span class="s1">const {NativeHorizontalScrollViewTuple, NativeVerticalScrollViewTuple} =</span>
  <span class="s1">Platform.OS === </span><span class="s2">'android'</span>
    <span class="s1">? {</span>
        <span class="s1">NativeHorizontalScrollViewTuple: [</span>
          <span class="s1">AndroidHorizontalScrollViewNativeComponent,</span>
          <span class="s1">AndroidHorizontalScrollContentViewNativeComponent,</span>
        <span class="s1">],</span>
        <span class="s1">NativeVerticalScrollViewTuple: [ScrollViewNativeComponent, View],</span>
      <span class="s1">}</span>
    <span class="s1">: {</span>
        <span class="s1">NativeHorizontalScrollViewTuple: [</span>
          <span class="s1">ScrollViewNativeComponent,</span>
          <span class="s1">ScrollContentViewNativeComponent,</span>
        <span class="s1">],</span>
        <span class="s1">NativeVerticalScrollViewTuple: [</span>
          <span class="s1">ScrollViewNativeComponent,</span>
          <span class="s1">ScrollContentViewNativeComponent,</span>
        <span class="s1">],</span>
      <span class="s1">};</span>

<span class="s0">/* 
 * iOS scroll event timing nuances: 
 * =============================== 
 * 
 * 
 * Scrolling without bouncing, if you touch down: 
 * ------------------------------- 
 * 
 * 1. `onMomentumScrollBegin` (when animation begins after letting up) 
 *    ... physical touch starts ... 
 * 2. `onTouchStartCapture`   (when you press down to stop the scroll) 
 * 3. `onTouchStart`          (same, but bubble phase) 
 * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting) 
 * 5. `onMomentumScrollEnd` 
 * 
 * 
 * Scrolling with bouncing, if you touch down: 
 * ------------------------------- 
 * 
 * 1. `onMomentumScrollBegin` (when animation begins after letting up) 
 *    ... bounce begins ... 
 *    ... some time elapses ... 
 *    ... physical touch during bounce ... 
 * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce) 
 * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`) 
 * 4. `onTouchStart`          (same, but bubble phase) 
 * 5. `onTouchEnd`            (You could hold the touch start for a long time) 
 * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back) 
 * 
 * So when we receive an `onTouchStart`, how can we tell if we are touching 
 * *during* an animation (which then causes the animation to stop)? The only way 
 * to tell is if the `touchStart` occurred immediately after the 
 * `onMomentumScrollEnd`. 
 * 
 * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if 
 * necessary 
 * 
 * `ScrollView` also includes logic for blurring a currently focused input 
 * if one is focused while scrolling. This is a natural place 
 * to put this logic since it can support not dismissing the keyboard while 
 * scrolling, unless a recognized &quot;tap&quot;-like gesture has occurred. 
 * 
 * The public lifecycle API includes events for keyboard interaction, responder 
 * interaction, and scrolling (among others). The keyboard callbacks 
 * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll 
 * responder's props so that you can guarantee that the scroll responder's 
 * internal state has been updated accordingly (and deterministically) by 
 * the time the props callbacks are invoke. Otherwise, you would always wonder 
 * if the scroll responder is currently in a state where it recognizes new 
 * keyboard positions etc. If coordinating scrolling with keyboard movement, 
 * *always* use these hooks instead of listening to your own global keyboard 
 * events. 
 * 
 * Public keyboard lifecycle API: (props callbacks) 
 * 
 * Standard Keyboard Appearance Sequence: 
 * 
 *   this.props.onKeyboardWillShow 
 *   this.props.onKeyboardDidShow 
 * 
 * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate 
 * tap inside the scroll responder's scrollable region was responsible 
 * for the dismissal of the keyboard. There are other reasons why the 
 * keyboard could be dismissed. 
 * 
 *   this.props.onScrollResponderKeyboardDismissed 
 * 
 * Standard Keyboard Hide Sequence: 
 * 
 *   this.props.onKeyboardWillHide 
 *   this.props.onKeyboardDidHide 
 */</span>

<span class="s0">// Public methods for ScrollView</span>
<span class="s1">export type ScrollViewImperativeMethods = $ReadOnly&lt;{|</span>
  <span class="s1">getScrollResponder: $PropertyType&lt;ScrollView, </span><span class="s2">'getScrollResponder'</span><span class="s1">&gt;,</span>
  <span class="s1">getScrollableNode: $PropertyType&lt;ScrollView, </span><span class="s2">'getScrollableNode'</span><span class="s1">&gt;,</span>
  <span class="s1">getInnerViewNode: $PropertyType&lt;ScrollView, </span><span class="s2">'getInnerViewNode'</span><span class="s1">&gt;,</span>
  <span class="s1">getInnerViewRef: $PropertyType&lt;ScrollView, </span><span class="s2">'getInnerViewRef'</span><span class="s1">&gt;,</span>
  <span class="s1">getNativeScrollRef: $PropertyType&lt;ScrollView, </span><span class="s2">'getNativeScrollRef'</span><span class="s1">&gt;,</span>
  <span class="s1">scrollTo: $PropertyType&lt;ScrollView, </span><span class="s2">'scrollTo'</span><span class="s1">&gt;,</span>
  <span class="s1">scrollToEnd: $PropertyType&lt;ScrollView, </span><span class="s2">'scrollToEnd'</span><span class="s1">&gt;,</span>
  <span class="s1">flashScrollIndicators: $PropertyType&lt;ScrollView, </span><span class="s2">'flashScrollIndicators'</span><span class="s1">&gt;,</span>
  <span class="s1">scrollResponderZoomTo: $PropertyType&lt;ScrollView, </span><span class="s2">'scrollResponderZoomTo'</span><span class="s1">&gt;,</span>
  <span class="s1">scrollResponderScrollNativeHandleToKeyboard: $PropertyType&lt;</span>
    <span class="s1">ScrollView,</span>
    <span class="s2">'scrollResponderScrollNativeHandleToKeyboard'</span><span class="s1">,</span>
  <span class="s1">&gt;,</span>
<span class="s1">|}&gt;;</span>

<span class="s1">export type DecelerationRateType = </span><span class="s2">'fast' </span><span class="s1">| </span><span class="s2">'normal' </span><span class="s1">| number;</span>
<span class="s1">export type ScrollResponderType = ScrollViewImperativeMethods;</span>

<span class="s1">type NativeScrollViewInstance = React.ElementRef&lt;HostComponent&lt;mixed&gt;&gt;;</span>
<span class="s1">type PublicScrollViewInstance = $ReadOnly&lt;{|</span>
  <span class="s1">...$Exact&lt;NativeScrollViewInstance&gt;,</span>
  <span class="s1">...ScrollViewImperativeMethods,</span>
<span class="s1">|}&gt;;</span>

<span class="s1">type InnerViewInstance = React.ElementRef&lt;</span><span class="s3">typeof </span><span class="s1">View&gt;;</span>

<span class="s1">type IOSProps = $ReadOnly&lt;{|</span>
  <span class="s0">/** 
   * Controls whether iOS should automatically adjust the content inset 
   * for scroll views that are placed behind a navigation bar or 
   * tab bar/ toolbar. The default value is true. 
   * @platform ios 
   */</span>
  <span class="s1">automaticallyAdjustContentInsets?: ?boolean,</span>
  <span class="s0">/** 
   * Controls whether the ScrollView should automatically adjust its `contentInset` 
   * and `scrollViewInsets` when the Keyboard changes its size. The default value is false. 
   * @platform ios 
   */</span>
  <span class="s1">automaticallyAdjustKeyboardInsets?: ?boolean,</span>
  <span class="s0">/** 
   * Controls whether iOS should automatically adjust the scroll indicator 
   * insets. The default value is true. Available on iOS 13 and later. 
   * @platform ios 
   */</span>
  <span class="s1">automaticallyAdjustsScrollIndicatorInsets?: ?boolean,</span>
  <span class="s0">/** 
   * The amount by which the scroll view content is inset from the edges 
   * of the scroll view. Defaults to `{top: 0, left: 0, bottom: 0, right: 0}`. 
   * @platform ios 
   */</span>
  <span class="s1">contentInset?: ?EdgeInsetsProp,</span>
  <span class="s0">/** 
   * When true, the scroll view bounces when it reaches the end of the 
   * content if the content is larger then the scroll view along the axis of 
   * the scroll direction. When false, it disables all bouncing even if 
   * the `alwaysBounce*` props are true. The default value is true. 
   * @platform ios 
   */</span>
  <span class="s1">bounces?: ?boolean,</span>
  <span class="s0">/** 
   * By default, ScrollView has an active pan responder that hijacks panresponders 
   * deeper in the render tree in order to prevent accidental touches while scrolling. 
   * However, in certain occasions (such as when using snapToInterval) in a vertical scrollview 
   * You may want to disable this behavior in order to prevent the ScrollView from blocking touches 
   */</span>
  <span class="s1">disableScrollViewPanResponder?: ?boolean,</span>
  <span class="s0">/** 
   * When true, gestures can drive zoom past min/max and the zoom will animate 
   * to the min/max value at gesture end, otherwise the zoom will not exceed 
   * the limits. 
   * @platform ios 
   */</span>
  <span class="s1">bouncesZoom?: ?boolean,</span>
  <span class="s0">/** 
   * When true, the scroll view bounces horizontally when it reaches the end 
   * even if the content is smaller than the scroll view itself. The default 
   * value is true when `horizontal={true}` and false otherwise. 
   * @platform ios 
   */</span>
  <span class="s1">alwaysBounceHorizontal?: ?boolean,</span>
  <span class="s0">/** 
   * When true, the scroll view bounces vertically when it reaches the end 
   * even if the content is smaller than the scroll view itself. The default 
   * value is false when `horizontal={true}` and true otherwise. 
   * @platform ios 
   */</span>
  <span class="s1">alwaysBounceVertical?: ?boolean,</span>
  <span class="s0">/** 
   * When true, the scroll view automatically centers the content when the 
   * content is smaller than the scroll view bounds; when the content is 
   * larger than the scroll view, this property has no effect. The default 
   * value is false. 
   * @platform ios 
   */</span>
  <span class="s1">centerContent?: ?boolean,</span>
  <span class="s0">/** 
   * The style of the scroll indicators. 
   * 
   *   - `'default'` (the default), same as `black`. 
   *   - `'black'`, scroll indicator is black. This style is good against a light background. 
   *   - `'white'`, scroll indicator is white. This style is good against a dark background. 
   * 
   * @platform ios 
   */</span>
  <span class="s1">indicatorStyle?: ?(</span><span class="s2">'default' </span><span class="s1">| </span><span class="s2">'black' </span><span class="s1">| </span><span class="s2">'white'</span><span class="s1">),</span>
  <span class="s0">/** 
   * When true, the ScrollView will try to lock to only vertical or horizontal 
   * scrolling while dragging.  The default value is false. 
   * @platform ios 
   */</span>
  <span class="s1">directionalLockEnabled?: ?boolean,</span>
  <span class="s0">/** 
   * When false, once tracking starts, won't try to drag if the touch moves. 
   * The default value is true. 
   * @platform ios 
   */</span>
  <span class="s1">canCancelContentTouches?: ?boolean,</span>
  <span class="s0">/** 
   * When set, the scroll view will adjust the scroll position so that the first child that is 
   * currently visible and at or beyond `minIndexForVisible` will not change position. This is 
   * useful for lists that are loading content in both directions, e.g. a chat thread, where new 
   * messages coming in might otherwise cause the scroll position to jump. A value of 0 is common, 
   * but other values such as 1 can be used to skip loading spinners or other content that should 
   * not maintain position. 
   * 
   * The optional `autoscrollToTopThreshold` can be used to make the content automatically scroll 
   * to the top after making the adjustment if the user was within the threshold of the top before 
   * the adjustment was made. This is also useful for chat-like applications where you want to see 
   * new messages scroll into place, but not if the user has scrolled up a ways and it would be 
   * disruptive to scroll a bunch. 
   * 
   * Caveat 1: Reordering elements in the scrollview with this enabled will probably cause 
   * jumpiness and jank. It can be fixed, but there are currently no plans to do so. For now, 
   * don't re-order the content of any ScrollViews or Lists that use this feature. 
   * 
   * Caveat 2: This simply uses `contentOffset` and `frame.origin` in native code to compute 
   * visibility. Occlusion, transforms, and other complexity won't be taken into account as to 
   * whether content is &quot;visible&quot; or not. 
   * 
   */</span>
  <span class="s1">maintainVisibleContentPosition?: ?$ReadOnly&lt;{|</span>
    <span class="s1">minIndexForVisible: number,</span>
    <span class="s1">autoscrollToTopThreshold?: ?number,</span>
  <span class="s1">|}&gt;,</span>
  <span class="s0">/** 
   * The maximum allowed zoom scale. The default value is 1.0. 
   * @platform ios 
   */</span>
  <span class="s1">maximumZoomScale?: ?number,</span>
  <span class="s0">/** 
   * The minimum allowed zoom scale. The default value is 1.0. 
   * @platform ios 
   */</span>
  <span class="s1">minimumZoomScale?: ?number,</span>
  <span class="s0">/** 
   * When true, ScrollView allows use of pinch gestures to zoom in and out. 
   * The default value is true. 
   * @platform ios 
   */</span>
  <span class="s1">pinchGestureEnabled?: ?boolean,</span>
  <span class="s0">/** 
   * The amount by which the scroll view indicators are inset from the edges 
   * of the scroll view. This should normally be set to the same value as 
   * the `contentInset`. Defaults to `{0, 0, 0, 0}`. 
   * @platform ios 
   */</span>
  <span class="s1">scrollIndicatorInsets?: ?EdgeInsetsProp,</span>
  <span class="s0">/** 
   * When true, the scroll view can be programmatically scrolled beyond its 
   * content size. The default value is false. 
   * @platform ios 
   */</span>
  <span class="s1">scrollToOverflowEnabled?: ?boolean,</span>
  <span class="s0">/** 
   * When true, the scroll view scrolls to top when the status bar is tapped. 
   * The default value is true. 
   * @platform ios 
   */</span>
  <span class="s1">scrollsToTop?: ?boolean,</span>
  <span class="s0">/** 
   * Fires when the scroll view scrolls to top after the status bar has been tapped 
   * @platform ios 
   */</span>
  <span class="s1">onScrollToTop?: (event: ScrollEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * When true, shows a horizontal scroll indicator. 
   * The default value is true. 
   */</span>
  <span class="s1">showsHorizontalScrollIndicator?: ?boolean,</span>
  <span class="s0">/** 
   * The current scale of the scroll view content. The default value is 1.0. 
   * @platform ios 
   */</span>
  <span class="s1">zoomScale?: ?number,</span>
  <span class="s0">/** 
   * This property specifies how the safe area insets are used to modify the 
   * content area of the scroll view. The default value of this property is 
   * &quot;never&quot;. Available on iOS 11 and later. 
   * @platform ios 
   */</span>
  <span class="s1">contentInsetAdjustmentBehavior?: ?(</span>
    <span class="s1">| </span><span class="s2">'automatic'</span>
    <span class="s1">| </span><span class="s2">'scrollableAxes'</span>
    <span class="s1">| </span><span class="s2">'never'</span>
    <span class="s1">| </span><span class="s2">'always'</span>
  <span class="s1">),</span>
<span class="s1">|}&gt;;</span>

<span class="s1">type AndroidProps = $ReadOnly&lt;{|</span>
  <span class="s0">/** 
   * Enables nested scrolling for Android API level 21+. 
   * Nested scrolling is supported by default on iOS 
   * @platform android 
   */</span>
  <span class="s1">nestedScrollEnabled?: ?boolean,</span>
  <span class="s0">/** 
   * Sometimes a scrollview takes up more space than its content fills. When this is 
   * the case, this prop will fill the rest of the scrollview with a color to avoid setting 
   * a background and creating unnecessary overdraw. This is an advanced optimization 
   * that is not needed in the general case. 
   * @platform android 
   */</span>
  <span class="s1">endFillColor?: ?ColorValue,</span>
  <span class="s0">/** 
   * Tag used to log scroll performance on this scroll view. Will force 
   * momentum events to be turned on (see sendMomentumEvents). This doesn't do 
   * anything out of the box and you need to implement a custom native 
   * FpsListener for it to be useful. 
   * @platform android 
   */</span>
  <span class="s1">scrollPerfTag?: ?string,</span>
  <span class="s0">/** 
   * Used to override default value of overScroll mode. 
   * 
   * Possible values: 
   * 
   *  - `'auto'` - Default value, allow a user to over-scroll 
   *    this view only if the content is large enough to meaningfully scroll. 
   *  - `'always'` - Always allow a user to over-scroll this view. 
   *  - `'never'` - Never allow a user to over-scroll this view. 
   * 
   * @platform android 
   */</span>
  <span class="s1">overScrollMode?: ?(</span><span class="s2">'auto' </span><span class="s1">| </span><span class="s2">'always' </span><span class="s1">| </span><span class="s2">'never'</span><span class="s1">),</span>
  <span class="s0">/** 
   * Causes the scrollbars not to turn transparent when they are not in use. 
   * The default value is false. 
   * 
   * @platform android 
   */</span>
  <span class="s1">persistentScrollbar?: ?boolean,</span>
  <span class="s0">/** 
   * Fades out the edges of the scroll content. 
   * 
   * If the value is greater than 0, the fading edges will be set accordingly 
   * to the current scroll direction and position, 
   * indicating if there is more content to show. 
   * 
   * The default value is 0. 
   * 
   * @platform android 
   */</span>
  <span class="s1">fadingEdgeLength?: ?number,</span>
<span class="s1">|}&gt;;</span>

<span class="s1">type StickyHeaderComponentType = React.AbstractComponent&lt;</span>
  <span class="s1">ScrollViewStickyHeaderProps,</span>
  <span class="s1">$ReadOnly&lt;interface {setNextHeaderY: number =&gt; </span><span class="s3">void</span><span class="s1">}&gt;,</span>
<span class="s1">&gt;;</span>

<span class="s1">export type Props = $ReadOnly&lt;{|</span>
  <span class="s1">...ViewProps,</span>
  <span class="s1">...IOSProps,</span>
  <span class="s1">...AndroidProps,</span>

  <span class="s0">/** 
   * These styles will be applied to the scroll view content container which 
   * wraps all of the child views. Example: 
   * 
   * ``` 
   * return ( 
   *   &lt;ScrollView contentContainerStyle={styles.contentContainer}&gt; 
   *   &lt;/ScrollView&gt; 
   * ); 
   * ... 
   * const styles = StyleSheet.create({ 
   *   contentContainer: { 
   *     paddingVertical: 20 
   *   } 
   * }); 
   * ``` 
   */</span>
  <span class="s1">contentContainerStyle?: ?ViewStyleProp,</span>
  <span class="s0">/** 
   * Used to manually set the starting scroll offset. 
   * The default value is `{x: 0, y: 0}`. 
   */</span>
  <span class="s1">contentOffset?: ?PointProp,</span>
  <span class="s0">/** 
   * When true, the scroll view stops on the next index (in relation to scroll 
   * position at release) regardless of how fast the gesture is. This can be 
   * used for pagination when the page is less than the width of the 
   * horizontal ScrollView or the height of the vertical ScrollView. The default value is false. 
   */</span>
  <span class="s1">disableIntervalMomentum?: ?boolean,</span>
  <span class="s0">/** 
   * A floating-point number that determines how quickly the scroll view 
   * decelerates after the user lifts their finger. You may also use string 
   * shortcuts `&quot;normal&quot;` and `&quot;fast&quot;` which match the underlying iOS settings 
   * for `UIScrollViewDecelerationRateNormal` and 
   * `UIScrollViewDecelerationRateFast` respectively. 
   * 
   *   - `'normal'`: 0.998 on iOS, 0.985 on Android (the default) 
   *   - `'fast'`: 0.99 on iOS, 0.9 on Android 
   */</span>
  <span class="s1">decelerationRate?: ?DecelerationRateType,</span>
  <span class="s0">/** 
   * When true, the scroll view's children are arranged horizontally in a row 
   * instead of vertically in a column. The default value is false. 
   */</span>
  <span class="s1">horizontal?: ?boolean,</span>
  <span class="s0">/** 
   * If sticky headers should stick at the bottom instead of the top of the 
   * ScrollView. This is usually used with inverted ScrollViews. 
   */</span>
  <span class="s1">invertStickyHeaders?: ?boolean,</span>
  <span class="s0">/** 
   * Determines whether the keyboard gets dismissed in response to a drag. 
   * 
   * *Cross platform* 
   * 
   *   - `'none'` (the default), drags do not dismiss the keyboard. 
   *   - `'on-drag'`, the keyboard is dismissed when a drag begins. 
   * 
   * *iOS Only* 
   * 
   *   - `'interactive'`, the keyboard is dismissed interactively with the drag and moves in 
   *     synchrony with the touch; dragging upwards cancels the dismissal. 
   *     On android this is not supported and it will have the same behavior as 'none'. 
   */</span>
  <span class="s1">keyboardDismissMode?: ?</span><span class="s0">// default</span>
  <span class="s0">// cross-platform</span>
  <span class="s1">(</span><span class="s2">'none' </span><span class="s1">| </span><span class="s2">'on-drag' </span><span class="s1">| </span><span class="s2">'interactive'</span><span class="s1">), </span><span class="s0">// ios only</span>
  <span class="s0">/** 
   * Determines when the keyboard should stay visible after a tap. 
   * 
   *   - `'never'` (the default), tapping outside of the focused text input when the keyboard 
   *     is up dismisses the keyboard. When this happens, children won't receive the tap. 
   *   - `'always'`, the keyboard will not dismiss automatically, and the scroll view will not 
   *     catch taps, but children of the scroll view can catch taps. 
   *   - `'handled'`, the keyboard will not dismiss automatically when the tap was handled by 
   *     a children, (or captured by an ancestor). 
   *   - `false`, deprecated, use 'never' instead 
   *   - `true`, deprecated, use 'always' instead 
   */</span>
  <span class="s1">keyboardShouldPersistTaps?: ?(</span><span class="s2">'always' </span><span class="s1">| </span><span class="s2">'never' </span><span class="s1">| </span><span class="s2">'handled' </span><span class="s1">| </span><span class="s3">true </span><span class="s1">| </span><span class="s3">false</span><span class="s1">),</span>
  <span class="s0">/** 
   * Called when the momentum scroll starts (scroll which occurs as the ScrollView glides to a stop). 
   */</span>
  <span class="s1">onMomentumScrollBegin?: ?(event: ScrollEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Called when the momentum scroll ends (scroll which occurs as the ScrollView glides to a stop). 
   */</span>
  <span class="s1">onMomentumScrollEnd?: ?(event: ScrollEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>

  <span class="s0">/** 
   * Fires at most once per frame during scrolling. The frequency of the 
   * events can be controlled using the `scrollEventThrottle` prop. 
   */</span>
  <span class="s1">onScroll?: ?(event: ScrollEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Called when the user begins to drag the scroll view. 
   */</span>
  <span class="s1">onScrollBeginDrag?: ?(event: ScrollEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Called when the user stops dragging the scroll view and it either stops 
   * or begins to glide. 
   */</span>
  <span class="s1">onScrollEndDrag?: ?(event: ScrollEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * Called when scrollable content view of the ScrollView changes. 
   * 
   * Handler function is passed the content width and content height as parameters: 
   * `(contentWidth, contentHeight)` 
   * 
   * It's implemented using onLayout handler attached to the content container 
   * which this ScrollView renders. 
   */</span>
  <span class="s1">onContentSizeChange?: (contentWidth: number, contentHeight: number) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onKeyboardDidShow?: (event: KeyboardEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onKeyboardDidHide?: (event: KeyboardEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onKeyboardWillShow?: (event: KeyboardEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">onKeyboardWillHide?: (event: KeyboardEvent) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s0">/** 
   * When true, the scroll view stops on multiples of the scroll view's size 
   * when scrolling. This can be used for horizontal pagination. The default 
   * value is false. 
   * 
   * Note: Vertical pagination is not supported on Android. 
   */</span>
  <span class="s1">pagingEnabled?: ?boolean,</span>
  <span class="s0">/** 
   * When false, the view cannot be scrolled via touch interaction. 
   * The default value is true. 
   * 
   * Note that the view can always be scrolled by calling `scrollTo`. 
   */</span>
  <span class="s1">scrollEnabled?: ?boolean,</span>
  <span class="s0">/** 
   * This controls how often the scroll event will be fired while scrolling 
   * (as a time interval in ms). A lower number yields better accuracy for code 
   * that is tracking the scroll position, but can lead to scroll performance 
   * problems due to the volume of information being send over the bridge. 
   * 
   * Values between 0 and 17ms indicate 60fps updates are needed and throttling 
   * will be disabled. 
   * 
   * If you do not need precise scroll position tracking, set this value higher 
   * to limit the information being sent across the bridge. 
   * 
   * The default value is zero, which results in the scroll event being sent only 
   * once each time the view is scrolled. 
   */</span>
  <span class="s1">scrollEventThrottle?: ?number,</span>
  <span class="s0">/** 
   * When true, shows a vertical scroll indicator. 
   * The default value is true. 
   */</span>
  <span class="s1">showsVerticalScrollIndicator?: ?boolean,</span>
  <span class="s0">/** 
   * When true, Sticky header is hidden when scrolling down, and dock at the top 
   * when scrolling up 
   */</span>
  <span class="s1">stickyHeaderHiddenOnScroll?: ?boolean,</span>
  <span class="s0">/** 
   * An array of child indices determining which children get docked to the 
   * top of the screen when scrolling. For example, passing 
   * `stickyHeaderIndices={[0]}` will cause the first child to be fixed to the 
   * top of the scroll view. This property is not supported in conjunction 
   * with `horizontal={true}`. 
   */</span>
  <span class="s1">stickyHeaderIndices?: ?$ReadOnlyArray&lt;number&gt;,</span>
  <span class="s0">/** 
   * A React Component that will be used to render sticky headers. 
   * To be used together with `stickyHeaderIndices` or with `SectionList`, defaults to `ScrollViewStickyHeader`. 
   * You may need to set this if your sticky header uses custom transforms (eg. translation), 
   * for example when you want your list to have an animated hidable header. 
   */</span>
  <span class="s1">StickyHeaderComponent?: StickyHeaderComponentType,</span>
  <span class="s0">/** 
   * When `snapToInterval` is set, `snapToAlignment` will define the relationship 
   * of the snapping to the scroll view. 
   * 
   *   - `'start'` (the default) will align the snap at the left (horizontal) or top (vertical) 
   *   - `'center'` will align the snap in the center 
   *   - `'end'` will align the snap at the right (horizontal) or bottom (vertical) 
   */</span>
  <span class="s1">snapToAlignment?: ?(</span><span class="s2">'start' </span><span class="s1">| </span><span class="s2">'center' </span><span class="s1">| </span><span class="s2">'end'</span><span class="s1">),</span>
  <span class="s0">/** 
   * When set, causes the scroll view to stop at multiples of the value of 
   * `snapToInterval`. This can be used for paginating through children 
   * that have lengths smaller than the scroll view. Typically used in 
   * combination with `snapToAlignment` and `decelerationRate=&quot;fast&quot;`. 
   * 
   * Overrides less configurable `pagingEnabled` prop. 
   */</span>
  <span class="s1">snapToInterval?: ?number,</span>
  <span class="s0">/** 
   * When set, causes the scroll view to stop at the defined offsets. 
   * This can be used for paginating through variously sized children 
   * that have lengths smaller than the scroll view. Typically used in 
   * combination with `decelerationRate=&quot;fast&quot;`. 
   * 
   * Overrides less configurable `pagingEnabled` and `snapToInterval` props. 
   */</span>
  <span class="s1">snapToOffsets?: ?$ReadOnlyArray&lt;number&gt;,</span>
  <span class="s0">/** 
   * Use in conjunction with `snapToOffsets`. By default, the beginning 
   * of the list counts as a snap offset. Set `snapToStart` to false to disable 
   * this behavior and allow the list to scroll freely between its start and 
   * the first `snapToOffsets` offset. 
   * The default value is true. 
   */</span>
  <span class="s1">snapToStart?: ?boolean,</span>
  <span class="s0">/** 
   * Use in conjunction with `snapToOffsets`. By default, the end 
   * of the list counts as a snap offset. Set `snapToEnd` to false to disable 
   * this behavior and allow the list to scroll freely between its end and 
   * the last `snapToOffsets` offset. 
   * The default value is true. 
   */</span>
  <span class="s1">snapToEnd?: ?boolean,</span>
  <span class="s0">/** 
   * Experimental: When true, offscreen child views (whose `overflow` value is 
   * `hidden`) are removed from their native backing superview when offscreen. 
   * This can improve scrolling performance on long lists. The default value is 
   * true. 
   */</span>
  <span class="s1">removeClippedSubviews?: ?boolean,</span>
  <span class="s0">/** 
   * A RefreshControl component, used to provide pull-to-refresh 
   * functionality for the ScrollView. Only works for vertical ScrollViews 
   * (`horizontal` prop must be `false`). 
   * 
   * See [RefreshControl](docs/refreshcontrol.html). 
   */</span>
  <span class="s0">/* $FlowFixMe[unclear-type] - how to handle generic type without existential 
   * operator? */</span>
  <span class="s1">refreshControl?: ?React.Element&lt;any&gt;,</span>
  <span class="s1">children?: React.Node,</span>
  <span class="s0">/** 
   * A ref to the inner View element of the ScrollView. This should be used 
   * instead of calling `getInnerViewRef`. 
   */</span>
  <span class="s1">innerViewRef?: ForwardedRef&lt;InnerViewInstance&gt;,</span>
  <span class="s0">/** 
   * A ref to the Native ScrollView component. This ref can be used to call 
   * all of ScrollView's public methods, in addition to native methods like 
   * measure, measureLayout, etc. 
   */</span>
  <span class="s1">scrollViewRef?: ForwardedRef&lt;PublicScrollViewInstance&gt;,</span>
<span class="s1">|}&gt;;</span>

<span class="s1">type State = {|</span>
  <span class="s1">layoutHeight: ?number,</span>
<span class="s1">|};</span>

<span class="s1">const IS_ANIMATING_TOUCH_START_THRESHOLD_MS = </span><span class="s4">16</span><span class="s1">;</span>

<span class="s1">export type ScrollViewComponentStatics = $ReadOnly&lt;{|</span>
  <span class="s1">Context: </span><span class="s3">typeof </span><span class="s1">ScrollViewContext,</span>
<span class="s1">|}&gt;;</span>

<span class="s0">/** 
 * Component that wraps platform ScrollView while providing 
 * integration with touch locking &quot;responder&quot; system. 
 * 
 * Keep in mind that ScrollViews must have a bounded height in order to work, 
 * since they contain unbounded-height children into a bounded container (via 
 * a scroll interaction). In order to bound the height of a ScrollView, either 
 * set the height of the view directly (discouraged) or make sure all parent 
 * views have bounded height. Forgetting to transfer `{flex: 1}` down the 
 * view stack can lead to errors here, which the element inspector makes 
 * easy to debug. 
 * 
 * Doesn't yet support other contained responders from blocking this scroll 
 * view from becoming the responder. 
 * 
 * 
 * `&lt;ScrollView&gt;` vs [`&lt;FlatList&gt;`](https://reactnative.dev/docs/flatlist) - which one to use? 
 * 
 * `ScrollView` simply renders all its react child components at once. That 
 * makes it very easy to understand and use. 
 * 
 * On the other hand, this has a performance downside. Imagine you have a very 
 * long list of items you want to display, maybe several screens worth of 
 * content. Creating JS components and native views for everything all at once, 
 * much of which may not even be shown, will contribute to slow rendering and 
 * increased memory usage. 
 * 
 * This is where `FlatList` comes into play. `FlatList` renders items lazily, 
 * just when they are about to appear, and removes items that scroll way off 
 * screen to save memory and processing time. 
 * 
 * `FlatList` is also handy if you want to render separators between your items, 
 * multiple columns, infinite scroll loading, or any number of other features it 
 * supports out of the box. 
 */</span>
<span class="s1">class ScrollView extends React.Component&lt;Props, State&gt; {</span>
  <span class="s1">static Context: </span><span class="s3">typeof </span><span class="s1">ScrollViewContext = ScrollViewContext;</span>

  <span class="s1">constructor(props: Props) {</span>
    <span class="s1">super(props);</span>

    <span class="s3">this</span><span class="s1">._scrollAnimatedValue = </span><span class="s3">new </span><span class="s1">AnimatedImplementation.Value(</span>
      <span class="s3">this</span><span class="s1">.props.contentOffset?.y ?? </span><span class="s4">0</span><span class="s1">,</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._scrollAnimatedValue.setOffset(</span><span class="s3">this</span><span class="s1">.props.contentInset?.top ?? </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s1">_scrollAnimatedValue: AnimatedImplementation.Value;</span>
  <span class="s1">_scrollAnimatedValueAttachment: ?{detach: () =&gt; </span><span class="s3">void</span><span class="s1">, ...} = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_stickyHeaderRefs: Map&lt;string, React.ElementRef&lt;StickyHeaderComponentType&gt;&gt; =</span>
    <span class="s3">new </span><span class="s1">Map();</span>
  <span class="s1">_headerLayoutYs: Map&lt;string, number&gt; = </span><span class="s3">new </span><span class="s1">Map();</span>

  <span class="s1">_keyboardMetrics: ?KeyboardMetrics = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_additionalScrollOffset: number = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">_isTouching: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_lastMomentumScrollBeginTime: number = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">_lastMomentumScrollEndTime: number = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s0">// Reset to false every time becomes responder. This is used to:</span>
  <span class="s0">// - Determine if the scroll view has been scrolled and therefore should</span>
  <span class="s0">// refuse to give up its responder lock.</span>
  <span class="s0">// - Determine if releasing should dismiss the keyboard when we are in</span>
  <span class="s0">// tap-to-dismiss mode (this.props.keyboardShouldPersistTaps !== 'always').</span>
  <span class="s1">_observedScrollSinceBecomingResponder: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_becameResponderWhileAnimating: boolean = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s1">_preventNegativeScrollOffset: ?boolean = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">_animated: ?boolean = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">_subscriptionKeyboardWillShow: ?EventSubscription = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_subscriptionKeyboardWillHide: ?EventSubscription = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_subscriptionKeyboardDidShow: ?EventSubscription = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s1">_subscriptionKeyboardDidHide: ?EventSubscription = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s1">state: State = {</span>
    <span class="s1">layoutHeight: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">};</span>

  <span class="s1">componentDidMount() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof this</span><span class="s1">.props.keyboardShouldPersistTaps === </span><span class="s2">'boolean'</span><span class="s1">) {</span>
      <span class="s1">console.warn(</span>
        <span class="s1">`</span><span class="s2">'keyboardShouldPersistTaps={${</span>
          <span class="s3">this</span><span class="s1">.props.keyboardShouldPersistTaps === </span><span class="s3">true </span><span class="s1">? </span><span class="s2">'true' </span><span class="s1">: </span><span class="s2">'false'</span>
        <span class="s1">}}</span><span class="s2">' is deprecated. ` +</span>
          <span class="s1">`Use </span><span class="s2">'keyboardShouldPersistTaps=&quot;${</span>
            <span class="s3">this</span><span class="s1">.props.keyboardShouldPersistTaps ? </span><span class="s2">'always' </span><span class="s1">: </span><span class="s2">'never'</span>
          <span class="s1">}</span><span class="s2">&quot;' instead`,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">._keyboardMetrics = Keyboard.metrics();</span>
    <span class="s3">this</span><span class="s1">._additionalScrollOffset = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">this</span><span class="s1">._subscriptionKeyboardWillShow = Keyboard.addListener(</span>
      <span class="s2">'keyboardWillShow'</span><span class="s1">,</span>
      <span class="s3">this</span><span class="s1">.scrollResponderKeyboardWillShow,</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptionKeyboardWillHide = Keyboard.addListener(</span>
      <span class="s2">'keyboardWillHide'</span><span class="s1">,</span>
      <span class="s3">this</span><span class="s1">.scrollResponderKeyboardWillHide,</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptionKeyboardDidShow = Keyboard.addListener(</span>
      <span class="s2">'keyboardDidShow'</span><span class="s1">,</span>
      <span class="s3">this</span><span class="s1">.scrollResponderKeyboardDidShow,</span>
    <span class="s1">);</span>
    <span class="s3">this</span><span class="s1">._subscriptionKeyboardDidHide = Keyboard.addListener(</span>
      <span class="s2">'keyboardDidHide'</span><span class="s1">,</span>
      <span class="s3">this</span><span class="s1">.scrollResponderKeyboardDidHide,</span>
    <span class="s1">);</span>

    <span class="s3">this</span><span class="s1">._updateAnimatedNodeAttachment();</span>
  <span class="s1">}</span>

  <span class="s1">componentDidUpdate(prevProps: Props) {</span>
    <span class="s1">const prevContentInsetTop = prevProps.contentInset</span>
      <span class="s1">? prevProps.contentInset.top</span>
      <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">const newContentInsetTop = </span><span class="s3">this</span><span class="s1">.props.contentInset</span>
      <span class="s1">? </span><span class="s3">this</span><span class="s1">.props.contentInset.top</span>
      <span class="s1">: </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(prevContentInsetTop !== newContentInsetTop) {</span>
      <span class="s3">this</span><span class="s1">._scrollAnimatedValue.setOffset(newContentInsetTop || </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">._updateAnimatedNodeAttachment();</span>
  <span class="s1">}</span>

  <span class="s1">componentWillUnmount() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._subscriptionKeyboardWillShow != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._subscriptionKeyboardWillShow.remove();</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._subscriptionKeyboardWillHide != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._subscriptionKeyboardWillHide.remove();</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._subscriptionKeyboardDidShow != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._subscriptionKeyboardDidShow.remove();</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._subscriptionKeyboardDidHide != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._subscriptionKeyboardDidHide.remove();</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._scrollAnimatedValueAttachment) {</span>
      <span class="s3">this</span><span class="s1">._scrollAnimatedValueAttachment.detach();</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * Returns a reference to the underlying scroll responder, which supports 
   * operations like `scrollTo`. All ScrollView-like components should 
   * implement this method so that they can be composed while providing access 
   * to the underlying scroll responder's methods. 
   */</span>
  <span class="s1">getScrollResponder: () =&gt; ScrollResponderType = () =&gt; {</span>
    <span class="s0">// $FlowFixMe[unclear-type]</span>
    <span class="s3">return </span><span class="s1">((</span><span class="s3">this</span><span class="s1">: any): ScrollResponderType);</span>
  <span class="s1">};</span>

  <span class="s1">getScrollableNode: () =&gt; ?number = () =&gt; {</span>
    <span class="s3">return </span><span class="s1">findNodeHandle(</span><span class="s3">this</span><span class="s1">._scrollView.nativeInstance);</span>
  <span class="s1">};</span>

  <span class="s1">getInnerViewNode: () =&gt; ?number = () =&gt; {</span>
    <span class="s3">return </span><span class="s1">findNodeHandle(</span><span class="s3">this</span><span class="s1">._innerView.nativeInstance);</span>
  <span class="s1">};</span>

  <span class="s1">getInnerViewRef: () =&gt; InnerViewInstance | </span><span class="s3">null </span><span class="s1">= () =&gt; {</span>
    <span class="s3">return this</span><span class="s1">._innerView.nativeInstance;</span>
  <span class="s1">};</span>

  <span class="s1">getNativeScrollRef: () =&gt; NativeScrollViewInstance | </span><span class="s3">null </span><span class="s1">= () =&gt; {</span>
    <span class="s3">return this</span><span class="s1">._scrollView.nativeInstance;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Scrolls to a given x, y offset, either immediately or with a smooth animation. 
   * 
   * Example: 
   * 
   * `scrollTo({x: 0, y: 0, animated: true})` 
   * 
   * Note: The weird function signature is due to the fact that, for historical reasons, 
   * the function also accepts separate arguments as an alternative to the options object. 
   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED. 
   */</span>
  <span class="s1">scrollTo: (</span>
    <span class="s1">options?:</span>
      <span class="s1">| {</span>
          <span class="s1">x?: number,</span>
          <span class="s1">y?: number,</span>
          <span class="s1">animated?: boolean,</span>
          <span class="s1">...</span>
        <span class="s1">}</span>
      <span class="s1">| number,</span>
    <span class="s1">deprecatedX?: number,</span>
    <span class="s1">deprecatedAnimated?: boolean,</span>
  <span class="s1">) =&gt; </span><span class="s3">void </span><span class="s1">= (</span>
    <span class="s1">options?:</span>
      <span class="s1">| {</span>
          <span class="s1">x?: number,</span>
          <span class="s1">y?: number,</span>
          <span class="s1">animated?: boolean,</span>
          <span class="s1">...</span>
        <span class="s1">}</span>
      <span class="s1">| number,</span>
    <span class="s1">deprecatedX?: number,</span>
    <span class="s1">deprecatedAnimated?: boolean,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s1">let x, y, animated;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">options === </span><span class="s2">'number'</span><span class="s1">) {</span>
      <span class="s1">console.warn(</span>
        <span class="s2">'`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' </span><span class="s1">+</span>
          <span class="s2">'animated: true})` instead.'</span><span class="s1">,</span>
      <span class="s1">);</span>
      <span class="s1">y = options;</span>
      <span class="s1">x = deprecatedX;</span>
      <span class="s1">animated = deprecatedAnimated;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(options) {</span>
      <span class="s1">y = options.y;</span>
      <span class="s1">x = options.x;</span>
      <span class="s1">animated = options.animated;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._scrollView.nativeInstance == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">Commands.scrollTo(</span>
      <span class="s3">this</span><span class="s1">._scrollView.nativeInstance,</span>
      <span class="s1">x || </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">y || </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">animated !== </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * If this is a vertical ScrollView scrolls to the bottom. 
   * If this is a horizontal ScrollView scrolls to the right. 
   * 
   * Use `scrollToEnd({animated: true})` for smooth animated scrolling, 
   * `scrollToEnd({animated: false})` for immediate scrolling. 
   * If no options are passed, `animated` defaults to true. 
   */</span>
  <span class="s1">scrollToEnd: (options?: ?{animated?: boolean, ...}) =&gt; </span><span class="s3">void </span><span class="s1">= (</span>
    <span class="s1">options?: ?{animated?: boolean, ...},</span>
  <span class="s1">) =&gt; {</span>
    <span class="s0">// Default to true</span>
    <span class="s1">const animated = (options &amp;&amp; options.animated) !== </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._scrollView.nativeInstance == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">Commands.scrollToEnd(</span><span class="s3">this</span><span class="s1">._scrollView.nativeInstance, animated);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Displays the scroll indicators momentarily. 
   * 
   * @platform ios 
   */</span>
  <span class="s1">flashScrollIndicators: () =&gt; </span><span class="s3">void </span><span class="s1">= () =&gt; {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._scrollView.nativeInstance == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">Commands.flashScrollIndicators(</span><span class="s3">this</span><span class="s1">._scrollView.nativeInstance);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * This method should be used as the callback to onFocus in a TextInputs' 
   * parent view. Note that any module using this mixin needs to return 
   * the parent view's ref in getScrollViewRef() in order to use this method. 
   * @param {number} nodeHandle The TextInput node handle 
   * @param {number} additionalOffset The scroll view's bottom &quot;contentInset&quot;. 
   *        Default is 0. 
   * @param {bool} preventNegativeScrolling Whether to allow pulling the content 
   *        down to make it meet the keyboard's top. Default is false. 
   */</span>
  <span class="s1">scrollResponderScrollNativeHandleToKeyboard: &lt;T&gt;(</span>
    <span class="s1">nodeHandle: number | React.ElementRef&lt;HostComponent&lt;T&gt;&gt;,</span>
    <span class="s1">additionalOffset?: number,</span>
    <span class="s1">preventNegativeScrollOffset?: boolean,</span>
  <span class="s1">) =&gt; </span><span class="s3">void </span><span class="s1">= &lt;T&gt;(</span>
    <span class="s1">nodeHandle: number | React.ElementRef&lt;HostComponent&lt;T&gt;&gt;,</span>
    <span class="s1">additionalOffset?: number,</span>
    <span class="s1">preventNegativeScrollOffset?: boolean,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._additionalScrollOffset = additionalOffset || </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">._preventNegativeScrollOffset = !!preventNegativeScrollOffset;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._innerView.nativeInstance == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">nodeHandle === </span><span class="s2">'number'</span><span class="s1">) {</span>
      <span class="s1">UIManager.measureLayout(</span>
        <span class="s1">nodeHandle,</span>
        <span class="s1">nullthrows(findNodeHandle(</span><span class="s3">this</span><span class="s1">)),</span>
        <span class="s0">// $FlowFixMe[method-unbinding] added when improving typing for this parameters</span>
        <span class="s3">this</span><span class="s1">._textInputFocusError,</span>
        <span class="s3">this</span><span class="s1">._inputMeasureAndScrollToKeyboard,</span>
      <span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">nodeHandle.measureLayout(</span>
        <span class="s3">this</span><span class="s1">._innerView.nativeInstance,</span>
        <span class="s3">this</span><span class="s1">._inputMeasureAndScrollToKeyboard,</span>
        <span class="s0">// $FlowFixMe[method-unbinding] added when improving typing for this parameters</span>
        <span class="s3">this</span><span class="s1">._textInputFocusError,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape 
   * {x: number; y: number; width: number; height: number; animated: boolean = true} 
   * 
   * @platform ios 
   */</span>
  <span class="s1">scrollResponderZoomTo: (</span>
    <span class="s1">rect: {|</span>
      <span class="s1">x: number,</span>
      <span class="s1">y: number,</span>
      <span class="s1">width: number,</span>
      <span class="s1">height: number,</span>
      <span class="s1">animated?: boolean,</span>
    <span class="s1">|},</span>
    <span class="s1">animated?: boolean, </span><span class="s0">// deprecated, put this inside the rect argument instead</span>
  <span class="s1">) =&gt; </span><span class="s3">void </span><span class="s1">= (</span>
    <span class="s1">rect: {|</span>
      <span class="s1">x: number,</span>
      <span class="s1">y: number,</span>
      <span class="s1">width: number,</span>
      <span class="s1">height: number,</span>
      <span class="s1">animated?: boolean,</span>
    <span class="s1">|},</span>
    <span class="s1">animated?: boolean, </span><span class="s0">// deprecated, put this inside the rect argument instead</span>
  <span class="s1">) =&gt; {</span>
    <span class="s1">invariant(Platform.OS === </span><span class="s2">'ios'</span><span class="s1">, </span><span class="s2">'zoomToRect is not implemented'</span><span class="s1">);</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s2">'animated' </span><span class="s3">in </span><span class="s1">rect) {</span>
      <span class="s3">this</span><span class="s1">._animated = rect.animated;</span>
      <span class="s3">delete </span><span class="s1">rect.animated;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">animated !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
      <span class="s1">console.warn(</span>
        <span class="s2">'`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._scrollView.nativeInstance == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">Commands.zoomToRect(</span>
      <span class="s3">this</span><span class="s1">._scrollView.nativeInstance,</span>
      <span class="s1">rect,</span>
      <span class="s1">animated !== </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s1">);</span>
  <span class="s1">};</span>

  <span class="s1">_textInputFocusError() {</span>
    <span class="s1">console.warn(</span><span class="s2">'Error measuring text field.'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * The calculations performed here assume the scroll view takes up the entire 
   * screen - even if has some content inset. We then measure the offsets of the 
   * keyboard, and compensate both for the scroll view's &quot;contentInset&quot;. 
   * 
   * @param {number} left Position of input w.r.t. table view. 
   * @param {number} top Position of input w.r.t. table view. 
   * @param {number} width Width of the text input. 
   * @param {number} height Height of the text input. 
   */</span>
  <span class="s1">_inputMeasureAndScrollToKeyboard: (</span>
    <span class="s1">left: number,</span>
    <span class="s1">top: number,</span>
    <span class="s1">width: number,</span>
    <span class="s1">height: number,</span>
  <span class="s1">) =&gt; </span><span class="s3">void </span><span class="s1">= (left: number, top: number, width: number, height: number) =&gt; {</span>
    <span class="s1">let keyboardScreenY = Dimensions.get(</span><span class="s2">'window'</span><span class="s1">).height;</span>

    <span class="s1">const scrollTextInputIntoVisibleRect = () =&gt; {</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._keyboardMetrics != </span><span class="s3">null</span><span class="s1">) {</span>
        <span class="s1">keyboardScreenY = </span><span class="s3">this</span><span class="s1">._keyboardMetrics.screenY;</span>
      <span class="s1">}</span>
      <span class="s1">let scrollOffsetY =</span>
        <span class="s1">top - keyboardScreenY + height + </span><span class="s3">this</span><span class="s1">._additionalScrollOffset;</span>

      <span class="s0">// By default, this can scroll with negative offset, pulling the content</span>
      <span class="s0">// down so that the target component's bottom meets the keyboard's top.</span>
      <span class="s0">// If requested otherwise, cap the offset at 0 minimum to avoid content</span>
      <span class="s0">// shifting down.</span>
      <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._preventNegativeScrollOffset === </span><span class="s3">true</span><span class="s1">) {</span>
        <span class="s1">scrollOffsetY = Math.max(</span><span class="s4">0</span><span class="s1">, scrollOffsetY);</span>
      <span class="s1">}</span>
      <span class="s3">this</span><span class="s1">.scrollTo({x: </span><span class="s4">0</span><span class="s1">, y: scrollOffsetY, animated: </span><span class="s3">true</span><span class="s1">});</span>

      <span class="s3">this</span><span class="s1">._additionalScrollOffset = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s1">._preventNegativeScrollOffset = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._keyboardMetrics == </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s0">// `_keyboardMetrics` is set inside `scrollResponderKeyboardWillShow` which</span>
      <span class="s0">// is not guaranteed to be called before `_inputMeasureAndScrollToKeyboard` but native has already scheduled it.</span>
      <span class="s0">// In case it was not called before `_inputMeasureAndScrollToKeyboard`, we postpone scrolling to</span>
      <span class="s0">// text input.</span>
      <span class="s1">setTimeout(() =&gt; {</span>
        <span class="s1">scrollTextInputIntoVisibleRect();</span>
      <span class="s1">}, </span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">scrollTextInputIntoVisibleRect();</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_getKeyForIndex(index: $FlowFixMe, childArray: $FlowFixMe): $FlowFixMe {</span>
    <span class="s1">const child = childArray[index];</span>
    <span class="s3">return </span><span class="s1">child &amp;&amp; child.key;</span>
  <span class="s1">}</span>

  <span class="s1">_updateAnimatedNodeAttachment() {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._scrollAnimatedValueAttachment) {</span>
      <span class="s3">this</span><span class="s1">._scrollAnimatedValueAttachment.detach();</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">this</span><span class="s1">.props.stickyHeaderIndices &amp;&amp;</span>
      <span class="s3">this</span><span class="s1">.props.stickyHeaderIndices.length &gt; </span><span class="s4">0</span>
    <span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">._scrollAnimatedValueAttachment =</span>
        <span class="s1">AnimatedImplementation.attachNativeEvent(</span>
          <span class="s3">this</span><span class="s1">._scrollView.nativeInstance,</span>
          <span class="s2">'onScroll'</span><span class="s1">,</span>
          <span class="s1">[{nativeEvent: {contentOffset: {y: </span><span class="s3">this</span><span class="s1">._scrollAnimatedValue}}}],</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_setStickyHeaderRef(</span>
    <span class="s1">key: string,</span>
    <span class="s1">ref: ?React.ElementRef&lt;StickyHeaderComponentType&gt;,</span>
  <span class="s1">) {</span>
    <span class="s3">if </span><span class="s1">(ref) {</span>
      <span class="s3">this</span><span class="s1">._stickyHeaderRefs.set(key, ref);</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s3">this</span><span class="s1">._stickyHeaderRefs.</span><span class="s3">delete</span><span class="s1">(key);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_onStickyHeaderLayout(index: $FlowFixMe, event: $FlowFixMe, key: $FlowFixMe) {</span>
    <span class="s1">const {stickyHeaderIndices} = </span><span class="s3">this</span><span class="s1">.props;</span>
    <span class="s3">if </span><span class="s1">(!stickyHeaderIndices) {</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">const childArray = React.Children.toArray&lt;$FlowFixMe&gt;(</span><span class="s3">this</span><span class="s1">.props.children);</span>
    <span class="s3">if </span><span class="s1">(key !== </span><span class="s3">this</span><span class="s1">._getKeyForIndex(index, childArray)) {</span>
      <span class="s0">// ignore stale layout update</span>
      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const layoutY = event.nativeEvent.layout.y;</span>
    <span class="s3">this</span><span class="s1">._headerLayoutYs.set(key, layoutY);</span>

    <span class="s1">const indexOfIndex = stickyHeaderIndices.indexOf(index);</span>
    <span class="s1">const previousHeaderIndex = stickyHeaderIndices[indexOfIndex - </span><span class="s4">1</span><span class="s1">];</span>
    <span class="s3">if </span><span class="s1">(previousHeaderIndex != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">const previousHeader = </span><span class="s3">this</span><span class="s1">._stickyHeaderRefs.get(</span>
        <span class="s3">this</span><span class="s1">._getKeyForIndex(previousHeaderIndex, childArray),</span>
      <span class="s1">);</span>
      <span class="s1">previousHeader &amp;&amp;</span>
        <span class="s1">previousHeader.setNextHeaderY &amp;&amp;</span>
        <span class="s1">previousHeader.setNextHeaderY(layoutY);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">_handleScroll = (e: ScrollEvent) =&gt; {</span>
    <span class="s3">if </span><span class="s1">(__DEV__) {</span>
      <span class="s3">if </span><span class="s1">(</span>
        <span class="s3">this</span><span class="s1">.props.onScroll &amp;&amp;</span>
        <span class="s3">this</span><span class="s1">.props.scrollEventThrottle == </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
        <span class="s1">Platform.OS === </span><span class="s2">'ios'</span>
      <span class="s1">) {</span>
        <span class="s1">console.log(</span>
          <span class="s2">'You specified `onScroll` on a &lt;ScrollView&gt; but not ' </span><span class="s1">+</span>
            <span class="s2">'`scrollEventThrottle`. You will only receive one event. ' </span><span class="s1">+</span>
            <span class="s2">'Using `16` you get all the events but be aware that it may ' </span><span class="s1">+</span>
            <span class="s2">&quot;cause frame drops, use a bigger number if you don't need as &quot; </span><span class="s1">+</span>
            <span class="s2">'much precision.'</span><span class="s1">,</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">._observedScrollSinceBecomingResponder = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.props.onScroll &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onScroll(e);</span>
  <span class="s1">};</span>

  <span class="s1">_handleLayout = (e: LayoutEvent) =&gt; {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.props.invertStickyHeaders === </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">this</span><span class="s1">.setState({layoutHeight: e.nativeEvent.layout.height});</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.props.onLayout) {</span>
      <span class="s3">this</span><span class="s1">.props.onLayout(e);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s1">_handleContentOnLayout = (e: LayoutEvent) =&gt; {</span>
    <span class="s1">const {width, height} = e.nativeEvent.layout;</span>
    <span class="s3">this</span><span class="s1">.props.onContentSizeChange &amp;&amp;</span>
      <span class="s3">this</span><span class="s1">.props.onContentSizeChange(width, height);</span>
  <span class="s1">};</span>

  <span class="s1">_innerView: RefForwarder&lt;InnerViewInstance, InnerViewInstance&gt; =</span>
    <span class="s1">createRefForwarder(</span>
      <span class="s1">(instance: InnerViewInstance): InnerViewInstance =&gt; instance,</span>
    <span class="s1">);</span>

  <span class="s1">_scrollView: RefForwarder&lt;</span>
    <span class="s1">NativeScrollViewInstance,</span>
    <span class="s1">PublicScrollViewInstance,</span>
  <span class="s1">&gt; = createRefForwarder(</span>
    <span class="s1">(nativeInstance: NativeScrollViewInstance): PublicScrollViewInstance =&gt; {</span>
      <span class="s0">// This is a hack. Ideally we would forwardRef  to the underlying</span>
      <span class="s0">// host component. However, since ScrollView has it's own methods that can be</span>
      <span class="s0">// called as well, if we used the standard forwardRef then these</span>
      <span class="s0">// methods wouldn't be accessible and thus be a breaking change.</span>
      <span class="s0">//</span>
      <span class="s0">// Therefore we edit ref to include ScrollView's public methods so that</span>
      <span class="s0">// they are callable from the ref.</span>

      <span class="s0">// $FlowFixMe[prop-missing] - Known issue with appending custom methods.</span>
      <span class="s1">const publicInstance: PublicScrollViewInstance = Object.assign(</span>
        <span class="s1">nativeInstance,</span>
        <span class="s1">{</span>
          <span class="s1">getScrollResponder: </span><span class="s3">this</span><span class="s1">.getScrollResponder,</span>
          <span class="s1">getScrollableNode: </span><span class="s3">this</span><span class="s1">.getScrollableNode,</span>
          <span class="s1">getInnerViewNode: </span><span class="s3">this</span><span class="s1">.getInnerViewNode,</span>
          <span class="s1">getInnerViewRef: </span><span class="s3">this</span><span class="s1">.getInnerViewRef,</span>
          <span class="s1">getNativeScrollRef: </span><span class="s3">this</span><span class="s1">.getNativeScrollRef,</span>
          <span class="s1">scrollTo: </span><span class="s3">this</span><span class="s1">.scrollTo,</span>
          <span class="s1">scrollToEnd: </span><span class="s3">this</span><span class="s1">.scrollToEnd,</span>
          <span class="s1">flashScrollIndicators: </span><span class="s3">this</span><span class="s1">.flashScrollIndicators,</span>
          <span class="s1">scrollResponderZoomTo: </span><span class="s3">this</span><span class="s1">.scrollResponderZoomTo,</span>
          <span class="s1">scrollResponderScrollNativeHandleToKeyboard:</span>
            <span class="s3">this</span><span class="s1">.scrollResponderScrollNativeHandleToKeyboard,</span>
        <span class="s1">},</span>
      <span class="s1">);</span>

      <span class="s3">return </span><span class="s1">publicInstance;</span>
    <span class="s1">},</span>
  <span class="s1">);</span>

  <span class="s0">/** 
   * Warning, this may be called several times for a single keyboard opening. 
   * It's best to store the information in this method and then take any action 
   * at a later point (either in `keyboardDidShow` or other). 
   * 
   * Here's the order that events occur in: 
   * - focus 
   * - willShow {startCoordinates, endCoordinates} several times 
   * - didShow several times 
   * - blur 
   * - willHide {startCoordinates, endCoordinates} several times 
   * - didHide several times 
   * 
   * The `ScrollResponder` module callbacks for each of these events. 
   * Even though any user could have easily listened to keyboard events 
   * themselves, using these `props` callbacks ensures that ordering of events 
   * is consistent - and not dependent on the order that the keyboard events are 
   * subscribed to. This matters when telling the scroll view to scroll to where 
   * the keyboard is headed - the scroll responder better have been notified of 
   * the keyboard destination before being instructed to scroll to where the 
   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything 
   * will work. 
   * 
   * WARNING: These callbacks will fire even if a keyboard is displayed in a 
   * different navigation pane. Filter out the events to determine if they are 
   * relevant to you. (For example, only if you receive these callbacks after 
   * you had explicitly focused a node etc). 
   */</span>

  <span class="s1">scrollResponderKeyboardWillShow: (e: KeyboardEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (</span>
    <span class="s1">e: KeyboardEvent,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._keyboardMetrics = e.endCoordinates;</span>
    <span class="s3">this</span><span class="s1">.props.onKeyboardWillShow &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onKeyboardWillShow(e);</span>
  <span class="s1">};</span>

  <span class="s1">scrollResponderKeyboardWillHide: (e: KeyboardEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (</span>
    <span class="s1">e: KeyboardEvent,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._keyboardMetrics = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.props.onKeyboardWillHide &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onKeyboardWillHide(e);</span>
  <span class="s1">};</span>

  <span class="s1">scrollResponderKeyboardDidShow: (e: KeyboardEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (</span>
    <span class="s1">e: KeyboardEvent,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._keyboardMetrics = e.endCoordinates;</span>
    <span class="s3">this</span><span class="s1">.props.onKeyboardDidShow &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onKeyboardDidShow(e);</span>
  <span class="s1">};</span>

  <span class="s1">scrollResponderKeyboardDidHide: (e: KeyboardEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (</span>
    <span class="s1">e: KeyboardEvent,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._keyboardMetrics = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.props.onKeyboardDidHide &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onKeyboardDidHide(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onMomentumScrollBegin` event. 
   */</span>
  <span class="s1">_handleMomentumScrollBegin: (e: ScrollEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: ScrollEvent) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._lastMomentumScrollBeginTime = global.performance.now();</span>
    <span class="s3">this</span><span class="s1">.props.onMomentumScrollBegin &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onMomentumScrollBegin(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onMomentumScrollEnd` event. 
   */</span>
  <span class="s1">_handleMomentumScrollEnd: (e: ScrollEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: ScrollEvent) =&gt; {</span>
    <span class="s1">FrameRateLogger.endScroll();</span>
    <span class="s3">this</span><span class="s1">._lastMomentumScrollEndTime = global.performance.now();</span>
    <span class="s3">this</span><span class="s1">.props.onMomentumScrollEnd &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onMomentumScrollEnd(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll 
   * animation, and there's not an easy way to distinguish a drag vs. stopping 
   * momentum. 
   * 
   * Invoke this from an `onScrollBeginDrag` event. 
   */</span>
  <span class="s1">_handleScrollBeginDrag: (e: ScrollEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: ScrollEvent) =&gt; {</span>
    <span class="s1">FrameRateLogger.beginScroll(); </span><span class="s0">// TODO: track all scrolls after implementing onScrollEndAnimation</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">Platform.OS === </span><span class="s2">'android' </span><span class="s1">&amp;&amp;</span>
      <span class="s3">this</span><span class="s1">.props.keyboardDismissMode === </span><span class="s2">'on-drag'</span>
    <span class="s1">) {</span>
      <span class="s1">dismissKeyboard();</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.props.onScrollBeginDrag &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onScrollBeginDrag(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onScrollEndDrag` event. 
   */</span>
  <span class="s1">_handleScrollEndDrag: (e: ScrollEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: ScrollEvent) =&gt; {</span>
    <span class="s1">const {velocity} = e.nativeEvent;</span>
    <span class="s0">// - If we are animating, then this is a &quot;drag&quot; that is stopping the scrollview and momentum end</span>
    <span class="s0">//   will fire.</span>
    <span class="s0">// - If velocity is non-zero, then the interaction will stop when momentum scroll ends or</span>
    <span class="s0">//   another drag starts and ends.</span>
    <span class="s0">// - If we don't get velocity, better to stop the interaction twice than not stop it.</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">!</span><span class="s3">this</span><span class="s1">._isAnimating() &amp;&amp;</span>
      <span class="s1">(!velocity || (velocity.x === </span><span class="s4">0 </span><span class="s1">&amp;&amp; velocity.y === </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">) {</span>
      <span class="s1">FrameRateLogger.endScroll();</span>
    <span class="s1">}</span>
    <span class="s3">this</span><span class="s1">.props.onScrollEndDrag &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onScrollEndDrag(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * A helper function for this class that lets us quickly determine if the 
   * view is currently animating. This is particularly useful to know when 
   * a touch has just started or ended. 
   */</span>
  <span class="s1">_isAnimating: () =&gt; boolean = () =&gt; {</span>
    <span class="s1">const now = global.performance.now();</span>
    <span class="s1">const timeSinceLastMomentumScrollEnd =</span>
      <span class="s1">now - </span><span class="s3">this</span><span class="s1">._lastMomentumScrollEndTime;</span>
    <span class="s1">const isAnimating =</span>
      <span class="s1">timeSinceLastMomentumScrollEnd &lt; IS_ANIMATING_TOUCH_START_THRESHOLD_MS ||</span>
      <span class="s3">this</span><span class="s1">._lastMomentumScrollEndTime &lt; </span><span class="s3">this</span><span class="s1">._lastMomentumScrollBeginTime;</span>
    <span class="s3">return </span><span class="s1">isAnimating;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onResponderGrant` event. 
   */</span>
  <span class="s1">_handleResponderGrant: (e: PressEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: PressEvent) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._observedScrollSinceBecomingResponder = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.props.onResponderGrant &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onResponderGrant(e);</span>
    <span class="s3">this</span><span class="s1">._becameResponderWhileAnimating = </span><span class="s3">this</span><span class="s1">._isAnimating();</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onResponderReject` event. 
   * 
   * Some other element is not yielding its role as responder. Normally, we'd 
   * just disable the `UIScrollView`, but a touch has already began on it, the 
   * `UIScrollView` will not accept being disabled after that. The easiest 
   * solution for now is to accept the limitation of disallowing this 
   * altogether. To improve this, find a way to disable the `UIScrollView` after 
   * a touch has already started. 
   */</span>
  <span class="s1">_handleResponderReject: () =&gt; </span><span class="s3">void </span><span class="s1">= () =&gt; {};</span>

  <span class="s0">/** 
   * Invoke this from an `onResponderRelease` event. 
   */</span>
  <span class="s1">_handleResponderRelease: (e: PressEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: PressEvent) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._isTouching = e.nativeEvent.touches.length !== </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.props.onResponderRelease &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onResponderRelease(e);</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">e.target === </span><span class="s2">'number'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(__DEV__) {</span>
        <span class="s1">console.error(</span>
          <span class="s2">'Did not expect event target to be a number. Should have been a native component'</span><span class="s1">,</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// By default scroll views will unfocus a textField</span>
    <span class="s0">// if another touch occurs outside of it</span>
    <span class="s1">const currentlyFocusedTextInput = TextInputState.currentlyFocusedInput();</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">currentlyFocusedTextInput != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s3">this</span><span class="s1">.props.keyboardShouldPersistTaps !== </span><span class="s3">true </span><span class="s1">&amp;&amp;</span>
      <span class="s3">this</span><span class="s1">.props.keyboardShouldPersistTaps !== </span><span class="s2">'always' </span><span class="s1">&amp;&amp;</span>
      <span class="s3">this</span><span class="s1">._keyboardIsDismissible() &amp;&amp;</span>
      <span class="s1">e.target !== currentlyFocusedTextInput &amp;&amp;</span>
      <span class="s1">!</span><span class="s3">this</span><span class="s1">._observedScrollSinceBecomingResponder &amp;&amp;</span>
      <span class="s1">!</span><span class="s3">this</span><span class="s1">._becameResponderWhileAnimating</span>
    <span class="s1">) {</span>
      <span class="s1">TextInputState.blurTextInput(currentlyFocusedTextInput);</span>
    <span class="s1">}</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * We will allow the scroll view to give up its lock iff it acquired the lock 
   * during an animation. This is a very useful default that happens to satisfy 
   * many common user experiences. 
   * 
   * - Stop a scroll on the left edge, then turn that into an outer view's 
   *   backswipe. 
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer 
   *   view dismiss. 
   * - However, without catching the scroll view mid-bounce (while it is 
   *   motionless), if you drag far enough for the scroll view to become 
   *   responder (and therefore drag the scroll view a bit), any backswipe 
   *   navigation of a swipe gesture higher in the view hierarchy, should be 
   *   rejected. 
   */</span>
  <span class="s1">_handleResponderTerminationRequest: () =&gt; boolean = () =&gt; {</span>
    <span class="s3">return </span><span class="s1">!</span><span class="s3">this</span><span class="s1">._observedScrollSinceBecomingResponder;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onScroll` event. 
   */</span>
  <span class="s1">_handleScrollShouldSetResponder: () =&gt; boolean = () =&gt; {</span>
    <span class="s0">// Allow any event touch pass through if the default pan responder is disabled</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.props.disableScrollViewPanResponder === </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return this</span><span class="s1">._isTouching;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Merely touch starting is not sufficient for a scroll view to become the 
   * responder. Being the &quot;responder&quot; means that the very next touch move/end 
   * event will result in an action/movement. 
   * 
   * Invoke this from an `onStartShouldSetResponder` event. 
   * 
   * `onStartShouldSetResponder` is used when the next move/end will trigger 
   * some UI movement/action, but when you want to yield priority to views 
   * nested inside of the view. 
   * 
   * There may be some cases where scroll views actually should return `true` 
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap 
   * that gives priority to nested views. 
   * 
   * - If a single tap on the scroll view triggers an action such as 
   *   recentering a map style view yet wants to give priority to interaction 
   *   views inside (such as dropped pins or labels), then we would return true 
   *   from this method when there is a single touch. 
   * 
   * - Similar to the previous case, if a two finger &quot;tap&quot; should trigger a 
   *   zoom, we would check the `touches` count, and if `&gt;= 2`, we would return 
   *   true. 
   * 
   */</span>
  <span class="s1">_handleStartShouldSetResponder: (e: PressEvent) =&gt; boolean = (</span>
    <span class="s1">e: PressEvent,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s0">// Allow any event touch pass through if the default pan responder is disabled</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.props.disableScrollViewPanResponder === </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">const currentlyFocusedInput = TextInputState.currentlyFocusedInput();</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s3">this</span><span class="s1">.props.keyboardShouldPersistTaps === </span><span class="s2">'handled' </span><span class="s1">&amp;&amp;</span>
      <span class="s3">this</span><span class="s1">._keyboardIsDismissible() &amp;&amp;</span>
      <span class="s1">e.target !== currentlyFocusedInput</span>
    <span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * There are times when the scroll view wants to become the responder 
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way 
   * that *doesn't* give priority to nested views (hence the capture phase): 
   * 
   * - Currently animating. 
   * - Tapping anywhere that is not a text input, while the keyboard is 
   *   up (which should dismiss the keyboard). 
   * 
   * Invoke this from an `onStartShouldSetResponderCapture` event. 
   */</span>
  <span class="s1">_handleStartShouldSetResponderCapture: (e: PressEvent) =&gt; boolean = (</span>
    <span class="s1">e: PressEvent,</span>
  <span class="s1">) =&gt; {</span>
    <span class="s0">// The scroll view should receive taps instead of its descendants if:</span>
    <span class="s0">// * it is already animating/decelerating</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._isAnimating()) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Allow any event touch pass through if the default pan responder is disabled</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.props.disableScrollViewPanResponder === </span><span class="s3">true</span><span class="s1">) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// * the keyboard is up, keyboardShouldPersistTaps is 'never' (the default),</span>
    <span class="s0">// and a new touch starts with a non-textinput target (in which case the</span>
    <span class="s0">// first tap should be sent to the scroll view and dismiss the keyboard,</span>
    <span class="s0">// then the second tap goes to the actual interior view)</span>
    <span class="s1">const {keyboardShouldPersistTaps} = </span><span class="s3">this</span><span class="s1">.props;</span>
    <span class="s1">const keyboardNeverPersistTaps =</span>
      <span class="s1">!keyboardShouldPersistTaps || keyboardShouldPersistTaps === </span><span class="s2">'never'</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">e.target === </span><span class="s2">'number'</span><span class="s1">) {</span>
      <span class="s3">if </span><span class="s1">(__DEV__) {</span>
        <span class="s1">console.error(</span>
          <span class="s2">'Did not expect event target to be a number. Should have been a native component'</span><span class="s1">,</span>
        <span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Let presses through if the soft keyboard is detached from the viewport</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">._softKeyboardIsDetached()) {</span>
      <span class="s3">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">keyboardNeverPersistTaps &amp;&amp;</span>
      <span class="s3">this</span><span class="s1">._keyboardIsDismissible() &amp;&amp;</span>
      <span class="s1">e.target != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s0">// $FlowFixMe[incompatible-call]</span>
      <span class="s1">!TextInputState.isTextInput(e.target)</span>
    <span class="s1">) {</span>
      <span class="s3">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Do we consider there to be a dismissible soft-keyboard open? 
   */</span>
  <span class="s1">_keyboardIsDismissible: () =&gt; boolean = () =&gt; {</span>
    <span class="s1">const currentlyFocusedInput = TextInputState.currentlyFocusedInput();</span>

    <span class="s0">// We cannot dismiss the keyboard without an input to blur, even if a soft</span>
    <span class="s0">// keyboard is open (e.g. when keyboard is open due to a native component</span>
    <span class="s0">// not participating in TextInputState). It's also possible that the</span>
    <span class="s0">// currently focused input isn't a TextInput (such as by calling ref.focus</span>
    <span class="s0">// on a non-TextInput).</span>
    <span class="s1">const hasFocusedTextInput =</span>
      <span class="s1">currentlyFocusedInput != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">TextInputState.isTextInput(currentlyFocusedInput);</span>

    <span class="s0">// Even if an input is focused, we may not have a keyboard to dismiss. E.g</span>
    <span class="s0">// when using a physical keyboard. Ensure we have an event for an opened</span>
    <span class="s0">// keyboard.</span>
    <span class="s1">const softKeyboardMayBeOpen =</span>
      <span class="s3">this</span><span class="s1">._keyboardMetrics != </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">this</span><span class="s1">._keyboardEventsAreUnreliable();</span>

    <span class="s3">return </span><span class="s1">hasFocusedTextInput &amp;&amp; softKeyboardMayBeOpen;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Whether an open soft keyboard is present which does not overlap the 
   * viewport. E.g. for a VR soft-keyboard which is detached from the app 
   * viewport. 
   */</span>
  <span class="s1">_softKeyboardIsDetached: () =&gt; boolean = () =&gt; {</span>
    <span class="s3">return this</span><span class="s1">._keyboardMetrics != </span><span class="s3">null </span><span class="s1">&amp;&amp; </span><span class="s3">this</span><span class="s1">._keyboardMetrics.height === </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s1">_keyboardEventsAreUnreliable: () =&gt; boolean = () =&gt; {</span>
    <span class="s0">// Android versions prior to API 30 rely on observing layout changes when</span>
    <span class="s0">// `android:windowSoftInputMode` is set to `adjustResize` or `adjustPan`.</span>
    <span class="s3">return </span><span class="s1">Platform.OS === </span><span class="s2">'android' </span><span class="s1">&amp;&amp; Platform.Version &lt; </span><span class="s4">30</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onTouchEnd` event. 
   * 
   * @param {PressEvent} e Event. 
   */</span>
  <span class="s1">_handleTouchEnd: (e: PressEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: PressEvent) =&gt; {</span>
    <span class="s1">const nativeEvent = e.nativeEvent;</span>
    <span class="s3">this</span><span class="s1">._isTouching = nativeEvent.touches.length !== </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s1">const {keyboardShouldPersistTaps} = </span><span class="s3">this</span><span class="s1">.props;</span>
    <span class="s1">const keyboardNeverPersistsTaps =</span>
      <span class="s1">!keyboardShouldPersistTaps || keyboardShouldPersistTaps === </span><span class="s2">'never'</span><span class="s1">;</span>

    <span class="s0">// Dismiss the keyboard now if we didn't become responder in capture phase</span>
    <span class="s0">// to eat presses, but still want to dismiss on interaction.</span>
    <span class="s0">// Don't do anything if the target of the touch event is the current input.</span>
    <span class="s1">const currentlyFocusedTextInput = TextInputState.currentlyFocusedInput();</span>
    <span class="s3">if </span><span class="s1">(</span>
      <span class="s1">currentlyFocusedTextInput != </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
      <span class="s1">e.target !== currentlyFocusedTextInput &amp;&amp;</span>
      <span class="s3">this</span><span class="s1">._softKeyboardIsDetached() &amp;&amp;</span>
      <span class="s3">this</span><span class="s1">._keyboardIsDismissible() &amp;&amp;</span>
      <span class="s1">keyboardNeverPersistsTaps</span>
    <span class="s1">) {</span>
      <span class="s1">TextInputState.blurTextInput(currentlyFocusedTextInput);</span>
    <span class="s1">}</span>

    <span class="s3">this</span><span class="s1">.props.onTouchEnd &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onTouchEnd(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onTouchCancel` event. 
   * 
   * @param {PressEvent} e Event. 
   */</span>
  <span class="s1">_handleTouchCancel: (e: PressEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: PressEvent) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._isTouching = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.props.onTouchCancel &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onTouchCancel(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onTouchStart` event. 
   * 
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin 
   * order, after `ResponderEventPlugin`, we can detect that we were *not* 
   * permitted to be the responder (presumably because a contained view became 
   * responder). The `onResponderReject` won't fire in that case - it only 
   * fires when a *current* responder rejects our request. 
   * 
   * @param {PressEvent} e Touch Start event. 
   */</span>
  <span class="s1">_handleTouchStart: (e: PressEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: PressEvent) =&gt; {</span>
    <span class="s3">this</span><span class="s1">._isTouching = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s1">.props.onTouchStart &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onTouchStart(e);</span>
  <span class="s1">};</span>

  <span class="s0">/** 
   * Invoke this from an `onTouchMove` event. 
   * 
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin 
   * order, after `ResponderEventPlugin`, we can detect that we were *not* 
   * permitted to be the responder (presumably because a contained view became 
   * responder). The `onResponderReject` won't fire in that case - it only 
   * fires when a *current* responder rejects our request. 
   * 
   * @param {PressEvent} e Touch Start event. 
   */</span>
  <span class="s1">_handleTouchMove: (e: PressEvent) =&gt; </span><span class="s3">void </span><span class="s1">= (e: PressEvent) =&gt; {</span>
    <span class="s3">this</span><span class="s1">.props.onTouchMove &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.onTouchMove(e);</span>
  <span class="s1">};</span>

  <span class="s1">render(): React.Node | React.Element&lt;string&gt; {</span>
    <span class="s1">const [NativeDirectionalScrollView, NativeDirectionalScrollContentView] =</span>
      <span class="s3">this</span><span class="s1">.props.horizontal === </span><span class="s3">true</span>
        <span class="s1">? NativeHorizontalScrollViewTuple</span>
        <span class="s1">: NativeVerticalScrollViewTuple;</span>

    <span class="s1">const contentContainerStyle = [</span>
      <span class="s3">this</span><span class="s1">.props.horizontal === </span><span class="s3">true </span><span class="s1">&amp;&amp; styles.contentContainerHorizontal,</span>
      <span class="s3">this</span><span class="s1">.props.contentContainerStyle,</span>
    <span class="s1">];</span>
    <span class="s3">if </span><span class="s1">(__DEV__ &amp;&amp; </span><span class="s3">this</span><span class="s1">.props.style !== undefined) {</span>
      <span class="s0">// $FlowFixMe[underconstrained-implicit-instantiation]</span>
      <span class="s1">const style = flattenStyle(</span><span class="s3">this</span><span class="s1">.props.style);</span>
      <span class="s1">const childLayoutProps = [</span><span class="s2">'alignItems'</span><span class="s1">, </span><span class="s2">'justifyContent'</span><span class="s1">].filter(</span>
        <span class="s1">prop =&gt; style &amp;&amp; style[prop] !== undefined,</span>
      <span class="s1">);</span>
      <span class="s1">invariant(</span>
        <span class="s1">childLayoutProps.length === </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s2">'ScrollView child layout (' </span><span class="s1">+</span>
          <span class="s1">JSON.stringify(childLayoutProps) +</span>
          <span class="s2">') must be applied through the contentContainerStyle prop.'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s1">const contentSizeChangeProps =</span>
      <span class="s3">this</span><span class="s1">.props.onContentSizeChange == </span><span class="s3">null</span>
        <span class="s1">? </span><span class="s3">null</span>
        <span class="s1">: {</span>
            <span class="s1">onLayout: </span><span class="s3">this</span><span class="s1">._handleContentOnLayout,</span>
          <span class="s1">};</span>

    <span class="s1">const {stickyHeaderIndices} = </span><span class="s3">this</span><span class="s1">.props;</span>
    <span class="s1">let children = </span><span class="s3">this</span><span class="s1">.props.children;</span>

    <span class="s3">if </span><span class="s1">(stickyHeaderIndices != </span><span class="s3">null </span><span class="s1">&amp;&amp; stickyHeaderIndices.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">const childArray = React.Children.toArray&lt;$FlowFixMe&gt;(</span>
        <span class="s3">this</span><span class="s1">.props.children,</span>
      <span class="s1">);</span>

      <span class="s1">children = childArray.map((child, index) =&gt; {</span>
        <span class="s1">const indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(indexOfIndex &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">const key = child.key;</span>
          <span class="s1">const nextIndex = stickyHeaderIndices[indexOfIndex + </span><span class="s4">1</span><span class="s1">];</span>
          <span class="s1">const StickyHeaderComponent =</span>
            <span class="s3">this</span><span class="s1">.props.StickyHeaderComponent || ScrollViewStickyHeader;</span>
          <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">&lt;StickyHeaderComponent</span>
              <span class="s1">key={key}</span>
              <span class="s1">nativeID={</span><span class="s2">'StickyHeader-' </span><span class="s1">+ key} </span><span class="s0">/* TODO: T68258846. */</span>
              <span class="s1">ref={ref =&gt; </span><span class="s3">this</span><span class="s1">._setStickyHeaderRef(key, ref)}</span>
              <span class="s1">nextHeaderLayoutY={</span><span class="s3">this</span><span class="s1">._headerLayoutYs.get(</span>
                <span class="s3">this</span><span class="s1">._getKeyForIndex(nextIndex, childArray),</span>
              <span class="s1">)}</span>
              <span class="s1">onLayout={event =&gt; </span><span class="s3">this</span><span class="s1">._onStickyHeaderLayout(index, event, key)}</span>
              <span class="s1">scrollAnimatedValue={</span><span class="s3">this</span><span class="s1">._scrollAnimatedValue}</span>
              <span class="s1">inverted={</span><span class="s3">this</span><span class="s1">.props.invertStickyHeaders}</span>
              <span class="s1">hiddenOnScroll={</span><span class="s3">this</span><span class="s1">.props.stickyHeaderHiddenOnScroll}</span>
              <span class="s1">scrollViewHeight={</span><span class="s3">this</span><span class="s1">.state.layoutHeight}&gt;</span>
              <span class="s1">{child}</span>
            <span class="s1">&lt;/StickyHeaderComponent&gt;</span>
          <span class="s1">);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s3">return </span><span class="s1">child;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">children = (</span>
      <span class="s1">&lt;ScrollViewContext.Provider</span>
        <span class="s1">value={</span><span class="s3">this</span><span class="s1">.props.horizontal === </span><span class="s3">true </span><span class="s1">? HORIZONTAL : VERTICAL}&gt;</span>
        <span class="s1">{children}</span>
      <span class="s1">&lt;/ScrollViewContext.Provider&gt;</span>
    <span class="s1">);</span>

    <span class="s1">const hasStickyHeaders =</span>
      <span class="s1">Array.isArray(stickyHeaderIndices) &amp;&amp; stickyHeaderIndices.length &gt; </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s1">const contentContainer = (</span>
      <span class="s1">&lt;NativeDirectionalScrollContentView</span>
        <span class="s1">{...contentSizeChangeProps}</span>
        <span class="s1">ref={</span><span class="s3">this</span><span class="s1">._innerView.getForwardingRef(</span><span class="s3">this</span><span class="s1">.props.innerViewRef)}</span>
        <span class="s1">style={contentContainerStyle}</span>
        <span class="s1">removeClippedSubviews={</span>
          <span class="s0">// Subview clipping causes issues with sticky headers on Android and</span>
          <span class="s0">// would be hard to fix properly in a performant way.</span>
          <span class="s1">Platform.OS === </span><span class="s2">'android' </span><span class="s1">&amp;&amp; hasStickyHeaders</span>
            <span class="s1">? </span><span class="s3">false</span>
            <span class="s1">: </span><span class="s3">this</span><span class="s1">.props.removeClippedSubviews</span>
        <span class="s1">}</span>
        <span class="s1">collapsable={</span><span class="s3">false</span><span class="s1">}&gt;</span>
        <span class="s1">{children}</span>
      <span class="s1">&lt;/NativeDirectionalScrollContentView&gt;</span>
    <span class="s1">);</span>

    <span class="s1">const alwaysBounceHorizontal =</span>
      <span class="s3">this</span><span class="s1">.props.alwaysBounceHorizontal !== undefined</span>
        <span class="s1">? </span><span class="s3">this</span><span class="s1">.props.alwaysBounceHorizontal</span>
        <span class="s1">: </span><span class="s3">this</span><span class="s1">.props.horizontal;</span>

    <span class="s1">const alwaysBounceVertical =</span>
      <span class="s3">this</span><span class="s1">.props.alwaysBounceVertical !== undefined</span>
        <span class="s1">? </span><span class="s3">this</span><span class="s1">.props.alwaysBounceVertical</span>
        <span class="s1">: !</span><span class="s3">this</span><span class="s1">.props.horizontal;</span>

    <span class="s1">const baseStyle =</span>
      <span class="s3">this</span><span class="s1">.props.horizontal === </span><span class="s3">true</span>
        <span class="s1">? styles.baseHorizontal</span>
        <span class="s1">: styles.baseVertical;</span>
    <span class="s1">const props = {</span>
      <span class="s1">...</span><span class="s3">this</span><span class="s1">.props,</span>
      <span class="s1">alwaysBounceHorizontal,</span>
      <span class="s1">alwaysBounceVertical,</span>
      <span class="s1">style: StyleSheet.compose(baseStyle, </span><span class="s3">this</span><span class="s1">.props.style),</span>
      <span class="s0">// Override the onContentSizeChange from props, since this event can</span>
      <span class="s0">// bubble up from TextInputs</span>
      <span class="s1">onContentSizeChange: </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">onLayout: </span><span class="s3">this</span><span class="s1">._handleLayout,</span>
      <span class="s1">onMomentumScrollBegin: </span><span class="s3">this</span><span class="s1">._handleMomentumScrollBegin,</span>
      <span class="s1">onMomentumScrollEnd: </span><span class="s3">this</span><span class="s1">._handleMomentumScrollEnd,</span>
      <span class="s1">onResponderGrant: </span><span class="s3">this</span><span class="s1">._handleResponderGrant,</span>
      <span class="s1">onResponderReject: </span><span class="s3">this</span><span class="s1">._handleResponderReject,</span>
      <span class="s1">onResponderRelease: </span><span class="s3">this</span><span class="s1">._handleResponderRelease,</span>
      <span class="s1">onResponderTerminationRequest: </span><span class="s3">this</span><span class="s1">._handleResponderTerminationRequest,</span>
      <span class="s1">onScrollBeginDrag: </span><span class="s3">this</span><span class="s1">._handleScrollBeginDrag,</span>
      <span class="s1">onScrollEndDrag: </span><span class="s3">this</span><span class="s1">._handleScrollEndDrag,</span>
      <span class="s1">onScrollShouldSetResponder: </span><span class="s3">this</span><span class="s1">._handleScrollShouldSetResponder,</span>
      <span class="s1">onStartShouldSetResponder: </span><span class="s3">this</span><span class="s1">._handleStartShouldSetResponder,</span>
      <span class="s1">onStartShouldSetResponderCapture:</span>
        <span class="s3">this</span><span class="s1">._handleStartShouldSetResponderCapture,</span>
      <span class="s1">onTouchEnd: </span><span class="s3">this</span><span class="s1">._handleTouchEnd,</span>
      <span class="s1">onTouchMove: </span><span class="s3">this</span><span class="s1">._handleTouchMove,</span>
      <span class="s1">onTouchStart: </span><span class="s3">this</span><span class="s1">._handleTouchStart,</span>
      <span class="s1">onTouchCancel: </span><span class="s3">this</span><span class="s1">._handleTouchCancel,</span>
      <span class="s1">onScroll: </span><span class="s3">this</span><span class="s1">._handleScroll,</span>
      <span class="s1">scrollEventThrottle: hasStickyHeaders</span>
        <span class="s1">? </span><span class="s4">1</span>
        <span class="s1">: </span><span class="s3">this</span><span class="s1">.props.scrollEventThrottle,</span>
      <span class="s1">sendMomentumEvents:</span>
        <span class="s3">this</span><span class="s1">.props.onMomentumScrollBegin || </span><span class="s3">this</span><span class="s1">.props.onMomentumScrollEnd</span>
          <span class="s1">? </span><span class="s3">true</span>
          <span class="s1">: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s0">// default to true</span>
      <span class="s1">snapToStart: </span><span class="s3">this</span><span class="s1">.props.snapToStart !== </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s0">// default to true</span>
      <span class="s1">snapToEnd: </span><span class="s3">this</span><span class="s1">.props.snapToEnd !== </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s0">// pagingEnabled is overridden by snapToInterval / snapToOffsets</span>
      <span class="s1">pagingEnabled: Platform.select({</span>
        <span class="s0">// on iOS, pagingEnabled must be set to false to have snapToInterval / snapToOffsets work</span>
        <span class="s1">ios:</span>
          <span class="s3">this</span><span class="s1">.props.pagingEnabled === </span><span class="s3">true </span><span class="s1">&amp;&amp;</span>
          <span class="s3">this</span><span class="s1">.props.snapToInterval == </span><span class="s3">null </span><span class="s1">&amp;&amp;</span>
          <span class="s3">this</span><span class="s1">.props.snapToOffsets == </span><span class="s3">null</span><span class="s1">,</span>
        <span class="s0">// on Android, pagingEnabled must be set to true to have snapToInterval / snapToOffsets work</span>
        <span class="s1">android:</span>
          <span class="s3">this</span><span class="s1">.props.pagingEnabled === </span><span class="s3">true </span><span class="s1">||</span>
          <span class="s3">this</span><span class="s1">.props.snapToInterval != </span><span class="s3">null </span><span class="s1">||</span>
          <span class="s3">this</span><span class="s1">.props.snapToOffsets != </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s1">}),</span>
    <span class="s1">};</span>

    <span class="s1">const {decelerationRate} = </span><span class="s3">this</span><span class="s1">.props;</span>
    <span class="s3">if </span><span class="s1">(decelerationRate != </span><span class="s3">null</span><span class="s1">) {</span>
      <span class="s1">props.decelerationRate = processDecelerationRate(decelerationRate);</span>
    <span class="s1">}</span>

    <span class="s1">const refreshControl = </span><span class="s3">this</span><span class="s1">.props.refreshControl;</span>
    <span class="s1">const scrollViewRef = </span><span class="s3">this</span><span class="s1">._scrollView.getForwardingRef(</span>
      <span class="s3">this</span><span class="s1">.props.scrollViewRef,</span>
    <span class="s1">);</span>

    <span class="s3">if </span><span class="s1">(refreshControl) {</span>
      <span class="s3">if </span><span class="s1">(Platform.OS === </span><span class="s2">'ios'</span><span class="s1">) {</span>
        <span class="s0">// On iOS the RefreshControl is a child of the ScrollView.</span>
        <span class="s3">return </span><span class="s1">(</span>
          <span class="s1">&lt;NativeDirectionalScrollView {...props} ref={scrollViewRef}&gt;</span>
            <span class="s1">{refreshControl}</span>
            <span class="s1">{contentContainer}</span>
          <span class="s1">&lt;/NativeDirectionalScrollView&gt;</span>
        <span class="s1">);</span>
      <span class="s1">} </span><span class="s3">else if </span><span class="s1">(Platform.OS === </span><span class="s2">'android'</span><span class="s1">) {</span>
        <span class="s0">// On Android wrap the ScrollView with a AndroidSwipeRefreshLayout.</span>
        <span class="s0">// Since the ScrollView is wrapped add the style props to the</span>
        <span class="s0">// AndroidSwipeRefreshLayout and use flex: 1 for the ScrollView.</span>
        <span class="s0">// Note: we should split props.style on the inner and outer props</span>
        <span class="s0">// however, the ScrollView still needs the baseStyle to be scrollable</span>
        <span class="s0">// $FlowFixMe[underconstrained-implicit-instantiation]</span>
        <span class="s1">const {outer, inner} = splitLayoutProps(flattenStyle(props.style));</span>
        <span class="s3">return </span><span class="s1">React.cloneElement(</span>
          <span class="s1">refreshControl,</span>
          <span class="s1">{style: StyleSheet.compose(baseStyle, outer)},</span>
          <span class="s1">&lt;NativeDirectionalScrollView</span>
            <span class="s1">{...props}</span>
            <span class="s1">style={StyleSheet.compose(baseStyle, inner)}</span>
            <span class="s1">ref={scrollViewRef}&gt;</span>
            <span class="s1">{contentContainer}</span>
          <span class="s1">&lt;/NativeDirectionalScrollView&gt;,</span>
        <span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">(</span>
      <span class="s1">&lt;NativeDirectionalScrollView {...props} ref={scrollViewRef}&gt;</span>
        <span class="s1">{contentContainer}</span>
      <span class="s1">&lt;/NativeDirectionalScrollView&gt;</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">const styles = StyleSheet.create({</span>
  <span class="s1">baseVertical: {</span>
    <span class="s1">flexGrow: </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">flexShrink: </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">flexDirection: </span><span class="s2">'column'</span><span class="s1">,</span>
    <span class="s1">overflow: </span><span class="s2">'scroll'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">baseHorizontal: {</span>
    <span class="s1">flexGrow: </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">flexShrink: </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">flexDirection: </span><span class="s2">'row'</span><span class="s1">,</span>
    <span class="s1">overflow: </span><span class="s2">'scroll'</span><span class="s1">,</span>
  <span class="s1">},</span>
  <span class="s1">contentContainerHorizontal: {</span>
    <span class="s1">flexDirection: </span><span class="s2">'row'</span><span class="s1">,</span>
  <span class="s1">},</span>
<span class="s1">});</span>

<span class="s1">type ForwardedRef&lt;T&gt; = {current: </span><span class="s3">null </span><span class="s1">| T, ...} | ((</span><span class="s3">null </span><span class="s1">| T) =&gt; mixed);</span>

<span class="s1">type RefForwarder&lt;TNativeInstance, TPublicInstance&gt; = {</span>
  <span class="s1">getForwardingRef: (</span>
    <span class="s1">?ForwardedRef&lt;TPublicInstance&gt;,</span>
  <span class="s1">) =&gt; (TNativeInstance | </span><span class="s3">null</span><span class="s1">) =&gt; </span><span class="s3">void</span><span class="s1">,</span>
  <span class="s1">nativeInstance: TNativeInstance | </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">publicInstance: TPublicInstance | </span><span class="s3">null</span><span class="s1">,</span>
<span class="s1">};</span>

<span class="s0">/** 
 * Helper function that should be replaced with `useCallback` and `useMergeRefs` 
 * once `ScrollView` is reimplemented as a functional component. 
 */</span>
<span class="s3">function </span><span class="s1">createRefForwarder&lt;TNativeInstance, TPublicInstance&gt;(</span>
  <span class="s1">mutator: TNativeInstance =&gt; TPublicInstance,</span>
<span class="s1">): RefForwarder&lt;TNativeInstance, TPublicInstance&gt; {</span>
  <span class="s1">const state: RefForwarder&lt;TNativeInstance, TPublicInstance&gt; = {</span>
    <span class="s1">getForwardingRef: memoize(forwardedRef =&gt; {</span>
      <span class="s3">return </span><span class="s1">(nativeInstance: TNativeInstance | </span><span class="s3">null</span><span class="s1">): </span><span class="s3">void </span><span class="s1">=&gt; {</span>
        <span class="s1">const publicInstance =</span>
          <span class="s1">nativeInstance == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">null </span><span class="s1">: mutator(nativeInstance);</span>

        <span class="s1">state.nativeInstance = nativeInstance;</span>
        <span class="s1">state.publicInstance = publicInstance;</span>

        <span class="s3">if </span><span class="s1">(forwardedRef != </span><span class="s3">null</span><span class="s1">) {</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">forwardedRef === </span><span class="s2">'function'</span><span class="s1">) {</span>
            <span class="s1">forwardedRef(publicInstance);</span>
          <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">forwardedRef.current = publicInstance;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">};</span>
    <span class="s1">}),</span>
    <span class="s1">nativeInstance: </span><span class="s3">null</span><span class="s1">,</span>
    <span class="s1">publicInstance: </span><span class="s3">null</span><span class="s1">,</span>
  <span class="s1">};</span>

  <span class="s3">return </span><span class="s1">state;</span>
<span class="s1">}</span>

<span class="s0">/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's 
 * LTI update could not be added via codemod */</span>
<span class="s3">function </span><span class="s1">Wrapper(props, ref: (mixed =&gt; mixed) | {current: mixed, ...}) {</span>
  <span class="s3">return </span><span class="s1">&lt;ScrollView {...props} scrollViewRef={ref} /&gt;;</span>
<span class="s1">}</span>
<span class="s1">Wrapper.displayName = </span><span class="s2">'ScrollView'</span><span class="s1">;</span>
<span class="s1">const ForwardedScrollView = React.forwardRef(Wrapper);</span>

<span class="s0">// $FlowFixMe[prop-missing] Add static context to ForwardedScrollView</span>
<span class="s1">ForwardedScrollView.Context = ScrollViewContext;</span>

<span class="s1">ForwardedScrollView.displayName = </span><span class="s2">'ScrollView'</span><span class="s1">;</span>

<span class="s1">module.exports = ((ForwardedScrollView: $FlowFixMe): React.AbstractComponent&lt;</span>
  <span class="s1">React.ElementConfig&lt;</span><span class="s3">typeof </span><span class="s1">ScrollView&gt;,</span>
  <span class="s1">PublicScrollViewInstance,</span>
<span class="s1">&gt; &amp;</span>
  <span class="s1">ScrollViewComponentStatics);</span>
</pre>
</body>
</html>
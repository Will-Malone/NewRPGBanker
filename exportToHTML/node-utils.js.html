<html>
<head>
<title>node-utils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node-utils.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
    <span class="s2">var </span><span class="s1">result = {};</span>
    <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">mod) </span><span class="s2">if </span><span class="s1">(k !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);</span>
    <span class="s1">__setModuleDefault(result, mod);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.isThisInTypeQuery = exports.isThisIdentifier = exports.identifierIsThisKeyword = exports.firstDefined = exports.nodeHasTokens = exports.createError = exports.TSError = exports.convertTokens = exports.convertToken = exports.getTokenType = exports.isChildUnwrappableOptionalChain = exports.isChainExpression = exports.isOptional = exports.isComputedProperty = exports.unescapeStringLiteralText = exports.hasJSXAncestor = exports.findFirstMatchingAncestor = exports.findNextToken = exports.getTSNodeAccessibility = exports.getDeclarationKind = exports.isJSXToken = exports.isToken = exports.getRange = exports.canContainDirective = exports.getLocFor = exports.getLineAndCharacterFor = exports.getBinaryExpressionType = exports.isJSDocComment = exports.isComment = exports.isComma = exports.getLastModifier = exports.hasModifier = exports.isESTreeClassMember = exports.getTextForTokenKind = exports.isLogicalOperator = exports.isAssignmentOperator = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">const ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s1">const getModifiers_1 = require(</span><span class="s0">&quot;./getModifiers&quot;</span><span class="s1">);</span>
<span class="s1">const xhtml_entities_1 = require(</span><span class="s0">&quot;./jsx/xhtml-entities&quot;</span><span class="s1">);</span>
<span class="s1">const ts_estree_1 = require(</span><span class="s0">&quot;./ts-estree&quot;</span><span class="s1">);</span>
<span class="s1">const version_check_1 = require(</span><span class="s0">&quot;./version-check&quot;</span><span class="s1">);</span>
<span class="s1">const isAtLeast50 = version_check_1.typescriptVersionIsAtLeast[</span><span class="s0">'5.0'</span><span class="s1">];</span>
<span class="s1">const SyntaxKind = ts.SyntaxKind;</span>
<span class="s1">const LOGICAL_OPERATORS = [</span>
    <span class="s1">SyntaxKind.BarBarToken,</span>
    <span class="s1">SyntaxKind.AmpersandAmpersandToken,</span>
    <span class="s1">SyntaxKind.QuestionQuestionToken,</span>
<span class="s1">];</span>
<span class="s4">/** 
 * Returns true if the given ts.Token is the assignment operator 
 * @param operator the operator token 
 * @returns is assignment 
 */</span>
<span class="s2">function </span><span class="s1">isAssignmentOperator(operator) {</span>
    <span class="s2">return </span><span class="s1">(operator.kind &gt;= SyntaxKind.FirstAssignment &amp;&amp;</span>
        <span class="s1">operator.kind &lt;= SyntaxKind.LastAssignment);</span>
<span class="s1">}</span>
<span class="s1">exports.isAssignmentOperator = isAssignmentOperator;</span>
<span class="s4">/** 
 * Returns true if the given ts.Token is a logical operator 
 * @param operator the operator token 
 * @returns is a logical operator 
 */</span>
<span class="s2">function </span><span class="s1">isLogicalOperator(operator) {</span>
    <span class="s2">return </span><span class="s1">LOGICAL_OPERATORS.includes(operator.kind);</span>
<span class="s1">}</span>
<span class="s1">exports.isLogicalOperator = isLogicalOperator;</span>
<span class="s4">/** 
 * Returns the string form of the given TSToken SyntaxKind 
 * @param kind the token's SyntaxKind 
 * @returns the token applicable token as a string 
 */</span>
<span class="s2">function </span><span class="s1">getTextForTokenKind(kind) {</span>
    <span class="s2">return </span><span class="s1">ts.tokenToString(kind);</span>
<span class="s1">}</span>
<span class="s1">exports.getTextForTokenKind = getTextForTokenKind;</span>
<span class="s4">/** 
 * Returns true if the given ts.Node is a valid ESTree class member 
 * @param node TypeScript AST node 
 * @returns is valid ESTree class member 
 */</span>
<span class="s2">function </span><span class="s1">isESTreeClassMember(node) {</span>
    <span class="s2">return </span><span class="s1">node.kind !== SyntaxKind.SemicolonClassElement;</span>
<span class="s1">}</span>
<span class="s1">exports.isESTreeClassMember = isESTreeClassMember;</span>
<span class="s4">/** 
 * Checks if a ts.Node has a modifier 
 * @param modifierKind TypeScript SyntaxKind modifier 
 * @param node TypeScript AST node 
 * @returns has the modifier specified 
 */</span>
<span class="s2">function </span><span class="s1">hasModifier(modifierKind, node) {</span>
    <span class="s1">const modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
    <span class="s2">return </span><span class="s1">(modifiers === </span><span class="s2">null </span><span class="s1">|| modifiers === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: modifiers.some(modifier =&gt; modifier.kind === modifierKind)) === </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">exports.hasModifier = hasModifier;</span>
<span class="s4">/** 
 * Get last last modifier in ast 
 * @param node TypeScript AST node 
 * @returns returns last modifier if present or null 
 */</span>
<span class="s2">function </span><span class="s1">getLastModifier(node) {</span>
    <span class="s2">var </span><span class="s1">_a;</span>
    <span class="s1">const modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
    <span class="s2">if </span><span class="s1">(modifiers == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(_a = modifiers[modifiers.length - </span><span class="s3">1</span><span class="s1">]) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? _a : </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">exports.getLastModifier = getLastModifier;</span>
<span class="s4">/** 
 * Returns true if the given ts.Token is a comma 
 * @param token the TypeScript token 
 * @returns is comma 
 */</span>
<span class="s2">function </span><span class="s1">isComma(token) {</span>
    <span class="s2">return </span><span class="s1">token.kind === SyntaxKind.CommaToken;</span>
<span class="s1">}</span>
<span class="s1">exports.isComma = isComma;</span>
<span class="s4">/** 
 * Returns true if the given ts.Node is a comment 
 * @param node the TypeScript node 
 * @returns is comment 
 */</span>
<span class="s2">function </span><span class="s1">isComment(node) {</span>
    <span class="s2">return </span><span class="s1">(node.kind === SyntaxKind.SingleLineCommentTrivia ||</span>
        <span class="s1">node.kind === SyntaxKind.MultiLineCommentTrivia);</span>
<span class="s1">}</span>
<span class="s1">exports.isComment = isComment;</span>
<span class="s4">/** 
 * Returns true if the given ts.Node is a JSDoc comment 
 * @param node the TypeScript node 
 * @returns is JSDoc comment 
 */</span>
<span class="s2">function </span><span class="s1">isJSDocComment(node) {</span>
    <span class="s2">return </span><span class="s1">node.kind === SyntaxKind.JSDocComment;</span>
<span class="s1">}</span>
<span class="s1">exports.isJSDocComment = isJSDocComment;</span>
<span class="s4">/** 
 * Returns the binary expression type of the given ts.Token 
 * @param operator the operator token 
 * @returns the binary expression type 
 */</span>
<span class="s2">function </span><span class="s1">getBinaryExpressionType(operator) {</span>
    <span class="s2">if </span><span class="s1">(isAssignmentOperator(operator)) {</span>
        <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.AssignmentExpression;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isLogicalOperator(operator)) {</span>
        <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.LogicalExpression;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.BinaryExpression;</span>
<span class="s1">}</span>
<span class="s1">exports.getBinaryExpressionType = getBinaryExpressionType;</span>
<span class="s4">/** 
 * Returns line and column data for the given positions, 
 * @param pos position to check 
 * @param ast the AST object 
 * @returns line and column 
 */</span>
<span class="s2">function </span><span class="s1">getLineAndCharacterFor(pos, ast) {</span>
    <span class="s1">const loc = ast.getLineAndCharacterOfPosition(pos);</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">line: loc.line + </span><span class="s3">1</span><span class="s1">,</span>
        <span class="s1">column: loc.character,</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">exports.getLineAndCharacterFor = getLineAndCharacterFor;</span>
<span class="s4">/** 
 * Returns line and column data for the given start and end positions, 
 * for the given AST 
 * @param start start data 
 * @param end   end data 
 * @param ast   the AST object 
 * @returns the loc data 
 */</span>
<span class="s2">function </span><span class="s1">getLocFor(start, end, ast) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">start: getLineAndCharacterFor(start, ast),</span>
        <span class="s1">end: getLineAndCharacterFor(end, ast),</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s1">exports.getLocFor = getLocFor;</span>
<span class="s4">/** 
 * Check whatever node can contain directive 
 * @param node 
 * @returns returns true if node can contain directive 
 */</span>
<span class="s2">function </span><span class="s1">canContainDirective(node) {</span>
    <span class="s2">if </span><span class="s1">(node.kind === ts.SyntaxKind.Block) {</span>
        <span class="s2">switch </span><span class="s1">(node.parent.kind) {</span>
            <span class="s2">case </span><span class="s1">ts.SyntaxKind.Constructor:</span>
            <span class="s2">case </span><span class="s1">ts.SyntaxKind.GetAccessor:</span>
            <span class="s2">case </span><span class="s1">ts.SyntaxKind.SetAccessor:</span>
            <span class="s2">case </span><span class="s1">ts.SyntaxKind.ArrowFunction:</span>
            <span class="s2">case </span><span class="s1">ts.SyntaxKind.FunctionExpression:</span>
            <span class="s2">case </span><span class="s1">ts.SyntaxKind.FunctionDeclaration:</span>
            <span class="s2">case </span><span class="s1">ts.SyntaxKind.MethodDeclaration:</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">exports.canContainDirective = canContainDirective;</span>
<span class="s4">/** 
 * Returns range for the given ts.Node 
 * @param node the ts.Node or ts.Token 
 * @param ast the AST object 
 * @returns the range data 
 */</span>
<span class="s2">function </span><span class="s1">getRange(node, ast) {</span>
    <span class="s2">return </span><span class="s1">[node.getStart(ast), node.getEnd()];</span>
<span class="s1">}</span>
<span class="s1">exports.getRange = getRange;</span>
<span class="s4">/** 
 * Returns true if a given ts.Node is a token 
 * @param node the ts.Node 
 * @returns is a token 
 */</span>
<span class="s2">function </span><span class="s1">isToken(node) {</span>
    <span class="s2">return </span><span class="s1">(node.kind &gt;= SyntaxKind.FirstToken &amp;&amp; node.kind &lt;= SyntaxKind.LastToken);</span>
<span class="s1">}</span>
<span class="s1">exports.isToken = isToken;</span>
<span class="s4">/** 
 * Returns true if a given ts.Node is a JSX token 
 * @param node ts.Node to be checked 
 * @returns is a JSX token 
 */</span>
<span class="s2">function </span><span class="s1">isJSXToken(node) {</span>
    <span class="s2">return </span><span class="s1">(node.kind &gt;= SyntaxKind.JsxElement &amp;&amp; node.kind &lt;= SyntaxKind.JsxAttribute);</span>
<span class="s1">}</span>
<span class="s1">exports.isJSXToken = isJSXToken;</span>
<span class="s4">/** 
 * Returns the declaration kind of the given ts.Node 
 * @param node TypeScript AST node 
 * @returns declaration kind 
 */</span>
<span class="s2">function </span><span class="s1">getDeclarationKind(node) {</span>
    <span class="s2">if </span><span class="s1">(node.flags &amp; ts.NodeFlags.Let) {</span>
        <span class="s2">return </span><span class="s0">'let'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.flags &amp; ts.NodeFlags.Const) {</span>
        <span class="s2">return </span><span class="s0">'const'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s0">'var'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">exports.getDeclarationKind = getDeclarationKind;</span>
<span class="s4">/** 
 * Gets a ts.Node's accessibility level 
 * @param node The ts.Node 
 * @returns accessibility &quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, or null 
 */</span>
<span class="s2">function </span><span class="s1">getTSNodeAccessibility(node) {</span>
    <span class="s1">const modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
    <span class="s2">if </span><span class="s1">(modifiers == </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(const modifier of modifiers) {</span>
        <span class="s2">switch </span><span class="s1">(modifier.kind) {</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PublicKeyword:</span>
                <span class="s2">return </span><span class="s0">'public'</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ProtectedKeyword:</span>
                <span class="s2">return </span><span class="s0">'protected'</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PrivateKeyword:</span>
                <span class="s2">return </span><span class="s0">'private'</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">exports.getTSNodeAccessibility = getTSNodeAccessibility;</span>
<span class="s4">/** 
 * Finds the next token based on the previous one and its parent 
 * Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren 
 * @param previousToken The previous TSToken 
 * @param parent The parent TSNode 
 * @param ast The TS AST 
 * @returns the next TSToken 
 */</span>
<span class="s2">function </span><span class="s1">findNextToken(previousToken, parent, ast) {</span>
    <span class="s2">return </span><span class="s1">find(parent);</span>
    <span class="s2">function </span><span class="s1">find(n) {</span>
        <span class="s2">if </span><span class="s1">(ts.isToken(n) &amp;&amp; n.pos === previousToken.end) {</span>
            <span class="s4">// this is token that starts at the end of previous token - return it</span>
            <span class="s2">return </span><span class="s1">n;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">firstDefined(n.getChildren(ast), (child) =&gt; {</span>
            <span class="s1">const shouldDiveInChildNode = </span>
            <span class="s4">// previous token is enclosed somewhere in the child</span>
            <span class="s1">(child.pos &lt;= previousToken.pos &amp;&amp; child.end &gt; previousToken.end) ||</span>
                <span class="s4">// previous token ends exactly at the beginning of child</span>
                <span class="s1">child.pos === previousToken.end;</span>
            <span class="s2">return </span><span class="s1">shouldDiveInChildNode &amp;&amp; nodeHasTokens(child, ast)</span>
                <span class="s1">? find(child)</span>
                <span class="s1">: undefined;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.findNextToken = findNextToken;</span>
<span class="s4">/** 
 * Find the first matching ancestor based on the given predicate function. 
 * @param node The current ts.Node 
 * @param predicate The predicate function to apply to each checked ancestor 
 * @returns a matching parent ts.Node 
 */</span>
<span class="s2">function </span><span class="s1">findFirstMatchingAncestor(node, predicate) {</span>
    <span class="s2">while </span><span class="s1">(node) {</span>
        <span class="s2">if </span><span class="s1">(predicate(node)) {</span>
            <span class="s2">return </span><span class="s1">node;</span>
        <span class="s1">}</span>
        <span class="s1">node = node.parent;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s1">exports.findFirstMatchingAncestor = findFirstMatchingAncestor;</span>
<span class="s4">/** 
 * Returns true if a given ts.Node has a JSX token within its hierarchy 
 * @param node ts.Node to be checked 
 * @returns has JSX ancestor 
 */</span>
<span class="s2">function </span><span class="s1">hasJSXAncestor(node) {</span>
    <span class="s2">return </span><span class="s1">!!findFirstMatchingAncestor(node, isJSXToken);</span>
<span class="s1">}</span>
<span class="s1">exports.hasJSXAncestor = hasJSXAncestor;</span>
<span class="s4">/** 
 * Unescape the text content of string literals, e.g. &amp;amp; -&gt; &amp; 
 * @param text The escaped string literal text. 
 * @returns The unescaped string literal text. 
 */</span>
<span class="s2">function </span><span class="s1">unescapeStringLiteralText(text) {</span>
    <span class="s2">return </span><span class="s1">text.replace(/&amp;(?:#\d+|#x[\da-fA-F]+|[</span><span class="s3">0</span><span class="s1">-</span><span class="s3">9</span><span class="s1">a-zA-Z]+);/g, entity =&gt; {</span>
        <span class="s1">const item = entity.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(item[</span><span class="s3">0</span><span class="s1">] === </span><span class="s0">'#'</span><span class="s1">) {</span>
            <span class="s1">const codePoint = item[</span><span class="s3">1</span><span class="s1">] === </span><span class="s0">'x'</span>
                <span class="s1">? parseInt(item.slice(</span><span class="s3">2</span><span class="s1">), </span><span class="s3">16</span><span class="s1">)</span>
                <span class="s1">: parseInt(item.slice(</span><span class="s3">1</span><span class="s1">), </span><span class="s3">10</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">codePoint &gt; </span><span class="s3">0</span><span class="s1">x10ffff </span><span class="s4">// RangeError: Invalid code point</span>
                <span class="s1">? entity</span>
                <span class="s1">: String.fromCodePoint(codePoint);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">xhtml_entities_1.xhtmlEntities[item] || entity;</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">exports.unescapeStringLiteralText = unescapeStringLiteralText;</span>
<span class="s4">/** 
 * Returns true if a given ts.Node is a computed property 
 * @param node ts.Node to be checked 
 * @returns is Computed Property 
 */</span>
<span class="s2">function </span><span class="s1">isComputedProperty(node) {</span>
    <span class="s2">return </span><span class="s1">node.kind === SyntaxKind.ComputedPropertyName;</span>
<span class="s1">}</span>
<span class="s1">exports.isComputedProperty = isComputedProperty;</span>
<span class="s4">/** 
 * Returns true if a given ts.Node is optional (has QuestionToken) 
 * @param node ts.Node to be checked 
 * @returns is Optional 
 */</span>
<span class="s2">function </span><span class="s1">isOptional(node) {</span>
    <span class="s2">return </span><span class="s1">node.questionToken</span>
        <span class="s1">? node.questionToken.kind === SyntaxKind.QuestionToken</span>
        <span class="s1">: </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">exports.isOptional = isOptional;</span>
<span class="s4">/** 
 * Returns true if the node is an optional chain node 
 */</span>
<span class="s2">function </span><span class="s1">isChainExpression(node) {</span>
    <span class="s2">return </span><span class="s1">node.type === ts_estree_1.AST_NODE_TYPES.ChainExpression;</span>
<span class="s1">}</span>
<span class="s1">exports.isChainExpression = isChainExpression;</span>
<span class="s4">/** 
 * Returns true of the child of property access expression is an optional chain 
 */</span>
<span class="s2">function </span><span class="s1">isChildUnwrappableOptionalChain(node, child) {</span>
    <span class="s2">return </span><span class="s1">(isChainExpression(child) &amp;&amp;</span>
        <span class="s4">// (x?.y).z is semantically different, and as such .z is no longer optional</span>
        <span class="s1">node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression);</span>
<span class="s1">}</span>
<span class="s1">exports.isChildUnwrappableOptionalChain = isChildUnwrappableOptionalChain;</span>
<span class="s4">/** 
 * Returns the type of a given ts.Token 
 * @param token the ts.Token 
 * @returns the token type 
 */</span>
<span class="s2">function </span><span class="s1">getTokenType(token) {</span>
    <span class="s1">let keywordKind;</span>
    <span class="s2">if </span><span class="s1">(isAtLeast50 &amp;&amp; token.kind === SyntaxKind.Identifier) {</span>
        <span class="s1">keywordKind = ts.identifierToKeywordKind(token);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s0">'originalKeywordKind' </span><span class="s2">in </span><span class="s1">token) {</span>
        <span class="s4">// eslint-disable-next-line deprecation/deprecation -- intentional fallback for older TS versions</span>
        <span class="s1">keywordKind = token.originalKeywordKind;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(keywordKind) {</span>
        <span class="s2">if </span><span class="s1">(keywordKind === SyntaxKind.NullKeyword) {</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Null;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(keywordKind &gt;= SyntaxKind.FirstFutureReservedWord &amp;&amp;</span>
            <span class="s1">keywordKind &lt;= SyntaxKind.LastKeyword) {</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Identifier;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Keyword;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(token.kind &gt;= SyntaxKind.FirstKeyword &amp;&amp;</span>
        <span class="s1">token.kind &lt;= SyntaxKind.LastFutureReservedWord) {</span>
        <span class="s2">if </span><span class="s1">(token.kind === SyntaxKind.FalseKeyword ||</span>
            <span class="s1">token.kind === SyntaxKind.TrueKeyword) {</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Boolean;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Keyword;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(token.kind &gt;= SyntaxKind.FirstPunctuation &amp;&amp;</span>
        <span class="s1">token.kind &lt;= SyntaxKind.LastPunctuation) {</span>
        <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Punctuator;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(token.kind &gt;= SyntaxKind.NoSubstitutionTemplateLiteral &amp;&amp;</span>
        <span class="s1">token.kind &lt;= SyntaxKind.TemplateTail) {</span>
        <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Template;</span>
    <span class="s1">}</span>
    <span class="s2">switch </span><span class="s1">(token.kind) {</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.NumericLiteral:</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Numeric;</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.JsxText:</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.JSXText;</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.StringLiteral:</span>
            <span class="s4">// A TypeScript-StringLiteral token with a TypeScript-JsxAttribute or TypeScript-JsxElement parent,</span>
            <span class="s4">// must actually be an ESTree-JSXText token</span>
            <span class="s2">if </span><span class="s1">(token.parent &amp;&amp;</span>
                <span class="s1">(token.parent.kind === SyntaxKind.JsxAttribute ||</span>
                    <span class="s1">token.parent.kind === SyntaxKind.JsxElement)) {</span>
                <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.JSXText;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.String;</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.RegularExpressionLiteral:</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.RegularExpression;</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.Identifier:</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.ConstructorKeyword:</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.GetKeyword:</span>
        <span class="s2">case </span><span class="s1">SyntaxKind.SetKeyword:</span>
        <span class="s4">// intentional fallthrough</span>
        <span class="s2">default</span><span class="s1">:</span>
    <span class="s1">}</span>
    <span class="s4">// Some JSX tokens have to be determined based on their parent</span>
    <span class="s2">if </span><span class="s1">(token.parent &amp;&amp; token.kind === SyntaxKind.Identifier) {</span>
        <span class="s2">if </span><span class="s1">(isJSXToken(token.parent)) {</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(token.parent.kind === SyntaxKind.PropertyAccessExpression &amp;&amp;</span>
            <span class="s1">hasJSXAncestor(token)) {</span>
            <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ts_estree_1.AST_TOKEN_TYPES.Identifier;</span>
<span class="s1">}</span>
<span class="s1">exports.getTokenType = getTokenType;</span>
<span class="s4">/** 
 * Extends and formats a given ts.Token, for a given AST 
 * @param token the ts.Token 
 * @param ast   the AST object 
 * @returns the converted Token 
 */</span>
<span class="s2">function </span><span class="s1">convertToken(token, ast) {</span>
    <span class="s1">const start = token.kind === SyntaxKind.JsxText</span>
        <span class="s1">? token.getFullStart()</span>
        <span class="s1">: token.getStart(ast);</span>
    <span class="s1">const end = token.getEnd();</span>
    <span class="s1">const value = ast.text.slice(start, end);</span>
    <span class="s1">const tokenType = getTokenType(token);</span>
    <span class="s2">if </span><span class="s1">(tokenType === ts_estree_1.AST_TOKEN_TYPES.RegularExpression) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: tokenType,</span>
            <span class="s1">value,</span>
            <span class="s1">range: [start, end],</span>
            <span class="s1">loc: getLocFor(start, end, ast),</span>
            <span class="s1">regex: {</span>
                <span class="s1">pattern: value.slice(</span><span class="s3">1</span><span class="s1">, value.lastIndexOf(</span><span class="s0">'/'</span><span class="s1">)),</span>
                <span class="s1">flags: value.slice(value.lastIndexOf(</span><span class="s0">'/'</span><span class="s1">) + </span><span class="s3">1</span><span class="s1">),</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s4">// @ts-expect-error TS is complaining about `value` not being the correct</span>
        <span class="s4">// type but it is</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: tokenType,</span>
            <span class="s1">value,</span>
            <span class="s1">range: [start, end],</span>
            <span class="s1">loc: getLocFor(start, end, ast),</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.convertToken = convertToken;</span>
<span class="s4">/** 
 * Converts all tokens for the given AST 
 * @param ast the AST object 
 * @returns the converted Tokens 
 */</span>
<span class="s2">function </span><span class="s1">convertTokens(ast) {</span>
    <span class="s1">const result = [];</span>
    <span class="s4">/** 
     * @param node the ts.Node 
     */</span>
    <span class="s2">function </span><span class="s1">walk(node) {</span>
        <span class="s4">// TypeScript generates tokens for types in JSDoc blocks. Comment tokens</span>
        <span class="s4">// and their children should not be walked or added to the resulting tokens list.</span>
        <span class="s2">if </span><span class="s1">(isComment(node) || isJSDocComment(node)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isToken(node) &amp;&amp; node.kind !== SyntaxKind.EndOfFileToken) {</span>
            <span class="s1">const converted = convertToken(node, ast);</span>
            <span class="s2">if </span><span class="s1">(converted) {</span>
                <span class="s1">result.push(converted);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">node.getChildren(ast).forEach(walk);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">walk(ast);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s1">exports.convertTokens = convertTokens;</span>
<span class="s1">class TSError extends Error {</span>
    <span class="s1">constructor(message, fileName, index, lineNumber, column) {</span>
        <span class="s1">super(message);</span>
        <span class="s2">this</span><span class="s1">.fileName = fileName;</span>
        <span class="s2">this</span><span class="s1">.index = index;</span>
        <span class="s2">this</span><span class="s1">.lineNumber = lineNumber;</span>
        <span class="s2">this</span><span class="s1">.column = column;</span>
        <span class="s1">Object.defineProperty(</span><span class="s2">this</span><span class="s1">, </span><span class="s0">'name'</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s2">new</span><span class="s1">.target.name,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.TSError = TSError;</span>
<span class="s4">/** 
 * @param ast     the AST object 
 * @param start   the index at which the error starts 
 * @param message the error message 
 * @returns converted error object 
 */</span>
<span class="s2">function </span><span class="s1">createError(ast, start, message) {</span>
    <span class="s1">const loc = ast.getLineAndCharacterOfPosition(start);</span>
    <span class="s2">return new </span><span class="s1">TSError(message, ast.fileName, start, loc.line + </span><span class="s3">1</span><span class="s1">, loc.character);</span>
<span class="s1">}</span>
<span class="s1">exports.createError = createError;</span>
<span class="s4">/** 
 * @param n the TSNode 
 * @param ast the TS AST 
 */</span>
<span class="s2">function </span><span class="s1">nodeHasTokens(n, ast) {</span>
    <span class="s4">// If we have a token or node that has a non-zero width, it must have tokens.</span>
    <span class="s4">// Note: getWidth() does not take trivia into account.</span>
    <span class="s2">return </span><span class="s1">n.kind === SyntaxKind.EndOfFileToken</span>
        <span class="s1">? !!n.jsDoc</span>
        <span class="s1">: n.getWidth(ast) !== </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s1">exports.nodeHasTokens = nodeHasTokens;</span>
<span class="s4">/** 
 * Like `forEach`, but suitable for use with numbers and strings (which may be falsy). 
 * @template T 
 * @template U 
 * @param array 
 * @param callback 
 */</span>
<span class="s2">function </span><span class="s1">firstDefined(array, callback) {</span>
    <span class="s2">if </span><span class="s1">(array === undefined) {</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(let i = </span><span class="s3">0</span><span class="s1">; i &lt; array.length; i++) {</span>
        <span class="s1">const result = callback(array[i], i);</span>
        <span class="s2">if </span><span class="s1">(result !== undefined) {</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">undefined;</span>
<span class="s1">}</span>
<span class="s1">exports.firstDefined = firstDefined;</span>
<span class="s2">function </span><span class="s1">identifierIsThisKeyword(id) {</span>
    <span class="s2">return </span><span class="s1">(</span>
    <span class="s4">// eslint-disable-next-line deprecation/deprecation -- intentional for older TS versions</span>
    <span class="s1">(isAtLeast50 ? ts.identifierToKeywordKind(id) : id.originalKeywordKind) ===</span>
        <span class="s1">SyntaxKind.ThisKeyword);</span>
<span class="s1">}</span>
<span class="s1">exports.identifierIsThisKeyword = identifierIsThisKeyword;</span>
<span class="s2">function </span><span class="s1">isThisIdentifier(node) {</span>
    <span class="s2">return </span><span class="s1">(!!node &amp;&amp;</span>
        <span class="s1">node.kind === SyntaxKind.Identifier &amp;&amp;</span>
        <span class="s1">identifierIsThisKeyword(node));</span>
<span class="s1">}</span>
<span class="s1">exports.isThisIdentifier = isThisIdentifier;</span>
<span class="s2">function </span><span class="s1">isThisInTypeQuery(node) {</span>
    <span class="s2">if </span><span class="s1">(!isThisIdentifier(node)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(ts.isQualifiedName(node.parent) &amp;&amp; node.parent.left === node) {</span>
        <span class="s1">node = node.parent;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">node.parent.kind === SyntaxKind.TypeQuery;</span>
<span class="s1">}</span>
<span class="s1">exports.isThisInTypeQuery = isThisInTypeQuery;</span>
<span class="s4">//# sourceMappingURL=node-utils.js.map</span></pre>
</body>
</html>
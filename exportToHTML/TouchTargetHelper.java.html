<html>
<head>
<title>TouchTargetHelper.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
TouchTargetHelper.java</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">package </span><span class="s1">com.facebook.react.uimanager</span><span class="s2">;</span>

<span class="s2">import static </span><span class="s1">com.facebook.react.uimanager.common.UIManagerType.FABRIC</span><span class="s2">;</span>

<span class="s2">import </span><span class="s1">android.annotation.SuppressLint</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Matrix</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.PointF</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.graphics.Rect</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.MotionEvent</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.View</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">android.view.ViewGroup</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">androidx.annotation.Nullable</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.common.logging.FLog</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.bridge.UiThreadUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.common.ReactConstants</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.touch.ReactHitSlopView</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">com.facebook.react.uimanager.common.ViewUtil</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.ArrayList</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.EnumSet</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.List</span><span class="s2">;</span>
<span class="s2">import </span><span class="s1">java.util.Objects</span><span class="s2">;</span>

<span class="s3">/**</span>
 <span class="s3">* Class responsible for identifying which react view should handle a given {</span><span class="s4">@link </span><span class="s3">MotionEvent}. It</span>
 <span class="s3">* uses the event coordinates to traverse the view hierarchy and return a suitable view.</span>
 <span class="s3">*/</span>
<span class="s2">public class </span><span class="s1">TouchTargetHelper {</span>

  <span class="s2">private static final float</span><span class="s1">[] mEventCoords = </span><span class="s2">new float</span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">PointF mTempPoint = </span><span class="s2">new </span><span class="s1">PointF()</span><span class="s2">;</span>
  <span class="s2">private static final float</span><span class="s1">[] mMatrixTransformCoords = </span><span class="s2">new float</span><span class="s1">[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">private static final </span><span class="s1">Matrix mInverseMatrix = </span><span class="s2">new </span><span class="s1">Matrix()</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Find touch event target view within the provided container given the coordinates provided via</span>
   <span class="s3">* {</span><span class="s4">@link </span><span class="s3">MotionEvent}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventX the X screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventY the Y screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">viewGroup the container view to traverse</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">the react tag ID of the child view that should handle the event</span>
   <span class="s3">*/</span>
  <span class="s2">public static int </span><span class="s1">findTargetTagForTouch(</span><span class="s2">float </span><span class="s1">eventX</span><span class="s2">, float </span><span class="s1">eventY</span><span class="s2">, </span><span class="s1">ViewGroup viewGroup) {</span>
    <span class="s2">return </span><span class="s1">findTargetTagAndCoordinatesForTouch(eventX</span><span class="s2">, </span><span class="s1">eventY</span><span class="s2">, </span><span class="s1">viewGroup</span><span class="s2">, </span><span class="s1">mEventCoords</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Find touch event target view within the provided container given the coordinates provided via</span>
   <span class="s3">* {</span><span class="s4">@link </span><span class="s3">MotionEvent}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventX the X screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventY the Y screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">viewGroup the container view to traverse</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">nativeViewId the native react view containing this touch target</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">the react tag ID of the child view that should handle the event</span>
   <span class="s3">*/</span>
  <span class="s2">public static int </span><span class="s1">findTargetTagForTouch(</span>
      <span class="s2">float </span><span class="s1">eventX</span><span class="s2">, float </span><span class="s1">eventY</span><span class="s2">, </span><span class="s1">ViewGroup viewGroup</span><span class="s2">, </span><span class="s1">@Nullable </span><span class="s2">int</span><span class="s1">[] nativeViewId) {</span>
    <span class="s2">return </span><span class="s1">findTargetTagAndCoordinatesForTouch(</span>
        <span class="s1">eventX</span><span class="s2">, </span><span class="s1">eventY</span><span class="s2">, </span><span class="s1">viewGroup</span><span class="s2">, </span><span class="s1">mEventCoords</span><span class="s2">, </span><span class="s1">nativeViewId)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Find touch event target view within the provided container given the coordinates provided via</span>
   <span class="s3">* {</span><span class="s4">@link </span><span class="s3">MotionEvent}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventX the X screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventY the Y screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">viewGroup the container view to traverse</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">viewCoords an out parameter that will return the X,Y value in the target view</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">nativeViewTag an out parameter that will return the native view id</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">the react tag ID of the child view that should handle the event</span>
   <span class="s3">*/</span>
  <span class="s2">public static int </span><span class="s1">findTargetTagAndCoordinatesForTouch(</span>
      <span class="s2">float </span><span class="s1">eventX</span><span class="s2">,</span>
      <span class="s2">float </span><span class="s1">eventY</span><span class="s2">,</span>
      <span class="s1">ViewGroup viewGroup</span><span class="s2">,</span>
      <span class="s2">float</span><span class="s1">[] viewCoords</span><span class="s2">,</span>
      <span class="s1">@Nullable </span><span class="s2">int</span><span class="s1">[] nativeViewTag) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>
    <span class="s2">int </span><span class="s1">targetTag = viewGroup.getId()</span><span class="s2">;</span>
    <span class="s0">// Store eventCoords in array so that they are modified to be relative to the targetView found.</span>
    <span class="s1">viewCoords[</span><span class="s5">0</span><span class="s1">] = eventX</span><span class="s2">;</span>
    <span class="s1">viewCoords[</span><span class="s5">1</span><span class="s1">] = eventY</span><span class="s2">;</span>
    <span class="s1">View nativeTargetView = findTouchTargetViewWithPointerEvents(viewCoords</span><span class="s2">, </span><span class="s1">viewGroup</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nativeTargetView != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">View reactTargetView = findClosestReactAncestor(nativeTargetView)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(reactTargetView != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(nativeViewTag != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">nativeViewTag[</span><span class="s5">0</span><span class="s1">] = reactTargetView.getId()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">targetTag = getTouchTargetForView(reactTargetView</span><span class="s2">, </span><span class="s1">viewCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">viewCoords[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">targetTag</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Find touch event target view within the provided container given the coordinates provided via</span>
   <span class="s3">* {</span><span class="s4">@link </span><span class="s3">MotionEvent}.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventX the X screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">eventY the Y screen coordinate of the touch location</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">viewGroup the container view to traverse</span>
   <span class="s3">* </span><span class="s4">@param </span><span class="s3">viewCoords an out parameter that will return the X,Y value in the target view</span>
   <span class="s3">* </span><span class="s4">@return </span><span class="s3">If a target was found, returns a {</span><span class="s4">@link </span><span class="s3">Lis</span><span class="s1">&lt;</span><span class="s3">ViewTarget</span><span class="s1">&gt;</span><span class="s3">} containing the path through</span>
   <span class="s3">*     the view tree of all react tags and views that are a container for the touch target,</span>
   <span class="s3">*     ordered from target to root (last element)</span>
   <span class="s3">*/</span>
  <span class="s1">@SuppressLint(</span><span class="s6">&quot;ResourceType&quot;</span><span class="s1">)</span>
  <span class="s2">public static </span><span class="s1">List&lt;ViewTarget&gt; findTargetPathAndCoordinatesForTouch(</span>
      <span class="s2">float </span><span class="s1">eventX</span><span class="s2">, float </span><span class="s1">eventY</span><span class="s2">, </span><span class="s1">ViewGroup viewGroup</span><span class="s2">, float</span><span class="s1">[] viewCoords) {</span>
    <span class="s1">UiThreadUtil.assertOnUiThread()</span><span class="s2">;</span>

    <span class="s0">// Store eventCoords in array so that they are modified to be relative to the targetView found.</span>
    <span class="s1">viewCoords[</span><span class="s5">0</span><span class="s1">] = eventX</span><span class="s2">;</span>
    <span class="s1">viewCoords[</span><span class="s5">1</span><span class="s1">] = eventY</span><span class="s2">;</span>

    <span class="s1">List&lt;ViewTarget&gt; pathAccumulator = </span><span class="s2">new </span><span class="s1">ArrayList&lt;&gt;()</span><span class="s2">;</span>
    <span class="s1">View targetView = findTouchTargetViewWithPointerEvents(viewCoords</span><span class="s2">, </span><span class="s1">viewGroup</span><span class="s2">, </span><span class="s1">pathAccumulator)</span><span class="s2">;</span>

    <span class="s2">if </span><span class="s1">(targetView != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">View reactTargetView = targetView</span><span class="s2">;</span>
      <span class="s2">int </span><span class="s1">firstReactAncestor = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s0">// Same logic as findClosestReactAncestor but also track the index</span>
      <span class="s2">while </span><span class="s1">(reactTargetView != </span><span class="s2">null </span><span class="s1">&amp;&amp; reactTargetView.getId() &lt;= </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">reactTargetView = (View) reactTargetView.getParent()</span><span class="s2">;</span>
        <span class="s1">firstReactAncestor++</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(firstReactAncestor &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s0">// Drop non-React views from the path trace</span>
        <span class="s1">pathAccumulator = pathAccumulator.subList(firstReactAncestor</span><span class="s2">, </span><span class="s1">pathAccumulator.size())</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s2">int </span><span class="s1">targetTag = getTouchTargetForView(reactTargetView</span><span class="s2">, </span><span class="s1">viewCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">viewCoords[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(targetTag != reactTargetView.getId()) {</span>
        <span class="s1">pathAccumulator.add(</span><span class="s5">0</span><span class="s2">, new </span><span class="s1">ViewTarget(targetTag</span><span class="s2">, </span><span class="s1">(View) </span><span class="s2">null</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">pathAccumulator</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">@SuppressLint(</span><span class="s6">&quot;ResourceType&quot;</span><span class="s1">)</span>
  <span class="s2">private static </span><span class="s1">View findClosestReactAncestor(View view) {</span>
    <span class="s2">while </span><span class="s1">(view != </span><span class="s2">null </span><span class="s1">&amp;&amp; view.getId() &lt;= </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">view = (View) view.getParent()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/** Types of allowed return values from {</span><span class="s4">@link </span><span class="s3">#findTouchTargetView}. */</span>
  <span class="s2">private enum </span><span class="s1">TouchTargetReturnType {</span>
    <span class="s3">/** Allow returning the view passed in through the parameters. */</span>
    <span class="s1">SELF</span><span class="s2">,</span>
    <span class="s3">/** Allow returning children of the view passed in through parameters. */</span>
    <span class="s1">CHILD</span><span class="s2">,</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns the touch target View that is either viewGroup or one if its descendants. This is a</span>
   <span class="s3">* recursive DFS since view the entire tree must be parsed until the target is found. If the</span>
   <span class="s3">* search does not backtrack, it is possible to follow a branch that cannot be a target (because</span>
   <span class="s3">* of pointerEvents). For example, if both C and E can be the target of an event: A</span>
   <span class="s3">* (pointerEvents: auto) - B (pointerEvents: box-none) - C (pointerEvents: none) \ D</span>
   <span class="s3">* (pointerEvents: auto) - E (pointerEvents: auto) If the search goes down the first branch, it</span>
   <span class="s3">* would return A as the target, which is incorrect. NB: This modifies the eventCoords to always</span>
   <span class="s3">* be relative to the current viewGroup. When the method returns, it will contain the eventCoords</span>
   <span class="s3">* relative to the targetView found.</span>
   <span class="s3">*/</span>
  <span class="s2">private static </span><span class="s1">View findTouchTargetView(</span>
      <span class="s2">float</span><span class="s1">[] eventCoords</span><span class="s2">,</span>
      <span class="s1">View view</span><span class="s2">,</span>
      <span class="s1">EnumSet&lt;TouchTargetReturnType&gt; allowReturnTouchTargetTypes</span><span class="s2">,</span>
      <span class="s1">List&lt;ViewTarget&gt; pathAccumulator) {</span>
    <span class="s0">// We prefer returning a child, so we check for a child that can handle the touch first</span>
    <span class="s2">if </span><span class="s1">(allowReturnTouchTargetTypes.contains(TouchTargetReturnType.CHILD)</span>
        <span class="s1">&amp;&amp; view </span><span class="s2">instanceof </span><span class="s1">ViewGroup) {</span>
      <span class="s1">ViewGroup viewGroup = (ViewGroup) view</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!isTouchPointInView(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">view)) {</span>
        <span class="s0">// We don't allow touches on views that are outside the bounds of an `overflow: hidden` and</span>
        <span class="s0">// `overflow: scroll` View.</span>
        <span class="s2">if </span><span class="s1">(view </span><span class="s2">instanceof </span><span class="s1">ReactOverflowViewWithInset) {</span>
          <span class="s0">// If the touch point is outside of the overflowinset for the view, we can safely ignore</span>
          <span class="s0">// it.</span>
          <span class="s2">if </span><span class="s1">(ViewUtil.getUIManagerType(view.getId()) == FABRIC</span>
              <span class="s1">&amp;&amp; !isTouchPointInViewWithOverflowInset(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">view)) {</span>
            <span class="s2">return null;</span>
          <span class="s1">}</span>

          <span class="s1">@Nullable String overflow = ((ReactOverflowViewWithInset) view).getOverflow()</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(ViewProps.HIDDEN.equals(overflow) || ViewProps.SCROLL.equals(overflow)) {</span>
            <span class="s2">return null;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">// We don't allow touches on views that are outside the bounds and has clipChildren set to</span>
        <span class="s0">// true.</span>
        <span class="s2">if </span><span class="s1">(viewGroup.getClipChildren()) {</span>
          <span class="s2">return null;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">int </span><span class="s1">childrenCount = viewGroup.getChildCount()</span><span class="s2">;</span>
      <span class="s0">// Consider z-index when determining the touch target.</span>
      <span class="s1">ReactZIndexedViewGroup zIndexedViewGroup =</span>
          <span class="s1">viewGroup </span><span class="s2">instanceof </span><span class="s1">ReactZIndexedViewGroup ? (ReactZIndexedViewGroup) viewGroup : </span><span class="s2">null;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = childrenCount - </span><span class="s5">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s5">0</span><span class="s2">; </span><span class="s1">i--) {</span>
        <span class="s2">int </span><span class="s1">childIndex =</span>
            <span class="s1">zIndexedViewGroup != </span><span class="s2">null </span><span class="s1">? zIndexedViewGroup.getZIndexMappedChildIndex(i) : i</span><span class="s2">;</span>
        <span class="s1">View child = viewGroup.getChildAt(childIndex)</span><span class="s2">;</span>
        <span class="s1">PointF childPoint = mTempPoint</span><span class="s2">;</span>
        <span class="s1">getChildPoint(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">viewGroup</span><span class="s2">, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">childPoint)</span><span class="s2">;</span>
        <span class="s0">// The childPoint value will contain the view coordinates relative to the child.</span>
        <span class="s0">// We need to store the existing X,Y for the viewGroup away as it is possible this child</span>
        <span class="s0">// will not actually be the target and so we restore them if not</span>
        <span class="s2">float </span><span class="s1">restoreX = eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s2">float </span><span class="s1">restoreY = eventCoords[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">eventCoords[</span><span class="s5">0</span><span class="s1">] = childPoint.x</span><span class="s2">;</span>
        <span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">] = childPoint.y</span><span class="s2">;</span>
        <span class="s1">View targetView = findTouchTargetViewWithPointerEvents(eventCoords</span><span class="s2">, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">pathAccumulator)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(targetView != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">return </span><span class="s1">targetView</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">eventCoords[</span><span class="s5">0</span><span class="s1">] = restoreX</span><span class="s2">;</span>
        <span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">] = restoreY</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// Check if parent can handle the touch after the children</span>
    <span class="s2">if </span><span class="s1">(allowReturnTouchTargetTypes.contains(TouchTargetReturnType.SELF)</span>
        <span class="s1">&amp;&amp; isTouchPointInView(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">view)) {</span>
      <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">return null;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Checks whether a touch at {</span><span class="s4">@code </span><span class="s3">x} and {</span><span class="s4">@code </span><span class="s3">y} are within the bounds of the View. Both</span>
   <span class="s3">* {</span><span class="s4">@code </span><span class="s3">x} and {</span><span class="s4">@code </span><span class="s3">y} must be relative to the top-left corner of the view.</span>
   <span class="s3">*/</span>
  <span class="s2">private static boolean </span><span class="s1">isTouchPointInView(</span><span class="s2">float </span><span class="s1">x</span><span class="s2">, float </span><span class="s1">y</span><span class="s2">, </span><span class="s1">View view) {</span>
    <span class="s2">if </span><span class="s1">(view </span><span class="s2">instanceof </span><span class="s1">ReactHitSlopView &amp;&amp; ((ReactHitSlopView) view).getHitSlopRect() != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">Rect hitSlopRect = ((ReactHitSlopView) view).getHitSlopRect()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">((x &gt;= -hitSlopRect.left &amp;&amp; x &lt; (view.getWidth()) + hitSlopRect.right)</span>
          <span class="s1">&amp;&amp; (y &gt;= -hitSlopRect.top &amp;&amp; y &lt; (view.getHeight()) + hitSlopRect.bottom)) {</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>

      <span class="s2">return false;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">((x &gt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; x &lt; (view.getWidth())) &amp;&amp; (y &gt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; y &lt; (view.getHeight()))) {</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>

      <span class="s2">return false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private static boolean </span><span class="s1">isTouchPointInViewWithOverflowInset(</span><span class="s2">float </span><span class="s1">x</span><span class="s2">, float </span><span class="s1">y</span><span class="s2">, </span><span class="s1">View view) {</span>
    <span class="s2">if </span><span class="s1">(!(view </span><span class="s2">instanceof </span><span class="s1">ReactOverflowViewWithInset)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>

    <span class="s2">final </span><span class="s1">Rect overflowInset = ((ReactOverflowViewWithInset) view).getOverflowInset()</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">(x &gt;= overflowInset.left &amp;&amp; x &lt; view.getWidth() - overflowInset.right)</span>
        <span class="s1">&amp;&amp; (y &gt;= overflowInset.top &amp;&amp; y &lt; view.getHeight() - overflowInset.bottom)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns the coordinates of a touch in the child View. It is transform aware and will invert the</span>
   <span class="s3">* transform Matrix to find the true local points This code is taken from {</span><span class="s4">@link</span>
   <span class="s3">* ViewGroup#isTransformedTouchPointInView()}</span>
   <span class="s3">*/</span>
  <span class="s2">private static void </span><span class="s1">getChildPoint(</span>
      <span class="s2">float </span><span class="s1">x</span><span class="s2">, float </span><span class="s1">y</span><span class="s2">, </span><span class="s1">ViewGroup parent</span><span class="s2">, </span><span class="s1">View child</span><span class="s2">, </span><span class="s1">PointF outLocalPoint) {</span>
    <span class="s2">float </span><span class="s1">localX = x + parent.getScrollX() - child.getLeft()</span><span class="s2">;</span>
    <span class="s2">float </span><span class="s1">localY = y + parent.getScrollY() - child.getTop()</span><span class="s2">;</span>
    <span class="s1">Matrix matrix = child.getMatrix()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!matrix.isIdentity()) {</span>
      <span class="s2">float</span><span class="s1">[] localXY = mMatrixTransformCoords</span><span class="s2">;</span>
      <span class="s1">localXY[</span><span class="s5">0</span><span class="s1">] = localX</span><span class="s2">;</span>
      <span class="s1">localXY[</span><span class="s5">1</span><span class="s1">] = localY</span><span class="s2">;</span>
      <span class="s1">Matrix inverseMatrix = mInverseMatrix</span><span class="s2">;</span>
      <span class="s1">matrix.invert(inverseMatrix)</span><span class="s2">;</span>
      <span class="s1">inverseMatrix.mapPoints(localXY)</span><span class="s2">;</span>
      <span class="s1">localX = localXY[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s1">localY = localXY[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">outLocalPoint.set(localX</span><span class="s2">, </span><span class="s1">localY)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Returns the touch target View of the event given, or null if neither the given View nor any of</span>
   <span class="s3">* its descendants are the touch target.</span>
   <span class="s3">*/</span>
  <span class="s2">private static </span><span class="s1">@Nullable View findTouchTargetViewWithPointerEvents(</span>
      <span class="s2">float </span><span class="s1">eventCoords[]</span><span class="s2">, </span><span class="s1">View view</span><span class="s2">, </span><span class="s1">@Nullable List&lt;ViewTarget&gt; pathAccumulator) {</span>
    <span class="s1">PointerEvents pointerEvents =</span>
        <span class="s1">view </span><span class="s2">instanceof </span><span class="s1">ReactPointerEventsView</span>
            <span class="s1">? ((ReactPointerEventsView) view).getPointerEvents()</span>
            <span class="s1">: PointerEvents.AUTO</span><span class="s2">;</span>

    <span class="s0">// Views that are disabled should never be the target of pointer events. However, their children</span>
    <span class="s0">// can be because some views (SwipeRefreshLayout) use enabled but still have children that can</span>
    <span class="s0">// be valid targets.</span>
    <span class="s2">if </span><span class="s1">(!view.isEnabled()) {</span>
      <span class="s2">if </span><span class="s1">(pointerEvents == PointerEvents.AUTO) {</span>
        <span class="s1">pointerEvents = PointerEvents.BOX_NONE</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pointerEvents == PointerEvents.BOX_ONLY) {</span>
        <span class="s1">pointerEvents = PointerEvents.NONE</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(pointerEvents == PointerEvents.NONE) {</span>
      <span class="s0">// This view and its children can't be the target</span>
      <span class="s2">return null;</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pointerEvents == PointerEvents.BOX_ONLY) {</span>
      <span class="s0">// This view may be the target, its children don't matter</span>
      <span class="s1">View targetView =</span>
          <span class="s1">findTouchTargetView(</span>
              <span class="s1">eventCoords</span><span class="s2">, </span><span class="s1">view</span><span class="s2">, </span><span class="s1">EnumSet.of(TouchTargetReturnType.SELF)</span><span class="s2">, </span><span class="s1">pathAccumulator)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(targetView != </span><span class="s2">null </span><span class="s1">&amp;&amp; pathAccumulator != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">pathAccumulator.add(</span><span class="s2">new </span><span class="s1">ViewTarget(view.getId()</span><span class="s2">, </span><span class="s1">view))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">targetView</span><span class="s2">;</span>

    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pointerEvents == PointerEvents.BOX_NONE) {</span>
      <span class="s0">// This view can't be the target, but its children might.</span>
      <span class="s1">View targetView =</span>
          <span class="s1">findTouchTargetView(</span>
              <span class="s1">eventCoords</span><span class="s2">, </span><span class="s1">view</span><span class="s2">, </span><span class="s1">EnumSet.of(TouchTargetReturnType.CHILD)</span><span class="s2">, </span><span class="s1">pathAccumulator)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(targetView != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(pathAccumulator != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">pathAccumulator.add(</span><span class="s2">new </span><span class="s1">ViewTarget(view.getId()</span><span class="s2">, </span><span class="s1">view))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">targetView</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">// PointerEvents.BOX_NONE means that this react element cannot receive pointer events.</span>
      <span class="s0">// However, there might be virtual children that can receive pointer events, in which case</span>
      <span class="s0">// we still want to return this View and dispatch a pointer event to the virtual element.</span>
      <span class="s0">// Note that this currently only applies to Nodes/FlatViewGroup as it's the only class that</span>
      <span class="s0">// is both a ViewGroup and ReactCompoundView (ReactTextView is a ReactCompoundView but not a</span>
      <span class="s0">// ViewGroup).</span>
      <span class="s2">if </span><span class="s1">(view </span><span class="s2">instanceof </span><span class="s1">ReactCompoundView</span>
          <span class="s1">&amp;&amp; isTouchPointInView(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">view)) {</span>
        <span class="s2">int </span><span class="s1">reactTag = ((ReactCompoundView) view).reactTagForTouch(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">;</span>
        <span class="s0">// make sure we exclude the View itself because of the PointerEvents.BOX_NONE</span>
        <span class="s2">if </span><span class="s1">(reactTag != view.getId()) {</span>
          <span class="s2">if </span><span class="s1">(pathAccumulator != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">pathAccumulator.add(</span><span class="s2">new </span><span class="s1">ViewTarget(view.getId()</span><span class="s2">, </span><span class="s1">view))</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return null;</span>

    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(pointerEvents != PointerEvents.AUTO) {</span>
        <span class="s1">FLog.w(ReactConstants.TAG</span><span class="s2">, </span><span class="s6">&quot;Unknown pointer event type: &quot; </span><span class="s1">+ pointerEvents.toString())</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s0">// Either this view or one of its children is the target</span>
      <span class="s2">if </span><span class="s1">(view </span><span class="s2">instanceof </span><span class="s1">ReactCompoundViewGroup</span>
          <span class="s1">&amp;&amp; isTouchPointInView(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">view)</span>
          <span class="s1">&amp;&amp; ((ReactCompoundViewGroup) view).interceptsTouchEvent(eventCoords[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventCoords[</span><span class="s5">1</span><span class="s1">])) {</span>
        <span class="s2">if </span><span class="s1">(pathAccumulator != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">pathAccumulator.add(</span><span class="s2">new </span><span class="s1">ViewTarget(view.getId()</span><span class="s2">, </span><span class="s1">view))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">view</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">View result =</span>
          <span class="s1">findTouchTargetView(</span>
              <span class="s1">eventCoords</span><span class="s2">,</span>
              <span class="s1">view</span><span class="s2">,</span>
              <span class="s1">EnumSet.of(TouchTargetReturnType.SELF</span><span class="s2">, </span><span class="s1">TouchTargetReturnType.CHILD)</span><span class="s2">,</span>
              <span class="s1">pathAccumulator)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(result != </span><span class="s2">null </span><span class="s1">&amp;&amp; pathAccumulator != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">pathAccumulator.add(</span><span class="s2">new </span><span class="s1">ViewTarget(view.getId()</span><span class="s2">, </span><span class="s1">view))</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">private static int </span><span class="s1">getTouchTargetForView(View targetView</span><span class="s2">, float </span><span class="s1">viewX</span><span class="s2">, float </span><span class="s1">viewY) {</span>
    <span class="s2">if </span><span class="s1">(targetView </span><span class="s2">instanceof </span><span class="s1">ReactCompoundView) {</span>
      <span class="s0">// Use coordinates relative to the view, which have been already computed by</span>
      <span class="s0">// {@link #findTouchTargetView()}.</span>
      <span class="s2">return </span><span class="s1">((ReactCompoundView) targetView).reactTagForTouch(viewX</span><span class="s2">, </span><span class="s1">viewY)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">targetView.getId()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s2">public static class </span><span class="s1">ViewTarget {</span>
    <span class="s2">private final int </span><span class="s1">mViewId</span><span class="s2">;</span>
    <span class="s2">private final </span><span class="s1">@Nullable View mView</span><span class="s2">;</span>

    <span class="s2">private </span><span class="s1">ViewTarget(</span><span class="s2">int </span><span class="s1">viewId</span><span class="s2">, </span><span class="s1">@Nullable View view) {</span>
      <span class="s1">mViewId = viewId</span><span class="s2">;</span>
      <span class="s1">mView = view</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s2">public int </span><span class="s1">getViewId() {</span>
      <span class="s2">return </span><span class="s1">mViewId</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Nullable</span>
    <span class="s2">public </span><span class="s1">View getView() {</span>
      <span class="s2">return </span><span class="s1">mView</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public boolean </span><span class="s1">equals(Object o) {</span>
      <span class="s0">// If the object is compared with itself then return true</span>
      <span class="s2">if </span><span class="s1">(o == </span><span class="s2">this</span><span class="s1">) {</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>

      <span class="s0">// Check if o is an instance of ViewTarget. Note that &quot;null instanceof ViewTarget&quot; also</span>
      <span class="s0">// returns false.</span>
      <span class="s2">if </span><span class="s1">(!(o </span><span class="s2">instanceof </span><span class="s1">ViewTarget)) {</span>
        <span class="s2">return false;</span>
      <span class="s1">}</span>

      <span class="s1">ViewTarget other = (ViewTarget) o</span><span class="s2">;</span>
      <span class="s0">// We only need to compare view id, as we assume the same view id will always map to the same</span>
      <span class="s0">// view. TargetView is not mutable so this should be safe.</span>
      <span class="s2">return </span><span class="s1">other.getViewId() == mViewId</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">@Override</span>
    <span class="s2">public int </span><span class="s1">hashCode() {</span>
      <span class="s2">return </span><span class="s1">Objects.hashCode(mViewId)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
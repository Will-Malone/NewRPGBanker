<html>
<head>
<title>RCTTextInputComponentView.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTTextInputComponentView.mm</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTTextInputComponentView.h&quot;</span>

<span class="s2">#import </span><span class="s3">&lt;react/renderer/components/iostextinput/TextInputComponentDescriptor.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;react/renderer/textlayoutmanager/RCTAttributedTextUtils.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;react/renderer/textlayoutmanager/TextLayoutManager.h&gt;</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTBackedTextInputViewProtocol.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUITextField.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUITextView.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUtils.h&gt;</span>

<span class="s2">#import </span><span class="s3">&quot;RCTConversions.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTTextInputNativeCommands.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTTextInputUtils.h&quot;</span>

<span class="s2">#import </span><span class="s3">&quot;RCTFabricComponentsPlugins.h&quot;</span>

<span class="s4">using namespace </span><span class="s1">facebook::react</span><span class="s4">;</span>

<span class="s4">@interface </span><span class="s1">RCTTextInputComponentView () &lt;RCTBackedTextInputDelegate</span><span class="s4">, </span><span class="s1">RCTTextInputViewProtocol&gt;</span>
<span class="s4">@end</span>

<span class="s4">@implementation </span><span class="s1">RCTTextInputComponentView {</span>
  <span class="s1">TextInputShadowNode::ConcreteState::Shared _state</span><span class="s4">;</span>
  <span class="s1">UIView&lt;RCTBackedTextInputViewProtocol&gt; *_backedTextInputView</span><span class="s4">;</span>
  <span class="s1">NSUInteger _mostRecentEventCount</span><span class="s4">;</span>
  <span class="s1">NSAttributedString *_lastStringStateWasUpdatedWith</span><span class="s4">;</span>

  <span class="s0">/* 
   * UIKit uses either UITextField or UITextView as its UIKit element for &lt;TextInput&gt;. UITextField is for single line 
   * entry, UITextView is for multiline entry. There is a problem with order of events when user types a character. In 
   * UITextField (single line text entry), typing a character first triggers `onChange` event and then 
   * onSelectionChange. In UITextView (multi line text entry), typing a character first triggers `onSelectionChange` and 
   * then onChange. JavaScript depends on `onChange` to be called before `onSelectionChange`. This flag keeps state so 
   * if UITextView is backing text input view, inside `-[RCTTextInputComponentView textInputDidChangeSelection]` we make 
   * sure to call `onChange` before `onSelectionChange` and ignore next `-[RCTTextInputComponentView 
   * textInputDidChange]` call. 
   */</span>
  <span class="s1">BOOL _ignoreNextTextInputCall</span><span class="s4">;</span>

  <span class="s0">/* 
   * A flag that when set to true, `_mostRecentEventCount` won't be incremented when `[self _updateState]` 
   * and delegate methods `textInputDidChange` and `textInputDidChangeSelection` will exit early. 
   * 
   * Setting `_backedTextInputView.attributedText` triggers delegate methods `textInputDidChange` and 
   * `textInputDidChangeSelection` for multiline text input only. 
   * In multiline text input this is undesirable as we don't want to be sending events for changes that JS triggered. 
   */</span>
  <span class="s1">BOOL _comingFromJS</span><span class="s4">;</span>
  <span class="s1">BOOL _didMoveToWindow</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - UIView overrides</span>

<span class="s1">- (instancetype)initWithFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self = [super initWithFrame:frame]) {</span>
    <span class="s4">static const auto </span><span class="s1">defaultProps = std::make_shared&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;()</span><span class="s4">;</span>
    <span class="s1">_props = defaultProps</span><span class="s4">;</span>
    <span class="s4">auto </span><span class="s1">&amp;props = *defaultProps</span><span class="s4">;</span>

    <span class="s1">_backedTextInputView = props.traits.multiline ? [RCTUITextView </span><span class="s4">new</span><span class="s1">] : [RCTUITextField </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">_backedTextInputView.textInputDelegate = self</span><span class="s4">;</span>
    <span class="s1">_ignoreNextTextInputCall = NO</span><span class="s4">;</span>
    <span class="s1">_comingFromJS = NO</span><span class="s4">;</span>
    <span class="s1">_didMoveToWindow = NO</span><span class="s4">;</span>
    <span class="s1">[self addSubview:_backedTextInputView]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)didMoveToWindow</span>
<span class="s1">{</span>
  <span class="s1">[super didMoveToWindow]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(self.window &amp;&amp; !_didMoveToWindow) {</span>
    <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(props.autoFocus) {</span>
      <span class="s1">[_backedTextInputView becomeFirstResponder]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">_didMoveToWindow = YES</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">[self _restoreTextSelection]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTViewComponentView overrides</span>

<span class="s1">- (NSObject *)accessibilityElement</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">_backedTextInputView</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTComponentViewProtocol</span>

<span class="s1">+ (ComponentDescriptorProvider)componentDescriptorProvider</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">concreteComponentDescriptorProvider&lt;TextInputComponentDescriptor&gt;()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateProps:(Props::Shared </span><span class="s4">const </span><span class="s1">&amp;)props oldProps:(Props::Shared </span><span class="s4">const </span><span class="s1">&amp;)oldProps</span>
<span class="s1">{</span>
  <span class="s4">auto const </span><span class="s1">&amp;oldTextInputProps = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>
  <span class="s4">auto const </span><span class="s1">&amp;newTextInputProps = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(props)</span><span class="s4">;</span>

  <span class="s0">// Traits:</span>
  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.multiline != oldTextInputProps.traits.multiline) {</span>
    <span class="s1">[self _setMultiline:newTextInputProps.traits.multiline]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.autocapitalizationType != oldTextInputProps.traits.autocapitalizationType) {</span>
    <span class="s1">_backedTextInputView.autocapitalizationType =</span>
        <span class="s1">RCTUITextAutocapitalizationTypeFromAutocapitalizationType(newTextInputProps.traits.autocapitalizationType)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.autoCorrect != oldTextInputProps.traits.autoCorrect) {</span>
    <span class="s1">_backedTextInputView.autocorrectionType =</span>
        <span class="s1">RCTUITextAutocorrectionTypeFromOptionalBool(newTextInputProps.traits.autoCorrect)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.contextMenuHidden != oldTextInputProps.traits.contextMenuHidden) {</span>
    <span class="s1">_backedTextInputView.contextMenuHidden = newTextInputProps.traits.contextMenuHidden</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.editable != oldTextInputProps.traits.editable) {</span>
    <span class="s1">_backedTextInputView.editable = newTextInputProps.traits.editable</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.enablesReturnKeyAutomatically !=</span>
      <span class="s1">oldTextInputProps.traits.enablesReturnKeyAutomatically) {</span>
    <span class="s1">_backedTextInputView.enablesReturnKeyAutomatically = newTextInputProps.traits.enablesReturnKeyAutomatically</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.keyboardAppearance != oldTextInputProps.traits.keyboardAppearance) {</span>
    <span class="s1">_backedTextInputView.keyboardAppearance =</span>
        <span class="s1">RCTUIKeyboardAppearanceFromKeyboardAppearance(newTextInputProps.traits.keyboardAppearance)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.spellCheck != oldTextInputProps.traits.spellCheck) {</span>
    <span class="s1">_backedTextInputView.spellCheckingType =</span>
        <span class="s1">RCTUITextSpellCheckingTypeFromOptionalBool(newTextInputProps.traits.spellCheck)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.caretHidden != oldTextInputProps.traits.caretHidden) {</span>
    <span class="s1">_backedTextInputView.caretHidden = newTextInputProps.traits.caretHidden</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.clearButtonMode != oldTextInputProps.traits.clearButtonMode) {</span>
    <span class="s1">_backedTextInputView.clearButtonMode =</span>
        <span class="s1">RCTUITextFieldViewModeFromTextInputAccessoryVisibilityMode(newTextInputProps.traits.clearButtonMode)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.scrollEnabled != oldTextInputProps.traits.scrollEnabled) {</span>
    <span class="s1">_backedTextInputView.scrollEnabled = newTextInputProps.traits.scrollEnabled</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.secureTextEntry != oldTextInputProps.traits.secureTextEntry) {</span>
    <span class="s1">_backedTextInputView.secureTextEntry = newTextInputProps.traits.secureTextEntry</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.keyboardType != oldTextInputProps.traits.keyboardType) {</span>
    <span class="s1">_backedTextInputView.keyboardType = RCTUIKeyboardTypeFromKeyboardType(newTextInputProps.traits.keyboardType)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.returnKeyType != oldTextInputProps.traits.returnKeyType) {</span>
    <span class="s1">_backedTextInputView.returnKeyType = RCTUIReturnKeyTypeFromReturnKeyType(newTextInputProps.traits.returnKeyType)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.textContentType != oldTextInputProps.traits.textContentType) {</span>
    <span class="s1">_backedTextInputView.textContentType = RCTUITextContentTypeFromString(newTextInputProps.traits.textContentType)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.traits.passwordRules != oldTextInputProps.traits.passwordRules) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">12.0</span><span class="s4">, </span><span class="s1">*)) {</span>
      <span class="s1">_backedTextInputView.passwordRules =</span>
          <span class="s1">RCTUITextInputPasswordRulesFromString(newTextInputProps.traits.passwordRules)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Traits `blurOnSubmit`, `clearTextOnFocus`, and `selectTextOnFocus` were omitted intentionally here</span>
  <span class="s0">// because they are being checked on-demand.</span>

  <span class="s0">// Other props:</span>
  <span class="s4">if </span><span class="s1">(newTextInputProps.placeholder != oldTextInputProps.placeholder) {</span>
    <span class="s1">_backedTextInputView.placeholder = RCTNSStringFromString(newTextInputProps.placeholder)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.placeholderTextColor != oldTextInputProps.placeholderTextColor) {</span>
    <span class="s1">_backedTextInputView.placeholderColor = RCTUIColorFromSharedColor(newTextInputProps.placeholderTextColor)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.textAttributes != oldTextInputProps.textAttributes) {</span>
    <span class="s1">_backedTextInputView.defaultTextAttributes =</span>
        <span class="s1">RCTNSTextAttributesFromTextAttributes(newTextInputProps.getEffectiveTextAttributes(RCTFontSizeMultiplier()))</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.selectionColor != oldTextInputProps.selectionColor) {</span>
    <span class="s1">_backedTextInputView.tintColor = RCTUIColorFromSharedColor(newTextInputProps.selectionColor)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(newTextInputProps.inputAccessoryViewID != oldTextInputProps.inputAccessoryViewID) {</span>
    <span class="s1">_backedTextInputView.inputAccessoryViewID = RCTNSStringFromString(newTextInputProps.inputAccessoryViewID)</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">[super updateProps:props oldProps:oldProps]</span><span class="s4">;</span>

  <span class="s1">[self setDefaultInputAccessoryView]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateState:(State::Shared </span><span class="s4">const </span><span class="s1">&amp;)state oldState:(State::Shared </span><span class="s4">const </span><span class="s1">&amp;)oldState</span>
<span class="s1">{</span>
  <span class="s1">_state = std::static_pointer_cast&lt;TextInputShadowNode::ConcreteState </span><span class="s4">const</span><span class="s1">&gt;(state)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!_state) {</span>
    <span class="s1">assert(</span><span class="s4">false </span><span class="s1">&amp;&amp; </span><span class="s3">&quot;State is `null` for &lt;TextInput&gt; component.&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">_backedTextInputView.attributedText = nil</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">auto </span><span class="s1">data = _state-&gt;getData()</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!oldState) {</span>
    <span class="s1">_mostRecentEventCount = _state-&gt;getData().mostRecentEventCount</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_mostRecentEventCount == _state-&gt;getData().mostRecentEventCount) {</span>
    <span class="s1">_comingFromJS = YES</span><span class="s4">;</span>
    <span class="s1">[self _setAttributedString:RCTNSAttributedStringFromAttributedStringBox(data.attributedStringBox)]</span><span class="s4">;</span>
    <span class="s1">_comingFromJS = NO</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)updateLayoutMetrics:(LayoutMetrics </span><span class="s4">const </span><span class="s1">&amp;)layoutMetrics</span>
           <span class="s1">oldLayoutMetrics:(LayoutMetrics </span><span class="s4">const </span><span class="s1">&amp;)oldLayoutMetrics</span>
<span class="s1">{</span>
  <span class="s1">[super updateLayoutMetrics:layoutMetrics oldLayoutMetrics:oldLayoutMetrics]</span><span class="s4">;</span>

  <span class="s1">_backedTextInputView.frame =</span>
      <span class="s1">UIEdgeInsetsInsetRect(self.bounds</span><span class="s4">, </span><span class="s1">RCTUIEdgeInsetsFromEdgeInsets(layoutMetrics.borderWidth))</span><span class="s4">;</span>
  <span class="s1">_backedTextInputView.textContainerInset =</span>
      <span class="s1">RCTUIEdgeInsetsFromEdgeInsets(layoutMetrics.contentInsets - layoutMetrics.borderWidth)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_eventEmitter) {</span>
    <span class="s4">auto const </span><span class="s1">&amp;textInputEventEmitter = *std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)</span><span class="s4">;</span>
    <span class="s1">textInputEventEmitter.onContentSizeChange([self _textInputMetrics])</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)prepareForRecycle</span>
<span class="s1">{</span>
  <span class="s1">[super prepareForRecycle]</span><span class="s4">;</span>
  <span class="s1">_state.reset()</span><span class="s4">;</span>
  <span class="s1">_backedTextInputView.attributedText = nil</span><span class="s4">;</span>
  <span class="s1">_mostRecentEventCount = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">_comingFromJS = NO</span><span class="s4">;</span>
  <span class="s1">_lastStringStateWasUpdatedWith = nil</span><span class="s4">;</span>
  <span class="s1">_ignoreNextTextInputCall = NO</span><span class="s4">;</span>
  <span class="s1">_didMoveToWindow = NO</span><span class="s4">;</span>
  <span class="s1">[_backedTextInputView resignFirstResponder]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTBackedTextInputDelegate</span>

<span class="s1">- (BOOL)textInputShouldBeginEditing</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidBeginEditing</span>
<span class="s1">{</span>
  <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(props.traits.clearTextOnFocus) {</span>
    <span class="s1">_backedTextInputView.attributedText = nil</span><span class="s4">;</span>
    <span class="s1">[self textInputDidChange]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.traits.selectTextOnFocus) {</span>
    <span class="s1">[_backedTextInputView selectAll:nil]</span><span class="s4">;</span>
    <span class="s1">[self textInputDidChangeSelection]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_eventEmitter) {</span>
    <span class="s1">std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)-&gt;onFocus([self _textInputMetrics])</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textInputShouldEndEditing</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidEndEditing</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_eventEmitter) {</span>
    <span class="s1">std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)-&gt;onEndEditing([self _textInputMetrics])</span><span class="s4">;</span>
    <span class="s1">std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)-&gt;onBlur([self _textInputMetrics])</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textInputShouldSubmitOnReturn</span>
<span class="s1">{</span>
  <span class="s4">const </span><span class="s1">SubmitBehavior submitBehavior = [self getSubmitBehavior]</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">BOOL shouldSubmit = submitBehavior == SubmitBehavior::Submit || submitBehavior == SubmitBehavior::BlurAndSubmit</span><span class="s4">;</span>
  <span class="s0">// We send `submit` event here, in `textInputShouldSubmitOnReturn`</span>
  <span class="s0">// (not in `textInputDidReturn)`, because of semantic of the event:</span>
  <span class="s0">// `onSubmitEditing` is called when &quot;Submit&quot; button</span>
  <span class="s0">// (the blue key on onscreen keyboard) did pressed</span>
  <span class="s0">// (no connection to any specific &quot;submitting&quot; process).</span>

  <span class="s4">if </span><span class="s1">(_eventEmitter &amp;&amp; shouldSubmit) {</span>
    <span class="s1">std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)-&gt;onSubmitEditing([self _textInputMetrics])</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">shouldSubmit</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textInputShouldReturn</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[self getSubmitBehavior] == SubmitBehavior::BlurAndSubmit</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidReturn</span>
<span class="s1">{</span>
  <span class="s0">// Does nothing.</span>
<span class="s1">}</span>

<span class="s1">- (NSString *)textInputShouldChangeText:(NSString *)text inRange:(NSRange)range</span>
<span class="s1">{</span>
  <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!_backedTextInputView.textWasPasted) {</span>
    <span class="s4">if </span><span class="s1">(_eventEmitter) {</span>
      <span class="s1">KeyPressMetrics keyPressMetrics</span><span class="s4">;</span>
      <span class="s1">keyPressMetrics.text = RCTStringFromNSString(text)</span><span class="s4">;</span>
      <span class="s1">keyPressMetrics.eventCount = _mostRecentEventCount</span><span class="s4">;</span>

      <span class="s4">auto const </span><span class="s1">&amp;textInputEventEmitter = *std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(props.onKeyPressSync) {</span>
        <span class="s1">textInputEventEmitter.onKeyPressSync(keyPressMetrics)</span><span class="s4">;</span>
      <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
        <span class="s1">textInputEventEmitter.onKeyPress(keyPressMetrics)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(props.maxLength) {</span>
    <span class="s1">NSInteger allowedLength = props.maxLength - _backedTextInputView.attributedText.string.length + range.length</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(allowedLength &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; text.length &gt; allowedLength) {</span>
      <span class="s0">// make sure unicode characters that are longer than 16 bits (such as emojis) are not cut off</span>
      <span class="s1">NSRange cutOffCharacterRange = [text rangeOfComposedCharacterSequenceAtIndex:allowedLength - </span><span class="s5">1</span><span class="s1">]</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(cutOffCharacterRange.location + cutOffCharacterRange.length &gt; allowedLength) {</span>
        <span class="s0">// the character at the length limit takes more than 16bits, truncation should end at the character before</span>
        <span class="s1">allowedLength = cutOffCharacterRange.location</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(allowedLength &lt;= </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">return </span><span class="s1">allowedLength &gt; text.length ? text : [text substringToIndex:allowedLength]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">text</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)textInputShouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidChange</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_comingFromJS) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_ignoreNextTextInputCall &amp;&amp; [_lastStringStateWasUpdatedWith isEqual:_backedTextInputView.attributedText]) {</span>
    <span class="s1">_ignoreNextTextInputCall = NO</span><span class="s4">;</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">[self _updateState]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_eventEmitter) {</span>
    <span class="s4">auto const </span><span class="s1">&amp;textInputEventEmitter = *std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)</span><span class="s4">;</span>
    <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(props.onChangeSync) {</span>
      <span class="s1">textInputEventEmitter.onChangeSync([self _textInputMetrics])</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">textInputEventEmitter.onChange([self _textInputMetrics])</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)textInputDidChangeSelection</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_comingFromJS) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(props.traits.multiline &amp;&amp; ![_lastStringStateWasUpdatedWith isEqual:_backedTextInputView.attributedText]) {</span>
    <span class="s1">[self textInputDidChange]</span><span class="s4">;</span>
    <span class="s1">_ignoreNextTextInputCall = YES</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_eventEmitter) {</span>
    <span class="s1">std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)-&gt;onSelectionChange([self _textInputMetrics])</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - RCTBackedTextInputDelegate (UIScrollViewDelegate)</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)scrollViewDidScroll:(UIScrollView *)scrollView</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_eventEmitter) {</span>
    <span class="s1">std::static_pointer_cast&lt;TextInputEventEmitter </span><span class="s4">const</span><span class="s1">&gt;(_eventEmitter)-&gt;onScroll([self _textInputMetrics])</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Native Commands</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)handleCommand:(</span><span class="s4">const </span><span class="s1">NSString *)commandName args:(</span><span class="s4">const </span><span class="s1">NSArray *)args</span>
<span class="s1">{</span>
  <span class="s1">RCTTextInputHandleCommand(self</span><span class="s4">, </span><span class="s1">commandName</span><span class="s4">, </span><span class="s1">args)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)focus</span>
<span class="s1">{</span>
  <span class="s1">[_backedTextInputView becomeFirstResponder]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)blur</span>
<span class="s1">{</span>
  <span class="s1">[_backedTextInputView resignFirstResponder]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setTextAndSelection:(NSInteger)eventCount</span>
                      <span class="s1">value:(NSString *</span><span class="s4">__nullable</span><span class="s1">)value</span>
                      <span class="s1">start:(NSInteger)start</span>
                        <span class="s4">end</span><span class="s1">:(NSInteger)</span><span class="s4">end</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(_mostRecentEventCount != eventCount) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">_comingFromJS = YES</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(value &amp;&amp; ![value isEqualToString:_backedTextInputView.attributedText.string]) {</span>
    <span class="s1">NSAttributedString *attributedString =</span>
        <span class="s1">[[NSAttributedString alloc] initWithString:value attributes:_backedTextInputView.defaultTextAttributes]</span><span class="s4">;</span>
    <span class="s1">[self _setAttributedString:attributedString]</span><span class="s4">;</span>
    <span class="s1">[self _updateState]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">UITextPosition *startPosition = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument</span>
                                                                      <span class="s1">offset:start]</span><span class="s4">;</span>
  <span class="s1">UITextPosition *endPosition = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument</span>
                                                                    <span class="s1">offset:</span><span class="s4">end</span><span class="s1">]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(startPosition &amp;&amp; endPosition) {</span>
    <span class="s1">UITextRange *range = [_backedTextInputView textRangeFromPosition:startPosition toPosition:endPosition]</span><span class="s4">;</span>
    <span class="s1">[_backedTextInputView setSelectedTextRange:range notifyDelegate:NO]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">_comingFromJS = NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Default input accessory view</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)setDefaultInputAccessoryView</span>
<span class="s1">{</span>
  <span class="s0">// InputAccessoryView component sets the inputAccessoryView when inputAccessoryViewID exists</span>
  <span class="s4">if </span><span class="s1">(_backedTextInputView.inputAccessoryViewID) {</span>
    <span class="s4">if </span><span class="s1">(_backedTextInputView.isFirstResponder) {</span>
      <span class="s1">[_backedTextInputView reloadInputViews]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s1">UIKeyboardType keyboardType = _backedTextInputView.keyboardType</span><span class="s4">;</span>

  <span class="s0">// These keyboard types (all are number pads) don't have a &quot;Done&quot; button by default,</span>
  <span class="s0">// so we create an `inputAccessoryView` with this button for them.</span>
  <span class="s1">BOOL shouldHaveInputAccessoryView =</span>
      <span class="s1">(keyboardType == UIKeyboardTypeNumberPad || keyboardType == UIKeyboardTypePhonePad ||</span>
       <span class="s1">keyboardType == UIKeyboardTypeDecimalPad || keyboardType == UIKeyboardTypeASCIICapableNumberPad) &amp;&amp;</span>
      <span class="s1">_backedTextInputView.returnKeyType == UIReturnKeyDone</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">((_backedTextInputView.inputAccessoryView != nil) == shouldHaveInputAccessoryView) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(shouldHaveInputAccessoryView) {</span>
    <span class="s1">UIToolbar *toolbarView = [UIToolbar </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
    <span class="s1">[toolbarView sizeToFit]</span><span class="s4">;</span>
    <span class="s1">UIBarButtonItem *flexibleSpace =</span>
        <span class="s1">[[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil]</span><span class="s4">;</span>
    <span class="s1">UIBarButtonItem *doneButton =</span>
        <span class="s1">[[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone</span>
                                                      <span class="s1">target:self</span>
                                                      <span class="s1">action:</span><span class="s4">@selector</span><span class="s1">(handleInputAccessoryDoneButton)]</span><span class="s4">;</span>
    <span class="s1">toolbarView.items = </span><span class="s4">@</span><span class="s1">[ flexibleSpace</span><span class="s4">, </span><span class="s1">doneButton ]</span><span class="s4">;</span>
    <span class="s1">_backedTextInputView.inputAccessoryView = toolbarView</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">_backedTextInputView.inputAccessoryView = nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_backedTextInputView.isFirstResponder) {</span>
    <span class="s1">[_backedTextInputView reloadInputViews]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)handleInputAccessoryDoneButton</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([self textInputShouldReturn]) {</span>
    <span class="s1">[_backedTextInputView endEditing:YES]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Other</span>

<span class="s1">- (TextInputMetrics)_textInputMetrics</span>
<span class="s1">{</span>
  <span class="s1">TextInputMetrics metrics</span><span class="s4">;</span>
  <span class="s1">metrics.text = RCTStringFromNSString(_backedTextInputView.attributedText.string)</span><span class="s4">;</span>
  <span class="s1">metrics.selectionRange = [self _selectionRange]</span><span class="s4">;</span>
  <span class="s1">metrics.eventCount = _mostRecentEventCount</span><span class="s4">;</span>

  <span class="s1">CGPoint contentOffset = _backedTextInputView.contentOffset</span><span class="s4">;</span>
  <span class="s1">metrics.contentOffset = {contentOffset.x</span><span class="s4">, </span><span class="s1">contentOffset.y}</span><span class="s4">;</span>

  <span class="s1">UIEdgeInsets contentInset = _backedTextInputView.contentInset</span><span class="s4">;</span>
  <span class="s1">metrics.contentInset = {contentInset.left</span><span class="s4">, </span><span class="s1">contentInset.top</span><span class="s4">, </span><span class="s1">contentInset.right</span><span class="s4">, </span><span class="s1">contentInset.bottom}</span><span class="s4">;</span>

  <span class="s1">CGSize contentSize = _backedTextInputView.contentSize</span><span class="s4">;</span>
  <span class="s1">metrics.contentSize = {contentSize.width</span><span class="s4">, </span><span class="s1">contentSize.height}</span><span class="s4">;</span>

  <span class="s1">CGSize layoutMeasurement = _backedTextInputView.bounds.size</span><span class="s4">;</span>
  <span class="s1">metrics.layoutMeasurement = {layoutMeasurement.width</span><span class="s4">, </span><span class="s1">layoutMeasurement.height}</span><span class="s4">;</span>

  <span class="s1">CGFloat zoomScale = _backedTextInputView.zoomScale</span><span class="s4">;</span>
  <span class="s1">metrics.zoomScale = zoomScale</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">metrics</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_updateState</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(!_state) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">NSAttributedString *attributedString = _backedTextInputView.attributedText</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">data = _state-&gt;getData()</span><span class="s4">;</span>
  <span class="s1">_lastStringStateWasUpdatedWith = attributedString</span><span class="s4">;</span>
  <span class="s1">data.attributedStringBox = RCTAttributedStringBoxFromNSAttributedString(attributedString)</span><span class="s4">;</span>
  <span class="s1">_mostRecentEventCount += _comingFromJS ? </span><span class="s5">0 </span><span class="s1">: </span><span class="s5">1</span><span class="s4">;</span>
  <span class="s1">data.mostRecentEventCount = _mostRecentEventCount</span><span class="s4">;</span>
  <span class="s1">_state-&gt;updateState(std::move(data))</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (AttributedString::Range)_selectionRange</span>
<span class="s1">{</span>
  <span class="s1">UITextRange *selectedTextRange = _backedTextInputView.selectedTextRange</span><span class="s4">;</span>
  <span class="s1">NSInteger start = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument</span>
                                                  <span class="s1">toPosition:selectedTextRange.start]</span><span class="s4">;</span>
  <span class="s1">NSInteger </span><span class="s4">end </span><span class="s1">= [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument</span>
                                                <span class="s1">toPosition:selectedTextRange.</span><span class="s4">end</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">AttributedString::Range{(</span><span class="s4">int</span><span class="s1">)start</span><span class="s4">, </span><span class="s1">(</span><span class="s4">int</span><span class="s1">)(</span><span class="s4">end </span><span class="s1">- start)}</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_restoreTextSelection</span>
<span class="s1">{</span>
  <span class="s4">auto const </span><span class="s1">selection = std::dynamic_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)-&gt;selection</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(!selection.has_value()) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s4">auto </span><span class="s1">start = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument</span>
                                                   <span class="s1">offset:selection-&gt;start]</span><span class="s4">;</span>
  <span class="s4">auto end </span><span class="s1">= [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument offset:selection-&gt;</span><span class="s4">end</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s4">auto </span><span class="s1">range = [_backedTextInputView textRangeFromPosition:start toPosition:</span><span class="s4">end</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">[_backedTextInputView setSelectedTextRange:range notifyDelegate:YES]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_setAttributedString:(NSAttributedString *)attributedString</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">([self _textOf:attributedString equals:_backedTextInputView.attributedText]) {</span>
    <span class="s4">return;</span>
  <span class="s1">}</span>
  <span class="s1">UITextRange *selectedRange = _backedTextInputView.selectedTextRange</span><span class="s4">;</span>
  <span class="s1">NSInteger oldTextLength = _backedTextInputView.attributedText.string.length</span><span class="s4">;</span>
  <span class="s1">_backedTextInputView.attributedText = attributedString</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(selectedRange.empty) {</span>
    <span class="s0">// Maintaining a cursor position relative to the end of the old text.</span>
    <span class="s1">NSInteger offsetStart = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument</span>
                                                          <span class="s1">toPosition:selectedRange.start]</span><span class="s4">;</span>
    <span class="s1">NSInteger offsetFromEnd = oldTextLength - offsetStart</span><span class="s4">;</span>
    <span class="s1">NSInteger newOffset = attributedString.string.length - offsetFromEnd</span><span class="s4">;</span>
    <span class="s1">UITextPosition *position = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument</span>
                                                                   <span class="s1">offset:newOffset]</span><span class="s4">;</span>
    <span class="s1">[_backedTextInputView setSelectedTextRange:[_backedTextInputView textRangeFromPosition:position toPosition:position]</span>
                                <span class="s1">notifyDelegate:YES]</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s1">[self _restoreTextSelection]</span><span class="s4">;</span>
  <span class="s1">_lastStringStateWasUpdatedWith = attributedString</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_setMultiline:(BOOL)multiline</span>
<span class="s1">{</span>
  <span class="s1">[_backedTextInputView removeFromSuperview]</span><span class="s4">;</span>
  <span class="s1">UIView&lt;RCTBackedTextInputViewProtocol&gt; *backedTextInputView = multiline ? [RCTUITextView </span><span class="s4">new</span><span class="s1">] : [RCTUITextField </span><span class="s4">new</span><span class="s1">]</span><span class="s4">;</span>
  <span class="s1">backedTextInputView.frame = _backedTextInputView.frame</span><span class="s4">;</span>
  <span class="s1">RCTCopyBackedTextInput(_backedTextInputView</span><span class="s4">, </span><span class="s1">backedTextInputView)</span><span class="s4">;</span>
  <span class="s1">_backedTextInputView = backedTextInputView</span><span class="s4">;</span>
  <span class="s1">[self addSubview:_backedTextInputView]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)_textOf:(NSAttributedString *)newText equals:(NSAttributedString *)oldText</span>
<span class="s1">{</span>
  <span class="s0">// When the dictation is running we can't update the attributed text on the backed up text view</span>
  <span class="s0">// because setting the attributed string will kill the dictation. This means that we can't impose</span>
  <span class="s0">// the settings on a dictation.</span>
  <span class="s0">// Similarly, when the user is in the middle of inputting some text in Japanese/Chinese, there will be styling on the</span>
  <span class="s0">// text that we should disregard. See</span>
  <span class="s0">// https://developer.apple.com/documentation/uikit/uitextinput/1614489-markedtextrange?language=objc for more info.</span>
  <span class="s0">// Also, updating the attributed text while inputting Korean language will break input mechanism.</span>
  <span class="s0">// If the user added an emoji, the system adds a font attribute for the emoji and stores the original font in</span>
  <span class="s0">// NSOriginalFont. Lastly, when entering a password, etc., there will be additional styling on the field as the native</span>
  <span class="s0">// text view handles showing the last character for a split second.</span>
  <span class="s1">__block BOOL fontHasBeenUpdatedBySystem = </span><span class="s4">false;</span>
  <span class="s1">[oldText enumerateAttribute:</span><span class="s4">@</span><span class="s3">&quot;NSOriginalFont&quot;</span>
                      <span class="s1">inRange:NSMakeRange(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">oldText.length)</span>
                      <span class="s1">options:</span><span class="s5">0</span>
                   <span class="s1">usingBlock:^(id value</span><span class="s4">, </span><span class="s1">NSRange range</span><span class="s4">, </span><span class="s1">BOOL *stop) {</span>
                     <span class="s4">if </span><span class="s1">(value) {</span>
                       <span class="s1">fontHasBeenUpdatedBySystem = </span><span class="s4">true;</span>
                     <span class="s1">}</span>
                   <span class="s1">}]</span><span class="s4">;</span>

  <span class="s1">BOOL shouldFallbackToBareTextComparison =</span>
      <span class="s1">[_backedTextInputView.textInputMode.primaryLanguage isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;dictation&quot;</span><span class="s1">] ||</span>
      <span class="s1">[_backedTextInputView.textInputMode.primaryLanguage isEqualToString:</span><span class="s4">@</span><span class="s3">&quot;ko-KR&quot;</span><span class="s1">] ||</span>
      <span class="s1">_backedTextInputView.markedTextRange || _backedTextInputView.isSecureTextEntry || fontHasBeenUpdatedBySystem</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(shouldFallbackToBareTextComparison) {</span>
    <span class="s4">return </span><span class="s1">([newText.string isEqualToString:oldText.string])</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s4">return </span><span class="s1">([newText isEqualToAttributedString:oldText])</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (SubmitBehavior)getSubmitBehavior</span>
<span class="s1">{</span>
  <span class="s4">auto const </span><span class="s1">&amp;props = *std::static_pointer_cast&lt;TextInputProps </span><span class="s4">const</span><span class="s1">&gt;(_props)</span><span class="s4">;</span>
  <span class="s4">const </span><span class="s1">SubmitBehavior submitBehaviorDefaultable = props.traits.submitBehavior</span><span class="s4">;</span>

  <span class="s0">// We should always have a non-default `submitBehavior`, but in case we don't, set it based on multiline.</span>
  <span class="s4">if </span><span class="s1">(submitBehaviorDefaultable == SubmitBehavior::Default) {</span>
    <span class="s4">return </span><span class="s1">props.traits.multiline ? SubmitBehavior::Newline : SubmitBehavior::BlurAndSubmit</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">submitBehaviorDefaultable</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>

<span class="s1">Class&lt;RCTComponentViewProtocol&gt; RCTTextInputCls(</span><span class="s4">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">RCTTextInputComponentView.</span><span class="s4">class;</span>
<span class="s1">}</span>
</pre>
</body>
</html>
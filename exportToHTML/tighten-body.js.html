<html>
<head>
<title>tighten-body.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tighten-body.js</font>
</center></td></tr></table>
<pre><span class="s0">/*********************************************************************** 
 
  A JavaScript tokenizer / parser / beautifier / compressor. 
  https://github.com/mishoo/UglifyJS2 
 
  -------------------------------- (C) --------------------------------- 
 
                           Author: Mihai Bazon 
                         &lt;mihai.bazon@gmail.com&gt; 
                       http://mihai.bazon.net/blog 
 
  Distributed under the BSD license: 
 
    Copyright 2012 (c) Mihai Bazon &lt;mihai.bazon@gmail.com&gt; 
 
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions 
    are met: 
 
        * Redistributions of source code must retain the above 
          copyright notice, this list of conditions and the following 
          disclaimer. 
 
        * Redistributions in binary form must reproduce the above 
          copyright notice, this list of conditions and the following 
          disclaimer in the documentation and/or other materials 
          provided with the distribution. 
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY 
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE 
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, 
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
    SUCH DAMAGE. 
 
 ***********************************************************************/</span>

<span class="s1">import {</span>
    <span class="s1">AST_Array,</span>
    <span class="s1">AST_Arrow,</span>
    <span class="s1">AST_Assign,</span>
    <span class="s1">AST_Await,</span>
    <span class="s1">AST_Binary,</span>
    <span class="s1">AST_Block,</span>
    <span class="s1">AST_BlockStatement,</span>
    <span class="s1">AST_Break,</span>
    <span class="s1">AST_Call,</span>
    <span class="s1">AST_Case,</span>
    <span class="s1">AST_Chain,</span>
    <span class="s1">AST_Class,</span>
    <span class="s1">AST_Conditional,</span>
    <span class="s1">AST_Const,</span>
    <span class="s1">AST_Constant,</span>
    <span class="s1">AST_Continue,</span>
    <span class="s1">AST_Debugger,</span>
    <span class="s1">AST_Default,</span>
    <span class="s1">AST_Definitions,</span>
    <span class="s1">AST_Defun,</span>
    <span class="s1">AST_Destructuring,</span>
    <span class="s1">AST_Directive,</span>
    <span class="s1">AST_Dot,</span>
    <span class="s1">AST_DWLoop,</span>
    <span class="s1">AST_EmptyStatement,</span>
    <span class="s1">AST_Exit,</span>
    <span class="s1">AST_Expansion,</span>
    <span class="s1">AST_Export,</span>
    <span class="s1">AST_For,</span>
    <span class="s1">AST_ForIn,</span>
    <span class="s1">AST_If,</span>
    <span class="s1">AST_Import,</span>
    <span class="s1">AST_IterationStatement,</span>
    <span class="s1">AST_Lambda,</span>
    <span class="s1">AST_Let,</span>
    <span class="s1">AST_LoopControl,</span>
    <span class="s1">AST_Node,</span>
    <span class="s1">AST_Number,</span>
    <span class="s1">AST_Object,</span>
    <span class="s1">AST_ObjectKeyVal,</span>
    <span class="s1">AST_PropAccess,</span>
    <span class="s1">AST_RegExp,</span>
    <span class="s1">AST_Return,</span>
    <span class="s1">AST_Scope,</span>
    <span class="s1">AST_Sequence,</span>
    <span class="s1">AST_SimpleStatement,</span>
    <span class="s1">AST_Sub,</span>
    <span class="s1">AST_Switch,</span>
    <span class="s1">AST_Symbol,</span>
    <span class="s1">AST_SymbolConst,</span>
    <span class="s1">AST_SymbolDeclaration,</span>
    <span class="s1">AST_SymbolDefun,</span>
    <span class="s1">AST_SymbolFunarg,</span>
    <span class="s1">AST_SymbolLambda,</span>
    <span class="s1">AST_SymbolLet,</span>
    <span class="s1">AST_SymbolRef,</span>
    <span class="s1">AST_SymbolVar,</span>
    <span class="s1">AST_This,</span>
    <span class="s1">AST_Try,</span>
    <span class="s1">AST_TryBlock,</span>
    <span class="s1">AST_Unary,</span>
    <span class="s1">AST_UnaryPostfix,</span>
    <span class="s1">AST_UnaryPrefix,</span>
    <span class="s1">AST_Undefined,</span>
    <span class="s1">AST_Var,</span>
    <span class="s1">AST_VarDef,</span>
    <span class="s1">AST_With,</span>
    <span class="s1">AST_Yield,</span>

    <span class="s1">TreeTransformer,</span>
    <span class="s1">TreeWalker,</span>
    <span class="s1">walk,</span>
    <span class="s1">walk_abort,</span>

    <span class="s1">_NOINLINE</span>
<span class="s1">} from </span><span class="s2">&quot;../ast.js&quot;</span><span class="s1">;</span>
<span class="s1">import {</span>
    <span class="s1">make_node,</span>
    <span class="s1">MAP,</span>
    <span class="s1">member,</span>
    <span class="s1">remove,</span>
    <span class="s1">has_annotation</span>
<span class="s1">} from </span><span class="s2">&quot;../utils/index.js&quot;</span><span class="s1">;</span>

<span class="s1">import { pure_prop_access_globals } from </span><span class="s2">&quot;./native-objects.js&quot;</span><span class="s1">;</span>
<span class="s1">import {</span>
    <span class="s1">lazy_op,</span>
    <span class="s1">unary_side_effects,</span>
    <span class="s1">is_modified,</span>
    <span class="s1">is_lhs,</span>
    <span class="s1">aborts</span>
<span class="s1">} from </span><span class="s2">&quot;./inference.js&quot;</span><span class="s1">;</span>
<span class="s1">import { WRITE_ONLY, clear_flag } from </span><span class="s2">&quot;./compressor-flags.js&quot;</span><span class="s1">;</span>
<span class="s1">import {</span>
    <span class="s1">make_sequence,</span>
    <span class="s1">merge_sequence,</span>
    <span class="s1">maintain_this_binding,</span>
    <span class="s1">is_func_expr,</span>
    <span class="s1">is_identifier_atom,</span>
    <span class="s1">is_ref_of,</span>
    <span class="s1">can_be_evicted_from_block,</span>
    <span class="s1">as_statement_array,</span>
<span class="s1">} from </span><span class="s2">&quot;./common.js&quot;</span><span class="s1">;</span>

<span class="s3">function </span><span class="s1">loop_body(x) {</span>
    <span class="s3">if </span><span class="s1">(x </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement) {</span>
        <span class="s3">return </span><span class="s1">x.body </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement ? x.body : x;</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">x;</span>
<span class="s1">}</span>

<span class="s3">function </span><span class="s1">is_lhs_read_only(lhs) {</span>
    <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_This) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) </span><span class="s3">return </span><span class="s1">lhs.definition().orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolLambda;</span>
    <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess) {</span>
        <span class="s1">lhs = lhs.expression;</span>
        <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
            <span class="s3">if </span><span class="s1">(lhs.is_immutable()) </span><span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">lhs = lhs.fixed_value();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!lhs) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_RegExp) </span><span class="s3">return false</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_Constant) </span><span class="s3">return true</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s1">is_lhs_read_only(lhs);</span>
    <span class="s1">}</span>
    <span class="s3">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** var a = 1 --&gt; var a*/</span>
<span class="s3">function </span><span class="s1">remove_initializers(var_statement) {</span>
    <span class="s3">var </span><span class="s1">decls = [];</span>
    <span class="s1">var_statement.definitions.forEach(</span><span class="s3">function</span><span class="s1">(def) {</span>
        <span class="s3">if </span><span class="s1">(def.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration) {</span>
            <span class="s1">def.value = </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s1">decls.push(def);</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
            <span class="s1">def.declarations_as_names().forEach(name =&gt; {</span>
                <span class="s1">decls.push(make_node(AST_VarDef, def, {</span>
                    <span class="s1">name,</span>
                    <span class="s1">value: </span><span class="s3">null</span>
                <span class="s1">}));</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">return </span><span class="s1">decls.length ? make_node(AST_Var, var_statement, { definitions: decls }) : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">/** Called on code which we know is unreachable, to keep elements that affect outside of it. */</span>
<span class="s1">export </span><span class="s3">function </span><span class="s1">trim_unreachable_code(compressor, stat, target) {</span>
    <span class="s1">walk(stat, node =&gt; {</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Var) {</span>
            <span class="s1">const no_initializers = remove_initializers(node);</span>
            <span class="s3">if </span><span class="s1">(no_initializers) target.push(no_initializers);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_Defun</span>
            <span class="s1">&amp;&amp; (node === stat || !compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">))</span>
        <span class="s1">) {</span>
            <span class="s1">target.push(node === stat ? node : make_node(AST_Var, node, {</span>
                <span class="s1">definitions: [</span>
                    <span class="s1">make_node(AST_VarDef, node, {</span>
                        <span class="s1">name: make_node(AST_SymbolVar, node.name, node.name),</span>
                        <span class="s1">value: </span><span class="s3">null</span>
                    <span class="s1">})</span>
                <span class="s1">]</span>
            <span class="s1">}));</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Export || node </span><span class="s3">instanceof </span><span class="s1">AST_Import) {</span>
            <span class="s1">target.push(node);</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
            <span class="s3">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s0">/** Tighten a bunch of statements together, and perform statement-level optimization. */</span>
<span class="s1">export </span><span class="s3">function </span><span class="s1">tighten_body(statements, compressor) {</span>
    <span class="s1">const nearest_scope = compressor.find_scope();</span>
    <span class="s1">const defun_scope = nearest_scope.get_defun_scope();</span>
    <span class="s1">const { in_loop, in_try } = find_loop_scope_try();</span>

    <span class="s3">var </span><span class="s1">CHANGED, max_iter = </span><span class="s4">10</span><span class="s1">;</span>
    <span class="s3">do </span><span class="s1">{</span>
        <span class="s1">CHANGED = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">eliminate_spurious_blocks(statements);</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;dead_code&quot;</span><span class="s1">)) {</span>
            <span class="s1">eliminate_dead_code(statements, compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;if_return&quot;</span><span class="s1">)) {</span>
            <span class="s1">handle_if_return(statements, compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.sequences_limit &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">sequencesize(statements, compressor);</span>
            <span class="s1">sequencesize_2(statements, compressor);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;join_vars&quot;</span><span class="s1">)) {</span>
            <span class="s1">join_consecutive_vars(statements);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;collapse_vars&quot;</span><span class="s1">)) {</span>
            <span class="s1">collapse(statements, compressor);</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s3">while </span><span class="s1">(CHANGED &amp;&amp; max_iter-- &gt; </span><span class="s4">0</span><span class="s1">);</span>

    <span class="s3">function </span><span class="s1">find_loop_scope_try() {</span>
        <span class="s3">var </span><span class="s1">node = compressor.self(), level = </span><span class="s4">0</span><span class="s1">, in_loop = </span><span class="s3">false</span><span class="s1">, in_try = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">do </span><span class="s1">{</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement) {</span>
                <span class="s1">in_loop = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope) {</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_TryBlock) {</span>
                <span class="s1">in_try = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(node = compressor.parent(level++));</span>

        <span class="s3">return </span><span class="s1">{ in_loop, in_try };</span>
    <span class="s1">}</span>

    <span class="s0">// Search from right to left for assignment-like expressions:</span>
    <span class="s0">// - `var a = x;`</span>
    <span class="s0">// - `a = x;`</span>
    <span class="s0">// - `++a`</span>
    <span class="s0">// For each candidate, scan from left to right for first usage, then try</span>
    <span class="s0">// to fold assignment into the site for compression.</span>
    <span class="s0">// Will not attempt to collapse assignments into or past code blocks</span>
    <span class="s0">// which are not sequentially executed, e.g. loops and conditionals.</span>
    <span class="s3">function </span><span class="s1">collapse(statements, compressor) {</span>
        <span class="s3">if </span><span class="s1">(nearest_scope.pinned() || defun_scope.pinned())</span>
            <span class="s3">return </span><span class="s1">statements;</span>
        <span class="s3">var </span><span class="s1">args;</span>
        <span class="s3">var </span><span class="s1">candidates = [];</span>
        <span class="s3">var </span><span class="s1">stat_index = statements.length;</span>
        <span class="s3">var </span><span class="s1">scanner = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function </span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(abort)</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s0">// Skip nodes before `candidate` as quickly as possible</span>
            <span class="s3">if </span><span class="s1">(!hit) {</span>
                <span class="s3">if </span><span class="s1">(node !== hit_stack[hit_index])</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">hit_index++;</span>
                <span class="s3">if </span><span class="s1">(hit_index &lt; hit_stack.length)</span>
                    <span class="s3">return </span><span class="s1">handle_custom_scan_order(node);</span>
                <span class="s1">hit = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">stop_after = find_stop(node, </span><span class="s4">0</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(stop_after === node)</span>
                    <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s0">// Stop immediately if these node types are encountered</span>
            <span class="s3">var </span><span class="s1">parent = scanner.parent();</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
                    <span class="s1">&amp;&amp; (node.logical || node.operator != </span><span class="s2">&quot;=&quot; </span><span class="s1">&amp;&amp; lhs.equivalent_to(node.left))</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Await</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; lhs </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess &amp;&amp; lhs.equivalent_to(node.expression)</span>
                <span class="s1">||</span>
                    <span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Call || node </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess)</span>
                    <span class="s1">&amp;&amp; node.optional</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Debugger</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Destructuring</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Expansion</span>
                    <span class="s1">&amp;&amp; node.expression </span><span class="s3">instanceof </span><span class="s1">AST_Symbol</span>
                    <span class="s1">&amp;&amp; (</span>
                        <span class="s1">node.expression </span><span class="s3">instanceof </span><span class="s1">AST_This</span>
                        <span class="s1">|| node.expression.definition().references.length &gt; </span><span class="s4">1</span>
                    <span class="s1">)</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement &amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_For)</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_LoopControl</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Try</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_With</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Yield</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Export</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Class</span>
                <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_For &amp;&amp; node !== parent.init</span>
                <span class="s1">|| !replace_all</span>
                    <span class="s1">&amp;&amp; (</span>
                        <span class="s1">node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                        <span class="s1">&amp;&amp; !node.is_declared(compressor)</span>
                        <span class="s1">&amp;&amp; !pure_prop_access_globals.has(node)</span>
                    <span class="s1">)</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                    <span class="s1">&amp;&amp; parent </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                    <span class="s1">&amp;&amp; has_annotation(parent, _NOINLINE)</span>
            <span class="s1">) {</span>
                <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s0">// Stop only if candidate is found within conditional branches</span>
            <span class="s3">if </span><span class="s1">(!stop_if_hit &amp;&amp; (!lhs_local || !replace_all)</span>
                <span class="s1">&amp;&amp; (parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary &amp;&amp; lazy_op.has(parent.operator) &amp;&amp; parent.left !== node</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional &amp;&amp; parent.condition !== node</span>
                    <span class="s1">|| parent </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; parent.condition !== node)) {</span>
                <span class="s1">stop_if_hit = parent;</span>
            <span class="s1">}</span>
            <span class="s0">// Replace variable with assignment when found</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">can_replace</span>
                <span class="s1">&amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration)</span>
                <span class="s1">&amp;&amp; lhs.equivalent_to(node)</span>
                <span class="s1">&amp;&amp; !shadows(scanner.find_scope() || nearest_scope, lvalues)</span>
            <span class="s1">) {</span>
                <span class="s3">if </span><span class="s1">(stop_if_hit) {</span>
                    <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(is_lhs(node, parent)) {</span>
                    <span class="s3">if </span><span class="s1">(value_def)</span>
                        <span class="s1">replaced++;</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">replaced++;</span>
                    <span class="s3">if </span><span class="s1">(value_def &amp;&amp; candidate </span><span class="s3">instanceof </span><span class="s1">AST_VarDef)</span>
                        <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">}</span>
                <span class="s1">CHANGED = abort = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(candidate </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPostfix) {</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_UnaryPrefix, candidate, candidate);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(candidate </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) {</span>
                    <span class="s3">var </span><span class="s1">def = candidate.name.definition();</span>
                    <span class="s3">var </span><span class="s1">value = candidate.value;</span>
                    <span class="s3">if </span><span class="s1">(def.references.length - def.replaced == </span><span class="s4">1 </span><span class="s1">&amp;&amp; !compressor.exposed(def)) {</span>
                        <span class="s1">def.replaced++;</span>
                        <span class="s3">if </span><span class="s1">(funarg &amp;&amp; is_identifier_atom(value)) {</span>
                            <span class="s3">return </span><span class="s1">value.transform(compressor);</span>
                        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                            <span class="s3">return </span><span class="s1">maintain_this_binding(parent, node, value);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_Assign, candidate, {</span>
                        <span class="s1">operator: </span><span class="s2">&quot;=&quot;</span><span class="s1">,</span>
                        <span class="s1">logical: </span><span class="s3">false</span><span class="s1">,</span>
                        <span class="s1">left: make_node(AST_SymbolRef, candidate.name, candidate.name),</span>
                        <span class="s1">right: value</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s1">clear_flag(candidate, WRITE_ONLY);</span>
                <span class="s3">return </span><span class="s1">candidate;</span>
            <span class="s1">}</span>
            <span class="s0">// These node types have child nodes that execute sequentially,</span>
            <span class="s0">// but are otherwise not safe to scan into or beyond them.</span>
            <span class="s3">var </span><span class="s1">sym;</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_Exit</span>
                <span class="s1">&amp;&amp; (side_effects || lhs </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess || may_modify(lhs))</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
                <span class="s1">&amp;&amp; (side_effects || node.expression.may_throw_on_access(compressor))</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; ((lvalues.has(node.name) &amp;&amp; lvalues.get(node.name).modified) || side_effects &amp;&amp; may_modify(node))</span>
                <span class="s1">|| node </span><span class="s3">instanceof </span><span class="s1">AST_VarDef &amp;&amp; node.value</span>
                <span class="s1">&amp;&amp; (lvalues.has(node.name.name) || side_effects &amp;&amp; may_modify(node.name))</span>
                <span class="s1">|| (sym = is_lhs(node.left, node))</span>
                <span class="s1">&amp;&amp; (sym </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess || lvalues.has(sym.name))</span>
                <span class="s1">|| may_throw</span>
                <span class="s1">&amp;&amp; (in_try ? node.has_side_effects(compressor) : side_effects_external(node))) {</span>
                <span class="s1">stop_after = node;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope)</span>
                    <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">handle_custom_scan_order(node);</span>
        <span class="s1">}, </span><span class="s3">function </span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(abort)</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(stop_after === node)</span>
                <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(stop_if_hit === node)</span>
                <span class="s1">stop_if_hit = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">});</span>

        <span class="s3">var </span><span class="s1">multi_replacer = </span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function </span><span class="s1">(node) {</span>
            <span class="s3">if </span><span class="s1">(abort)</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s0">// Skip nodes before `candidate` as quickly as possible</span>
            <span class="s3">if </span><span class="s1">(!hit) {</span>
                <span class="s3">if </span><span class="s1">(node !== hit_stack[hit_index])</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">hit_index++;</span>
                <span class="s3">if </span><span class="s1">(hit_index &lt; hit_stack.length)</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">hit = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s0">// Replace variable when found</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; node.name == def.name) {</span>
                <span class="s3">if </span><span class="s1">(!--replaced)</span>
                    <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(is_lhs(node, multi_replacer.parent()))</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s1">def.replaced++;</span>
                <span class="s1">value_def.replaced--;</span>
                <span class="s3">return </span><span class="s1">candidate.value;</span>
            <span class="s1">}</span>
            <span class="s0">// Skip (non-executed) functions and (leading) default case in switch statements</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Default || node </span><span class="s3">instanceof </span><span class="s1">AST_Scope)</span>
                <span class="s3">return </span><span class="s1">node;</span>
        <span class="s1">});</span>

        <span class="s3">while </span><span class="s1">(--stat_index &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">// Treat parameters as collapsible in IIFE, i.e.</span>
            <span class="s0">//   function(a, b){ ... }(x());</span>
            <span class="s0">// would be translated into equivalent assignments:</span>
            <span class="s0">//   var a = x(), b = undefined;</span>
            <span class="s3">if </span><span class="s1">(stat_index == </span><span class="s4">0 </span><span class="s1">&amp;&amp; compressor.option(</span><span class="s2">&quot;unused&quot;</span><span class="s1">))</span>
                <span class="s1">extract_args();</span>
            <span class="s0">// Find collapsible assignments</span>
            <span class="s3">var </span><span class="s1">hit_stack = [];</span>
            <span class="s1">extract_candidates(statements[stat_index]);</span>
            <span class="s3">while </span><span class="s1">(candidates.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">hit_stack = candidates.pop();</span>
                <span class="s3">var </span><span class="s1">hit_index = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">candidate = hit_stack[hit_stack.length - </span><span class="s4">1</span><span class="s1">];</span>
                <span class="s3">var </span><span class="s1">value_def = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">stop_after = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">stop_if_hit = </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">lhs = get_lhs(candidate);</span>
                <span class="s3">if </span><span class="s1">(!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor))</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s0">// Locate symbols which may execute code outside of scanning range</span>
                <span class="s3">var </span><span class="s1">lvalues = get_lvalues(candidate);</span>
                <span class="s3">var </span><span class="s1">lhs_local = is_lhs_local(lhs);</span>
                <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                    <span class="s1">lvalues.set(lhs.name, { def: lhs.definition(), modified: </span><span class="s3">false </span><span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s3">var </span><span class="s1">side_effects = value_has_side_effects(candidate);</span>
                <span class="s3">var </span><span class="s1">replace_all = replace_all_symbols();</span>
                <span class="s3">var </span><span class="s1">may_throw = candidate.may_throw(compressor);</span>
                <span class="s3">var </span><span class="s1">funarg = candidate.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg;</span>
                <span class="s3">var </span><span class="s1">hit = funarg;</span>
                <span class="s3">var </span><span class="s1">abort = </span><span class="s3">false</span><span class="s1">, replaced = </span><span class="s4">0</span><span class="s1">, can_replace = !args || !hit;</span>
                <span class="s3">if </span><span class="s1">(!can_replace) {</span>
                    <span class="s3">for </span><span class="s1">(</span>
                        <span class="s1">let j = compressor.self().argnames.lastIndexOf(candidate.name) + </span><span class="s4">1</span><span class="s1">;</span>
                        <span class="s1">!abort &amp;&amp; j &lt; args.length;</span>
                        <span class="s1">j++</span>
                    <span class="s1">) {</span>
                        <span class="s1">args[j].transform(scanner);</span>
                    <span class="s1">}</span>
                    <span class="s1">can_replace = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = stat_index; !abort &amp;&amp; i &lt; statements.length; i++) {</span>
                    <span class="s1">statements[i].transform(scanner);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(value_def) {</span>
                    <span class="s3">var </span><span class="s1">def = candidate.name.definition();</span>
                    <span class="s3">if </span><span class="s1">(abort &amp;&amp; def.references.length - def.replaced &gt; replaced)</span>
                        <span class="s1">replaced = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">abort = </span><span class="s3">false</span><span class="s1">;</span>
                        <span class="s1">hit_index = </span><span class="s4">0</span><span class="s1">;</span>
                        <span class="s1">hit = funarg;</span>
                        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = stat_index; !abort &amp;&amp; i &lt; statements.length; i++) {</span>
                            <span class="s1">statements[i].transform(multi_replacer);</span>
                        <span class="s1">}</span>
                        <span class="s1">value_def.single_use = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(replaced &amp;&amp; !remove_candidate(candidate))</span>
                    <span class="s1">statements.splice(stat_index, </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">handle_custom_scan_order(node) {</span>
            <span class="s0">// Skip (non-executed) functions</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope)</span>
                <span class="s3">return </span><span class="s1">node;</span>

            <span class="s0">// Scan case expressions first in a switch statement</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                <span class="s1">node.expression = node.expression.transform(scanner);</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = node.body.length; !abort &amp;&amp; i &lt; len; i++) {</span>
                    <span class="s3">var </span><span class="s1">branch = node.body[i];</span>
                    <span class="s3">if </span><span class="s1">(branch </span><span class="s3">instanceof </span><span class="s1">AST_Case) {</span>
                        <span class="s3">if </span><span class="s1">(!hit) {</span>
                            <span class="s3">if </span><span class="s1">(branch !== hit_stack[hit_index])</span>
                                <span class="s3">continue</span><span class="s1">;</span>
                            <span class="s1">hit_index++;</span>
                        <span class="s1">}</span>
                        <span class="s1">branch.expression = branch.expression.transform(scanner);</span>
                        <span class="s3">if </span><span class="s1">(!replace_all)</span>
                            <span class="s3">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">abort = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">redefined_within_scope(def, scope) {</span>
            <span class="s3">if </span><span class="s1">(def.global)</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">let cur_scope = def.scope;</span>
            <span class="s3">while </span><span class="s1">(cur_scope &amp;&amp; cur_scope !== scope) {</span>
                <span class="s3">if </span><span class="s1">(cur_scope.variables.has(def.name)) {</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">cur_scope = cur_scope.parent_scope;</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">has_overlapping_symbol(fn, arg, fn_strict) {</span>
            <span class="s3">var </span><span class="s1">found = </span><span class="s3">false</span><span class="s1">, scan_this = !(fn </span><span class="s3">instanceof </span><span class="s1">AST_Arrow);</span>
            <span class="s1">arg.walk(</span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function </span><span class="s1">(node, descend) {</span>
                <span class="s3">if </span><span class="s1">(found)</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef &amp;&amp; (fn.variables.has(node.name) || redefined_within_scope(node.definition(), fn))) {</span>
                    <span class="s3">var </span><span class="s1">s = node.definition().scope;</span>
                    <span class="s3">if </span><span class="s1">(s !== defun_scope)</span>
                        <span class="s3">while </span><span class="s1">(s = s.parent_scope) {</span>
                            <span class="s3">if </span><span class="s1">(s === defun_scope)</span>
                                <span class="s3">return true</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">found = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">((fn_strict || scan_this) &amp;&amp; node </span><span class="s3">instanceof </span><span class="s1">AST_This) {</span>
                    <span class="s3">return </span><span class="s1">found = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope &amp;&amp; !(node </span><span class="s3">instanceof </span><span class="s1">AST_Arrow)) {</span>
                    <span class="s3">var </span><span class="s1">prev = scan_this;</span>
                    <span class="s1">scan_this = </span><span class="s3">false</span><span class="s1">;</span>
                    <span class="s1">descend();</span>
                    <span class="s1">scan_this = prev;</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}));</span>
            <span class="s3">return </span><span class="s1">found;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">extract_args() {</span>
            <span class="s3">var </span><span class="s1">iife, fn = compressor.self();</span>
            <span class="s3">if </span><span class="s1">(is_func_expr(fn)</span>
                <span class="s1">&amp;&amp; !fn.name</span>
                <span class="s1">&amp;&amp; !fn.uses_arguments</span>
                <span class="s1">&amp;&amp; !fn.pinned()</span>
                <span class="s1">&amp;&amp; (iife = compressor.parent()) </span><span class="s3">instanceof </span><span class="s1">AST_Call</span>
                <span class="s1">&amp;&amp; iife.expression === fn</span>
                <span class="s1">&amp;&amp; iife.args.every((arg) =&gt; !(arg </span><span class="s3">instanceof </span><span class="s1">AST_Expansion))) {</span>
                <span class="s3">var </span><span class="s1">fn_strict = compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(fn_strict &amp;&amp; !member(fn_strict, fn.body))</span>
                    <span class="s1">fn_strict = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">len = fn.argnames.length;</span>
                <span class="s1">args = iife.args.slice(len);</span>
                <span class="s3">var </span><span class="s1">names = </span><span class="s3">new </span><span class="s1">Set();</span>
                <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = len; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                    <span class="s3">var </span><span class="s1">sym = fn.argnames[i];</span>
                    <span class="s3">var </span><span class="s1">arg = iife.args[i];</span>
                    <span class="s0">// The following two line fix is a duplicate of the fix at</span>
                    <span class="s0">// https://github.com/terser/terser/commit/011d3eb08cefe6922c7d1bdfa113fc4aeaca1b75</span>
                    <span class="s0">// This might mean that these two pieces of code (one here in collapse_vars and another in reduce_vars</span>
                    <span class="s0">// Might be doing the exact same thing.</span>
                    <span class="s1">const def = sym.definition &amp;&amp; sym.definition();</span>
                    <span class="s1">const is_reassigned = def &amp;&amp; def.orig.length &gt; </span><span class="s4">1</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(is_reassigned)</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">args.unshift(make_node(AST_VarDef, sym, {</span>
                        <span class="s1">name: sym,</span>
                        <span class="s1">value: arg</span>
                    <span class="s1">}));</span>
                    <span class="s3">if </span><span class="s1">(names.has(sym.name))</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">names.add(sym.name);</span>
                    <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_Expansion) {</span>
                        <span class="s3">var </span><span class="s1">elements = iife.args.slice(i);</span>
                        <span class="s3">if </span><span class="s1">(elements.every((arg) =&gt; !has_overlapping_symbol(fn, arg, fn_strict)</span>
                        <span class="s1">)) {</span>
                            <span class="s1">candidates.unshift([make_node(AST_VarDef, sym, {</span>
                                <span class="s1">name: sym.expression,</span>
                                <span class="s1">value: make_node(AST_Array, iife, {</span>
                                    <span class="s1">elements: elements</span>
                                <span class="s1">})</span>
                            <span class="s1">})]);</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s3">if </span><span class="s1">(!arg) {</span>
                            <span class="s1">arg = make_node(AST_Undefined, sym).transform(compressor);</span>
                        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(arg </span><span class="s3">instanceof </span><span class="s1">AST_Lambda &amp;&amp; arg.pinned()</span>
                            <span class="s1">|| has_overlapping_symbol(fn, arg, fn_strict)) {</span>
                            <span class="s1">arg = </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s3">if </span><span class="s1">(arg)</span>
                            <span class="s1">candidates.unshift([make_node(AST_VarDef, sym, {</span>
                                <span class="s1">name: sym,</span>
                                <span class="s1">value: arg</span>
                            <span class="s1">})]);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">extract_candidates(expr) {</span>
            <span class="s1">hit_stack.push(expr);</span>
            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                <span class="s3">if </span><span class="s1">(!expr.left.has_side_effects(compressor)</span>
                    <span class="s1">&amp;&amp; !(expr.right </span><span class="s3">instanceof </span><span class="s1">AST_Chain)) {</span>
                    <span class="s1">candidates.push(hit_stack.slice());</span>
                <span class="s1">}</span>
                <span class="s1">extract_candidates(expr.right);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Binary) {</span>
                <span class="s1">extract_candidates(expr.left);</span>
                <span class="s1">extract_candidates(expr.right);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Call &amp;&amp; !has_annotation(expr, _NOINLINE)) {</span>
                <span class="s1">extract_candidates(expr.expression);</span>
                <span class="s1">expr.args.forEach(extract_candidates);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Case) {</span>
                <span class="s1">extract_candidates(expr.expression);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Conditional) {</span>
                <span class="s1">extract_candidates(expr.condition);</span>
                <span class="s1">extract_candidates(expr.consequent);</span>
                <span class="s1">extract_candidates(expr.alternative);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) {</span>
                <span class="s3">var </span><span class="s1">len = expr.definitions.length;</span>
                <span class="s0">// limit number of trailing variable definitions for consideration</span>
                <span class="s3">var </span><span class="s1">i = len - </span><span class="s4">200</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(i &lt; </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s3">for </span><span class="s1">(; i &lt; len; i++) {</span>
                    <span class="s1">extract_candidates(expr.definitions[i]);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_DWLoop) {</span>
                <span class="s1">extract_candidates(expr.condition);</span>
                <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                    <span class="s1">extract_candidates(expr.body);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                <span class="s3">if </span><span class="s1">(expr.value)</span>
                    <span class="s1">extract_candidates(expr.value);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                <span class="s3">if </span><span class="s1">(expr.init)</span>
                    <span class="s1">extract_candidates(expr.init);</span>
                <span class="s3">if </span><span class="s1">(expr.condition)</span>
                    <span class="s1">extract_candidates(expr.condition);</span>
                <span class="s3">if </span><span class="s1">(expr.step)</span>
                    <span class="s1">extract_candidates(expr.step);</span>
                <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                    <span class="s1">extract_candidates(expr.body);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_ForIn) {</span>
                <span class="s1">extract_candidates(expr.object);</span>
                <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                    <span class="s1">extract_candidates(expr.body);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                <span class="s1">extract_candidates(expr.condition);</span>
                <span class="s3">if </span><span class="s1">(!(expr.body </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                    <span class="s1">extract_candidates(expr.body);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(expr.alternative &amp;&amp; !(expr.alternative </span><span class="s3">instanceof </span><span class="s1">AST_Block)) {</span>
                    <span class="s1">extract_candidates(expr.alternative);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                <span class="s1">expr.expressions.forEach(extract_candidates);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                <span class="s1">extract_candidates(expr.body);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                <span class="s1">extract_candidates(expr.expression);</span>
                <span class="s1">expr.body.forEach(extract_candidates);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Unary) {</span>
                <span class="s3">if </span><span class="s1">(expr.operator == </span><span class="s2">&quot;++&quot; </span><span class="s1">|| expr.operator == </span><span class="s2">&quot;--&quot;</span><span class="s1">) {</span>
                    <span class="s1">candidates.push(hit_stack.slice());</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) {</span>
                <span class="s3">if </span><span class="s1">(expr.value &amp;&amp; !(expr.value </span><span class="s3">instanceof </span><span class="s1">AST_Chain)) {</span>
                    <span class="s1">candidates.push(hit_stack.slice());</span>
                    <span class="s1">extract_candidates(expr.value);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">hit_stack.pop();</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">find_stop(node, level, write_only) {</span>
            <span class="s3">var </span><span class="s1">parent = scanner.parent(level);</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                <span class="s3">if </span><span class="s1">(write_only</span>
                    <span class="s1">&amp;&amp; !parent.logical</span>
                    <span class="s1">&amp;&amp; !(parent.left </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess</span>
                        <span class="s1">|| lvalues.has(parent.left.name))) {</span>
                    <span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, write_only);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Binary) {</span>
                <span class="s3">if </span><span class="s1">(write_only &amp;&amp; (!lazy_op.has(parent.operator) || parent.left === node)) {</span>
                    <span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, write_only);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Call)</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Case)</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Conditional) {</span>
                <span class="s3">if </span><span class="s1">(write_only &amp;&amp; parent.condition === node) {</span>
                    <span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, write_only);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) {</span>
                <span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                <span class="s3">return </span><span class="s1">write_only ? find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, write_only) : node;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                <span class="s3">if </span><span class="s1">(write_only &amp;&amp; parent.condition === node) {</span>
                    <span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, write_only);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement)</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                <span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, parent.tail_node() !== node);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                <span class="s3">return </span><span class="s1">find_stop(parent, level + </span><span class="s4">1</span><span class="s1">, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_Switch)</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s3">if </span><span class="s1">(parent </span><span class="s3">instanceof </span><span class="s1">AST_VarDef)</span>
                <span class="s3">return </span><span class="s1">node;</span>
            <span class="s3">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">mangleable_var(var_def) {</span>
            <span class="s3">var </span><span class="s1">value = var_def.value;</span>
            <span class="s3">if </span><span class="s1">(!(value </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef))</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(value.name == </span><span class="s2">&quot;arguments&quot;</span><span class="s1">)</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">def = value.definition();</span>
            <span class="s3">if </span><span class="s1">(def.undeclared)</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">value_def = def;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">get_lhs(expr) {</span>
            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; expr.logical) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_VarDef &amp;&amp; expr.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDeclaration) {</span>
                <span class="s3">var </span><span class="s1">def = expr.name.definition();</span>
                <span class="s3">if </span><span class="s1">(!member(expr.name, def.orig))</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">referenced = def.references.length - def.replaced;</span>
                <span class="s3">if </span><span class="s1">(!referenced)</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s3">var </span><span class="s1">declared = def.orig.length - def.eliminated;</span>
                <span class="s3">if </span><span class="s1">(declared &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; !(expr.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg)</span>
                    <span class="s1">|| (referenced &gt; </span><span class="s4">1 </span><span class="s1">? mangleable_var(expr) : !compressor.exposed(def))) {</span>
                    <span class="s3">return </span><span class="s1">make_node(AST_SymbolRef, expr.name, expr.name);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">const lhs = expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
                    <span class="s1">? expr.left</span>
                    <span class="s1">: expr.expression;</span>
                <span class="s3">return </span><span class="s1">!is_ref_of(lhs, AST_SymbolConst)</span>
                    <span class="s1">&amp;&amp; !is_ref_of(lhs, AST_SymbolLet) &amp;&amp; lhs;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">get_rvalue(expr) {</span>
            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Assign) {</span>
                <span class="s3">return </span><span class="s1">expr.right;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s3">return </span><span class="s1">expr.value;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">get_lvalues(expr) {</span>
            <span class="s3">var </span><span class="s1">lvalues = </span><span class="s3">new </span><span class="s1">Map();</span>
            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Unary)</span>
                <span class="s3">return </span><span class="s1">lvalues;</span>
            <span class="s3">var </span><span class="s1">tw = </span><span class="s3">new </span><span class="s1">TreeWalker(</span><span class="s3">function </span><span class="s1">(node) {</span>
                <span class="s3">var </span><span class="s1">sym = node;</span>
                <span class="s3">while </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess)</span>
                    <span class="s1">sym = sym.expression;</span>
                <span class="s3">if </span><span class="s1">(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                    <span class="s1">const prev = lvalues.get(sym.name);</span>
                    <span class="s3">if </span><span class="s1">(!prev || !prev.modified) {</span>
                        <span class="s1">lvalues.set(sym.name, {</span>
                            <span class="s1">def: sym.definition(),</span>
                            <span class="s1">modified: is_modified(compressor, tw, node, node, </span><span class="s4">0</span><span class="s1">)</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">get_rvalue(expr).walk(tw);</span>
            <span class="s3">return </span><span class="s1">lvalues;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">remove_candidate(expr) {</span>
            <span class="s3">if </span><span class="s1">(expr.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolFunarg) {</span>
                <span class="s3">var </span><span class="s1">iife = compressor.parent(), argnames = compressor.self().argnames;</span>
                <span class="s3">var </span><span class="s1">index = argnames.indexOf(expr.name);</span>
                <span class="s3">if </span><span class="s1">(index &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">iife.args.length = Math.min(iife.args.length, argnames.length - </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">var </span><span class="s1">args = iife.args;</span>
                    <span class="s3">if </span><span class="s1">(args[index])</span>
                        <span class="s1">args[index] = make_node(AST_Number, args[index], {</span>
                            <span class="s1">value: </span><span class="s4">0</span>
                        <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">found = </span><span class="s3">false</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">statements[stat_index].transform(</span><span class="s3">new </span><span class="s1">TreeTransformer(</span><span class="s3">function </span><span class="s1">(node, descend, in_list) {</span>
                <span class="s3">if </span><span class="s1">(found)</span>
                    <span class="s3">return </span><span class="s1">node;</span>
                <span class="s3">if </span><span class="s1">(node === expr || node.body === expr) {</span>
                    <span class="s1">found = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_VarDef) {</span>
                        <span class="s1">node.value = node.name </span><span class="s3">instanceof </span><span class="s1">AST_SymbolConst</span>
                            <span class="s1">? make_node(AST_Undefined, node.value) </span><span class="s0">// `const` always needs value.</span>
                            <span class="s1">: </span><span class="s3">null</span><span class="s1">;</span>
                        <span class="s3">return </span><span class="s1">node;</span>
                    <span class="s1">}</span>
                    <span class="s3">return </span><span class="s1">in_list ? MAP.skip : </span><span class="s3">null</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}, </span><span class="s3">function </span><span class="s1">(node) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Sequence)</span>
                    <span class="s3">switch </span><span class="s1">(node.expressions.length) {</span>
                        <span class="s3">case </span><span class="s4">0</span><span class="s1">: </span><span class="s3">return null</span><span class="s1">;</span>
                        <span class="s3">case </span><span class="s4">1</span><span class="s1">: </span><span class="s3">return </span><span class="s1">node.expressions[</span><span class="s4">0</span><span class="s1">];</span>
                    <span class="s1">}</span>
            <span class="s1">}));</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">is_lhs_local(lhs) {</span>
            <span class="s3">while </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess)</span>
                <span class="s1">lhs = lhs.expression;</span>
            <span class="s3">return </span><span class="s1">lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef</span>
                <span class="s1">&amp;&amp; lhs.definition().scope.get_defun_scope() === defun_scope</span>
                <span class="s1">&amp;&amp; !(in_loop</span>
                    <span class="s1">&amp;&amp; (lvalues.has(lhs.name)</span>
                        <span class="s1">|| candidate </span><span class="s3">instanceof </span><span class="s1">AST_Unary</span>
                        <span class="s1">|| (candidate </span><span class="s3">instanceof </span><span class="s1">AST_Assign</span>
                            <span class="s1">&amp;&amp; !candidate.logical</span>
                            <span class="s1">&amp;&amp; candidate.operator != </span><span class="s2">&quot;=&quot;</span><span class="s1">)));</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">value_has_side_effects(expr) {</span>
            <span class="s3">if </span><span class="s1">(expr </span><span class="s3">instanceof </span><span class="s1">AST_Unary)</span>
                <span class="s3">return </span><span class="s1">unary_side_effects.has(expr.operator);</span>
            <span class="s3">return </span><span class="s1">get_rvalue(expr).has_side_effects(compressor);</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">replace_all_symbols() {</span>
            <span class="s3">if </span><span class="s1">(side_effects)</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(value_def)</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(lhs </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef) {</span>
                <span class="s3">var </span><span class="s1">def = lhs.definition();</span>
                <span class="s3">if </span><span class="s1">(def.references.length - def.replaced == (candidate </span><span class="s3">instanceof </span><span class="s1">AST_VarDef ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">2</span><span class="s1">)) {</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">may_modify(sym) {</span>
            <span class="s3">if </span><span class="s1">(!sym.definition)</span>
                <span class="s3">return true</span><span class="s1">; </span><span class="s0">// AST_Destructuring</span>
            <span class="s3">var </span><span class="s1">def = sym.definition();</span>
            <span class="s3">if </span><span class="s1">(def.orig.length == </span><span class="s4">1 </span><span class="s1">&amp;&amp; def.orig[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">instanceof </span><span class="s1">AST_SymbolDefun)</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(def.scope.get_defun_scope() !== defun_scope)</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">def.references.some((ref) =&gt;</span>
                <span class="s1">ref.scope.get_defun_scope() !== defun_scope</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">side_effects_external(node, lhs) {</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign)</span>
                <span class="s3">return </span><span class="s1">side_effects_external(node.left, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Unary)</span>
                <span class="s3">return </span><span class="s1">side_effects_external(node.expression, </span><span class="s3">true</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_VarDef)</span>
                <span class="s3">return </span><span class="s1">node.value &amp;&amp; side_effects_external(node.value);</span>
            <span class="s3">if </span><span class="s1">(lhs) {</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Dot)</span>
                    <span class="s3">return </span><span class="s1">side_effects_external(node.expression, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Sub)</span>
                    <span class="s3">return </span><span class="s1">side_effects_external(node.expression, </span><span class="s3">true</span><span class="s1">);</span>
                <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef)</span>
                    <span class="s3">return </span><span class="s1">node.definition().scope.get_defun_scope() !== defun_scope;</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/** 
         * Will any of the pulled-in lvalues shadow a variable in newScope or parents? 
         * similar to scope_encloses_variables_in_this_scope */</span>
        <span class="s3">function </span><span class="s1">shadows(my_scope, lvalues) {</span>
            <span class="s3">for </span><span class="s1">(const { def } of lvalues.values()) {</span>
                <span class="s1">const looked_up = my_scope.find_variable(def.name);</span>
                <span class="s3">if </span><span class="s1">(looked_up) {</span>
                    <span class="s3">if </span><span class="s1">(looked_up === def) </span><span class="s3">continue</span><span class="s1">;</span>
                    <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">eliminate_spurious_blocks(statements) {</span>
        <span class="s3">var </span><span class="s1">seen_dirs = [];</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; statements.length;) {</span>
            <span class="s3">var </span><span class="s1">stat = statements[i];</span>
            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement &amp;&amp; stat.body.every(can_be_evicted_from_block)) {</span>
                <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">eliminate_spurious_blocks(stat.body);</span>
                <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">, ...stat.body);</span>
                <span class="s1">i += stat.body.length;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_EmptyStatement) {</span>
                <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Directive) {</span>
                <span class="s3">if </span><span class="s1">(seen_dirs.indexOf(stat.value) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">i++;</span>
                    <span class="s1">seen_dirs.push(stat.value);</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else</span>
                <span class="s1">i++;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">handle_if_return(statements, compressor) {</span>
        <span class="s3">var </span><span class="s1">self = compressor.self();</span>
        <span class="s3">var </span><span class="s1">multiple_if_returns = has_multiple_if_returns(statements);</span>
        <span class="s3">var </span><span class="s1">in_lambda = self </span><span class="s3">instanceof </span><span class="s1">AST_Lambda;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = statements.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
            <span class="s3">var </span><span class="s1">stat = statements[i];</span>
            <span class="s3">var </span><span class="s1">j = next_index(i);</span>
            <span class="s3">var </span><span class="s1">next = statements[j];</span>

            <span class="s3">if </span><span class="s1">(in_lambda &amp;&amp; !next &amp;&amp; stat </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                <span class="s3">if </span><span class="s1">(!stat.value) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">statements.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(stat.value </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix &amp;&amp; stat.value.operator == </span><span class="s2">&quot;void&quot;</span><span class="s1">) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">statements[i] = make_node(AST_SimpleStatement, stat, {</span>
                        <span class="s1">body: stat.value.expression</span>
                    <span class="s1">});</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                <span class="s1">let ab, new_else;</span>

                <span class="s1">ab = aborts(stat.body);</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">can_merge_flow(ab)</span>
                    <span class="s1">&amp;&amp; (new_else = as_statement_array_with_return(stat.body, ab))</span>
                <span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(ab.label) {</span>
                        <span class="s1">remove(ab.label.thedef.references, ab);</span>
                    <span class="s1">}</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">stat = stat.clone();</span>
                    <span class="s1">stat.condition = stat.condition.negate(compressor);</span>
                    <span class="s1">stat.body = make_node(AST_BlockStatement, stat, {</span>
                        <span class="s1">body: as_statement_array(stat.alternative).concat(extract_functions())</span>
                    <span class="s1">});</span>
                    <span class="s1">stat.alternative = make_node(AST_BlockStatement, stat, {</span>
                        <span class="s1">body: new_else</span>
                    <span class="s1">});</span>
                    <span class="s1">statements[i] = stat.transform(compressor);</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">ab = aborts(stat.alternative);</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">can_merge_flow(ab)</span>
                    <span class="s1">&amp;&amp; (new_else = as_statement_array_with_return(stat.alternative, ab))</span>
                <span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(ab.label) {</span>
                        <span class="s1">remove(ab.label.thedef.references, ab);</span>
                    <span class="s1">}</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">stat = stat.clone();</span>
                    <span class="s1">stat.body = make_node(AST_BlockStatement, stat.body, {</span>
                        <span class="s1">body: as_statement_array(stat.body).concat(extract_functions())</span>
                    <span class="s1">});</span>
                    <span class="s1">stat.alternative = make_node(AST_BlockStatement, stat.alternative, {</span>
                        <span class="s1">body: new_else</span>
                    <span class="s1">});</span>
                    <span class="s1">statements[i] = stat.transform(compressor);</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; stat.body </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                <span class="s3">var </span><span class="s1">value = stat.body.value;</span>
                <span class="s0">//---</span>
                <span class="s0">// pretty silly case, but:</span>
                <span class="s0">// if (foo()) return; return; ==&gt; foo(); return;</span>
                <span class="s3">if </span><span class="s1">(!value &amp;&amp; !stat.alternative</span>
                    <span class="s1">&amp;&amp; (in_lambda &amp;&amp; !next || next </span><span class="s3">instanceof </span><span class="s1">AST_Return &amp;&amp; !next.value)) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">statements[i] = make_node(AST_SimpleStatement, stat.condition, {</span>
                        <span class="s1">body: stat.condition</span>
                    <span class="s1">});</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">//---</span>
                <span class="s0">// if (foo()) return x; return y; ==&gt; return foo() ? x : y;</span>
                <span class="s3">if </span><span class="s1">(value &amp;&amp; !stat.alternative &amp;&amp; next </span><span class="s3">instanceof </span><span class="s1">AST_Return &amp;&amp; next.value) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">stat = stat.clone();</span>
                    <span class="s1">stat.alternative = next;</span>
                    <span class="s1">statements[i] = stat.transform(compressor);</span>
                    <span class="s1">statements.splice(j, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">//---</span>
                <span class="s0">// if (foo()) return x; [ return ; ] ==&gt; return foo() ? x : undefined;</span>
                <span class="s3">if </span><span class="s1">(value &amp;&amp; !stat.alternative</span>
                    <span class="s1">&amp;&amp; (!next &amp;&amp; in_lambda &amp;&amp; multiple_if_returns</span>
                        <span class="s1">|| next </span><span class="s3">instanceof </span><span class="s1">AST_Return)) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">stat = stat.clone();</span>
                    <span class="s1">stat.alternative = next || make_node(AST_Return, stat, {</span>
                        <span class="s1">value: </span><span class="s3">null</span>
                    <span class="s1">});</span>
                    <span class="s1">statements[i] = stat.transform(compressor);</span>
                    <span class="s3">if </span><span class="s1">(next)</span>
                        <span class="s1">statements.splice(j, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">//---</span>
                <span class="s0">// if (a) return b; if (c) return d; e; ==&gt; return a ? b : c ? d : void e;</span>
                <span class="s0">//</span>
                <span class="s0">// if sequences is not enabled, this can lead to an endless loop (issue #866).</span>
                <span class="s0">// however, with sequences on this helps producing slightly better output for</span>
                <span class="s0">// the example code.</span>
                <span class="s3">var </span><span class="s1">prev = statements[prev_index(i)];</span>
                <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;sequences&quot;</span><span class="s1">) &amp;&amp; in_lambda &amp;&amp; !stat.alternative</span>
                    <span class="s1">&amp;&amp; prev </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; prev.body </span><span class="s3">instanceof </span><span class="s1">AST_Return</span>
                    <span class="s1">&amp;&amp; next_index(j) == statements.length &amp;&amp; next </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">stat = stat.clone();</span>
                    <span class="s1">stat.alternative = make_node(AST_BlockStatement, next, {</span>
                        <span class="s1">body: [</span>
                            <span class="s1">next,</span>
                            <span class="s1">make_node(AST_Return, next, {</span>
                                <span class="s1">value: </span><span class="s3">null</span>
                            <span class="s1">})</span>
                        <span class="s1">]</span>
                    <span class="s1">});</span>
                    <span class="s1">statements[i] = stat.transform(compressor);</span>
                    <span class="s1">statements.splice(j, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">has_multiple_if_returns(statements) {</span>
            <span class="s3">var </span><span class="s1">n = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = statements.length; --i &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[i];</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If &amp;&amp; stat.body </span><span class="s3">instanceof </span><span class="s1">AST_Return) {</span>
                    <span class="s3">if </span><span class="s1">(++n &gt; </span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s3">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">is_return_void(value) {</span>
            <span class="s3">return </span><span class="s1">!value || value </span><span class="s3">instanceof </span><span class="s1">AST_UnaryPrefix &amp;&amp; value.operator == </span><span class="s2">&quot;void&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">can_merge_flow(ab) {</span>
            <span class="s3">if </span><span class="s1">(!ab)</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s1">, len = statements.length; j &lt; len; j++) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[j];</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Const || stat </span><span class="s3">instanceof </span><span class="s1">AST_Let)</span>
                    <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">var </span><span class="s1">lct = ab </span><span class="s3">instanceof </span><span class="s1">AST_LoopControl ? compressor.loopcontrol_target(ab) : </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">ab </span><span class="s3">instanceof </span><span class="s1">AST_Return &amp;&amp; in_lambda &amp;&amp; is_return_void(ab.value)</span>
                <span class="s1">|| ab </span><span class="s3">instanceof </span><span class="s1">AST_Continue &amp;&amp; self === loop_body(lct)</span>
                <span class="s1">|| ab </span><span class="s3">instanceof </span><span class="s1">AST_Break &amp;&amp; lct </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement &amp;&amp; self === lct;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">extract_functions() {</span>
            <span class="s3">var </span><span class="s1">tail = statements.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">statements.length = i + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s3">return </span><span class="s1">tail.filter(</span><span class="s3">function </span><span class="s1">(stat) {</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Defun) {</span>
                    <span class="s1">statements.push(stat);</span>
                    <span class="s3">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">return true</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">as_statement_array_with_return(node, ab) {</span>
            <span class="s3">var </span><span class="s1">body = as_statement_array(node);</span>
            <span class="s3">if </span><span class="s1">(ab !== body[body.length - </span><span class="s4">1</span><span class="s1">]) {</span>
                <span class="s3">return </span><span class="s1">undefined;</span>
            <span class="s1">}</span>
            <span class="s1">body = body.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">);</span>
            <span class="s3">if </span><span class="s1">(ab.value) {</span>
                <span class="s1">body.push(make_node(AST_SimpleStatement, ab.value, {</span>
                    <span class="s1">body: ab.value.expression</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">body;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">next_index(i) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s1">, len = statements.length; j &lt; len; j++) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[j];</span>
                <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var &amp;&amp; declarations_only(stat))) {</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">j;</span>
        <span class="s1">}</span>

        <span class="s3">function </span><span class="s1">prev_index(i) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">j = i; --j &gt;= </span><span class="s4">0</span><span class="s1">;) {</span>
                <span class="s3">var </span><span class="s1">stat = statements[j];</span>
                <span class="s3">if </span><span class="s1">(!(stat </span><span class="s3">instanceof </span><span class="s1">AST_Var &amp;&amp; declarations_only(stat))) {</span>
                    <span class="s3">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">j;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">eliminate_dead_code(statements, compressor) {</span>
        <span class="s3">var </span><span class="s1">has_quit;</span>
        <span class="s3">var </span><span class="s1">self = compressor.self();</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, n = </span><span class="s4">0</span><span class="s1">, len = statements.length; i &lt; len; i++) {</span>
            <span class="s3">var </span><span class="s1">stat = statements[i];</span>
            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_LoopControl) {</span>
                <span class="s3">var </span><span class="s1">lct = compressor.loopcontrol_target(stat);</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Break</span>
                    <span class="s1">&amp;&amp; !(lct </span><span class="s3">instanceof </span><span class="s1">AST_IterationStatement)</span>
                    <span class="s1">&amp;&amp; loop_body(lct) === self</span>
                    <span class="s1">|| stat </span><span class="s3">instanceof </span><span class="s1">AST_Continue</span>
                    <span class="s1">&amp;&amp; loop_body(lct) === self) {</span>
                    <span class="s3">if </span><span class="s1">(stat.label) {</span>
                        <span class="s1">remove(stat.label.thedef.references, stat);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">statements[n++] = stat;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">statements[n++] = stat;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(aborts(stat)) {</span>
                <span class="s1">has_quit = statements.slice(i + </span><span class="s4">1</span><span class="s1">);</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">statements.length = n;</span>
        <span class="s1">CHANGED = n != len;</span>
        <span class="s3">if </span><span class="s1">(has_quit)</span>
            <span class="s1">has_quit.forEach(</span><span class="s3">function </span><span class="s1">(stat) {</span>
                <span class="s1">trim_unreachable_code(compressor, stat, statements);</span>
            <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">declarations_only(node) {</span>
        <span class="s3">return </span><span class="s1">node.definitions.every((var_def) =&gt; !var_def.value);</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">sequencesize(statements, compressor) {</span>
        <span class="s3">if </span><span class="s1">(statements.length &lt; </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">seq = [], n = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">function </span><span class="s1">push_seq() {</span>
            <span class="s3">if </span><span class="s1">(!seq.length)</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">body = make_sequence(seq[</span><span class="s4">0</span><span class="s1">], seq);</span>
            <span class="s1">statements[n++] = make_node(AST_SimpleStatement, body, { body: body });</span>
            <span class="s1">seq = [];</span>
        <span class="s1">}</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = statements.length; i &lt; len; i++) {</span>
            <span class="s3">var </span><span class="s1">stat = statements[i];</span>
            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                <span class="s3">if </span><span class="s1">(seq.length &gt;= compressor.sequences_limit)</span>
                    <span class="s1">push_seq();</span>
                <span class="s3">var </span><span class="s1">body = stat.body;</span>
                <span class="s3">if </span><span class="s1">(seq.length &gt; </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">body = body.drop_side_effect_free(compressor);</span>
                <span class="s3">if </span><span class="s1">(body)</span>
                    <span class="s1">merge_sequence(seq, body);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Definitions &amp;&amp; declarations_only(stat)</span>
                <span class="s1">|| stat </span><span class="s3">instanceof </span><span class="s1">AST_Defun) {</span>
                <span class="s1">statements[n++] = stat;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">push_seq();</span>
                <span class="s1">statements[n++] = stat;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">push_seq();</span>
        <span class="s1">statements.length = n;</span>
        <span class="s3">if </span><span class="s1">(n != len)</span>
            <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">to_simple_statement(block, decls) {</span>
        <span class="s3">if </span><span class="s1">(!(block </span><span class="s3">instanceof </span><span class="s1">AST_BlockStatement))</span>
            <span class="s3">return </span><span class="s1">block;</span>
        <span class="s3">var </span><span class="s1">stat = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, len = block.body.length; i &lt; len; i++) {</span>
            <span class="s3">var </span><span class="s1">line = block.body[i];</span>
            <span class="s3">if </span><span class="s1">(line </span><span class="s3">instanceof </span><span class="s1">AST_Var &amp;&amp; declarations_only(line)) {</span>
                <span class="s1">decls.push(line);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat || line </span><span class="s3">instanceof </span><span class="s1">AST_Const || line </span><span class="s3">instanceof </span><span class="s1">AST_Let) {</span>
                <span class="s3">return false</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">stat = line;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">stat;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">sequencesize_2(statements, compressor) {</span>
        <span class="s3">function </span><span class="s1">cons_seq(right) {</span>
            <span class="s1">n--;</span>
            <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">left = prev.body;</span>
            <span class="s3">return </span><span class="s1">make_sequence(left, [left, right]).transform(compressor);</span>
        <span class="s1">}</span>
        <span class="s3">var </span><span class="s1">n = </span><span class="s4">0</span><span class="s1">, prev;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; statements.length; i++) {</span>
            <span class="s3">var </span><span class="s1">stat = statements[i];</span>
            <span class="s3">if </span><span class="s1">(prev) {</span>
                <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                    <span class="s1">stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor));</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                    <span class="s3">if </span><span class="s1">(!(stat.init </span><span class="s3">instanceof </span><span class="s1">AST_Definitions)) {</span>
                        <span class="s1">const abort = walk(prev.body, node =&gt; {</span>
                            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Scope)</span>
                                <span class="s3">return true</span><span class="s1">;</span>
                            <span class="s3">if </span><span class="s1">(node </span><span class="s3">instanceof </span><span class="s1">AST_Binary</span>
                                <span class="s1">&amp;&amp; node.operator === </span><span class="s2">&quot;in&quot;</span><span class="s1">) {</span>
                                <span class="s3">return </span><span class="s1">walk_abort;</span>
                            <span class="s1">}</span>
                        <span class="s1">});</span>
                        <span class="s3">if </span><span class="s1">(!abort) {</span>
                            <span class="s3">if </span><span class="s1">(stat.init)</span>
                                <span class="s1">stat.init = cons_seq(stat.init);</span>
                            <span class="s3">else </span><span class="s1">{</span>
                                <span class="s1">stat.init = prev.body;</span>
                                <span class="s1">n--;</span>
                                <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_ForIn) {</span>
                    <span class="s3">if </span><span class="s1">(!(stat.init </span><span class="s3">instanceof </span><span class="s1">AST_Const) &amp;&amp; !(stat.init </span><span class="s3">instanceof </span><span class="s1">AST_Let)) {</span>
                        <span class="s1">stat.object = cons_seq(stat.object);</span>
                    <span class="s1">}</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                    <span class="s1">stat.condition = cons_seq(stat.condition);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                    <span class="s1">stat.expression = cons_seq(stat.expression);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_With) {</span>
                    <span class="s1">stat.expression = cons_seq(stat.expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(compressor.option(</span><span class="s2">&quot;conditionals&quot;</span><span class="s1">) &amp;&amp; stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                <span class="s3">var </span><span class="s1">decls = [];</span>
                <span class="s3">var </span><span class="s1">body = to_simple_statement(stat.body, decls);</span>
                <span class="s3">var </span><span class="s1">alt = to_simple_statement(stat.alternative, decls);</span>
                <span class="s3">if </span><span class="s1">(body !== </span><span class="s3">false </span><span class="s1">&amp;&amp; alt !== </span><span class="s3">false </span><span class="s1">&amp;&amp; decls.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">var </span><span class="s1">len = decls.length;</span>
                    <span class="s1">decls.push(make_node(AST_If, stat, {</span>
                        <span class="s1">condition: stat.condition,</span>
                        <span class="s1">body: body || make_node(AST_EmptyStatement, stat.body),</span>
                        <span class="s1">alternative: alt</span>
                    <span class="s1">}));</span>
                    <span class="s1">decls.unshift(n, </span><span class="s4">1</span><span class="s1">);</span>
                    <span class="s1">[].splice.apply(statements, decls);</span>
                    <span class="s1">i += len;</span>
                    <span class="s1">n += len + </span><span class="s4">1</span><span class="s1">;</span>
                    <span class="s1">prev = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">continue</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">statements[n++] = stat;</span>
            <span class="s1">prev = stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement ? stat : </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">statements.length = n;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">join_object_assignments(defn, body) {</span>
        <span class="s3">if </span><span class="s1">(!(defn </span><span class="s3">instanceof </span><span class="s1">AST_Definitions))</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">def = defn.definitions[defn.definitions.length - </span><span class="s4">1</span><span class="s1">];</span>
        <span class="s3">if </span><span class="s1">(!(def.value </span><span class="s3">instanceof </span><span class="s1">AST_Object))</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">exprs;</span>
        <span class="s3">if </span><span class="s1">(body </span><span class="s3">instanceof </span><span class="s1">AST_Assign &amp;&amp; !body.logical) {</span>
            <span class="s1">exprs = [body];</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(body </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
            <span class="s1">exprs = body.expressions.slice();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!exprs)</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s3">var </span><span class="s1">trimmed = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">do </span><span class="s1">{</span>
            <span class="s3">var </span><span class="s1">node = exprs[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(!(node </span><span class="s3">instanceof </span><span class="s1">AST_Assign))</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(node.operator != </span><span class="s2">&quot;=&quot;</span><span class="s1">)</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!(node.left </span><span class="s3">instanceof </span><span class="s1">AST_PropAccess))</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">sym = node.left.expression;</span>
            <span class="s3">if </span><span class="s1">(!(sym </span><span class="s3">instanceof </span><span class="s1">AST_SymbolRef))</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(def.name.name != sym.name)</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(!node.right.is_constant_expression(nearest_scope))</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">prop = node.left.property;</span>
            <span class="s3">if </span><span class="s1">(prop </span><span class="s3">instanceof </span><span class="s1">AST_Node) {</span>
                <span class="s1">prop = prop.evaluate(compressor);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(prop </span><span class="s3">instanceof </span><span class="s1">AST_Node)</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s1">prop = </span><span class="s2">&quot;&quot; </span><span class="s1">+ prop;</span>
            <span class="s3">var </span><span class="s1">diff = compressor.option(</span><span class="s2">&quot;ecma&quot;</span><span class="s1">) &lt; </span><span class="s4">2015</span>
                <span class="s1">&amp;&amp; compressor.has_directive(</span><span class="s2">&quot;use strict&quot;</span><span class="s1">) ? </span><span class="s3">function </span><span class="s1">(node) {</span>
                    <span class="s3">return </span><span class="s1">node.key != prop &amp;&amp; (node.key &amp;&amp; node.key.name != prop);</span>
                <span class="s1">} : </span><span class="s3">function </span><span class="s1">(node) {</span>
                    <span class="s3">return </span><span class="s1">node.key &amp;&amp; node.key.name != prop;</span>
                <span class="s1">};</span>
            <span class="s3">if </span><span class="s1">(!def.value.properties.every(diff))</span>
                <span class="s3">break</span><span class="s1">;</span>
            <span class="s3">var </span><span class="s1">p = def.value.properties.filter(</span><span class="s3">function </span><span class="s1">(p) { </span><span class="s3">return </span><span class="s1">p.key === prop; })[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s3">if </span><span class="s1">(!p) {</span>
                <span class="s1">def.value.properties.push(make_node(AST_ObjectKeyVal, node, {</span>
                    <span class="s1">key: prop,</span>
                    <span class="s1">value: node.right</span>
                <span class="s1">}));</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">p.value = </span><span class="s3">new </span><span class="s1">AST_Sequence({</span>
                    <span class="s1">start: p.start,</span>
                    <span class="s1">expressions: [p.value.clone(), node.right.clone()],</span>
                    <span class="s1">end: p.end</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">exprs.shift();</span>
            <span class="s1">trimmed = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s3">while </span><span class="s1">(exprs.length);</span>
        <span class="s3">return </span><span class="s1">trimmed &amp;&amp; exprs;</span>
    <span class="s1">}</span>

    <span class="s3">function </span><span class="s1">join_consecutive_vars(statements) {</span>
        <span class="s3">var </span><span class="s1">defs;</span>
        <span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, j = -</span><span class="s4">1</span><span class="s1">, len = statements.length; i &lt; len; i++) {</span>
            <span class="s3">var </span><span class="s1">stat = statements[i];</span>
            <span class="s3">var </span><span class="s1">prev = statements[j];</span>
            <span class="s3">if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Definitions) {</span>
                <span class="s3">if </span><span class="s1">(prev &amp;&amp; prev.TYPE == stat.TYPE) {</span>
                    <span class="s1">prev.definitions = prev.definitions.concat(stat.definitions);</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(defs &amp;&amp; defs.TYPE == stat.TYPE &amp;&amp; declarations_only(stat)) {</span>
                    <span class="s1">defs.definitions = defs.definitions.concat(stat.definitions);</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">statements[++j] = stat;</span>
                    <span class="s1">defs = stat;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Exit) {</span>
                <span class="s1">stat.value = extract_object_assignments(stat.value);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_For) {</span>
                <span class="s3">var </span><span class="s1">exprs = join_object_assignments(prev, stat.init);</span>
                <span class="s3">if </span><span class="s1">(exprs) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s1">stat.init = exprs.length ? make_sequence(stat.init, exprs) : </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">statements[++j] = stat;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
                    <span class="s1">prev </span><span class="s3">instanceof </span><span class="s1">AST_Var</span>
                    <span class="s1">&amp;&amp; (!stat.init || stat.init.TYPE == prev.TYPE)</span>
                <span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(stat.init) {</span>
                        <span class="s1">prev.definitions = prev.definitions.concat(stat.init.definitions);</span>
                    <span class="s1">}</span>
                    <span class="s1">stat.init = prev;</span>
                    <span class="s1">statements[j] = stat;</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(</span>
                    <span class="s1">defs </span><span class="s3">instanceof </span><span class="s1">AST_Var</span>
                    <span class="s1">&amp;&amp; stat.init </span><span class="s3">instanceof </span><span class="s1">AST_Var</span>
                    <span class="s1">&amp;&amp; declarations_only(stat.init)</span>
                <span class="s1">) {</span>
                    <span class="s1">defs.definitions = defs.definitions.concat(stat.init.definitions);</span>
                    <span class="s1">stat.init = </span><span class="s3">null</span><span class="s1">;</span>
                    <span class="s1">statements[++j] = stat;</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">statements[++j] = stat;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_ForIn) {</span>
                <span class="s1">stat.object = extract_object_assignments(stat.object);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_If) {</span>
                <span class="s1">stat.condition = extract_object_assignments(stat.condition);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_SimpleStatement) {</span>
                <span class="s3">var </span><span class="s1">exprs = join_object_assignments(prev, stat.body);</span>
                <span class="s3">if </span><span class="s1">(exprs) {</span>
                    <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                    <span class="s3">if </span><span class="s1">(!exprs.length)</span>
                        <span class="s3">continue</span><span class="s1">;</span>
                    <span class="s1">stat.body = make_sequence(stat.body, exprs);</span>
                <span class="s1">}</span>
                <span class="s1">statements[++j] = stat;</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_Switch) {</span>
                <span class="s1">stat.expression = extract_object_assignments(stat.expression);</span>
            <span class="s1">} </span><span class="s3">else if </span><span class="s1">(stat </span><span class="s3">instanceof </span><span class="s1">AST_With) {</span>
                <span class="s1">stat.expression = extract_object_assignments(stat.expression);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">statements[++j] = stat;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">statements.length = j + </span><span class="s4">1</span><span class="s1">;</span>

        <span class="s3">function </span><span class="s1">extract_object_assignments(value) {</span>
            <span class="s1">statements[++j] = stat;</span>
            <span class="s3">var </span><span class="s1">exprs = join_object_assignments(prev, value);</span>
            <span class="s3">if </span><span class="s1">(exprs) {</span>
                <span class="s1">CHANGED = </span><span class="s3">true</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(exprs.length) {</span>
                    <span class="s3">return </span><span class="s1">make_sequence(value, exprs);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(value </span><span class="s3">instanceof </span><span class="s1">AST_Sequence) {</span>
                    <span class="s3">return </span><span class="s1">value.tail_node().left;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s3">return </span><span class="s1">value.left;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">return </span><span class="s1">value;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>
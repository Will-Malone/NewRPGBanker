<html>
<head>
<title>legacy.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #4646f1;}
.s6 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
legacy.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>

<span class="s2">function </span><span class="s1">_typeof(obj) { </span><span class="s0">&quot;@babel/helpers - typeof&quot;</span><span class="s1">; </span><span class="s2">return </span><span class="s1">_typeof = </span><span class="s0">&quot;function&quot; </span><span class="s1">== </span><span class="s2">typeof </span><span class="s1">Symbol &amp;&amp; </span><span class="s0">&quot;symbol&quot; </span><span class="s1">== </span><span class="s2">typeof </span><span class="s1">Symbol.iterator ? </span><span class="s2">function </span><span class="s1">(obj) { </span><span class="s2">return typeof </span><span class="s1">obj; } : </span><span class="s2">function </span><span class="s1">(obj) { </span><span class="s2">return </span><span class="s1">obj &amp;&amp; </span><span class="s0">&quot;function&quot; </span><span class="s1">== </span><span class="s2">typeof </span><span class="s1">Symbol &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s0">&quot;symbol&quot; </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">obj; }, _typeof(obj); }</span>
<span class="s2">function </span><span class="s1">_defineProperties(target, props) { </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; props.length; i++) { </span><span class="s2">var </span><span class="s1">descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || </span><span class="s2">false</span><span class="s1">; descriptor.configurable = </span><span class="s2">true</span><span class="s1">; </span><span class="s2">if </span><span class="s1">(</span><span class="s0">&quot;value&quot; </span><span class="s2">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s2">true</span><span class="s1">; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }</span>
<span class="s2">function </span><span class="s1">_createClass(Constructor, protoProps, staticProps) { </span><span class="s2">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype, protoProps); </span><span class="s2">if </span><span class="s1">(staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, </span><span class="s0">&quot;prototype&quot;</span><span class="s1">, { writable: </span><span class="s2">false </span><span class="s1">}); </span><span class="s2">return </span><span class="s1">Constructor; }</span>
<span class="s2">function </span><span class="s1">_toPropertyKey(arg) { </span><span class="s2">var </span><span class="s1">key = _toPrimitive(arg, </span><span class="s0">&quot;string&quot;</span><span class="s1">); </span><span class="s2">return </span><span class="s1">_typeof(key) === </span><span class="s0">&quot;symbol&quot; </span><span class="s1">? key : String(key); }</span>
<span class="s2">function </span><span class="s1">_toPrimitive(input, hint) { </span><span class="s2">if </span><span class="s1">(_typeof(input) !== </span><span class="s0">&quot;object&quot; </span><span class="s1">|| input === </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">input; </span><span class="s2">var </span><span class="s1">prim = input[Symbol.toPrimitive]; </span><span class="s2">if </span><span class="s1">(prim !== undefined) { </span><span class="s2">var </span><span class="s1">res = prim.call(input, hint || </span><span class="s0">&quot;default&quot;</span><span class="s1">); </span><span class="s2">if </span><span class="s1">(_typeof(res) !== </span><span class="s0">&quot;object&quot;</span><span class="s1">) </span><span class="s2">return </span><span class="s1">res; </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;@@toPrimitive must return a primitive value.&quot;</span><span class="s1">); } </span><span class="s2">return </span><span class="s1">(hint === </span><span class="s0">&quot;string&quot; </span><span class="s1">? String : Number)(input); }</span>
<span class="s2">function </span><span class="s1">_classCallCheck(instance, Constructor) { </span><span class="s2">if </span><span class="s1">(!(instance </span><span class="s2">instanceof </span><span class="s1">Constructor)) { </span><span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Cannot call a class as a function&quot;</span><span class="s1">); } }</span>
<span class="s4">// A simple implementation of make-array</span>
<span class="s2">function </span><span class="s1">makeArray(subject) {</span>
  <span class="s2">return </span><span class="s1">Array.isArray(subject) ? subject : [subject];</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">EMPTY = </span><span class="s0">''</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">SPACE = </span><span class="s0">' '</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">ESCAPE = </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">'</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">REGEX_TEST_BLANK_LINE = /^\s+$/;</span>
<span class="s2">var </span><span class="s1">REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;</span>
<span class="s2">var </span><span class="s1">REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;</span>
<span class="s2">var </span><span class="s1">REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;</span>
<span class="s2">var </span><span class="s1">REGEX_SPLITALL_CRLF = /\r?\n/g;</span>
<span class="s4">// /foo,</span>
<span class="s4">// ./foo,</span>
<span class="s4">// ../foo,</span>
<span class="s4">// .</span>
<span class="s4">// ..</span>
<span class="s2">var </span><span class="s1">REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;</span>
<span class="s2">var </span><span class="s1">SLASH = </span><span class="s0">'/'</span><span class="s1">;</span>

<span class="s4">// Do not use ternary expression here, since &quot;istanbul ignore next&quot; is buggy</span>
<span class="s2">var </span><span class="s1">TMP_KEY_IGNORE = </span><span class="s0">'node-ignore'</span><span class="s1">;</span>
<span class="s4">/* istanbul ignore else */</span>
<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Symbol !== </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">TMP_KEY_IGNORE = Symbol[</span><span class="s0">&quot;for&quot;</span><span class="s1">](</span><span class="s0">'node-ignore'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">KEY_IGNORE = TMP_KEY_IGNORE;</span>
<span class="s2">var </span><span class="s1">define = </span><span class="s2">function </span><span class="s1">define(object, key, value) {</span>
  <span class="s2">return </span><span class="s1">Object.defineProperty(object, key, {</span>
    <span class="s1">value: value</span>
  <span class="s1">});</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">REGEX_REGEXP_RANGE = /([</span><span class="s3">0</span><span class="s1">-z])-([</span><span class="s3">0</span><span class="s1">-z])/g;</span>
<span class="s2">var </span><span class="s1">RETURN_FALSE = </span><span class="s2">function </span><span class="s1">RETURN_FALSE() {</span>
  <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s4">// Sanitize the range of a regular expression</span>
<span class="s4">// The cases are complicated, see test cases for details</span>
<span class="s2">var </span><span class="s1">sanitizeRange = </span><span class="s2">function </span><span class="s1">sanitizeRange(range) {</span>
  <span class="s2">return </span><span class="s1">range.replace(REGEX_REGEXP_RANGE, </span><span class="s2">function </span><span class="s1">(match, from, to) {</span>
    <span class="s2">return </span><span class="s1">from.charCodeAt(</span><span class="s3">0</span><span class="s1">) &lt;= to.charCodeAt(</span><span class="s3">0</span><span class="s1">) ? match</span>
    <span class="s4">// Invalid range (out of order) which is ok for gitignore rules but</span>
    <span class="s4">//   fatal for JavaScript regular expression, so eliminate it.</span>
    <span class="s1">: EMPTY;</span>
  <span class="s1">});</span>
<span class="s1">};</span>

<span class="s4">// See fixtures #59</span>
<span class="s2">var </span><span class="s1">cleanRangeBackSlash = </span><span class="s2">function </span><span class="s1">cleanRangeBackSlash(slashes) {</span>
  <span class="s2">var </span><span class="s1">length = slashes.length;</span>
  <span class="s2">return </span><span class="s1">slashes.slice(</span><span class="s3">0</span><span class="s1">, length - length % </span><span class="s3">2</span><span class="s1">);</span>
<span class="s1">};</span>

<span class="s4">// &gt; If the pattern ends with a slash,</span>
<span class="s4">// &gt; it is removed for the purpose of the following description,</span>
<span class="s4">// &gt; but it would only find a match with a directory.</span>
<span class="s4">// &gt; In other words, foo/ will match a directory foo and paths underneath it,</span>
<span class="s4">// &gt; but will not match a regular file or a symbolic link foo</span>
<span class="s4">// &gt;  (this is consistent with the way how pathspec works in general in Git).</span>
<span class="s4">// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'</span>
<span class="s4">// -&gt; ignore-rules will not deal with it, because it costs extra `fs.stat` call</span>
<span class="s4">//      you could use option `mark: true` with `glob`</span>

<span class="s4">// '`foo/`' should not continue with the '`..`'</span>
<span class="s2">var </span><span class="s1">REPLACERS = [</span>
<span class="s4">// &gt; Trailing spaces are ignored unless they are quoted with backslash (&quot;\&quot;)</span>
<span class="s1">[</span>
<span class="s4">// (a\ ) -&gt; (a )</span>
<span class="s4">// (a  ) -&gt; (a)</span>
<span class="s4">// (a \ ) -&gt; (a  )</span>
<span class="s1">/\\?\s+$/, </span><span class="s2">function </span><span class="s1">(match) {</span>
  <span class="s2">return </span><span class="s1">match.indexOf(</span><span class="s0">'</span><span class="s5">\\</span><span class="s0">'</span><span class="s1">) === </span><span class="s3">0 </span><span class="s1">? SPACE : EMPTY;</span>
<span class="s1">}],</span>
<span class="s4">// replace (\ ) with ' '</span>
<span class="s1">[/\\\s/g, </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s1">SPACE;</span>
<span class="s1">}],</span>
<span class="s4">// Escape metacharacters</span>
<span class="s4">// which is written down by users but means special for regular expressions.</span>

<span class="s4">// &gt; There are 12 characters with special meanings:</span>
<span class="s4">// &gt; - the backslash \,</span>
<span class="s4">// &gt; - the caret ^,</span>
<span class="s4">// &gt; - the dollar sign $,</span>
<span class="s4">// &gt; - the period or dot .,</span>
<span class="s4">// &gt; - the vertical bar or pipe symbol |,</span>
<span class="s4">// &gt; - the question mark ?,</span>
<span class="s4">// &gt; - the asterisk or star *,</span>
<span class="s4">// &gt; - the plus sign +,</span>
<span class="s4">// &gt; - the opening parenthesis (,</span>
<span class="s4">// &gt; - the closing parenthesis ),</span>
<span class="s4">// &gt; - and the opening square bracket [,</span>
<span class="s4">// &gt; - the opening curly brace {,</span>
<span class="s4">// &gt; These special characters are often called &quot;metacharacters&quot;.</span>
<span class="s1">[/[\\$.|*+(){^]/g, </span><span class="s2">function </span><span class="s1">(match) {</span>
  <span class="s2">return </span><span class="s0">&quot;</span><span class="s5">\\</span><span class="s0">&quot;</span><span class="s1">.concat(match);</span>
<span class="s1">}], [</span>
<span class="s4">// &gt; a question mark (?) matches a single character</span>
<span class="s1">/(?!\\)\?/g, </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s0">'[^/]'</span><span class="s1">;</span>
<span class="s1">}],</span>
<span class="s4">// leading slash</span>
<span class="s1">[</span>
<span class="s4">// &gt; A leading slash matches the beginning of the pathname.</span>
<span class="s4">// &gt; For example, &quot;/*.c&quot; matches &quot;cat-file.c&quot; but not &quot;mozilla-sha1/sha1.c&quot;.</span>
<span class="s4">// A leading slash matches the beginning of the pathname</span>
<span class="s1">/^\</span><span class="s4">//, function () {</span>
  <span class="s2">return </span><span class="s0">'^'</span><span class="s1">;</span>
<span class="s1">}],</span>
<span class="s4">// replace special metacharacter slash after the leading slash</span>
<span class="s1">[/\</span><span class="s4">//g, function () {</span>
  <span class="s2">return </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">/'</span><span class="s1">;</span>
<span class="s1">}], [</span>
<span class="s4">// &gt; A leading &quot;**&quot; followed by a slash means match in all directories.</span>
<span class="s4">// &gt; For example, &quot;**/foo&quot; matches file or directory &quot;foo&quot; anywhere,</span>
<span class="s4">// &gt; the same as pattern &quot;foo&quot;.</span>
<span class="s4">// &gt; &quot;**/foo/bar&quot; matches file or directory &quot;bar&quot; anywhere that is directly</span>
<span class="s4">// &gt;   under directory &quot;foo&quot;.</span>
<span class="s4">// Notice that the '*'s have been replaced as '\\*'</span>
<span class="s1">/^\^*\\\*\\\*\\\</span><span class="s4">//,</span>
<span class="s4">// '**/foo' &lt;-&gt; 'foo'</span>
<span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s0">'^(?:.*</span><span class="s5">\\</span><span class="s0">/)?'</span><span class="s1">;</span>
<span class="s1">}],</span>
<span class="s4">// starting</span>
<span class="s1">[</span>
<span class="s4">// there will be no leading '/'</span>
<span class="s4">//   (which has been replaced by section &quot;leading slash&quot;)</span>
<span class="s4">// If starts with '**', adding a '^' to the regular expression also works</span>
<span class="s1">/^(?=[^^])/, </span><span class="s2">function </span><span class="s1">startingReplacer() {</span>
  <span class="s4">// If has a slash `/` at the beginning or middle</span>
  <span class="s2">return </span><span class="s1">!/\/(?!$)/.test(</span><span class="s2">this</span><span class="s1">)</span>
  <span class="s4">// &gt; Prior to 2.22.1</span>
  <span class="s4">// &gt; If the pattern does not contain a slash /,</span>
  <span class="s4">// &gt;   Git treats it as a shell glob pattern</span>
  <span class="s4">// Actually, if there is only a trailing slash,</span>
  <span class="s4">//   git also treats it as a shell glob pattern</span>

  <span class="s4">// After 2.22.1 (compatible but clearer)</span>
  <span class="s4">// &gt; If there is a separator at the beginning or middle (or both)</span>
  <span class="s4">// &gt; of the pattern, then the pattern is relative to the directory</span>
  <span class="s4">// &gt; level of the particular .gitignore file itself.</span>
  <span class="s4">// &gt; Otherwise the pattern may also match at any level below</span>
  <span class="s4">// &gt; the .gitignore level.</span>
  <span class="s1">? </span><span class="s0">'(?:^|</span><span class="s5">\\</span><span class="s0">/)'</span>

  <span class="s4">// &gt; Otherwise, Git treats the pattern as a shell glob suitable for</span>
  <span class="s4">// &gt;   consumption by fnmatch(3)</span>
  <span class="s1">: </span><span class="s0">'^'</span><span class="s1">;</span>
<span class="s1">}],</span>
<span class="s4">// two globstars</span>
<span class="s1">[</span>
<span class="s4">// Use lookahead assertions so that we could match more than one `'/**'`</span>
<span class="s1">/\\\/\\\*\\\*(?=\\\/|$)/g,</span>
<span class="s4">// Zero, one or several directories</span>
<span class="s4">// should not use '*', or it will be replaced by the next replacer</span>

<span class="s4">// Check if it is not the last `'/**'`</span>
<span class="s2">function </span><span class="s1">(_, index, str) {</span>
  <span class="s2">return </span><span class="s1">index + </span><span class="s3">6 </span><span class="s1">&lt; str.length</span>

  <span class="s4">// case: /**/</span>
  <span class="s4">// &gt; A slash followed by two consecutive asterisks then a slash matches</span>
  <span class="s4">// &gt;   zero or more directories.</span>
  <span class="s4">// &gt; For example, &quot;a/**/b&quot; matches &quot;a/b&quot;, &quot;a/x/b&quot;, &quot;a/x/y/b&quot; and so on.</span>
  <span class="s4">// '/**/'</span>
  <span class="s1">? </span><span class="s0">'(?:</span><span class="s5">\\</span><span class="s0">/[^</span><span class="s5">\\</span><span class="s0">/]+)*'</span>

  <span class="s4">// case: /**</span>
  <span class="s4">// &gt; A trailing `&quot;/**&quot;` matches everything inside.</span>

  <span class="s4">// #21: everything inside but it should not include the current folder</span>
  <span class="s1">: </span><span class="s0">'</span><span class="s5">\\</span><span class="s0">/.+'</span><span class="s1">;</span>
<span class="s1">}],</span>
<span class="s4">// normal intermediate wildcards</span>
<span class="s1">[</span>
<span class="s4">// Never replace escaped '*'</span>
<span class="s4">// ignore rule '\*' will match the path '*'</span>

<span class="s4">// 'abc.*/' -&gt; go</span>
<span class="s4">// 'abc.*'  -&gt; skip this rule,</span>
<span class="s4">//    coz trailing single wildcard will be handed by [trailing wildcard]</span>
<span class="s1">/(^|[^\\]+)(\\\*)+(?=.+)/g,</span>
<span class="s4">// '*.js' matches '.js'</span>
<span class="s4">// '*.js' doesn't match 'abc'</span>
<span class="s2">function </span><span class="s1">(_, p1, p2) {</span>
  <span class="s4">// 1.</span>
  <span class="s4">// &gt; An asterisk &quot;*&quot; matches anything except a slash.</span>
  <span class="s4">// 2.</span>
  <span class="s4">// &gt; Other consecutive asterisks are considered regular asterisks</span>
  <span class="s4">// &gt; and will match according to the previous rules.</span>
  <span class="s2">var </span><span class="s1">unescaped = p2.replace(/\\\*/g, </span><span class="s0">'[^</span><span class="s5">\\</span><span class="s0">/]*'</span><span class="s1">);</span>
  <span class="s2">return </span><span class="s1">p1 + unescaped;</span>
<span class="s1">}], [</span>
<span class="s4">// unescape, revert step 3 except for back slash</span>
<span class="s4">// For example, if a user escape a '\\*',</span>
<span class="s4">// after step 3, the result will be '\\\\\\*'</span>
<span class="s1">/\\\\\\(?=[$.|*+(){^])/g, </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s1">ESCAPE;</span>
<span class="s1">}], [</span>
<span class="s4">// '\\\\' -&gt; '\\'</span>
<span class="s1">/\\\\/g, </span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">return </span><span class="s1">ESCAPE;</span>
<span class="s1">}], [</span>
<span class="s4">// &gt; The range notation, e.g. [a-zA-Z],</span>
<span class="s4">// &gt; can be used to match one of the characters in a range.</span>

<span class="s4">// `\` is escaped by step 3</span>
<span class="s1">/(\\)?\[([^\]/]*?)(\\*)($|\])/g, </span><span class="s2">function </span><span class="s1">(match, leadEscape, range, endEscape, close) {</span>
  <span class="s2">return </span><span class="s1">leadEscape === ESCAPE</span>
  <span class="s4">// '\\[bar]' -&gt; '\\\\[bar\\]'</span>
  <span class="s1">? </span><span class="s0">&quot;</span><span class="s5">\\</span><span class="s0">[&quot;</span><span class="s1">.concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === </span><span class="s0">']' </span><span class="s1">? endEscape.length % </span><span class="s3">2 </span><span class="s1">=== </span><span class="s3">0</span>
  <span class="s4">// A normal case, and it is a range notation</span>
  <span class="s4">// '[bar]'</span>
  <span class="s4">// '[bar\\\\]'</span>
  <span class="s1">? </span><span class="s0">&quot;[&quot;</span><span class="s1">.concat(sanitizeRange(range)).concat(endEscape, </span><span class="s0">&quot;]&quot;</span><span class="s1">) </span><span class="s4">// Invalid range notaton</span>
  <span class="s4">// '[bar\\]' -&gt; '[bar\\\\]'</span>
  <span class="s1">: </span><span class="s0">'[]' </span><span class="s1">: </span><span class="s0">'[]'</span><span class="s1">;</span>
<span class="s1">}],</span>
<span class="s4">// ending</span>
<span class="s1">[</span>
<span class="s4">// 'js' will not match 'js.'</span>
<span class="s4">// 'ab' will not match 'abc'</span>
<span class="s1">/(?:[^*])$/,</span>
<span class="s4">// WTF!</span>
<span class="s4">// https://git-scm.com/docs/gitignore</span>
<span class="s4">// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)</span>
<span class="s4">// which re-fixes #24, #38</span>

<span class="s4">// &gt; If there is a separator at the end of the pattern then the pattern</span>
<span class="s4">// &gt; will only match directories, otherwise the pattern can match both</span>
<span class="s4">// &gt; files and directories.</span>

<span class="s4">// 'js*' will not match 'a.js'</span>
<span class="s4">// 'js/' will not match 'a.js'</span>
<span class="s4">// 'js' will match 'a.js' and 'a.js/'</span>
<span class="s2">function </span><span class="s1">(match) {</span>
  <span class="s2">return </span><span class="s1">/\/$/.test(match)</span>
  <span class="s4">// foo/ will not match 'foo'</span>
  <span class="s1">? </span><span class="s0">&quot;&quot;</span><span class="s1">.concat(match, </span><span class="s0">&quot;$&quot;</span><span class="s1">) </span><span class="s4">// foo matches 'foo' and 'foo/'</span>
  <span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">.concat(match, </span><span class="s0">&quot;(?=$|</span><span class="s5">\\</span><span class="s0">/$)&quot;</span><span class="s1">);</span>
<span class="s1">}],</span>
<span class="s4">// trailing wildcard</span>
<span class="s1">[/(\^|\\\/)?\\\*$/, </span><span class="s2">function </span><span class="s1">(_, p1) {</span>
  <span class="s2">var </span><span class="s1">prefix = p1</span>
  <span class="s4">// '\^':</span>
  <span class="s4">// '/*' does not match EMPTY</span>
  <span class="s4">// '/*' does not match everything</span>

  <span class="s4">// '\\\/':</span>
  <span class="s4">// 'abc/*' does not match 'abc/'</span>
  <span class="s1">? </span><span class="s0">&quot;&quot;</span><span class="s1">.concat(p1, </span><span class="s0">&quot;[^/]+&quot;</span><span class="s1">) </span><span class="s4">// 'a*' matches 'a'</span>
  <span class="s4">// 'a*' matches 'aa'</span>
  <span class="s1">: </span><span class="s0">'[^/]*'</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s0">&quot;&quot;</span><span class="s1">.concat(prefix, </span><span class="s0">&quot;(?=$|</span><span class="s5">\\</span><span class="s0">/$)&quot;</span><span class="s1">);</span>
<span class="s1">}]];</span>

<span class="s4">// A simple cache, because an ignore rule only has only one certain meaning</span>
<span class="s2">var </span><span class="s1">regexCache = Object.create(</span><span class="s2">null</span><span class="s1">);</span>

<span class="s4">// @param {pattern}</span>
<span class="s2">var </span><span class="s1">makeRegex = </span><span class="s2">function </span><span class="s1">makeRegex(pattern, ignoreCase) {</span>
  <span class="s2">var </span><span class="s1">source = regexCache[pattern];</span>
  <span class="s2">if </span><span class="s1">(!source) {</span>
    <span class="s1">source = REPLACERS.reduce(</span><span class="s2">function </span><span class="s1">(prev, current) {</span>
      <span class="s2">return </span><span class="s1">prev.replace(current[</span><span class="s3">0</span><span class="s1">], current[</span><span class="s3">1</span><span class="s1">].bind(pattern));</span>
    <span class="s1">}, pattern);</span>
    <span class="s1">regexCache[pattern] = source;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ignoreCase ? </span><span class="s2">new </span><span class="s1">RegExp(source, </span><span class="s0">'i'</span><span class="s1">) : </span><span class="s2">new </span><span class="s1">RegExp(source);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">isString = </span><span class="s2">function </span><span class="s1">isString(subject) {</span>
  <span class="s2">return typeof </span><span class="s1">subject === </span><span class="s0">'string'</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s4">// &gt; A blank line matches no files, so it can serve as a separator for readability.</span>
<span class="s2">var </span><span class="s1">checkPattern = </span><span class="s2">function </span><span class="s1">checkPattern(pattern) {</span>
  <span class="s2">return </span><span class="s1">pattern &amp;&amp; isString(pattern) &amp;&amp; !REGEX_TEST_BLANK_LINE.test(pattern) &amp;&amp; !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)</span>

  <span class="s4">// &gt; A line starting with # serves as a comment.</span>
  <span class="s1">&amp;&amp; pattern.indexOf(</span><span class="s0">'#'</span><span class="s1">) !== </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">splitPattern = </span><span class="s2">function </span><span class="s1">splitPattern(pattern) {</span>
  <span class="s2">return </span><span class="s1">pattern.split(REGEX_SPLITALL_CRLF);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">IgnoreRule = </span><span class="s4">/*#__PURE__*/</span><span class="s1">_createClass(</span><span class="s2">function </span><span class="s1">IgnoreRule(origin, pattern, negative, regex) {</span>
  <span class="s1">_classCallCheck(</span><span class="s2">this</span><span class="s1">, IgnoreRule);</span>
  <span class="s2">this</span><span class="s1">.origin = origin;</span>
  <span class="s2">this</span><span class="s1">.pattern = pattern;</span>
  <span class="s2">this</span><span class="s1">.negative = negative;</span>
  <span class="s2">this</span><span class="s1">.regex = regex;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">createRule = </span><span class="s2">function </span><span class="s1">createRule(pattern, ignoreCase) {</span>
  <span class="s2">var </span><span class="s1">origin = pattern;</span>
  <span class="s2">var </span><span class="s1">negative = </span><span class="s2">false</span><span class="s1">;</span>

  <span class="s4">// &gt; An optional prefix &quot;!&quot; which negates the pattern;</span>
  <span class="s2">if </span><span class="s1">(pattern.indexOf(</span><span class="s0">'!'</span><span class="s1">) === </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">negative = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">pattern = pattern.substr(</span><span class="s3">1</span><span class="s1">);</span>
  <span class="s1">}</span>
  <span class="s1">pattern = pattern</span>
  <span class="s4">// &gt; Put a backslash (&quot;\&quot;) in front of the first &quot;!&quot; for patterns that</span>
  <span class="s4">// &gt;   begin with a literal &quot;!&quot;, for example, `&quot;\!important!.txt&quot;`.</span>
  <span class="s1">.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, </span><span class="s0">'!'</span><span class="s1">)</span>
  <span class="s4">// &gt; Put a backslash (&quot;\&quot;) in front of the first hash for patterns that</span>
  <span class="s4">// &gt;   begin with a hash.</span>
  <span class="s1">.replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, </span><span class="s0">'#'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">regex = makeRegex(pattern, ignoreCase);</span>
  <span class="s2">return new </span><span class="s1">IgnoreRule(origin, pattern, negative, regex);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">throwError = </span><span class="s2">function </span><span class="s1">throwError(message, Ctor) {</span>
  <span class="s2">throw new </span><span class="s1">Ctor(message);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">checkPath = </span><span class="s2">function </span><span class="s1">checkPath(path, originalPath, doThrow) {</span>
  <span class="s2">if </span><span class="s1">(!isString(path)) {</span>
    <span class="s2">return </span><span class="s1">doThrow(</span><span class="s0">&quot;path must be a string, but got `&quot;</span><span class="s1">.concat(originalPath, </span><span class="s0">&quot;`&quot;</span><span class="s1">), TypeError);</span>
  <span class="s1">}</span>

  <span class="s4">// We don't know if we should ignore EMPTY, so throw</span>
  <span class="s2">if </span><span class="s1">(!path) {</span>
    <span class="s2">return </span><span class="s1">doThrow(</span><span class="s0">&quot;path must not be empty&quot;</span><span class="s1">, TypeError);</span>
  <span class="s1">}</span>

  <span class="s4">// Check if it is a relative path</span>
  <span class="s2">if </span><span class="s1">(checkPath.isNotRelative(path)) {</span>
    <span class="s2">var </span><span class="s1">r = </span><span class="s0">'`path.relative()`d'</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">doThrow(</span><span class="s0">&quot;path should be a &quot;</span><span class="s1">.concat(r, </span><span class="s0">&quot; string, but got </span><span class="s5">\&quot;</span><span class="s0">&quot;</span><span class="s1">).concat(originalPath, </span><span class="s0">&quot;</span><span class="s5">\&quot;</span><span class="s0">&quot;</span><span class="s1">), RangeError);</span>
  <span class="s1">}</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">isNotRelative = </span><span class="s2">function </span><span class="s1">isNotRelative(path) {</span>
  <span class="s2">return </span><span class="s1">REGEX_TEST_INVALID_PATH.test(path);</span>
<span class="s1">};</span>
<span class="s1">checkPath.isNotRelative = isNotRelative;</span>
<span class="s1">checkPath.convert = </span><span class="s2">function </span><span class="s1">(p) {</span>
  <span class="s2">return </span><span class="s1">p;</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">Ignore = </span><span class="s4">/*#__PURE__*/</span><span class="s2">function </span><span class="s1">() {</span>
  <span class="s2">function </span><span class="s1">Ignore() {</span>
    <span class="s2">var </span><span class="s1">_ref = arguments.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; arguments[</span><span class="s3">0</span><span class="s1">] !== undefined ? arguments[</span><span class="s3">0</span><span class="s1">] : {},</span>
      <span class="s1">_ref$ignorecase = _ref.ignorecase,</span>
      <span class="s1">ignorecase = _ref$ignorecase === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">true </span><span class="s1">: _ref$ignorecase,</span>
      <span class="s1">_ref$ignoreCase = _ref.ignoreCase,</span>
      <span class="s1">ignoreCase = _ref$ignoreCase === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? ignorecase : _ref$ignoreCase,</span>
      <span class="s1">_ref$allowRelativePat = _ref.allowRelativePaths,</span>
      <span class="s1">allowRelativePaths = _ref$allowRelativePat === </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: _ref$allowRelativePat;</span>
    <span class="s1">_classCallCheck(</span><span class="s2">this</span><span class="s1">, Ignore);</span>
    <span class="s1">define(</span><span class="s2">this</span><span class="s1">, KEY_IGNORE, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">this</span><span class="s1">._rules = [];</span>
    <span class="s2">this</span><span class="s1">._ignoreCase = ignoreCase;</span>
    <span class="s2">this</span><span class="s1">._allowRelativePaths = allowRelativePaths;</span>
    <span class="s2">this</span><span class="s1">._initCache();</span>
  <span class="s1">}</span>
  <span class="s1">_createClass(Ignore, [{</span>
    <span class="s1">key: </span><span class="s0">&quot;_initCache&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">_initCache() {</span>
      <span class="s2">this</span><span class="s1">._ignoreCache = Object.create(</span><span class="s2">null</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">._testCache = Object.create(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;_addPattern&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">_addPattern(pattern) {</span>
      <span class="s4">// #32</span>
      <span class="s2">if </span><span class="s1">(pattern &amp;&amp; pattern[KEY_IGNORE]) {</span>
        <span class="s2">this</span><span class="s1">._rules = </span><span class="s2">this</span><span class="s1">._rules.concat(pattern._rules);</span>
        <span class="s2">this</span><span class="s1">._added = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(checkPattern(pattern)) {</span>
        <span class="s2">var </span><span class="s1">rule = createRule(pattern, </span><span class="s2">this</span><span class="s1">._ignoreCase);</span>
        <span class="s2">this</span><span class="s1">._added = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">._rules.push(rule);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">// @param {Array&lt;string&gt; | string | Ignore} pattern</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;add&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">add(pattern) {</span>
      <span class="s2">this</span><span class="s1">._added = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(</span><span class="s2">this</span><span class="s1">._addPattern, </span><span class="s2">this</span><span class="s1">);</span>

      <span class="s4">// Some rules have just added to the ignore,</span>
      <span class="s4">// making the behavior changed.</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._added) {</span>
        <span class="s2">this</span><span class="s1">._initCache();</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s4">// legacy</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;addPattern&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">addPattern(pattern) {</span>
      <span class="s2">return this</span><span class="s1">.add(pattern);</span>
    <span class="s1">}</span>

    <span class="s4">//          |           ignored : unignored</span>
    <span class="s4">// negative |   0:0   |   0:1   |   1:0   |   1:1</span>
    <span class="s4">// -------- | ------- | ------- | ------- | --------</span>
    <span class="s4">//     0    |  TEST   |  TEST   |  SKIP   |    X</span>
    <span class="s4">//     1    |  TESTIF |  SKIP   |  TEST   |    X</span>

    <span class="s4">// - SKIP: always skip</span>
    <span class="s4">// - TEST: always test</span>
    <span class="s4">// - TESTIF: only test if checkUnignored</span>
    <span class="s4">// - X: that never happen</span>

    <span class="s4">// @param {boolean} whether should check if the path is unignored,</span>
    <span class="s4">//   setting `checkUnignored` to `false` could reduce additional</span>
    <span class="s4">//   path matching.</span>

    <span class="s4">// @returns {TestResult} true if a file is ignored</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;_testOne&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">_testOne(path, checkUnignored) {</span>
      <span class="s2">var </span><span class="s1">ignored = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">unignored = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">._rules.forEach(</span><span class="s2">function </span><span class="s1">(rule) {</span>
        <span class="s2">var </span><span class="s1">negative = rule.negative;</span>
        <span class="s2">if </span><span class="s1">(unignored === negative &amp;&amp; ignored !== unignored || negative &amp;&amp; !ignored &amp;&amp; !unignored &amp;&amp; !checkUnignored) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">var </span><span class="s1">matched = rule.regex.test(path);</span>
        <span class="s2">if </span><span class="s1">(matched) {</span>
          <span class="s1">ignored = !negative;</span>
          <span class="s1">unignored = negative;</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">ignored: ignored,</span>
        <span class="s1">unignored: unignored</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s4">// @returns {TestResult}</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;_test&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">_test(originalPath, cache, checkUnignored, slices) {</span>
      <span class="s2">var </span><span class="s1">path = originalPath</span>
      <span class="s4">// Supports nullable path</span>
      <span class="s1">&amp;&amp; checkPath.convert(originalPath);</span>
      <span class="s1">checkPath(path, originalPath, </span><span class="s2">this</span><span class="s1">._allowRelativePaths ? RETURN_FALSE : throwError);</span>
      <span class="s2">return this</span><span class="s1">._t(path, cache, checkUnignored, slices);</span>
    <span class="s1">}</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;_t&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">_t(path, cache, checkUnignored, slices) {</span>
      <span class="s2">if </span><span class="s1">(path </span><span class="s2">in </span><span class="s1">cache) {</span>
        <span class="s2">return </span><span class="s1">cache[path];</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!slices) {</span>
        <span class="s4">// path/to/a.js</span>
        <span class="s4">// ['path', 'to', 'a.js']</span>
        <span class="s1">slices = path.split(SLASH);</span>
      <span class="s1">}</span>
      <span class="s1">slices.pop();</span>

      <span class="s4">// If the path has no parent directory, just test it</span>
      <span class="s2">if </span><span class="s1">(!slices.length) {</span>
        <span class="s2">return </span><span class="s1">cache[path] = </span><span class="s2">this</span><span class="s1">._testOne(path, checkUnignored);</span>
      <span class="s1">}</span>
      <span class="s2">var </span><span class="s1">parent = </span><span class="s2">this</span><span class="s1">._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);</span>

      <span class="s4">// If the path contains a parent directory, check the parent first</span>
      <span class="s2">return </span><span class="s1">cache[path] = parent.ignored</span>
      <span class="s4">// &gt; It is not possible to re-include a file if a parent directory of</span>
      <span class="s4">// &gt;   that file is excluded.</span>
      <span class="s1">? parent : </span><span class="s2">this</span><span class="s1">._testOne(path, checkUnignored);</span>
    <span class="s1">}</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;ignores&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">ignores(path) {</span>
      <span class="s2">return this</span><span class="s1">._test(path, </span><span class="s2">this</span><span class="s1">._ignoreCache, </span><span class="s2">false</span><span class="s1">).ignored;</span>
    <span class="s1">}</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;createFilter&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">createFilter() {</span>
      <span class="s2">var </span><span class="s1">_this = </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s2">return function </span><span class="s1">(path) {</span>
        <span class="s2">return </span><span class="s1">!_this.ignores(path);</span>
      <span class="s1">};</span>
    <span class="s1">}</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;filter&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">filter(paths) {</span>
      <span class="s2">return </span><span class="s1">makeArray(paths).filter(</span><span class="s2">this</span><span class="s1">.createFilter());</span>
    <span class="s1">}</span>

    <span class="s4">// @returns {TestResult}</span>
  <span class="s1">}, {</span>
    <span class="s1">key: </span><span class="s0">&quot;test&quot;</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">function </span><span class="s1">test(path) {</span>
      <span class="s2">return this</span><span class="s1">._test(path, </span><span class="s2">this</span><span class="s1">._testCache, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}]);</span>
  <span class="s2">return </span><span class="s1">Ignore;</span>
<span class="s1">}();</span>
<span class="s2">var </span><span class="s1">factory = </span><span class="s2">function </span><span class="s1">factory(options) {</span>
  <span class="s2">return new </span><span class="s1">Ignore(options);</span>
<span class="s1">};</span>
<span class="s2">var </span><span class="s1">isPathValid = </span><span class="s2">function </span><span class="s1">isPathValid(path) {</span>
  <span class="s2">return </span><span class="s1">checkPath(path &amp;&amp; checkPath.convert(path), path, RETURN_FALSE);</span>
<span class="s1">};</span>
<span class="s1">factory.isPathValid = isPathValid;</span>

<span class="s4">// Fixes typescript</span>
<span class="s1">factory[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = factory;</span>
<span class="s1">module.exports = factory;</span>

<span class="s4">// Windows</span>
<span class="s4">// --------------------------------------------------------------</span>
<span class="s4">/* istanbul ignore if */</span>
<span class="s2">if </span><span class="s1">(</span>
<span class="s4">// Detect `process` so that it can run in browsers.</span>
<span class="s2">typeof </span><span class="s1">process !== </span><span class="s0">'undefined' </span><span class="s1">&amp;&amp; (process.env &amp;&amp; process.env.IGNORE_TEST_WIN32 || process.platform === </span><span class="s0">'win32'</span><span class="s1">)) {</span>
  <span class="s4">/* eslint no-control-regex: &quot;off&quot; */</span>
  <span class="s2">var </span><span class="s1">makePosix = </span><span class="s2">function </span><span class="s1">makePosix(str) {</span>
    <span class="s2">return </span><span class="s1">/^\\\\\?\\/.test(str) || /[\</span><span class="s3">0</span><span class="s1">-\x1F</span><span class="s0">&quot;&lt;&gt;</span><span class="s6">\|</span><span class="s0">]+/.test(str) ? str : str.replace(/</span><span class="s5">\\</span><span class="s0">/g, '/');</span>
  <span class="s1">};</span>
  <span class="s1">checkPath.convert = makePosix;</span>

  <span class="s4">// 'C:\\foo'     &lt;- 'C:\\foo' has been converted to 'C:/'</span>
  <span class="s4">// 'd:\\foo'</span>
  <span class="s2">var </span><span class="s1">REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\</span><span class="s4">//i;</span>
  <span class="s1">checkPath.isNotRelative = </span><span class="s2">function </span><span class="s1">(path) {</span>
    <span class="s2">return </span><span class="s1">REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);</span>
  <span class="s1">};</span>
<span class="s1">}</span>
</pre>
</body>
</html>
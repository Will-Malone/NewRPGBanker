<html>
<head>
<title>RNSScreenStackHeaderConfig.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bbb529;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RNSScreenStackHeaderConfig.mm</font>
</center></td></tr></table>
<pre><span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTConversions.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTFabricComponentsPlugins.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTImageComponentView.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/UIView+React.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/image/ImageProps.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/ComponentDescriptors.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/EventEmitters.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/Props.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;react/renderer/components/rnscreens/RCTComponentViewHelpers.h&gt;</span>
<span class="s0">#import </span><span class="s2">&quot;RCTImageComponentView+RNSScreenStackHeaderConfig.h&quot;</span>
<span class="s0">#else</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTImageView.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTShadowView.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTUIManager.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTUIManagerUtils.h&gt;</span>
<span class="s0">#endif</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTBridge.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTFont.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTImageLoader.h&gt;</span>
<span class="s0">#import </span><span class="s2">&lt;React/RCTImageSource.h&gt;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreen.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSScreenStackHeaderConfig.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSSearchBar.h&quot;</span>
<span class="s0">#import </span><span class="s2">&quot;RNSUIBarButtonItem.h&quot;</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s3">namespace </span><span class="s1">rct = facebook::react</span><span class="s3">;</span>
<span class="s0">#endif </span><span class="s4">// RCT_NEW_ARCH_ENABLED</span>

<span class="s0">#ifndef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s4">// Some RN private method hacking below. Couldn't figure out better way to access image data</span>
<span class="s4">// of a given RCTImageView. See more comments in the code section processing SubviewTypeBackButton</span>
<span class="s3">@interface </span><span class="s1">RCTImageView (Private)</span>
<span class="s1">- (UIImage *)image</span><span class="s3">;</span>
<span class="s3">@end</span>
<span class="s0">#endif </span><span class="s4">// !RCT_NEW_ARCH_ENABLED</span>

<span class="s3">@interface </span><span class="s1">RCTImageLoader (Private)</span>
<span class="s1">- (id&lt;RCTImageCache&gt;)imageCache</span><span class="s3">;</span>
<span class="s3">@end</span>

<span class="s3">@implementation </span><span class="s1">NSString (RNSStringUtil)</span>

<span class="s1">+ (BOOL)RNSisBlank:(NSString *)string</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(string == nil) {</span>
    <span class="s3">return </span><span class="s1">YES</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">[[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] length] == </span><span class="s5">0</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s3">@end</span>

<span class="s3">@implementation </span><span class="s1">RNSScreenStackHeaderConfig {</span>
  <span class="s1">NSMutableArray&lt;RNSScreenStackHeaderSubview *&gt; *_reactSubviews</span><span class="s3">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">BOOL _initialPropsSet</span><span class="s3">;</span>
<span class="s0">#else</span>
<span class="s0">#endif</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">- (instancetype)initWithFrame:(CGRect)frame</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self = [super initWithFrame:frame]) {</span>
    <span class="s3">static const auto </span><span class="s1">defaultProps = std::make_shared&lt;</span><span class="s3">const </span><span class="s1">rct::RNSScreenStackHeaderConfigProps&gt;()</span><span class="s3">;</span>
    <span class="s1">_props = defaultProps</span><span class="s3">;</span>
    <span class="s1">_show = YES</span><span class="s3">;</span>
    <span class="s1">_translucent = NO</span><span class="s3">;</span>
    <span class="s1">[self initProps]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">self</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#else</span>
<span class="s1">- (instancetype)init</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(self = [super init]) {</span>
    <span class="s1">_translucent = YES</span><span class="s3">;</span>
    <span class="s1">[self initProps]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">self</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)initProps</span>
<span class="s1">{</span>
  <span class="s1">self.hidden = YES</span><span class="s3">;</span>
  <span class="s1">_reactSubviews = [NSMutableArray </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
  <span class="s1">_backTitleVisible = YES</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UIView *)reactSuperview</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">_screenView</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (NSArray&lt;UIView *&gt; *)reactSubviews</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">_reactSubviews</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)removeFromSuperview</span>
<span class="s1">{</span>
  <span class="s1">[super removeFromSuperview]</span><span class="s3">;</span>
  <span class="s1">_screenView = nil</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s4">// this method is never invoked by the system since this view</span>
<span class="s4">// is not added to native view hierarchy so we can apply our logic</span>
<span class="s1">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s3">for </span><span class="s1">(RNSScreenStackHeaderSubview *subview in _reactSubviews) {</span>
    <span class="s3">if </span><span class="s1">(subview.type == RNSScreenStackHeaderSubviewTypeLeft || subview.type == RNSScreenStackHeaderSubviewTypeRight) {</span>
      <span class="s4">// we wrap the headerLeft/Right component in a UIBarButtonItem</span>
      <span class="s4">// so we need to use the only subview of it to retrieve the correct view</span>
      <span class="s1">UIView *headerComponent = subview.subviews.firstObject</span><span class="s3">;</span>
      <span class="s4">// we convert the point to RNSScreenStackView since it always contains the header inside it</span>
      <span class="s1">CGPoint convertedPoint = [_screenView.reactSuperview convertPoint:point toView:headerComponent]</span><span class="s3">;</span>

      <span class="s1">UIView *hitTestResult = [headerComponent hitTest:convertedPoint withEvent:event]</span><span class="s3">;</span>
      <span class="s3">if </span><span class="s1">(hitTestResult != nil) {</span>
        <span class="s3">return </span><span class="s1">hitTestResult</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">nil</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)updateViewControllerIfNeeded</span>
<span class="s1">{</span>
  <span class="s1">UIViewController *vc = _screenView.controller</span><span class="s3">;</span>
  <span class="s1">UINavigationController *nav = (UINavigationController *)vc.parentViewController</span><span class="s3">;</span>
  <span class="s1">UIViewController *nextVC = nav.visibleViewController</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(nav.transitionCoordinator != nil) {</span>
    <span class="s4">// if navigator is performing transition instead of allowing to update of `visibleConttroller`</span>
    <span class="s4">// we look at `topController`. This is because during transitiong the `visibleController` won't</span>
    <span class="s4">// point to the controller that is going to be revealed after transition. This check fixes the</span>
    <span class="s4">// problem when config gets updated while the transition is ongoing.</span>
    <span class="s1">nextVC = nav.topViewController</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">// we want updates sent to the VC below modal too since it is also visible</span>
  <span class="s1">BOOL isPresentingVC = nextVC != nil &amp;&amp; vc.presentedViewController == nextVC</span><span class="s3">;</span>

  <span class="s1">BOOL isInFullScreenModal = nav == nil &amp;&amp; _screenView.stackPresentation == RNSScreenStackPresentationFullScreenModal</span><span class="s3">;</span>
  <span class="s4">// if nav is nil, it means we can be in a fullScreen modal, so there is no nextVC, but we still want to update</span>
  <span class="s3">if </span><span class="s1">(vc != nil &amp;&amp; (nextVC == vc || isInFullScreenModal || isPresentingVC)) {</span>
    <span class="s1">[RNSScreenStackHeaderConfig updateViewController:self.screenView.controller withConfig:self animated:YES]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)layoutNavigationControllerView</span>
<span class="s1">{</span>
  <span class="s4">// We need to layout navigation controller view after translucent prop changes, because otherwise</span>
  <span class="s4">// frame of RNSScreen will not be changed and screen content will remain the same size.</span>
  <span class="s4">// For more details look at https://github.com/software-mansion/react-native-screens/issues/1158</span>
  <span class="s1">UIViewController *vc = _screenView.controller</span><span class="s3">;</span>
  <span class="s1">UINavigationController *navctr = vc.navigationController</span><span class="s3">;</span>
  <span class="s1">[navctr.view setNeedsLayout]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">+ (</span><span class="s3">void</span><span class="s1">)setAnimatedConfig:(UIViewController *)vc withConfig:(RNSScreenStackHeaderConfig *)config</span>
<span class="s1">{</span>
  <span class="s1">UINavigationBar *navbar = ((UINavigationController *)vc.parentViewController).navigationBar</span><span class="s3">;</span>
  <span class="s4">// It is workaround for loading custom back icon when transitioning from a screen without header to the screen which</span>
  <span class="s4">// has one. This action fails when navigating to the screen with header for the second time and loads default back</span>
  <span class="s4">// button. It looks like changing the tint color of navbar triggers an update of the items belonging to it and it</span>
  <span class="s4">// seems to load the custom back image so we change the tint color's alpha by a very small amount and then set it to</span>
  <span class="s4">// the one it should have.</span>
<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_14_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_14_0</span>
  <span class="s4">// it brakes the behavior of `headerRight` in iOS 14, where the bug desribed above seems to be fixed, so we do nothing</span>
  <span class="s4">// in iOS 14</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">14.0</span><span class="s3">, </span><span class="s1">*)) {</span>
  <span class="s1">} </span><span class="s3">else</span>
<span class="s0">#endif</span>
  <span class="s1">{</span>
    <span class="s1">[navbar setTintColor:[config.color colorWithAlphaComponent:CGColorGetAlpha(config.color.CGColor) - </span><span class="s5">0.01</span><span class="s1">]]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">[navbar setTintColor:config.color]</span><span class="s3">;</span>

<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_13_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s4">// font customized on the navigation item level, so nothing to do here</span>
  <span class="s1">} </span><span class="s3">else</span>
<span class="s0">#endif</span>
  <span class="s1">{</span>
    <span class="s1">BOOL hideShadow = config.hideShadow</span><span class="s3">;</span>

    <span class="s3">if </span><span class="s1">(config.backgroundColor &amp;&amp; CGColorGetAlpha(config.backgroundColor.CGColor) == </span><span class="s5">0.</span><span class="s1">) {</span>
      <span class="s1">[navbar setBackgroundImage:[UIImage </span><span class="s3">new</span><span class="s1">] forBarMetrics:UIBarMetricsDefault]</span><span class="s3">;</span>
      <span class="s1">[navbar setBarTintColor:[UIColor clearColor]]</span><span class="s3">;</span>
      <span class="s1">hideShadow = YES</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">[navbar setBackgroundImage:nil forBarMetrics:UIBarMetricsDefault]</span><span class="s3">;</span>
      <span class="s1">[navbar setBarTintColor:config.backgroundColor]</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s1">[navbar setTranslucent:config.translucent]</span><span class="s3">;</span>
    <span class="s1">[navbar setValue:</span><span class="s3">@</span><span class="s1">(hideShadow ? YES : NO) forKey:</span><span class="s3">@</span><span class="s2">&quot;hidesShadow&quot;</span><span class="s1">]</span><span class="s3">;</span>

    <span class="s3">if </span><span class="s1">(config.titleFontFamily || config.titleFontSize || config.titleFontWeight || config.titleColor) {</span>
      <span class="s1">NSMutableDictionary *attrs = [NSMutableDictionary </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>

      <span class="s3">if </span><span class="s1">(config.titleColor) {</span>
        <span class="s1">attrs[NSForegroundColorAttributeName] = config.titleColor</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s1">NSString *family = config.titleFontFamily ?: nil</span><span class="s3">;</span>
      <span class="s1">NSNumber *size = config.titleFontSize ?: </span><span class="s3">@</span><span class="s5">17</span><span class="s3">;</span>
      <span class="s1">NSString *weight = config.titleFontWeight ?: nil</span><span class="s3">;</span>
      <span class="s3">if </span><span class="s1">(family || weight) {</span>
        <span class="s1">attrs[NSFontAttributeName] = [RCTFont updateFont:nil</span>
                                              <span class="s1">withFamily:family</span>
                                                    <span class="s1">size:size</span>
                                                  <span class="s1">weight:weight</span>
                                                   <span class="s1">style:nil</span>
                                                 <span class="s1">variant:nil</span>
                                         <span class="s1">scaleMultiplier:</span><span class="s5">1.0</span><span class="s1">]</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">attrs[NSFontAttributeName] = [UIFont boldSystemFontOfSize:[size floatValue]]</span><span class="s3">;</span>
      <span class="s1">}</span>
      <span class="s1">[navbar setTitleTextAttributes:attrs]</span><span class="s3">;</span>
    <span class="s1">}</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">11.0</span><span class="s3">, </span><span class="s1">*)) {</span>
      <span class="s3">if </span><span class="s1">(config.largeTitle &amp;&amp;</span>
          <span class="s1">(config.largeTitleFontFamily || config.largeTitleFontSize || config.largeTitleFontWeight ||</span>
           <span class="s1">config.largeTitleColor || config.titleColor)) {</span>
        <span class="s1">NSMutableDictionary *largeAttrs = [NSMutableDictionary </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
        <span class="s3">if </span><span class="s1">(config.largeTitleColor || config.titleColor) {</span>
          <span class="s1">largeAttrs[NSForegroundColorAttributeName] =</span>
              <span class="s1">config.largeTitleColor ? config.largeTitleColor : config.titleColor</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">NSString *largeFamily = config.largeTitleFontFamily ?: nil</span><span class="s3">;</span>
        <span class="s1">NSNumber *largeSize = config.largeTitleFontSize ?: </span><span class="s3">@</span><span class="s5">34</span><span class="s3">;</span>
        <span class="s1">NSString *largeWeight = config.largeTitleFontWeight ?: nil</span><span class="s3">;</span>
        <span class="s3">if </span><span class="s1">(largeFamily || largeWeight) {</span>
          <span class="s1">largeAttrs[NSFontAttributeName] = [RCTFont updateFont:nil</span>
                                                     <span class="s1">withFamily:largeFamily</span>
                                                           <span class="s1">size:largeSize</span>
                                                         <span class="s1">weight:largeWeight</span>
                                                          <span class="s1">style:nil</span>
                                                        <span class="s1">variant:nil</span>
                                                <span class="s1">scaleMultiplier:</span><span class="s5">1.0</span><span class="s1">]</span><span class="s3">;</span>
        <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
          <span class="s1">largeAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:[largeSize floatValue] weight:UIFontWeightBold]</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">[navbar setLargeTitleTextAttributes:largeAttrs]</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s0">#endif</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">+ (</span><span class="s3">void</span><span class="s1">)setTitleAttibutes:(NSDictionary *)attrs forButton:(UIBarButtonItem *)button</span>
<span class="s1">{</span>
  <span class="s1">[button setTitleTextAttributes:attrs forState:UIControlStateNormal]</span><span class="s3">;</span>
  <span class="s1">[button setTitleTextAttributes:attrs forState:UIControlStateHighlighted]</span><span class="s3">;</span>
  <span class="s1">[button setTitleTextAttributes:attrs forState:UIControlStateDisabled]</span><span class="s3">;</span>
  <span class="s1">[button setTitleTextAttributes:attrs forState:UIControlStateSelected]</span><span class="s3">;</span>
  <span class="s1">[button setTitleTextAttributes:attrs forState:UIControlStateFocused]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">+ (UIImage *)loadBackButtonImageInViewController:(UIViewController *)vc withConfig:(RNSScreenStackHeaderConfig *)config</span>
<span class="s1">{</span>
  <span class="s1">BOOL hasBackButtonImage = NO</span><span class="s3">;</span>
  <span class="s3">for </span><span class="s1">(RNSScreenStackHeaderSubview *subview in config.reactSubviews) {</span>
    <span class="s3">if </span><span class="s1">(subview.type == RNSScreenStackHeaderSubviewTypeBackButton &amp;&amp; subview.subviews.count &gt; </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">hasBackButtonImage = YES</span><span class="s3">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
      <span class="s1">RCTImageComponentView *imageView = subview.subviews[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span>
<span class="s0">#else</span>
      <span class="s1">RCTImageView *imageView = subview.subviews[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span>
<span class="s0">#endif </span><span class="s4">// RCT_NEW_ARCH_ENABLED</span>
      <span class="s3">if </span><span class="s1">(imageView.image == nil) {</span>
        <span class="s4">// This is yet another workaround for loading custom back icon. It turns out that under</span>
        <span class="s4">// certain circumstances image attribute can be null despite the app running in production</span>
        <span class="s4">// mode (when images are loaded from the filesystem). This can happen because image attribute</span>
        <span class="s4">// is reset when image view is detached from window, and also in some cases initialization</span>
        <span class="s4">// does not populate the frame of the image view before the loading start. The latter result</span>
        <span class="s4">// in the image attribute not being updated. We manually set frame to the size of an image</span>
        <span class="s4">// in order to trigger proper reload that'd update the image attribute.</span>
        <span class="s1">RCTImageSource *imageSource = [RNSScreenStackHeaderConfig imageSourceFromImageView:imageView]</span><span class="s3">;</span>
        <span class="s1">[imageView reactSetFrame:CGRectMake(</span>
                                     <span class="s1">imageView.frame.origin.x</span><span class="s3">,</span>
                                     <span class="s1">imageView.frame.origin.y</span><span class="s3">,</span>
                                     <span class="s1">imageSource.size.width</span><span class="s3">,</span>
                                     <span class="s1">imageSource.size.height)]</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s1">UIImage *image = imageView.image</span><span class="s3">;</span>

      <span class="s4">// IMPORTANT!!!</span>
      <span class="s4">// image can be nil in DEV MODE ONLY</span>
      <span class="s4">//</span>
      <span class="s4">// It is so, because in dev mode images are loaded over HTTP from the packager. In that case</span>
      <span class="s4">// we first check if image is already loaded in cache and if it is, we take it from cache and</span>
      <span class="s4">// display immediately. Otherwise we wait for the transition to finish and retry updating</span>
      <span class="s4">// header config.</span>
      <span class="s4">// Unfortunately due to some problems in UIKit we cannot update the image while the screen</span>
      <span class="s4">// transition is ongoing. This results in the settings being reset after the transition is done</span>
      <span class="s4">// to the state from before the transition.</span>
      <span class="s3">if </span><span class="s1">(image == nil) {</span>
        <span class="s4">// in DEV MODE we try to load from cache (we use private API for that as it is not exposed</span>
        <span class="s4">// publically in headers).</span>
        <span class="s1">RCTImageSource *imageSource = [RNSScreenStackHeaderConfig imageSourceFromImageView:imageView]</span><span class="s3">;</span>
        <span class="s1">RCTImageLoader *imageLoader = [subview.bridge moduleForClass:[RCTImageLoader </span><span class="s3">class</span><span class="s1">]]</span><span class="s3">;</span>

        <span class="s1">image = [imageLoader.imageCache</span>
            <span class="s1">imageForUrl:imageSource.request.URL.absoluteString</span>
                   <span class="s1">size:imageSource.size</span>
                  <span class="s1">scale:imageSource.scale</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
             <span class="s1">resizeMode:resizeModeFromCppEquiv(</span>
                            <span class="s1">std::static_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">rct::ImageProps&gt;(imageView.props)-&gt;resizeMode)]</span><span class="s3">;</span>
<span class="s0">#else</span>
             <span class="s1">resizeMode:imageView.resizeMode]</span><span class="s3">;</span>
<span class="s0">#endif </span><span class="s4">// RCT_NEW_ARCH_ENABLED</span>
      <span class="s1">}</span>
      <span class="s3">if </span><span class="s1">(image == nil) {</span>
        <span class="s4">// This will be triggered if the image is not in the cache yet. What we do is we wait until</span>
        <span class="s4">// the end of transition and run header config updates again. We could potentially wait for</span>
        <span class="s4">// image on load to trigger, but that would require even more private method hacking.</span>
        <span class="s3">if </span><span class="s1">(vc.transitionCoordinator) {</span>
          <span class="s1">[vc.transitionCoordinator</span>
              <span class="s1">animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s3">_Nonnull </span><span class="s1">context) {</span>
                <span class="s4">// nothing, we just want completion</span>
              <span class="s1">}</span>
              <span class="s1">completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s3">_Nonnull </span><span class="s1">context) {</span>
          <span class="s4">// in order for new back button image to be loaded we need to trigger another change</span>
          <span class="s4">// in back button props that'd make UIKit redraw the button. Otherwise the changes are</span>
          <span class="s4">// not reflected. Here we change back button visibility which is then immediately restored</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
                <span class="s1">vc.navigationItem.hidesBackButton = YES</span><span class="s3">;</span>
<span class="s0">#endif</span>
                <span class="s1">[config updateViewControllerIfNeeded]</span><span class="s3">;</span>
              <span class="s1">}]</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s3">return </span><span class="s1">[UIImage </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s3">return </span><span class="s1">image</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">nil</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">+ (</span><span class="s3">void</span><span class="s1">)willShowViewController:(UIViewController *)vc</span>
                      <span class="s1">animated:(BOOL)animated</span>
                    <span class="s1">withConfig:(RNSScreenStackHeaderConfig *)config</span>
<span class="s1">{</span>
  <span class="s1">[self updateViewController:vc withConfig:config animated:animated]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_13_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0</span>
<span class="s1">+ (UINavigationBarAppearance *)buildAppearance:(UIViewController *)vc</span>
                                    <span class="s1">withConfig:(RNSScreenStackHeaderConfig *)config API_AVAILABLE(ios(</span><span class="s5">13.0</span><span class="s1">))</span>
<span class="s1">{</span>
  <span class="s1">UINavigationBarAppearance *appearance = [UINavigationBarAppearance </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(config.backgroundColor &amp;&amp; CGColorGetAlpha(config.backgroundColor.CGColor) == </span><span class="s5">0.</span><span class="s1">) {</span>
    <span class="s4">// transparent background color</span>
    <span class="s1">[appearance configureWithTransparentBackground]</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">[appearance configureWithOpaqueBackground]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">// set background color if specified</span>
  <span class="s3">if </span><span class="s1">(config.backgroundColor) {</span>
    <span class="s1">appearance.backgroundColor = config.backgroundColor</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">// TODO: implement blurEffect on Fabric</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#else</span>
  <span class="s3">if </span><span class="s1">(config.blurEffect) {</span>
    <span class="s1">appearance.backgroundEffect = [UIBlurEffect effectWithStyle:config.blurEffect]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>

  <span class="s3">if </span><span class="s1">(config.hideShadow) {</span>
    <span class="s1">appearance.shadowColor = nil</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(config.titleFontFamily || config.titleFontSize || config.titleFontWeight || config.titleColor) {</span>
    <span class="s1">NSMutableDictionary *attrs = [NSMutableDictionary </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>

    <span class="s3">if </span><span class="s1">(config.titleColor) {</span>
      <span class="s1">attrs[NSForegroundColorAttributeName] = config.titleColor</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s1">NSString *family = config.titleFontFamily ?: nil</span><span class="s3">;</span>
    <span class="s1">NSNumber *size = config.titleFontSize ?: </span><span class="s3">@</span><span class="s5">17</span><span class="s3">;</span>
    <span class="s1">NSString *weight = config.titleFontWeight ?: nil</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(family || weight) {</span>
      <span class="s1">attrs[NSFontAttributeName] = [RCTFont updateFont:nil</span>
                                            <span class="s1">withFamily:config.titleFontFamily</span>
                                                  <span class="s1">size:size</span>
                                                <span class="s1">weight:weight</span>
                                                 <span class="s1">style:nil</span>
                                               <span class="s1">variant:nil</span>
                                       <span class="s1">scaleMultiplier:</span><span class="s5">1.0</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">attrs[NSFontAttributeName] = [UIFont boldSystemFontOfSize:[size floatValue]]</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s1">appearance.titleTextAttributes = attrs</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(config.largeTitleFontFamily || config.largeTitleFontSize || config.largeTitleFontWeight ||</span>
      <span class="s1">config.largeTitleColor || config.titleColor) {</span>
    <span class="s1">NSMutableDictionary *largeAttrs = [NSMutableDictionary </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>

    <span class="s3">if </span><span class="s1">(config.largeTitleColor || config.titleColor) {</span>
      <span class="s1">largeAttrs[NSForegroundColorAttributeName] = config.largeTitleColor ? config.largeTitleColor : config.titleColor</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s1">NSString *largeFamily = config.largeTitleFontFamily ?: nil</span><span class="s3">;</span>
    <span class="s1">NSNumber *largeSize = config.largeTitleFontSize ?: </span><span class="s3">@</span><span class="s5">34</span><span class="s3">;</span>
    <span class="s1">NSString *largeWeight = config.largeTitleFontWeight ?: nil</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(largeFamily || largeWeight) {</span>
      <span class="s1">largeAttrs[NSFontAttributeName] = [RCTFont updateFont:nil</span>
                                                 <span class="s1">withFamily:largeFamily</span>
                                                       <span class="s1">size:largeSize</span>
                                                     <span class="s1">weight:largeWeight</span>
                                                      <span class="s1">style:nil</span>
                                                    <span class="s1">variant:nil</span>
                                            <span class="s1">scaleMultiplier:</span><span class="s5">1.0</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
      <span class="s1">largeAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:[largeSize floatValue] weight:UIFontWeightBold]</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s1">appearance.largeTitleTextAttributes = largeAttrs</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">UIImage *backButtonImage = [self loadBackButtonImageInViewController:vc withConfig:config]</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(backButtonImage) {</span>
    <span class="s1">[appearance setBackIndicatorImage:backButtonImage transitionMaskImage:backButtonImage]</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else if </span><span class="s1">(appearance.backIndicatorImage) {</span>
    <span class="s1">[appearance setBackIndicatorImage:nil transitionMaskImage:nil]</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s3">return </span><span class="s1">appearance</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">#endif </span><span class="s4">// Check for &gt;= iOS 13.0</span>

<span class="s1">+ (</span><span class="s3">void</span><span class="s1">)updateViewController:(UIViewController *)vc</span>
                  <span class="s1">withConfig:(RNSScreenStackHeaderConfig *)config</span>
                    <span class="s1">animated:(BOOL)animated</span>
<span class="s1">{</span>
  <span class="s1">UINavigationItem *navitem = vc.navigationItem</span><span class="s3">;</span>
  <span class="s1">UINavigationController *navctr = (UINavigationController *)vc.parentViewController</span><span class="s3">;</span>

  <span class="s1">NSUInteger currentIndex = [navctr.viewControllers indexOfObject:vc]</span><span class="s3">;</span>
  <span class="s1">UINavigationItem *prevItem =</span>
      <span class="s1">currentIndex &gt; </span><span class="s5">0 </span><span class="s1">? [navctr.viewControllers objectAtIndex:currentIndex - </span><span class="s5">1</span><span class="s1">].navigationItem : nil</span><span class="s3">;</span>

  <span class="s1">BOOL wasHidden = navctr.navigationBarHidden</span><span class="s3">;</span>
<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
  <span class="s1">BOOL shouldHide = config == nil || !config.show</span><span class="s3">;</span>
<span class="s0">#else</span>
  <span class="s1">BOOL shouldHide = config == nil || config.hide</span><span class="s3">;</span>
<span class="s0">#endif</span>

  <span class="s3">if </span><span class="s1">(!shouldHide &amp;&amp; !config.translucent) {</span>
    <span class="s4">// when nav bar is not translucent we chage edgesForExtendedLayout to avoid system laying out</span>
    <span class="s4">// the screen underneath navigation controllers</span>
    <span class="s1">vc.edgesForExtendedLayout = UIRectEdgeNone</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s4">// system default is UIRectEdgeAll</span>
    <span class="s1">vc.edgesForExtendedLayout = UIRectEdgeAll</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">[navctr setNavigationBarHidden:shouldHide animated:animated]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">((config.direction == UISemanticContentAttributeForceLeftToRight ||</span>
       <span class="s1">config.direction == UISemanticContentAttributeForceRightToLeft) &amp;&amp;</span>
      <span class="s4">// iOS 12 cancels swipe gesture when direction is changed. See #1091</span>
      <span class="s1">navctr.view.semanticContentAttribute != config.direction) {</span>
    <span class="s1">navctr.view.semanticContentAttribute = config.direction</span><span class="s3">;</span>
    <span class="s1">navctr.navigationBar.semanticContentAttribute = config.direction</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(shouldHide) {</span>
    <span class="s3">return;</span>
  <span class="s1">}</span>

<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s3">const auto </span><span class="s1">isBackTitleBlank = [NSString RNSisBlank:config.backTitle] == YES</span><span class="s3">;</span>
  <span class="s1">NSString *resolvedBackTitle = isBackTitleBlank ? prevItem.title : config.backTitle</span><span class="s3">;</span>
  <span class="s1">RNSUIBarButtonItem *backBarButtonItem = [[RNSUIBarButtonItem alloc] initWithTitle:resolvedBackTitle</span>
                                                                              <span class="s1">style:UIBarButtonItemStylePlain</span>
                                                                             <span class="s1">target:nil</span>
                                                                             <span class="s1">action:nil]</span><span class="s3">;</span>
  <span class="s1">[backBarButtonItem setMenuHidden:config.disableBackButtonMenu]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(config.isBackTitleVisible) {</span>
    <span class="s3">if </span><span class="s1">(config.backTitleFontFamily || config.backTitleFontSize) {</span>
      <span class="s1">NSMutableDictionary *attrs = [NSMutableDictionary </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
      <span class="s1">NSNumber *size = config.backTitleFontSize ?: </span><span class="s3">@</span><span class="s5">17</span><span class="s3">;</span>
      <span class="s3">if </span><span class="s1">(config.backTitleFontFamily) {</span>
        <span class="s1">attrs[NSFontAttributeName] = [RCTFont updateFont:nil</span>
                                              <span class="s1">withFamily:config.backTitleFontFamily</span>
                                                    <span class="s1">size:size</span>
                                                  <span class="s1">weight:nil</span>
                                                   <span class="s1">style:nil</span>
                                                 <span class="s1">variant:nil</span>
                                         <span class="s1">scaleMultiplier:</span><span class="s5">1.0</span><span class="s1">]</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
        <span class="s1">attrs[NSFontAttributeName] = [UIFont boldSystemFontOfSize:[size floatValue]]</span><span class="s3">;</span>
      <span class="s1">}</span>
      <span class="s1">[self setTitleAttibutes:attrs forButton:backBarButtonItem]</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s4">// back button title should be not visible next to back button,</span>
    <span class="s4">// but it should still appear in back menu (if one is enabled)</span>

    <span class="s4">// When backBarButtonItem's title is null, back menu will use value</span>
    <span class="s4">// of backButtonTitle</span>
    <span class="s1">[backBarButtonItem setTitle:nil]</span><span class="s3">;</span>
    <span class="s1">prevItem.backButtonTitle = resolvedBackTitle</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">prevItem.backBarButtonItem = backBarButtonItem</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">11.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s3">if </span><span class="s1">(config.largeTitle) {</span>
      <span class="s1">navctr.navigationBar.prefersLargeTitles = YES</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s1">navitem.largeTitleDisplayMode =</span>
        <span class="s1">config.largeTitle ? UINavigationItemLargeTitleDisplayModeAlways : UINavigationItemLargeTitleDisplayModeNever</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s0">#if </span><span class="s1">defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_13_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">tvOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s1">UINavigationBarAppearance *appearance = [self buildAppearance:vc withConfig:config]</span><span class="s3">;</span>
    <span class="s1">navitem.standardAppearance = appearance</span><span class="s3">;</span>
    <span class="s1">navitem.compactAppearance = appearance</span><span class="s3">;</span>

    <span class="s1">UINavigationBarAppearance *scrollEdgeAppearance =</span>
        <span class="s1">[[UINavigationBarAppearance alloc] initWithBarAppearance:appearance]</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(config.largeTitleBackgroundColor != nil) {</span>
      <span class="s1">scrollEdgeAppearance.backgroundColor = config.largeTitleBackgroundColor</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(config.largeTitleHideShadow) {</span>
      <span class="s1">scrollEdgeAppearance.shadowColor = nil</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s1">navitem.scrollEdgeAppearance = scrollEdgeAppearance</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else</span>
<span class="s0">#endif</span>
  <span class="s1">{</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
    <span class="s4">// updating backIndicatotImage does not work when called during transition. On iOS pre 13 we need</span>
    <span class="s4">// to update it before the navigation starts.</span>
    <span class="s1">UIImage *backButtonImage = [self loadBackButtonImageInViewController:vc withConfig:config]</span><span class="s3">;</span>
    <span class="s3">if </span><span class="s1">(backButtonImage) {</span>
      <span class="s1">navctr.navigationBar.backIndicatorImage = backButtonImage</span><span class="s3">;</span>
      <span class="s1">navctr.navigationBar.backIndicatorTransitionMaskImage = backButtonImage</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s3">else if </span><span class="s1">(navctr.navigationBar.backIndicatorImage) {</span>
      <span class="s1">navctr.navigationBar.backIndicatorImage = nil</span><span class="s3">;</span>
      <span class="s1">navctr.navigationBar.backIndicatorTransitionMaskImage = nil</span><span class="s3">;</span>
    <span class="s1">}</span>
<span class="s0">#endif</span>
  <span class="s1">}</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
  <span class="s1">navitem.hidesBackButton = config.hideBackButton</span><span class="s3">;</span>
<span class="s0">#endif</span>
  <span class="s1">navitem.leftBarButtonItem = nil</span><span class="s3">;</span>
  <span class="s1">navitem.rightBarButtonItem = nil</span><span class="s3">;</span>
  <span class="s1">navitem.titleView = nil</span><span class="s3">;</span>

  <span class="s3">for </span><span class="s1">(RNSScreenStackHeaderSubview *subview in config.reactSubviews) {</span>
    <span class="s3">switch </span><span class="s1">(subview.type) {</span>
      <span class="s3">case </span><span class="s1">RNSScreenStackHeaderSubviewTypeLeft: {</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
        <span class="s1">navitem.leftItemsSupplementBackButton = config.backButtonInCustomView</span><span class="s3">;</span>
<span class="s0">#endif</span>
        <span class="s1">UIBarButtonItem *buttonItem = [[UIBarButtonItem alloc] initWithCustomView:subview]</span><span class="s3">;</span>
        <span class="s1">navitem.leftBarButtonItem = buttonItem</span><span class="s3">;</span>
        <span class="s3">break;</span>
      <span class="s1">}</span>
      <span class="s3">case </span><span class="s1">RNSScreenStackHeaderSubviewTypeRight: {</span>
        <span class="s1">UIBarButtonItem *buttonItem = [[UIBarButtonItem alloc] initWithCustomView:subview]</span><span class="s3">;</span>
        <span class="s1">navitem.rightBarButtonItem = buttonItem</span><span class="s3">;</span>
        <span class="s3">break;</span>
      <span class="s1">}</span>
      <span class="s3">case </span><span class="s1">RNSScreenStackHeaderSubviewTypeCenter:</span>
      <span class="s3">case </span><span class="s1">RNSScreenStackHeaderSubviewTypeTitle: {</span>
        <span class="s1">navitem.titleView = subview</span><span class="s3">;</span>
        <span class="s3">break;</span>
      <span class="s1">}</span>
      <span class="s3">case </span><span class="s1">RNSScreenStackHeaderSubviewTypeSearchBar: {</span>
        <span class="s3">if </span><span class="s1">(subview.subviews == nil || [subview.subviews count] == </span><span class="s5">0</span><span class="s1">) {</span>
          <span class="s1">RCTLogWarn(</span>
              <span class="s3">@</span><span class="s2">&quot;Failed to attach search bar to the header. We recommend using `useLayoutEffect` when managing &quot;</span>
               <span class="s2">&quot;searchBar properties dynamically. </span><span class="s3">\n\n</span><span class="s2">See: github.com/software-mansion/react-native-screens/issues/1188&quot;</span><span class="s1">)</span><span class="s3">;</span>
          <span class="s3">break;</span>
        <span class="s1">}</span>

        <span class="s3">if </span><span class="s1">([subview.subviews[</span><span class="s5">0</span><span class="s1">] isKindOfClass:[RNSSearchBar </span><span class="s3">class</span><span class="s1">]]) {</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV</span>
          <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">11.0</span><span class="s3">, </span><span class="s1">*)) {</span>
            <span class="s1">RNSSearchBar *searchBar = subview.subviews[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span>
            <span class="s1">navitem.searchController = searchBar.controller</span><span class="s3">;</span>
            <span class="s1">navitem.hidesSearchBarWhenScrolling = searchBar.hideWhenScrolling</span><span class="s3">;</span>
          <span class="s1">}</span>
<span class="s0">#endif</span>
        <span class="s1">}</span>
        <span class="s3">break;</span>
      <span class="s1">}</span>
      <span class="s3">case </span><span class="s1">RNSScreenStackHeaderSubviewTypeBackButton: {</span>
        <span class="s3">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">// This assignment should be done after `navitem.titleView = ...` assignment (iOS 16.0 bug).</span>
  <span class="s4">// See: https://github.com/software-mansion/react-native-screens/issues/1570 (comments)</span>
  <span class="s1">navitem.title = config.title</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(animated &amp;&amp; vc.transitionCoordinator != nil &amp;&amp;</span>
      <span class="s1">vc.transitionCoordinator.presentationStyle == UIModalPresentationNone &amp;&amp; !wasHidden) {</span>
    <span class="s4">// when there is an ongoing transition we may need to update navbar setting in animation block</span>
    <span class="s4">// using animateAlongsideTransition. However, we only do that given the transition is not a modal</span>
    <span class="s4">// transition (presentationStyle == UIModalPresentationNone) and that the bar was not previously</span>
    <span class="s4">// hidden. This is because both for modal transitions and transitions from screen with hidden bar</span>
    <span class="s4">// the transition animation block does not get triggered. This is ok, because with both of those</span>
    <span class="s4">// types of transitions there is no &quot;shared&quot; navigation bar that needs to be updated in an animated</span>
    <span class="s4">// way.</span>
    <span class="s1">[vc.transitionCoordinator</span>
        <span class="s1">animateAlongsideTransition:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s3">_Nonnull </span><span class="s1">context) {</span>
          <span class="s1">[self setAnimatedConfig:vc withConfig:config]</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">completion:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt; </span><span class="s3">_Nonnull </span><span class="s1">context) {</span>
          <span class="s3">if </span><span class="s1">([context isCancelled]) {</span>
            <span class="s1">UIViewController *fromVC = [context viewControllerForKey:UITransitionContextFromViewControllerKey]</span><span class="s3">;</span>
            <span class="s1">RNSScreenStackHeaderConfig *config = nil</span><span class="s3">;</span>
            <span class="s3">for </span><span class="s1">(UIView *subview in fromVC.view.reactSubviews) {</span>
              <span class="s3">if </span><span class="s1">([subview isKindOfClass:[RNSScreenStackHeaderConfig </span><span class="s3">class</span><span class="s1">]]) {</span>
                <span class="s1">config = (RNSScreenStackHeaderConfig *)subview</span><span class="s3">;</span>
                <span class="s3">break;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">[self setAnimatedConfig:fromVC withConfig:config]</span><span class="s3">;</span>
          <span class="s1">}</span>
        <span class="s1">}]</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
    <span class="s1">[self setAnimatedConfig:vc withConfig:config]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)insertReactSubview:(RNSScreenStackHeaderSubview *)subview atIndex:(NSInteger)atIndex</span>
<span class="s1">{</span>
  <span class="s1">[_reactSubviews insertObject:subview atIndex:atIndex]</span><span class="s3">;</span>
  <span class="s1">subview.reactSuperview = self</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)removeReactSubview:(RNSScreenStackHeaderSubview *)subview</span>
<span class="s1">{</span>
  <span class="s1">[_reactSubviews removeObject:subview]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)didUpdateReactSubviews</span>
<span class="s1">{</span>
  <span class="s1">[super didUpdateReactSubviews]</span><span class="s3">;</span>
  <span class="s1">[self updateViewControllerIfNeeded]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s0">#pragma </span><span class="s1">mark - Fabric specific</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)mountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(![childComponentView isKindOfClass:[RNSScreenStackHeaderSubview </span><span class="s3">class</span><span class="s1">]]) {</span>
    <span class="s1">RCTLogError(</span><span class="s3">@</span><span class="s2">&quot;ScreenStackHeader only accepts children of type ScreenStackHeaderSubview&quot;</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s3">return;</span>
  <span class="s1">}</span>

  <span class="s1">RCTAssert(</span>
      <span class="s1">childComponentView.superview == nil</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;Attempt to mount already mounted component view. (parent: %@, child: %@, index: %@, existing parent: %@)&quot;</span><span class="s3">,</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">childComponentView</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s1">(index)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s1">([childComponentView.superview tag]))</span><span class="s3">;</span>

  <span class="s4">//  [_reactSubviews insertObject:(RNSScreenStackHeaderSubview *)childComponentView atIndex:index];</span>
  <span class="s1">[self insertReactSubview:(RNSScreenStackHeaderSubview *)childComponentView atIndex:index]</span><span class="s3">;</span>
  <span class="s1">[self updateViewControllerIfNeeded]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)unmountChildComponentView:(UIView&lt;RCTComponentViewProtocol&gt; *)childComponentView index:(NSInteger)index</span>
<span class="s1">{</span>
  <span class="s1">[_reactSubviews removeObject:(RNSScreenStackHeaderSubview *)childComponentView]</span><span class="s3">;</span>
  <span class="s1">[childComponentView removeFromSuperview]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s3">static </span><span class="s1">RCTResizeMode resizeModeFromCppEquiv(rct::ImageResizeMode resizeMode)</span>
<span class="s1">{</span>
  <span class="s3">switch </span><span class="s1">(resizeMode) {</span>
    <span class="s3">case </span><span class="s1">rct::ImageResizeMode::Cover:</span>
      <span class="s3">return </span><span class="s1">RCTResizeModeCover</span><span class="s3">;</span>
    <span class="s3">case </span><span class="s1">rct::ImageResizeMode::Contain:</span>
      <span class="s3">return </span><span class="s1">RCTResizeModeContain</span><span class="s3">;</span>
    <span class="s3">case </span><span class="s1">rct::ImageResizeMode::Stretch:</span>
      <span class="s3">return </span><span class="s1">RCTResizeModeStretch</span><span class="s3">;</span>
    <span class="s3">case </span><span class="s1">rct::ImageResizeMode::Center:</span>
      <span class="s3">return </span><span class="s1">RCTResizeModeCenter</span><span class="s3">;</span>
    <span class="s3">case </span><span class="s1">rct::ImageResizeMode::Repeat:</span>
      <span class="s3">return </span><span class="s1">RCTResizeModeRepeat</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">/** 
 * Fabric implementation of helper method for +loadBackButtonImageInViewController:withConfig: 
 * There is corresponding Paper implementation (with different parameter type) in Paper specific section. 
 */</span>
<span class="s1">+ (RCTImageSource *)imageSourceFromImageView:(RCTImageComponentView *)view</span>
<span class="s1">{</span>
  <span class="s3">auto const </span><span class="s1">imageProps = *std::static_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">rct::ImageProps&gt;(view.props)</span><span class="s3">;</span>
  <span class="s1">rct::ImageSource cppImageSource = imageProps.sources.at(</span><span class="s5">0</span><span class="s1">)</span><span class="s3">;</span>
  <span class="s3">auto </span><span class="s1">imageSize = CGSize{cppImageSource.size.width</span><span class="s3">, </span><span class="s1">cppImageSource.size.height}</span><span class="s3">;</span>
  <span class="s1">NSURLRequest *request =</span>
      <span class="s1">[NSURLRequest requestWithURL:[NSURL URLWithString:RCTNSStringFromStringNilIfEmpty(cppImageSource.uri)]]</span><span class="s3">;</span>
  <span class="s1">RCTImageSource *imageSource = [[RCTImageSource alloc] initWithURLRequest:request</span>
                                                                      <span class="s1">size:imageSize</span>
                                                                     <span class="s1">scale:cppImageSource.scale]</span><span class="s3">;</span>
  <span class="s3">return </span><span class="s1">imageSource</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#pragma </span><span class="s1">mark - RCTComponentViewProtocol</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)prepareForRecycle</span>
<span class="s1">{</span>
  <span class="s1">[super prepareForRecycle]</span><span class="s3">;</span>
  <span class="s1">_initialPropsSet = NO</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">+ (rct::ComponentDescriptorProvider)componentDescriptorProvider</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">rct::concreteComponentDescriptorProvider&lt;rct::RNSScreenStackHeaderConfigComponentDescriptor&gt;()</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (NSNumber *)getFontSizePropValue:(</span><span class="s3">int</span><span class="s1">)value</span>
<span class="s1">{</span>
  <span class="s3">if </span><span class="s1">(value &gt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">[NSNumber numberWithInt:value]</span><span class="s3">;</span>
  <span class="s3">return </span><span class="s1">nil</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">- (UISemanticContentAttribute)getDirectionPropValue:(rct::RNSScreenStackHeaderConfigDirection)direction</span>
<span class="s1">{</span>
  <span class="s3">switch </span><span class="s1">(direction) {</span>
    <span class="s3">case </span><span class="s1">rct::RNSScreenStackHeaderConfigDirection::Rtl:</span>
      <span class="s3">return </span><span class="s1">UISemanticContentAttributeForceRightToLeft</span><span class="s3">;</span>
    <span class="s3">case </span><span class="s1">rct::RNSScreenStackHeaderConfigDirection::Ltr:</span>
      <span class="s3">return </span><span class="s1">UISemanticContentAttributeForceLeftToRight</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)updateProps:(rct::Props::Shared </span><span class="s3">const </span><span class="s1">&amp;)props oldProps:(rct::Props::Shared </span><span class="s3">const </span><span class="s1">&amp;)oldProps</span>
<span class="s1">{</span>
  <span class="s3">const auto </span><span class="s1">&amp;oldScreenProps = *std::static_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">rct::RNSScreenStackHeaderConfigProps&gt;(_props)</span><span class="s3">;</span>
  <span class="s3">const auto </span><span class="s1">&amp;newScreenProps = *std::static_pointer_cast&lt;</span><span class="s3">const </span><span class="s1">rct::RNSScreenStackHeaderConfigProps&gt;(props)</span><span class="s3">;</span>

  <span class="s1">BOOL needsNavigationControllerLayout = !_initialPropsSet</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.hidden != !_show) {</span>
    <span class="s1">_show = !newScreenProps.hidden</span><span class="s3">;</span>
    <span class="s1">needsNavigationControllerLayout = YES</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.translucent != _translucent) {</span>
    <span class="s1">_translucent = newScreenProps.translucent</span><span class="s3">;</span>
    <span class="s1">needsNavigationControllerLayout = YES</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.backButtonInCustomView != _backButtonInCustomView) {</span>
    <span class="s1">[self setBackButtonInCustomView:newScreenProps.backButtonInCustomView]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">_title = RCTNSStringFromStringNilIfEmpty(newScreenProps.title)</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(newScreenProps.titleFontFamily != oldScreenProps.titleFontFamily) {</span>
    <span class="s1">_titleFontFamily = RCTNSStringFromStringNilIfEmpty(newScreenProps.titleFontFamily)</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">_titleFontWeight = RCTNSStringFromStringNilIfEmpty(newScreenProps.titleFontWeight)</span><span class="s3">;</span>
  <span class="s1">_titleFontSize = [self getFontSizePropValue:newScreenProps.titleFontSize]</span><span class="s3">;</span>
  <span class="s1">_hideShadow = newScreenProps.hideShadow</span><span class="s3">;</span>

  <span class="s1">_largeTitle = newScreenProps.largeTitle</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(newScreenProps.largeTitleFontFamily != oldScreenProps.largeTitleFontFamily) {</span>
    <span class="s1">_largeTitleFontFamily = RCTNSStringFromStringNilIfEmpty(newScreenProps.largeTitleFontFamily)</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">_largeTitleFontWeight = RCTNSStringFromStringNilIfEmpty(newScreenProps.largeTitleFontWeight)</span><span class="s3">;</span>
  <span class="s1">_largeTitleFontSize = [self getFontSizePropValue:newScreenProps.largeTitleFontSize]</span><span class="s3">;</span>
  <span class="s1">_largeTitleHideShadow = newScreenProps.largeTitleHideShadow</span><span class="s3">;</span>

  <span class="s1">_backTitle = RCTNSStringFromStringNilIfEmpty(newScreenProps.backTitle)</span><span class="s3">;</span>
  <span class="s3">if </span><span class="s1">(newScreenProps.backTitleFontFamily != oldScreenProps.backTitleFontFamily) {</span>
    <span class="s1">_backTitleFontFamily = RCTNSStringFromStringNilIfEmpty(newScreenProps.backTitleFontFamily)</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s1">_backTitleFontSize = [self getFontSizePropValue:newScreenProps.backTitleFontSize]</span><span class="s3">;</span>
  <span class="s1">_hideBackButton = newScreenProps.hideBackButton</span><span class="s3">;</span>
  <span class="s1">_disableBackButtonMenu = newScreenProps.disableBackButtonMenu</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(newScreenProps.direction != oldScreenProps.direction) {</span>
    <span class="s1">_direction = [self getDirectionPropValue:newScreenProps.direction]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">_backTitleVisible = newScreenProps.backTitleVisible</span><span class="s3">;</span>

  <span class="s4">// We cannot compare SharedColor because it is shared value.</span>
  <span class="s4">// We could compare color value, but it is more performant to just assign new value</span>
  <span class="s1">_titleColor = RCTUIColorFromSharedColor(newScreenProps.titleColor)</span><span class="s3">;</span>
  <span class="s1">_largeTitleColor = RCTUIColorFromSharedColor(newScreenProps.largeTitleColor)</span><span class="s3">;</span>
  <span class="s1">_color = RCTUIColorFromSharedColor(newScreenProps.color)</span><span class="s3">;</span>
  <span class="s1">_backgroundColor = RCTUIColorFromSharedColor(newScreenProps.backgroundColor)</span><span class="s3">;</span>

  <span class="s1">[self updateViewControllerIfNeeded]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(needsNavigationControllerLayout) {</span>
    <span class="s1">[self layoutNavigationControllerView]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">_initialPropsSet = YES</span><span class="s3">;</span>
  <span class="s1">_props = std::static_pointer_cast&lt;rct::RNSScreenStackHeaderConfigProps </span><span class="s3">const</span><span class="s1">&gt;(props)</span><span class="s3">;</span>

  <span class="s1">[super updateProps:props oldProps:oldProps]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#else</span>
<span class="s0">#pragma </span><span class="s1">mark - Paper specific</span>

<span class="s1">- (</span><span class="s3">void</span><span class="s1">)didSetProps:(NSArray&lt;NSString *&gt; *)changedProps</span>
<span class="s1">{</span>
  <span class="s1">[super didSetProps:changedProps]</span><span class="s3">;</span>
  <span class="s1">[self updateViewControllerIfNeeded]</span><span class="s3">;</span>
  <span class="s4">// We need to layout navigation controller view after translucent prop changes, because otherwise</span>
  <span class="s4">// frame of RNSScreen will not be changed and screen content will remain the same size.</span>
  <span class="s4">// For more details look at https://github.com/software-mansion/react-native-screens/issues/1158</span>
  <span class="s3">if </span><span class="s1">([changedProps containsObject:</span><span class="s3">@</span><span class="s2">&quot;translucent&quot;</span><span class="s1">]) {</span>
    <span class="s1">[self layoutNavigationControllerView]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">/** 
 * Paper implementation of helper method for +loadBackButtonImageInViewController:withConfig: 
 * There is corresponding Fabric implementation (with different parameter type) in Fabric specific section. 
 */</span>
<span class="s1">+ (RCTImageSource *)imageSourceFromImageView:(RCTImageView *)view</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">view.imageSources[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s0">#endif</span>
<span class="s3">@end</span>

<span class="s0">#ifdef </span><span class="s1">RCT_NEW_ARCH_ENABLED</span>
<span class="s1">Class&lt;RCTComponentViewProtocol&gt; RNSScreenStackHeaderConfigCls(</span><span class="s3">void</span><span class="s1">)</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">RNSScreenStackHeaderConfig.</span><span class="s3">class;</span>
<span class="s1">}</span>
<span class="s0">#endif</span>

<span class="s3">@implementation </span><span class="s1">RNSScreenStackHeaderConfigManager</span>

<span class="s1">RCT_EXPORT_MODULE()</span>

<span class="s1">- (UIView *)view</span>
<span class="s1">{</span>
  <span class="s3">return </span><span class="s1">[RNSScreenStackHeaderConfig </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">RCT_EXPORT_VIEW_PROPERTY(title</span><span class="s3">, </span><span class="s1">NSString)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(titleFontFamily</span><span class="s3">, </span><span class="s1">NSString)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(titleFontSize</span><span class="s3">, </span><span class="s1">NSNumber)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(titleFontWeight</span><span class="s3">, </span><span class="s1">NSString)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(titleColor</span><span class="s3">, </span><span class="s1">UIColor)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(backTitle</span><span class="s3">, </span><span class="s1">NSString)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(backTitleFontFamily</span><span class="s3">, </span><span class="s1">NSString)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(backTitleFontSize</span><span class="s3">, </span><span class="s1">NSNumber)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(backgroundColor</span><span class="s3">, </span><span class="s1">UIColor)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(backTitleVisible</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(blurEffect</span><span class="s3">, </span><span class="s1">UIBlurEffectStyle)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(color</span><span class="s3">, </span><span class="s1">UIColor)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(direction</span><span class="s3">, </span><span class="s1">UISemanticContentAttribute)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(largeTitle</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(largeTitleFontFamily</span><span class="s3">, </span><span class="s1">NSString)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(largeTitleFontSize</span><span class="s3">, </span><span class="s1">NSNumber)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(largeTitleFontWeight</span><span class="s3">, </span><span class="s1">NSString)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(largeTitleColor</span><span class="s3">, </span><span class="s1">UIColor)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(largeTitleBackgroundColor</span><span class="s3">, </span><span class="s1">UIColor)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(largeTitleHideShadow</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(hideBackButton</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(hideShadow</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(backButtonInCustomView</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(disableBackButtonMenu</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s4">// `hidden` is an UIView property, we need to use different name internally</span>
<span class="s1">RCT_REMAP_VIEW_PROPERTY(hidden</span><span class="s3">, </span><span class="s1">hide</span><span class="s3">, </span><span class="s1">BOOL)</span>
<span class="s1">RCT_EXPORT_VIEW_PROPERTY(translucent</span><span class="s3">, </span><span class="s1">BOOL)</span>

<span class="s3">@end</span>

<span class="s3">@implementation </span><span class="s1">RCTConvert (RNSScreenStackHeader)</span>

<span class="s1">+ (NSMutableDictionary *)blurEffectsForIOSVersion</span>
<span class="s1">{</span>
  <span class="s1">NSMutableDictionary *blurEffects = [NSMutableDictionary </span><span class="s3">new</span><span class="s1">]</span><span class="s3">;</span>
  <span class="s1">[blurEffects addEntriesFromDictionary:</span><span class="s3">@</span><span class="s1">{</span>
    <span class="s3">@</span><span class="s2">&quot;extraLight&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleExtraLight)</span><span class="s3">,</span>
    <span class="s3">@</span><span class="s2">&quot;light&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleLight)</span><span class="s3">,</span>
    <span class="s3">@</span><span class="s2">&quot;dark&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleDark)</span><span class="s3">,</span>
  <span class="s1">}]</span><span class="s3">;</span>

  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">10.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s1">[blurEffects addEntriesFromDictionary:</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;regular&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleRegular)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;prominent&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleProminent)</span><span class="s3">,</span>
    <span class="s1">}]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#if </span><span class="s1">!TARGET_OS_TV &amp;&amp; defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; defined(__IPHONE_13_0) &amp;&amp; \ 
    __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_13_0</span>
  <span class="s3">if </span><span class="s1">(</span><span class="s3">@available</span><span class="s1">(iOS </span><span class="s5">13.0</span><span class="s3">, </span><span class="s1">*)) {</span>
    <span class="s1">[blurEffects addEntriesFromDictionary:</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;systemUltraThinMaterial&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemUltraThinMaterial)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemThinMaterial&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemThinMaterial)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemMaterial&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemMaterial)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemThickMaterial&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemThickMaterial)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemChromeMaterial&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemChromeMaterial)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemUltraThinMaterialLight&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemUltraThinMaterialLight)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemThinMaterialLight&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemThinMaterialLight)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemMaterialLight&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemMaterialLight)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemThickMaterialLight&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemThickMaterialLight)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemChromeMaterialLight&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemChromeMaterialLight)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemUltraThinMaterialDark&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemUltraThinMaterialDark)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemThinMaterialDark&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemThinMaterialDark)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemMaterialDark&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemMaterialDark)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemThickMaterialDark&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemThickMaterialDark)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;systemChromeMaterialDark&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UIBlurEffectStyleSystemChromeMaterialDark)</span><span class="s3">,</span>
    <span class="s1">}]</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s0">#endif</span>
  <span class="s3">return </span><span class="s1">blurEffects</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s1">RCT_ENUM_CONVERTER(</span>
    <span class="s1">UISemanticContentAttribute</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s3">@</span><span class="s1">{</span>
      <span class="s3">@</span><span class="s2">&quot;ltr&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UISemanticContentAttributeForceLeftToRight)</span><span class="s3">,</span>
      <span class="s3">@</span><span class="s2">&quot;rtl&quot; </span><span class="s1">: </span><span class="s3">@</span><span class="s1">(UISemanticContentAttributeForceRightToLeft)</span><span class="s3">,</span>
    <span class="s1">})</span><span class="s3">,</span>
    <span class="s1">UISemanticContentAttributeUnspecified</span><span class="s3">,</span>
    <span class="s1">integerValue)</span>

<span class="s1">RCT_ENUM_CONVERTER(UIBlurEffectStyle</span><span class="s3">, </span><span class="s1">([self blurEffectsForIOSVersion])</span><span class="s3">, </span><span class="s1">UIBlurEffectStyleExtraLight</span><span class="s3">, </span><span class="s1">integerValue)</span>

<span class="s3">@end</span>
</pre>
</body>
</html>
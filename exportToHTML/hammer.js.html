<html>
<head>
<title>hammer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hammer.js</font>
</center></td></tr></table>
<pre><span class="s0">/*! Hammer.JS - v2.0.17-rc - 2019-12-16 
 * http://naver.github.io/egjs 
 * 
 * Forked By Naver egjs 
 * Copyright (c) hammerjs 
 * Licensed under the MIT license */</span>
<span class="s1">(</span><span class="s2">function </span><span class="s1">(global, factory) {</span>
  <span class="s2">typeof </span><span class="s1">exports === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module !== </span><span class="s3">'undefined' </span><span class="s1">? module.exports = factory() :</span>
  <span class="s2">typeof </span><span class="s1">define === </span><span class="s3">'function' </span><span class="s1">&amp;&amp; define.amd ? define(factory) :</span>
  <span class="s1">(global.Hammer = factory());</span>
<span class="s1">}(</span><span class="s2">this</span><span class="s1">, (</span><span class="s2">function </span><span class="s1">() { </span><span class="s3">'use strict'</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">_extends() {</span>
    <span class="s1">_extends = Object.assign || </span><span class="s2">function </span><span class="s1">(target) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">1</span><span class="s1">; i &lt; arguments.length; i++) {</span>
        <span class="s2">var </span><span class="s1">source = arguments[i];</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">source) {</span>
          <span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(source, key)) {</span>
            <span class="s1">target[key] = source[key];</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">target;</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">_extends.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">_inheritsLoose(subClass, superClass) {</span>
    <span class="s1">subClass.prototype = Object.create(superClass.prototype);</span>
    <span class="s1">subClass.prototype.constructor = subClass;</span>
    <span class="s1">subClass.__proto__ = superClass;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">_assertThisInitialized(self) {</span>
    <span class="s2">if </span><span class="s1">(self === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">throw new </span><span class="s1">ReferenceError(</span><span class="s3">&quot;this hasn't been initialised - super() hasn't been called&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">self;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * extend object. 
   * means that properties in dest will be overwritten by the ones in src. 
   * @param {Object} target 
   * @param {...Object} objects_to_assign 
   * @returns {Object} target 
   */</span>
  <span class="s2">var </span><span class="s1">assign;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">Object.assign !== </span><span class="s3">'function'</span><span class="s1">) {</span>
    <span class="s1">assign = </span><span class="s2">function </span><span class="s1">assign(target) {</span>
      <span class="s2">if </span><span class="s1">(target === undefined || target === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s3">'Cannot convert undefined or null to object'</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">output = Object(target);</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">index = </span><span class="s4">1</span><span class="s1">; index &lt; arguments.length; index++) {</span>
        <span class="s2">var </span><span class="s1">source = arguments[index];</span>

        <span class="s2">if </span><span class="s1">(source !== undefined &amp;&amp; source !== </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">nextKey </span><span class="s2">in </span><span class="s1">source) {</span>
            <span class="s2">if </span><span class="s1">(source.hasOwnProperty(nextKey)) {</span>
              <span class="s1">output[nextKey] = source[nextKey];</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">output;</span>
    <span class="s1">};</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">assign = Object.assign;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">assign$1 = assign;</span>

  <span class="s2">var </span><span class="s1">VENDOR_PREFIXES = [</span><span class="s3">''</span><span class="s1">, </span><span class="s3">'webkit'</span><span class="s1">, </span><span class="s3">'Moz'</span><span class="s1">, </span><span class="s3">'MS'</span><span class="s1">, </span><span class="s3">'ms'</span><span class="s1">, </span><span class="s3">'o'</span><span class="s1">];</span>
  <span class="s2">var </span><span class="s1">TEST_ELEMENT = </span><span class="s2">typeof </span><span class="s1">document === </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? {</span>
    <span class="s1">style: {}</span>
  <span class="s1">} : document.createElement(</span><span class="s3">'div'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">TYPE_FUNCTION = </span><span class="s3">'function'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">round = Math.round,</span>
      <span class="s1">abs = Math.abs;</span>
  <span class="s2">var </span><span class="s1">now = Date.now;</span>

  <span class="s0">/** 
   * @private 
   * get the prefixed property 
   * @param {Object} obj 
   * @param {String} property 
   * @returns {String|Undefined} prefixed 
   */</span>

  <span class="s2">function </span><span class="s1">prefixed(obj, property) {</span>
    <span class="s2">var </span><span class="s1">prefix;</span>
    <span class="s2">var </span><span class="s1">prop;</span>
    <span class="s2">var </span><span class="s1">camelProp = property[</span><span class="s4">0</span><span class="s1">].toUpperCase() + property.slice(</span><span class="s4">1</span><span class="s1">);</span>
    <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(i &lt; VENDOR_PREFIXES.length) {</span>
      <span class="s1">prefix = VENDOR_PREFIXES[i];</span>
      <span class="s1">prop = prefix ? prefix + camelProp : property;</span>

      <span class="s2">if </span><span class="s1">(prop </span><span class="s2">in </span><span class="s1">obj) {</span>
        <span class="s2">return </span><span class="s1">prop;</span>
      <span class="s1">}</span>

      <span class="s1">i++;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">undefined;</span>
  <span class="s1">}</span>

  <span class="s0">/* eslint-disable no-new-func, no-nested-ternary */</span>
  <span class="s2">var </span><span class="s1">win;</span>

  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window === </span><span class="s3">&quot;undefined&quot;</span><span class="s1">) {</span>
    <span class="s0">// window is undefined in node.js</span>
    <span class="s1">win = {};</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">win = window;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, </span><span class="s3">'touchAction'</span><span class="s1">);</span>
  <span class="s2">var </span><span class="s1">NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;</span>
  <span class="s2">function </span><span class="s1">getTouchActionProps() {</span>
    <span class="s2">if </span><span class="s1">(!NATIVE_TOUCH_ACTION) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">touchMap = {};</span>
    <span class="s2">var </span><span class="s1">cssSupports = win.CSS &amp;&amp; win.CSS.supports;</span>
    <span class="s1">[</span><span class="s3">'auto'</span><span class="s1">, </span><span class="s3">'manipulation'</span><span class="s1">, </span><span class="s3">'pan-y'</span><span class="s1">, </span><span class="s3">'pan-x'</span><span class="s1">, </span><span class="s3">'pan-x pan-y'</span><span class="s1">, </span><span class="s3">'none'</span><span class="s1">].forEach(</span><span class="s2">function </span><span class="s1">(val) {</span>
      <span class="s0">// If css.supports is not supported but there is native touch-action assume it supports</span>
      <span class="s0">// all values. This is the case for IE 10 and 11.</span>
      <span class="s2">return </span><span class="s1">touchMap[val] = cssSupports ? win.CSS.supports(</span><span class="s3">'touch-action'</span><span class="s1">, val) : </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">touchMap;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">TOUCH_ACTION_COMPUTE = </span><span class="s3">'compute'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TOUCH_ACTION_AUTO = </span><span class="s3">'auto'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TOUCH_ACTION_MANIPULATION = </span><span class="s3">'manipulation'</span><span class="s1">; </span><span class="s0">// not implemented</span>

  <span class="s2">var </span><span class="s1">TOUCH_ACTION_NONE = </span><span class="s3">'none'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TOUCH_ACTION_PAN_X = </span><span class="s3">'pan-x'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TOUCH_ACTION_PAN_Y = </span><span class="s3">'pan-y'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">TOUCH_ACTION_MAP = getTouchActionProps();</span>

  <span class="s2">var </span><span class="s1">MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;</span>
  <span class="s2">var </span><span class="s1">SUPPORT_TOUCH = </span><span class="s3">'ontouchstart' </span><span class="s2">in </span><span class="s1">win;</span>
  <span class="s2">var </span><span class="s1">SUPPORT_POINTER_EVENTS = prefixed(win, </span><span class="s3">'PointerEvent'</span><span class="s1">) !== undefined;</span>
  <span class="s2">var </span><span class="s1">SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH &amp;&amp; MOBILE_REGEX.test(navigator.userAgent);</span>
  <span class="s2">var </span><span class="s1">INPUT_TYPE_TOUCH = </span><span class="s3">'touch'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">INPUT_TYPE_PEN = </span><span class="s3">'pen'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">INPUT_TYPE_MOUSE = </span><span class="s3">'mouse'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">INPUT_TYPE_KINECT = </span><span class="s3">'kinect'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">COMPUTE_INTERVAL = </span><span class="s4">25</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">INPUT_START = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">INPUT_MOVE = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">INPUT_END = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">INPUT_CANCEL = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_NONE = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_LEFT = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_RIGHT = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_UP = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_DOWN = </span><span class="s4">16</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;</span>
  <span class="s2">var </span><span class="s1">DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;</span>
  <span class="s2">var </span><span class="s1">PROPS_XY = [</span><span class="s3">'x'</span><span class="s1">, </span><span class="s3">'y'</span><span class="s1">];</span>
  <span class="s2">var </span><span class="s1">PROPS_CLIENT_XY = [</span><span class="s3">'clientX'</span><span class="s1">, </span><span class="s3">'clientY'</span><span class="s1">];</span>

  <span class="s0">/** 
   * @private 
   * walk objects and arrays 
   * @param {Object} obj 
   * @param {Function} iterator 
   * @param {Object} context 
   */</span>
  <span class="s2">function </span><span class="s1">each(obj, iterator, context) {</span>
    <span class="s2">var </span><span class="s1">i;</span>

    <span class="s2">if </span><span class="s1">(!obj) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(obj.forEach) {</span>
      <span class="s1">obj.forEach(iterator, context);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(obj.length !== undefined) {</span>
      <span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(i &lt; obj.length) {</span>
        <span class="s1">iterator.call(context, obj[i], i, obj);</span>
        <span class="s1">i++;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">for </span><span class="s1">(i </span><span class="s2">in </span><span class="s1">obj) {</span>
        <span class="s1">obj.hasOwnProperty(i) &amp;&amp; iterator.call(context, obj[i], i, obj);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * let a boolean value also be a function that must return a boolean 
   * this first item in args will be used as the context 
   * @param {Boolean|Function} val 
   * @param {Array} [args] 
   * @returns {Boolean} 
   */</span>

  <span class="s2">function </span><span class="s1">boolOrFn(val, args) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">val === TYPE_FUNCTION) {</span>
      <span class="s2">return </span><span class="s1">val.apply(args ? args[</span><span class="s4">0</span><span class="s1">] || undefined : undefined, args);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">val;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * small indexOf wrapper 
   * @param {String} str 
   * @param {String} find 
   * @returns {Boolean} found 
   */</span>
  <span class="s2">function </span><span class="s1">inStr(str, find) {</span>
    <span class="s2">return </span><span class="s1">str.indexOf(find) &gt; -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * when the touchActions are collected they are not a valid value, so we need to clean things up. * 
   * @param {String} actions 
   * @returns {*} 
   */</span>

  <span class="s2">function </span><span class="s1">cleanTouchActions(actions) {</span>
    <span class="s0">// none</span>
    <span class="s2">if </span><span class="s1">(inStr(actions, TOUCH_ACTION_NONE)) {</span>
      <span class="s2">return </span><span class="s1">TOUCH_ACTION_NONE;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);</span>
    <span class="s2">var </span><span class="s1">hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); </span><span class="s0">// if both pan-x and pan-y are set (different recognizers</span>
    <span class="s0">// for different directions, e.g. horizontal pan but vertical swipe?)</span>
    <span class="s0">// we need none (as otherwise with pan-x pan-y combined none of these</span>
    <span class="s0">// recognizers will work, since the browser would handle all panning</span>

    <span class="s2">if </span><span class="s1">(hasPanX &amp;&amp; hasPanY) {</span>
      <span class="s2">return </span><span class="s1">TOUCH_ACTION_NONE;</span>
    <span class="s1">} </span><span class="s0">// pan-x OR pan-y</span>


    <span class="s2">if </span><span class="s1">(hasPanX || hasPanY) {</span>
      <span class="s2">return </span><span class="s1">hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;</span>
    <span class="s1">} </span><span class="s0">// manipulation</span>


    <span class="s2">if </span><span class="s1">(inStr(actions, TOUCH_ACTION_MANIPULATION)) {</span>
      <span class="s2">return </span><span class="s1">TOUCH_ACTION_MANIPULATION;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">TOUCH_ACTION_AUTO;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * Touch Action 
   * sets the touchAction property or uses the js alternative 
   * @param {Manager} manager 
   * @param {String} value 
   * @constructor 
   */</span>

  <span class="s2">var </span><span class="s1">TouchAction =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">function </span><span class="s1">TouchAction(manager, value) {</span>
      <span class="s2">this</span><span class="s1">.manager = manager;</span>
      <span class="s2">this</span><span class="s1">.set(value);</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * @private 
     * set the touchAction value on the element or enable the polyfill 
     * @param {String} value 
     */</span>


    <span class="s2">var </span><span class="s1">_proto = TouchAction.prototype;</span>

    <span class="s1">_proto.set = </span><span class="s2">function </span><span class="s1">set(value) {</span>
      <span class="s0">// find out the touch-action by the event handlers</span>
      <span class="s2">if </span><span class="s1">(value === TOUCH_ACTION_COMPUTE) {</span>
        <span class="s1">value = </span><span class="s2">this</span><span class="s1">.compute();</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(NATIVE_TOUCH_ACTION &amp;&amp; </span><span class="s2">this</span><span class="s1">.manager.element.style &amp;&amp; TOUCH_ACTION_MAP[value]) {</span>
        <span class="s2">this</span><span class="s1">.manager.element.style[PREFIXED_TOUCH_ACTION] = value;</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.actions = value.toLowerCase().trim();</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * just re-set the touchAction value 
     */</span>


    <span class="s1">_proto.update = </span><span class="s2">function </span><span class="s1">update() {</span>
      <span class="s2">this</span><span class="s1">.set(</span><span class="s2">this</span><span class="s1">.manager.options.touchAction);</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * compute the value for the touchAction property based on the recognizer's settings 
     * @returns {String} value 
     */</span>


    <span class="s1">_proto.compute = </span><span class="s2">function </span><span class="s1">compute() {</span>
      <span class="s2">var </span><span class="s1">actions = [];</span>
      <span class="s1">each(</span><span class="s2">this</span><span class="s1">.manager.recognizers, </span><span class="s2">function </span><span class="s1">(recognizer) {</span>
        <span class="s2">if </span><span class="s1">(boolOrFn(recognizer.options.enable, [recognizer])) {</span>
          <span class="s1">actions = actions.concat(recognizer.getTouchAction());</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return </span><span class="s1">cleanTouchActions(actions.join(</span><span class="s3">' '</span><span class="s1">));</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * this method is called on each input cycle and provides the preventing of the browser behavior 
     * @param {Object} input 
     */</span>


    <span class="s1">_proto.preventDefaults = </span><span class="s2">function </span><span class="s1">preventDefaults(input) {</span>
      <span class="s2">var </span><span class="s1">srcEvent = input.srcEvent;</span>
      <span class="s2">var </span><span class="s1">direction = input.offsetDirection; </span><span class="s0">// if the touch action did prevented once this session</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.manager.session.prevented) {</span>
        <span class="s1">srcEvent.preventDefault();</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">actions = </span><span class="s2">this</span><span class="s1">.actions;</span>
      <span class="s2">var </span><span class="s1">hasNone = inStr(actions, TOUCH_ACTION_NONE) &amp;&amp; !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];</span>
      <span class="s2">var </span><span class="s1">hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) &amp;&amp; !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];</span>
      <span class="s2">var </span><span class="s1">hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) &amp;&amp; !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];</span>

      <span class="s2">if </span><span class="s1">(hasNone) {</span>
        <span class="s0">// do not prevent defaults if this is a tap gesture</span>
        <span class="s2">var </span><span class="s1">isTapPointer = input.pointers.length === </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">isTapMovement = input.distance &lt; </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">isTapTouchTime = input.deltaTime &lt; </span><span class="s4">250</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(isTapPointer &amp;&amp; isTapMovement &amp;&amp; isTapTouchTime) {</span>
          <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(hasPanX &amp;&amp; hasPanY) {</span>
        <span class="s0">// `pan-x pan-y` means browser handles all scrolling/panning, do not prevent</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(hasNone || hasPanY &amp;&amp; direction &amp; DIRECTION_HORIZONTAL || hasPanX &amp;&amp; direction &amp; DIRECTION_VERTICAL) {</span>
        <span class="s2">return this</span><span class="s1">.preventSrc(srcEvent);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases) 
     * @param {Object} srcEvent 
     */</span>


    <span class="s1">_proto.preventSrc = </span><span class="s2">function </span><span class="s1">preventSrc(srcEvent) {</span>
      <span class="s2">this</span><span class="s1">.manager.session.prevented = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">srcEvent.preventDefault();</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">TouchAction;</span>
  <span class="s1">}();</span>

  <span class="s0">/** 
   * @private 
   * find if a node is in the given parent 
   * @method hasParent 
   * @param {HTMLElement} node 
   * @param {HTMLElement} parent 
   * @return {Boolean} found 
   */</span>
  <span class="s2">function </span><span class="s1">hasParent(node, parent) {</span>
    <span class="s2">while </span><span class="s1">(node) {</span>
      <span class="s2">if </span><span class="s1">(node === parent) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">node = node.parentNode;</span>
    <span class="s1">}</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * get the center of all the pointers 
   * @param {Array} pointers 
   * @return {Object} center contains `x` and `y` properties 
   */</span>

  <span class="s2">function </span><span class="s1">getCenter(pointers) {</span>
    <span class="s2">var </span><span class="s1">pointersLength = pointers.length; </span><span class="s0">// no need to loop when only one touch</span>

    <span class="s2">if </span><span class="s1">(pointersLength === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">x: round(pointers[</span><span class="s4">0</span><span class="s1">].clientX),</span>
        <span class="s1">y: round(pointers[</span><span class="s4">0</span><span class="s1">].clientY)</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">x = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">y = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(i &lt; pointersLength) {</span>
      <span class="s1">x += pointers[i].clientX;</span>
      <span class="s1">y += pointers[i].clientY;</span>
      <span class="s1">i++;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">x: round(x / pointersLength),</span>
      <span class="s1">y: round(y / pointersLength)</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * create a simple clone from the input used for storage of firstInput and firstMultiple 
   * @param {Object} input 
   * @returns {Object} clonedInputData 
   */</span>

  <span class="s2">function </span><span class="s1">simpleCloneInputData(input) {</span>
    <span class="s0">// make a simple copy of the pointers because we will get a reference if we don't</span>
    <span class="s0">// we only need clientXY for the calculations</span>
    <span class="s2">var </span><span class="s1">pointers = [];</span>
    <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(i &lt; input.pointers.length) {</span>
      <span class="s1">pointers[i] = {</span>
        <span class="s1">clientX: round(input.pointers[i].clientX),</span>
        <span class="s1">clientY: round(input.pointers[i].clientY)</span>
      <span class="s1">};</span>
      <span class="s1">i++;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">timeStamp: now(),</span>
      <span class="s1">pointers: pointers,</span>
      <span class="s1">center: getCenter(pointers),</span>
      <span class="s1">deltaX: input.deltaX,</span>
      <span class="s1">deltaY: input.deltaY</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * calculate the absolute distance between two points 
   * @param {Object} p1 {x, y} 
   * @param {Object} p2 {x, y} 
   * @param {Array} [props] containing x and y keys 
   * @return {Number} distance 
   */</span>

  <span class="s2">function </span><span class="s1">getDistance(p1, p2, props) {</span>
    <span class="s2">if </span><span class="s1">(!props) {</span>
      <span class="s1">props = PROPS_XY;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">x = p2[props[</span><span class="s4">0</span><span class="s1">]] - p1[props[</span><span class="s4">0</span><span class="s1">]];</span>
    <span class="s2">var </span><span class="s1">y = p2[props[</span><span class="s4">1</span><span class="s1">]] - p1[props[</span><span class="s4">1</span><span class="s1">]];</span>
    <span class="s2">return </span><span class="s1">Math.sqrt(x * x + y * y);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * calculate the angle between two coordinates 
   * @param {Object} p1 
   * @param {Object} p2 
   * @param {Array} [props] containing x and y keys 
   * @return {Number} angle 
   */</span>

  <span class="s2">function </span><span class="s1">getAngle(p1, p2, props) {</span>
    <span class="s2">if </span><span class="s1">(!props) {</span>
      <span class="s1">props = PROPS_XY;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">x = p2[props[</span><span class="s4">0</span><span class="s1">]] - p1[props[</span><span class="s4">0</span><span class="s1">]];</span>
    <span class="s2">var </span><span class="s1">y = p2[props[</span><span class="s4">1</span><span class="s1">]] - p1[props[</span><span class="s4">1</span><span class="s1">]];</span>
    <span class="s2">return </span><span class="s1">Math.atan2(y, x) * </span><span class="s4">180 </span><span class="s1">/ Math.PI;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * get the direction between two points 
   * @param {Number} x 
   * @param {Number} y 
   * @return {Number} direction 
   */</span>

  <span class="s2">function </span><span class="s1">getDirection(x, y) {</span>
    <span class="s2">if </span><span class="s1">(x === y) {</span>
      <span class="s2">return </span><span class="s1">DIRECTION_NONE;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(abs(x) &gt;= abs(y)) {</span>
      <span class="s2">return </span><span class="s1">x &lt; </span><span class="s4">0 </span><span class="s1">? DIRECTION_LEFT : DIRECTION_RIGHT;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">y &lt; </span><span class="s4">0 </span><span class="s1">? DIRECTION_UP : DIRECTION_DOWN;</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">computeDeltaXY(session, input) {</span>
    <span class="s2">var </span><span class="s1">center = input.center; </span><span class="s0">// let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;</span>
    <span class="s0">// jscs throwing error on defalut destructured values and without defaults tests fail</span>

    <span class="s2">var </span><span class="s1">offset = session.offsetDelta || {};</span>
    <span class="s2">var </span><span class="s1">prevDelta = session.prevDelta || {};</span>
    <span class="s2">var </span><span class="s1">prevInput = session.prevInput || {};</span>

    <span class="s2">if </span><span class="s1">(input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {</span>
      <span class="s1">prevDelta = session.prevDelta = {</span>
        <span class="s1">x: prevInput.deltaX || </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">y: prevInput.deltaY || </span><span class="s4">0</span>
      <span class="s1">};</span>
      <span class="s1">offset = session.offsetDelta = {</span>
        <span class="s1">x: center.x,</span>
        <span class="s1">y: center.y</span>
      <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s1">input.deltaX = prevDelta.x + (center.x - offset.x);</span>
    <span class="s1">input.deltaY = prevDelta.y + (center.y - offset.y);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * calculate the velocity between two points. unit is in px per ms. 
   * @param {Number} deltaTime 
   * @param {Number} x 
   * @param {Number} y 
   * @return {Object} velocity `x` and `y` 
   */</span>
  <span class="s2">function </span><span class="s1">getVelocity(deltaTime, x, y) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">x: x / deltaTime || </span><span class="s4">0</span><span class="s1">,</span>
      <span class="s1">y: y / deltaTime || </span><span class="s4">0</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * calculate the scale factor between two pointersets 
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out 
   * @param {Array} start array of pointers 
   * @param {Array} end array of pointers 
   * @return {Number} scale 
   */</span>

  <span class="s2">function </span><span class="s1">getScale(start, end) {</span>
    <span class="s2">return </span><span class="s1">getDistance(end[</span><span class="s4">0</span><span class="s1">], end[</span><span class="s4">1</span><span class="s1">], PROPS_CLIENT_XY) / getDistance(start[</span><span class="s4">0</span><span class="s1">], start[</span><span class="s4">1</span><span class="s1">], PROPS_CLIENT_XY);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * calculate the rotation degrees between two pointersets 
   * @param {Array} start array of pointers 
   * @param {Array} end array of pointers 
   * @return {Number} rotation 
   */</span>

  <span class="s2">function </span><span class="s1">getRotation(start, end) {</span>
    <span class="s2">return </span><span class="s1">getAngle(end[</span><span class="s4">1</span><span class="s1">], end[</span><span class="s4">0</span><span class="s1">], PROPS_CLIENT_XY) + getAngle(start[</span><span class="s4">1</span><span class="s1">], start[</span><span class="s4">0</span><span class="s1">], PROPS_CLIENT_XY);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * velocity is calculated every x ms 
   * @param {Object} session 
   * @param {Object} input 
   */</span>

  <span class="s2">function </span><span class="s1">computeIntervalInputData(session, input) {</span>
    <span class="s2">var </span><span class="s1">last = session.lastInterval || input;</span>
    <span class="s2">var </span><span class="s1">deltaTime = input.timeStamp - last.timeStamp;</span>
    <span class="s2">var </span><span class="s1">velocity;</span>
    <span class="s2">var </span><span class="s1">velocityX;</span>
    <span class="s2">var </span><span class="s1">velocityY;</span>
    <span class="s2">var </span><span class="s1">direction;</span>

    <span class="s2">if </span><span class="s1">(input.eventType !== INPUT_CANCEL &amp;&amp; (deltaTime &gt; COMPUTE_INTERVAL || last.velocity === undefined)) {</span>
      <span class="s2">var </span><span class="s1">deltaX = input.deltaX - last.deltaX;</span>
      <span class="s2">var </span><span class="s1">deltaY = input.deltaY - last.deltaY;</span>
      <span class="s2">var </span><span class="s1">v = getVelocity(deltaTime, deltaX, deltaY);</span>
      <span class="s1">velocityX = v.x;</span>
      <span class="s1">velocityY = v.y;</span>
      <span class="s1">velocity = abs(v.x) &gt; abs(v.y) ? v.x : v.y;</span>
      <span class="s1">direction = getDirection(deltaX, deltaY);</span>
      <span class="s1">session.lastInterval = input;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s0">// use latest velocity info if it doesn't overtake a minimum period</span>
      <span class="s1">velocity = last.velocity;</span>
      <span class="s1">velocityX = last.velocityX;</span>
      <span class="s1">velocityY = last.velocityY;</span>
      <span class="s1">direction = last.direction;</span>
    <span class="s1">}</span>

    <span class="s1">input.velocity = velocity;</span>
    <span class="s1">input.velocityX = velocityX;</span>
    <span class="s1">input.velocityY = velocityY;</span>
    <span class="s1">input.direction = direction;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
  * @private 
   * extend the data with some usable properties like scale, rotate, velocity etc 
   * @param {Object} manager 
   * @param {Object} input 
   */</span>

  <span class="s2">function </span><span class="s1">computeInputData(manager, input) {</span>
    <span class="s2">var </span><span class="s1">session = manager.session;</span>
    <span class="s2">var </span><span class="s1">pointers = input.pointers;</span>
    <span class="s2">var </span><span class="s1">pointersLength = pointers.length; </span><span class="s0">// store the first input to calculate the distance and direction</span>

    <span class="s2">if </span><span class="s1">(!session.firstInput) {</span>
      <span class="s1">session.firstInput = simpleCloneInputData(input);</span>
    <span class="s1">} </span><span class="s0">// to compute scale and rotation we need to store the multiple touches</span>


    <span class="s2">if </span><span class="s1">(pointersLength &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; !session.firstMultiple) {</span>
      <span class="s1">session.firstMultiple = simpleCloneInputData(input);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pointersLength === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">session.firstMultiple = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">firstInput = session.firstInput,</span>
        <span class="s1">firstMultiple = session.firstMultiple;</span>
    <span class="s2">var </span><span class="s1">offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;</span>
    <span class="s2">var </span><span class="s1">center = input.center = getCenter(pointers);</span>
    <span class="s1">input.timeStamp = now();</span>
    <span class="s1">input.deltaTime = input.timeStamp - firstInput.timeStamp;</span>
    <span class="s1">input.angle = getAngle(offsetCenter, center);</span>
    <span class="s1">input.distance = getDistance(offsetCenter, center);</span>
    <span class="s1">computeDeltaXY(session, input);</span>
    <span class="s1">input.offsetDirection = getDirection(input.deltaX, input.deltaY);</span>
    <span class="s2">var </span><span class="s1">overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);</span>
    <span class="s1">input.overallVelocityX = overallVelocity.x;</span>
    <span class="s1">input.overallVelocityY = overallVelocity.y;</span>
    <span class="s1">input.overallVelocity = abs(overallVelocity.x) &gt; abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;</span>
    <span class="s1">input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length &gt; session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;</span>
    <span class="s1">computeIntervalInputData(session, input); </span><span class="s0">// find the correct target</span>

    <span class="s2">var </span><span class="s1">target = manager.element;</span>
    <span class="s2">var </span><span class="s1">srcEvent = input.srcEvent;</span>
    <span class="s2">var </span><span class="s1">srcEventTarget;</span>

    <span class="s2">if </span><span class="s1">(srcEvent.composedPath) {</span>
      <span class="s1">srcEventTarget = srcEvent.composedPath()[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(srcEvent.path) {</span>
      <span class="s1">srcEventTarget = srcEvent.path[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">srcEventTarget = srcEvent.target;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(hasParent(srcEventTarget, target)) {</span>
      <span class="s1">target = srcEventTarget;</span>
    <span class="s1">}</span>

    <span class="s1">input.target = target;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * handle input events 
   * @param {Manager} manager 
   * @param {String} eventType 
   * @param {Object} input 
   */</span>

  <span class="s2">function </span><span class="s1">inputHandler(manager, eventType, input) {</span>
    <span class="s2">var </span><span class="s1">pointersLen = input.pointers.length;</span>
    <span class="s2">var </span><span class="s1">changedPointersLen = input.changedPointers.length;</span>
    <span class="s2">var </span><span class="s1">isFirst = eventType &amp; INPUT_START &amp;&amp; pointersLen - changedPointersLen === </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">isFinal = eventType &amp; (INPUT_END | INPUT_CANCEL) &amp;&amp; pointersLen - changedPointersLen === </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">input.isFirst = !!isFirst;</span>
    <span class="s1">input.isFinal = !!isFinal;</span>

    <span class="s2">if </span><span class="s1">(isFirst) {</span>
      <span class="s1">manager.session = {};</span>
    <span class="s1">} </span><span class="s0">// source event is the normalized value of the domEvents</span>
    <span class="s0">// like 'touchstart, mouseup, pointerdown'</span>


    <span class="s1">input.eventType = eventType; </span><span class="s0">// compute scale, rotation etc</span>

    <span class="s1">computeInputData(manager, input); </span><span class="s0">// emit secret event</span>

    <span class="s1">manager.emit(</span><span class="s3">'hammer.input'</span><span class="s1">, input);</span>
    <span class="s1">manager.recognize(input);</span>
    <span class="s1">manager.session.prevInput = input;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * split string on whitespace 
   * @param {String} str 
   * @returns {Array} words 
   */</span>
  <span class="s2">function </span><span class="s1">splitStr(str) {</span>
    <span class="s2">return </span><span class="s1">str.trim().split(/\s+/g);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * addEventListener with multiple events at once 
   * @param {EventTarget} target 
   * @param {String} types 
   * @param {Function} handler 
   */</span>

  <span class="s2">function </span><span class="s1">addEventListeners(target, types, handler) {</span>
    <span class="s1">each(splitStr(types), </span><span class="s2">function </span><span class="s1">(type) {</span>
      <span class="s1">target.addEventListener(type, handler, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * removeEventListener with multiple events at once 
   * @param {EventTarget} target 
   * @param {String} types 
   * @param {Function} handler 
   */</span>

  <span class="s2">function </span><span class="s1">removeEventListeners(target, types, handler) {</span>
    <span class="s1">each(splitStr(types), </span><span class="s2">function </span><span class="s1">(type) {</span>
      <span class="s1">target.removeEventListener(type, handler, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">});</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * get the window object of an element 
   * @param {HTMLElement} element 
   * @returns {DocumentView|Window} 
   */</span>
  <span class="s2">function </span><span class="s1">getWindowForElement(element) {</span>
    <span class="s2">var </span><span class="s1">doc = element.ownerDocument || element;</span>
    <span class="s2">return </span><span class="s1">doc.defaultView || doc.parentWindow || window;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * create new input type manager 
   * @param {Manager} manager 
   * @param {Function} callback 
   * @returns {Input} 
   * @constructor 
   */</span>

  <span class="s2">var </span><span class="s1">Input =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">function </span><span class="s1">Input(manager, callback) {</span>
      <span class="s2">var </span><span class="s1">self = </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.manager = manager;</span>
      <span class="s2">this</span><span class="s1">.callback = callback;</span>
      <span class="s2">this</span><span class="s1">.element = manager.element;</span>
      <span class="s2">this</span><span class="s1">.target = manager.options.inputTarget; </span><span class="s0">// smaller wrapper around the handler, for the scope and the enabled state of the manager,</span>
      <span class="s0">// so when disabled the input events are completely bypassed.</span>

      <span class="s2">this</span><span class="s1">.domHandler = </span><span class="s2">function </span><span class="s1">(ev) {</span>
        <span class="s2">if </span><span class="s1">(boolOrFn(manager.options.enable, [manager])) {</span>
          <span class="s1">self.handler(ev);</span>
        <span class="s1">}</span>
      <span class="s1">};</span>

      <span class="s2">this</span><span class="s1">.init();</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * @private 
     * should handle the inputEvent data and trigger the callback 
     * @virtual 
     */</span>


    <span class="s2">var </span><span class="s1">_proto = Input.prototype;</span>

    <span class="s1">_proto.handler = </span><span class="s2">function </span><span class="s1">handler() {};</span>
    <span class="s0">/** 
     * @private 
     * bind the events 
     */</span>


    <span class="s1">_proto.init = </span><span class="s2">function </span><span class="s1">init() {</span>
      <span class="s2">this</span><span class="s1">.evEl &amp;&amp; addEventListeners(</span><span class="s2">this</span><span class="s1">.element, </span><span class="s2">this</span><span class="s1">.evEl, </span><span class="s2">this</span><span class="s1">.domHandler);</span>
      <span class="s2">this</span><span class="s1">.evTarget &amp;&amp; addEventListeners(</span><span class="s2">this</span><span class="s1">.target, </span><span class="s2">this</span><span class="s1">.evTarget, </span><span class="s2">this</span><span class="s1">.domHandler);</span>
      <span class="s2">this</span><span class="s1">.evWin &amp;&amp; addEventListeners(getWindowForElement(</span><span class="s2">this</span><span class="s1">.element), </span><span class="s2">this</span><span class="s1">.evWin, </span><span class="s2">this</span><span class="s1">.domHandler);</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * unbind the events 
     */</span>


    <span class="s1">_proto.destroy = </span><span class="s2">function </span><span class="s1">destroy() {</span>
      <span class="s2">this</span><span class="s1">.evEl &amp;&amp; removeEventListeners(</span><span class="s2">this</span><span class="s1">.element, </span><span class="s2">this</span><span class="s1">.evEl, </span><span class="s2">this</span><span class="s1">.domHandler);</span>
      <span class="s2">this</span><span class="s1">.evTarget &amp;&amp; removeEventListeners(</span><span class="s2">this</span><span class="s1">.target, </span><span class="s2">this</span><span class="s1">.evTarget, </span><span class="s2">this</span><span class="s1">.domHandler);</span>
      <span class="s2">this</span><span class="s1">.evWin &amp;&amp; removeEventListeners(getWindowForElement(</span><span class="s2">this</span><span class="s1">.element), </span><span class="s2">this</span><span class="s1">.evWin, </span><span class="s2">this</span><span class="s1">.domHandler);</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">Input;</span>
  <span class="s1">}();</span>

  <span class="s0">/** 
   * @private 
   * find if a array contains the object using indexOf or a simple polyFill 
   * @param {Array} src 
   * @param {String} find 
   * @param {String} [findByKey] 
   * @return {Boolean|Number} false when not found, or the index 
   */</span>
  <span class="s2">function </span><span class="s1">inArray(src, find, findByKey) {</span>
    <span class="s2">if </span><span class="s1">(src.indexOf &amp;&amp; !findByKey) {</span>
      <span class="s2">return </span><span class="s1">src.indexOf(find);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(i &lt; src.length) {</span>
        <span class="s2">if </span><span class="s1">(findByKey &amp;&amp; src[i][findByKey] == find || !findByKey &amp;&amp; src[i] === find) {</span>
          <span class="s0">// do not use === here, test fails</span>
          <span class="s2">return </span><span class="s1">i;</span>
        <span class="s1">}</span>

        <span class="s1">i++;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">POINTER_INPUT_MAP = {</span>
    <span class="s1">pointerdown: INPUT_START,</span>
    <span class="s1">pointermove: INPUT_MOVE,</span>
    <span class="s1">pointerup: INPUT_END,</span>
    <span class="s1">pointercancel: INPUT_CANCEL,</span>
    <span class="s1">pointerout: INPUT_CANCEL</span>
  <span class="s1">}; </span><span class="s0">// in IE10 the pointer types is defined as an enum</span>

  <span class="s2">var </span><span class="s1">IE10_POINTER_TYPE_ENUM = {</span>
    <span class="s4">2</span><span class="s1">: INPUT_TYPE_TOUCH,</span>
    <span class="s4">3</span><span class="s1">: INPUT_TYPE_PEN,</span>
    <span class="s4">4</span><span class="s1">: INPUT_TYPE_MOUSE,</span>
    <span class="s4">5</span><span class="s1">: INPUT_TYPE_KINECT </span><span class="s0">// see https://twitter.com/jacobrossi/status/480596438489890816</span>

  <span class="s1">};</span>
  <span class="s2">var </span><span class="s1">POINTER_ELEMENT_EVENTS = </span><span class="s3">'pointerdown'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">POINTER_WINDOW_EVENTS = </span><span class="s3">'pointermove pointerup pointercancel'</span><span class="s1">; </span><span class="s0">// IE10 has prefixed support, and case-sensitive</span>

  <span class="s2">if </span><span class="s1">(win.MSPointerEvent &amp;&amp; !win.PointerEvent) {</span>
    <span class="s1">POINTER_ELEMENT_EVENTS = </span><span class="s3">'MSPointerDown'</span><span class="s1">;</span>
    <span class="s1">POINTER_WINDOW_EVENTS = </span><span class="s3">'MSPointerMove MSPointerUp MSPointerCancel'</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @private 
   * Pointer events input 
   * @constructor 
   * @extends Input 
   */</span>


  <span class="s2">var </span><span class="s1">PointerEventInput =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_Input) {</span>
    <span class="s1">_inheritsLoose(PointerEventInput, _Input);</span>

    <span class="s2">function </span><span class="s1">PointerEventInput() {</span>
      <span class="s2">var </span><span class="s1">_this;</span>

      <span class="s2">var </span><span class="s1">proto = PointerEventInput.prototype;</span>
      <span class="s1">proto.evEl = POINTER_ELEMENT_EVENTS;</span>
      <span class="s1">proto.evWin = POINTER_WINDOW_EVENTS;</span>
      <span class="s1">_this = _Input.apply(</span><span class="s2">this</span><span class="s1">, arguments) || </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s1">_this.store = _this.manager.session.pointerEvents = [];</span>
      <span class="s2">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * @private 
     * handle mouse events 
     * @param {Object} ev 
     */</span>


    <span class="s2">var </span><span class="s1">_proto = PointerEventInput.prototype;</span>

    <span class="s1">_proto.handler = </span><span class="s2">function </span><span class="s1">handler(ev) {</span>
      <span class="s2">var </span><span class="s1">store = </span><span class="s2">this</span><span class="s1">.store;</span>
      <span class="s2">var </span><span class="s1">removePointer = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">eventTypeNormalized = ev.type.toLowerCase().replace(</span><span class="s3">'ms'</span><span class="s1">, </span><span class="s3">''</span><span class="s1">);</span>
      <span class="s2">var </span><span class="s1">eventType = POINTER_INPUT_MAP[eventTypeNormalized];</span>
      <span class="s2">var </span><span class="s1">pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;</span>
      <span class="s2">var </span><span class="s1">isTouch = pointerType === INPUT_TYPE_TOUCH; </span><span class="s0">// get index of the event in the store</span>

      <span class="s2">var </span><span class="s1">storeIndex = inArray(store, ev.pointerId, </span><span class="s3">'pointerId'</span><span class="s1">); </span><span class="s0">// start and mouse must be down</span>

      <span class="s2">if </span><span class="s1">(eventType &amp; INPUT_START &amp;&amp; (ev.button === </span><span class="s4">0 </span><span class="s1">|| isTouch)) {</span>
        <span class="s2">if </span><span class="s1">(storeIndex &lt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">store.push(ev);</span>
          <span class="s1">storeIndex = store.length - </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(eventType &amp; (INPUT_END | INPUT_CANCEL)) {</span>
        <span class="s1">removePointer = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// it not found, so the pointer hasn't been down (so it's probably a hover)</span>


      <span class="s2">if </span><span class="s1">(storeIndex &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// update the event in the store</span>


      <span class="s1">store[storeIndex] = ev;</span>
      <span class="s2">this</span><span class="s1">.callback(</span><span class="s2">this</span><span class="s1">.manager, eventType, {</span>
        <span class="s1">pointers: store,</span>
        <span class="s1">changedPointers: [ev],</span>
        <span class="s1">pointerType: pointerType,</span>
        <span class="s1">srcEvent: ev</span>
      <span class="s1">});</span>

      <span class="s2">if </span><span class="s1">(removePointer) {</span>
        <span class="s0">// remove from the store</span>
        <span class="s1">store.splice(storeIndex, </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">PointerEventInput;</span>
  <span class="s1">}(Input);</span>

  <span class="s0">/** 
   * @private 
   * convert array-like objects to real arrays 
   * @param {Object} obj 
   * @returns {Array} 
   */</span>
  <span class="s2">function </span><span class="s1">toArray(obj) {</span>
    <span class="s2">return </span><span class="s1">Array.prototype.slice.call(obj, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * unique array with objects based on a key (like 'id') or just by the array's value 
   * @param {Array} src [{id:1},{id:2},{id:1}] 
   * @param {String} [key] 
   * @param {Boolean} [sort=False] 
   * @returns {Array} [{id:1},{id:2}] 
   */</span>

  <span class="s2">function </span><span class="s1">uniqueArray(src, key, sort) {</span>
    <span class="s2">var </span><span class="s1">results = [];</span>
    <span class="s2">var </span><span class="s1">values = [];</span>
    <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(i &lt; src.length) {</span>
      <span class="s2">var </span><span class="s1">val = key ? src[i][key] : src[i];</span>

      <span class="s2">if </span><span class="s1">(inArray(values, val) &lt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">results.push(src[i]);</span>
      <span class="s1">}</span>

      <span class="s1">values[i] = val;</span>
      <span class="s1">i++;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(sort) {</span>
      <span class="s2">if </span><span class="s1">(!key) {</span>
        <span class="s1">results = results.sort();</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">results = results.sort(</span><span class="s2">function </span><span class="s1">(a, b) {</span>
          <span class="s2">return </span><span class="s1">a[key] &gt; b[key];</span>
        <span class="s1">});</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">results;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">TOUCH_INPUT_MAP = {</span>
    <span class="s1">touchstart: INPUT_START,</span>
    <span class="s1">touchmove: INPUT_MOVE,</span>
    <span class="s1">touchend: INPUT_END,</span>
    <span class="s1">touchcancel: INPUT_CANCEL</span>
  <span class="s1">};</span>
  <span class="s2">var </span><span class="s1">TOUCH_TARGET_EVENTS = </span><span class="s3">'touchstart touchmove touchend touchcancel'</span><span class="s1">;</span>
  <span class="s0">/** 
   * @private 
   * Multi-user touch events input 
   * @constructor 
   * @extends Input 
   */</span>

  <span class="s2">var </span><span class="s1">TouchInput =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_Input) {</span>
    <span class="s1">_inheritsLoose(TouchInput, _Input);</span>

    <span class="s2">function </span><span class="s1">TouchInput() {</span>
      <span class="s2">var </span><span class="s1">_this;</span>

      <span class="s1">TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;</span>
      <span class="s1">_this = _Input.apply(</span><span class="s2">this</span><span class="s1">, arguments) || </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s1">_this.targetIds = {}; </span><span class="s0">// this.evTarget = TOUCH_TARGET_EVENTS;</span>

      <span class="s2">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = TouchInput.prototype;</span>

    <span class="s1">_proto.handler = </span><span class="s2">function </span><span class="s1">handler(ev) {</span>
      <span class="s2">var </span><span class="s1">type = TOUCH_INPUT_MAP[ev.type];</span>
      <span class="s2">var </span><span class="s1">touches = getTouches.call(</span><span class="s2">this</span><span class="s1">, ev, type);</span>

      <span class="s2">if </span><span class="s1">(!touches) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.callback(</span><span class="s2">this</span><span class="s1">.manager, type, {</span>
        <span class="s1">pointers: touches[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">changedPointers: touches[</span><span class="s4">1</span><span class="s1">],</span>
        <span class="s1">pointerType: INPUT_TYPE_TOUCH,</span>
        <span class="s1">srcEvent: ev</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">TouchInput;</span>
  <span class="s1">}(Input);</span>

  <span class="s2">function </span><span class="s1">getTouches(ev, type) {</span>
    <span class="s2">var </span><span class="s1">allTouches = toArray(ev.touches);</span>
    <span class="s2">var </span><span class="s1">targetIds = </span><span class="s2">this</span><span class="s1">.targetIds; </span><span class="s0">// when there is only one touch, the process can be simplified</span>

    <span class="s2">if </span><span class="s1">(type &amp; (INPUT_START | INPUT_MOVE) &amp;&amp; allTouches.length === </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">targetIds[allTouches[</span><span class="s4">0</span><span class="s1">].identifier] = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">[allTouches, allTouches];</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">i;</span>
    <span class="s2">var </span><span class="s1">targetTouches;</span>
    <span class="s2">var </span><span class="s1">changedTouches = toArray(ev.changedTouches);</span>
    <span class="s2">var </span><span class="s1">changedTargetTouches = [];</span>
    <span class="s2">var </span><span class="s1">target = </span><span class="s2">this</span><span class="s1">.target; </span><span class="s0">// get target touches from touches</span>

    <span class="s1">targetTouches = allTouches.filter(</span><span class="s2">function </span><span class="s1">(touch) {</span>
      <span class="s2">return </span><span class="s1">hasParent(touch.target, target);</span>
    <span class="s1">}); </span><span class="s0">// collect touches</span>

    <span class="s2">if </span><span class="s1">(type === INPUT_START) {</span>
      <span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(i &lt; targetTouches.length) {</span>
        <span class="s1">targetIds[targetTouches[i].identifier] = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">i++;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// filter changed touches to only contain touches that exist in the collected target ids</span>


    <span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(i &lt; changedTouches.length) {</span>
      <span class="s2">if </span><span class="s1">(targetIds[changedTouches[i].identifier]) {</span>
        <span class="s1">changedTargetTouches.push(changedTouches[i]);</span>
      <span class="s1">} </span><span class="s0">// cleanup removed touches</span>


      <span class="s2">if </span><span class="s1">(type &amp; (INPUT_END | INPUT_CANCEL)) {</span>
        <span class="s2">delete </span><span class="s1">targetIds[changedTouches[i].identifier];</span>
      <span class="s1">}</span>

      <span class="s1">i++;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!changedTargetTouches.length) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">[</span><span class="s0">// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'</span>
    <span class="s1">uniqueArray(targetTouches.concat(changedTargetTouches), </span><span class="s3">'identifier'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">), changedTargetTouches];</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">MOUSE_INPUT_MAP = {</span>
    <span class="s1">mousedown: INPUT_START,</span>
    <span class="s1">mousemove: INPUT_MOVE,</span>
    <span class="s1">mouseup: INPUT_END</span>
  <span class="s1">};</span>
  <span class="s2">var </span><span class="s1">MOUSE_ELEMENT_EVENTS = </span><span class="s3">'mousedown'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">MOUSE_WINDOW_EVENTS = </span><span class="s3">'mousemove mouseup'</span><span class="s1">;</span>
  <span class="s0">/** 
   * @private 
   * Mouse events input 
   * @constructor 
   * @extends Input 
   */</span>

  <span class="s2">var </span><span class="s1">MouseInput =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_Input) {</span>
    <span class="s1">_inheritsLoose(MouseInput, _Input);</span>

    <span class="s2">function </span><span class="s1">MouseInput() {</span>
      <span class="s2">var </span><span class="s1">_this;</span>

      <span class="s2">var </span><span class="s1">proto = MouseInput.prototype;</span>
      <span class="s1">proto.evEl = MOUSE_ELEMENT_EVENTS;</span>
      <span class="s1">proto.evWin = MOUSE_WINDOW_EVENTS;</span>
      <span class="s1">_this = _Input.apply(</span><span class="s2">this</span><span class="s1">, arguments) || </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s1">_this.pressed = </span><span class="s2">false</span><span class="s1">; </span><span class="s0">// mousedown state</span>

      <span class="s2">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * @private 
     * handle mouse events 
     * @param {Object} ev 
     */</span>


    <span class="s2">var </span><span class="s1">_proto = MouseInput.prototype;</span>

    <span class="s1">_proto.handler = </span><span class="s2">function </span><span class="s1">handler(ev) {</span>
      <span class="s2">var </span><span class="s1">eventType = MOUSE_INPUT_MAP[ev.type]; </span><span class="s0">// on start we want to have the left mouse button down</span>

      <span class="s2">if </span><span class="s1">(eventType &amp; INPUT_START &amp;&amp; ev.button === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.pressed = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(eventType &amp; INPUT_MOVE &amp;&amp; ev.which !== </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">eventType = INPUT_END;</span>
      <span class="s1">} </span><span class="s0">// mouse must be down</span>


      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.pressed) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(eventType &amp; INPUT_END) {</span>
        <span class="s2">this</span><span class="s1">.pressed = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.callback(</span><span class="s2">this</span><span class="s1">.manager, eventType, {</span>
        <span class="s1">pointers: [ev],</span>
        <span class="s1">changedPointers: [ev],</span>
        <span class="s1">pointerType: INPUT_TYPE_MOUSE,</span>
        <span class="s1">srcEvent: ev</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">MouseInput;</span>
  <span class="s1">}(Input);</span>

  <span class="s0">/** 
   * @private 
   * Combined touch and mouse input 
   * 
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed. 
   * This because touch devices also emit mouse events while doing a touch. 
   * 
   * @constructor 
   * @extends Input 
   */</span>

  <span class="s2">var </span><span class="s1">DEDUP_TIMEOUT = </span><span class="s4">2500</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">DEDUP_DISTANCE = </span><span class="s4">25</span><span class="s1">;</span>

  <span class="s2">function </span><span class="s1">setLastTouch(eventData) {</span>
    <span class="s2">var </span><span class="s1">_eventData$changedPoi = eventData.changedPointers,</span>
        <span class="s1">touch = _eventData$changedPoi[</span><span class="s4">0</span><span class="s1">];</span>

    <span class="s2">if </span><span class="s1">(touch.identifier === </span><span class="s2">this</span><span class="s1">.primaryTouch) {</span>
      <span class="s2">var </span><span class="s1">lastTouch = {</span>
        <span class="s1">x: touch.clientX,</span>
        <span class="s1">y: touch.clientY</span>
      <span class="s1">};</span>
      <span class="s2">var </span><span class="s1">lts = </span><span class="s2">this</span><span class="s1">.lastTouches;</span>
      <span class="s2">this</span><span class="s1">.lastTouches.push(lastTouch);</span>

      <span class="s2">var </span><span class="s1">removeLastTouch = </span><span class="s2">function </span><span class="s1">removeLastTouch() {</span>
        <span class="s2">var </span><span class="s1">i = lts.indexOf(lastTouch);</span>

        <span class="s2">if </span><span class="s1">(i &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">lts.splice(i, </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">};</span>

      <span class="s1">setTimeout(removeLastTouch, DEDUP_TIMEOUT);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">recordTouches(eventType, eventData) {</span>
    <span class="s2">if </span><span class="s1">(eventType &amp; INPUT_START) {</span>
      <span class="s2">this</span><span class="s1">.primaryTouch = eventData.changedPointers[</span><span class="s4">0</span><span class="s1">].identifier;</span>
      <span class="s1">setLastTouch.call(</span><span class="s2">this</span><span class="s1">, eventData);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(eventType &amp; (INPUT_END | INPUT_CANCEL)) {</span>
      <span class="s1">setLastTouch.call(</span><span class="s2">this</span><span class="s1">, eventData);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">function </span><span class="s1">isSyntheticEvent(eventData) {</span>
    <span class="s2">var </span><span class="s1">x = eventData.srcEvent.clientX;</span>
    <span class="s2">var </span><span class="s1">y = eventData.srcEvent.clientY;</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.lastTouches.length; i++) {</span>
      <span class="s2">var </span><span class="s1">t = </span><span class="s2">this</span><span class="s1">.lastTouches[i];</span>
      <span class="s2">var </span><span class="s1">dx = Math.abs(x - t.x);</span>
      <span class="s2">var </span><span class="s1">dy = Math.abs(y - t.y);</span>

      <span class="s2">if </span><span class="s1">(dx &lt;= DEDUP_DISTANCE &amp;&amp; dy &lt;= DEDUP_DISTANCE) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">TouchMouseInput =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">TouchMouseInput =</span>
    <span class="s0">/*#__PURE__*/</span>
    <span class="s2">function </span><span class="s1">(_Input) {</span>
      <span class="s1">_inheritsLoose(TouchMouseInput, _Input);</span>

      <span class="s2">function </span><span class="s1">TouchMouseInput(_manager, callback) {</span>
        <span class="s2">var </span><span class="s1">_this;</span>

        <span class="s1">_this = _Input.call(</span><span class="s2">this</span><span class="s1">, _manager, callback) || </span><span class="s2">this</span><span class="s1">;</span>

        <span class="s1">_this.handler = </span><span class="s2">function </span><span class="s1">(manager, inputEvent, inputData) {</span>
          <span class="s2">var </span><span class="s1">isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;</span>
          <span class="s2">var </span><span class="s1">isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;</span>

          <span class="s2">if </span><span class="s1">(isMouse &amp;&amp; inputData.sourceCapabilities &amp;&amp; inputData.sourceCapabilities.firesTouchEvents) {</span>
            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s0">// when we're in a touch event, record touches to  de-dupe synthetic mouse event</span>


          <span class="s2">if </span><span class="s1">(isTouch) {</span>
            <span class="s1">recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isMouse &amp;&amp; isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
          <span class="s1">}</span>

          <span class="s1">_this.callback(manager, inputEvent, inputData);</span>
        <span class="s1">};</span>

        <span class="s1">_this.touch = </span><span class="s2">new </span><span class="s1">TouchInput(_this.manager, _this.handler);</span>
        <span class="s1">_this.mouse = </span><span class="s2">new </span><span class="s1">MouseInput(_this.manager, _this.handler);</span>
        <span class="s1">_this.primaryTouch = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">_this.lastTouches = [];</span>
        <span class="s2">return </span><span class="s1">_this;</span>
      <span class="s1">}</span>
      <span class="s0">/** 
       * @private 
       * handle mouse and touch events 
       * @param {Hammer} manager 
       * @param {String} inputEvent 
       * @param {Object} inputData 
       */</span>


      <span class="s2">var </span><span class="s1">_proto = TouchMouseInput.prototype;</span>

      <span class="s0">/** 
       * @private 
       * remove the event listeners 
       */</span>
      <span class="s1">_proto.destroy = </span><span class="s2">function </span><span class="s1">destroy() {</span>
        <span class="s2">this</span><span class="s1">.touch.destroy();</span>
        <span class="s2">this</span><span class="s1">.mouse.destroy();</span>
      <span class="s1">};</span>

      <span class="s2">return </span><span class="s1">TouchMouseInput;</span>
    <span class="s1">}(Input);</span>

    <span class="s2">return </span><span class="s1">TouchMouseInput;</span>
  <span class="s1">}();</span>

  <span class="s0">/** 
   * @private 
   * create new input type manager 
   * called by the Manager constructor 
   * @param {Hammer} manager 
   * @returns {Input} 
   */</span>

  <span class="s2">function </span><span class="s1">createInputInstance(manager) {</span>
    <span class="s2">var </span><span class="s1">Type; </span><span class="s0">// let inputClass = manager.options.inputClass;</span>

    <span class="s2">var </span><span class="s1">inputClass = manager.options.inputClass;</span>

    <span class="s2">if </span><span class="s1">(inputClass) {</span>
      <span class="s1">Type = inputClass;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(SUPPORT_POINTER_EVENTS) {</span>
      <span class="s1">Type = PointerEventInput;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(SUPPORT_ONLY_TOUCH) {</span>
      <span class="s1">Type = TouchInput;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!SUPPORT_TOUCH) {</span>
      <span class="s1">Type = MouseInput;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">Type = TouchMouseInput;</span>
    <span class="s1">}</span>

    <span class="s2">return new </span><span class="s1">Type(manager, inputHandler);</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * if the argument is an array, we want to execute the fn on each entry 
   * if it aint an array we don't want to do a thing. 
   * this is used by all the methods that accept a single and array argument. 
   * @param {*|Array} arg 
   * @param {String} fn 
   * @param {Object} [context] 
   * @returns {Boolean} 
   */</span>

  <span class="s2">function </span><span class="s1">invokeArrayArg(arg, fn, context) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(arg)) {</span>
      <span class="s1">each(arg, context[fn], context);</span>
      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return false</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">var </span><span class="s1">STATE_POSSIBLE = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">STATE_BEGAN = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">STATE_CHANGED = </span><span class="s4">4</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">STATE_ENDED = </span><span class="s4">8</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">STATE_RECOGNIZED = STATE_ENDED;</span>
  <span class="s2">var </span><span class="s1">STATE_CANCELLED = </span><span class="s4">16</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">STATE_FAILED = </span><span class="s4">32</span><span class="s1">;</span>

  <span class="s0">/** 
   * @private 
   * get a unique id 
   * @returns {number} uniqueId 
   */</span>
  <span class="s2">var </span><span class="s1">_uniqueId = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">function </span><span class="s1">uniqueId() {</span>
    <span class="s2">return </span><span class="s1">_uniqueId++;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * get a recognizer by name if it is bound to a manager 
   * @param {Recognizer|String} otherRecognizer 
   * @param {Recognizer} recognizer 
   * @returns {Recognizer} 
   */</span>
  <span class="s2">function </span><span class="s1">getRecognizerByNameIfManager(otherRecognizer, recognizer) {</span>
    <span class="s2">var </span><span class="s1">manager = recognizer.manager;</span>

    <span class="s2">if </span><span class="s1">(manager) {</span>
      <span class="s2">return </span><span class="s1">manager.get(otherRecognizer);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">otherRecognizer;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * get a usable string, used as event postfix 
   * @param {constant} state 
   * @returns {String} state 
   */</span>

  <span class="s2">function </span><span class="s1">stateStr(state) {</span>
    <span class="s2">if </span><span class="s1">(state &amp; STATE_CANCELLED) {</span>
      <span class="s2">return </span><span class="s3">'cancel'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state &amp; STATE_ENDED) {</span>
      <span class="s2">return </span><span class="s3">'end'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state &amp; STATE_CHANGED) {</span>
      <span class="s2">return </span><span class="s3">'move'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(state &amp; STATE_BEGAN) {</span>
      <span class="s2">return </span><span class="s3">'start'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * Recognizer flow explained; * 
   * All recognizers have the initial state of POSSIBLE when a input session starts. 
   * The definition of a input session is from the first input until the last input, with all it's movement in it. * 
   * Example session for mouse-input: mousedown -&gt; mousemove -&gt; mouseup 
   * 
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed 
   * which determines with state it should be. 
   * 
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to 
   * POSSIBLE to give it another change on the next cycle. 
   * 
   *               Possible 
   *                  | 
   *            +-----+---------------+ 
   *            |                     | 
   *      +-----+-----+               | 
   *      |           |               | 
   *   Failed      Cancelled          | 
   *                          +-------+------+ 
   *                          |              | 
   *                      Recognized       Began 
   *                                         | 
   *                                      Changed 
   *                                         | 
   *                                  Ended/Recognized 
   */</span>

  <span class="s0">/** 
   * @private 
   * Recognizer 
   * Every recognizer needs to extend from this class. 
   * @constructor 
   * @param {Object} options 
   */</span>

  <span class="s2">var </span><span class="s1">Recognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">function </span><span class="s1">Recognizer(options) {</span>
      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.options = _extends({</span>
        <span class="s1">enable: </span><span class="s2">true</span>
      <span class="s1">}, options);</span>
      <span class="s2">this</span><span class="s1">.id = uniqueId();</span>
      <span class="s2">this</span><span class="s1">.manager = </span><span class="s2">null</span><span class="s1">; </span><span class="s0">// default is enable true</span>

      <span class="s2">this</span><span class="s1">.state = STATE_POSSIBLE;</span>
      <span class="s2">this</span><span class="s1">.simultaneous = {};</span>
      <span class="s2">this</span><span class="s1">.requireFail = [];</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * @private 
     * set options 
     * @param {Object} options 
     * @return {Recognizer} 
     */</span>


    <span class="s2">var </span><span class="s1">_proto = Recognizer.prototype;</span>

    <span class="s1">_proto.set = </span><span class="s2">function </span><span class="s1">set(options) {</span>
      <span class="s1">assign$1(</span><span class="s2">this</span><span class="s1">.options, options); </span><span class="s0">// also update the touchAction, in case something changed about the directions/enabled state</span>

      <span class="s2">this</span><span class="s1">.manager &amp;&amp; </span><span class="s2">this</span><span class="s1">.manager.touchAction.update();</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * recognize simultaneous with an other recognizer. 
     * @param {Recognizer} otherRecognizer 
     * @returns {Recognizer} this 
     */</span>


    <span class="s1">_proto.recognizeWith = </span><span class="s2">function </span><span class="s1">recognizeWith(otherRecognizer) {</span>
      <span class="s2">if </span><span class="s1">(invokeArrayArg(otherRecognizer, </span><span class="s3">'recognizeWith'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">)) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">simultaneous = </span><span class="s2">this</span><span class="s1">.simultaneous;</span>
      <span class="s1">otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, </span><span class="s2">this</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(!simultaneous[otherRecognizer.id]) {</span>
        <span class="s1">simultaneous[otherRecognizer.id] = otherRecognizer;</span>
        <span class="s1">otherRecognizer.recognizeWith(</span><span class="s2">this</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * drop the simultaneous link. it doesnt remove the link on the other recognizer. 
     * @param {Recognizer} otherRecognizer 
     * @returns {Recognizer} this 
     */</span>


    <span class="s1">_proto.dropRecognizeWith = </span><span class="s2">function </span><span class="s1">dropRecognizeWith(otherRecognizer) {</span>
      <span class="s2">if </span><span class="s1">(invokeArrayArg(otherRecognizer, </span><span class="s3">'dropRecognizeWith'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">)) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, </span><span class="s2">this</span><span class="s1">);</span>
      <span class="s2">delete this</span><span class="s1">.simultaneous[otherRecognizer.id];</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * recognizer can only run when an other is failing 
     * @param {Recognizer} otherRecognizer 
     * @returns {Recognizer} this 
     */</span>


    <span class="s1">_proto.requireFailure = </span><span class="s2">function </span><span class="s1">requireFailure(otherRecognizer) {</span>
      <span class="s2">if </span><span class="s1">(invokeArrayArg(otherRecognizer, </span><span class="s3">'requireFailure'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">)) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">requireFail = </span><span class="s2">this</span><span class="s1">.requireFail;</span>
      <span class="s1">otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, </span><span class="s2">this</span><span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(inArray(requireFail, otherRecognizer) === -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">requireFail.push(otherRecognizer);</span>
        <span class="s1">otherRecognizer.requireFailure(</span><span class="s2">this</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * drop the requireFailure link. it does not remove the link on the other recognizer. 
     * @param {Recognizer} otherRecognizer 
     * @returns {Recognizer} this 
     */</span>


    <span class="s1">_proto.dropRequireFailure = </span><span class="s2">function </span><span class="s1">dropRequireFailure(otherRecognizer) {</span>
      <span class="s2">if </span><span class="s1">(invokeArrayArg(otherRecognizer, </span><span class="s3">'dropRequireFailure'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">)) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, </span><span class="s2">this</span><span class="s1">);</span>
      <span class="s2">var </span><span class="s1">index = inArray(</span><span class="s2">this</span><span class="s1">.requireFail, otherRecognizer);</span>

      <span class="s2">if </span><span class="s1">(index &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.requireFail.splice(index, </span><span class="s4">1</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * has require failures boolean 
     * @returns {boolean} 
     */</span>


    <span class="s1">_proto.hasRequireFailures = </span><span class="s2">function </span><span class="s1">hasRequireFailures() {</span>
      <span class="s2">return this</span><span class="s1">.requireFail.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * if the recognizer can recognize simultaneous with an other recognizer 
     * @param {Recognizer} otherRecognizer 
     * @returns {Boolean} 
     */</span>


    <span class="s1">_proto.canRecognizeWith = </span><span class="s2">function </span><span class="s1">canRecognizeWith(otherRecognizer) {</span>
      <span class="s2">return </span><span class="s1">!!</span><span class="s2">this</span><span class="s1">.simultaneous[otherRecognizer.id];</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * You should use `tryEmit` instead of `emit` directly to check 
     * that all the needed recognizers has failed before emitting. 
     * @param {Object} input 
     */</span>


    <span class="s1">_proto.emit = </span><span class="s2">function </span><span class="s1">emit(input) {</span>
      <span class="s2">var </span><span class="s1">self = </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">state = </span><span class="s2">this</span><span class="s1">.state;</span>

      <span class="s2">function </span><span class="s1">emit(event) {</span>
        <span class="s1">self.manager.emit(event, input);</span>
      <span class="s1">} </span><span class="s0">// 'panstart' and 'panmove'</span>


      <span class="s2">if </span><span class="s1">(state &lt; STATE_ENDED) {</span>
        <span class="s1">emit(self.options.event + stateStr(state));</span>
      <span class="s1">}</span>

      <span class="s1">emit(self.options.event); </span><span class="s0">// simple 'eventName' events</span>

      <span class="s2">if </span><span class="s1">(input.additionalEvent) {</span>
        <span class="s0">// additional event(panleft, panright, pinchin, pinchout...)</span>
        <span class="s1">emit(input.additionalEvent);</span>
      <span class="s1">} </span><span class="s0">// panend and pancancel</span>


      <span class="s2">if </span><span class="s1">(state &gt;= STATE_ENDED) {</span>
        <span class="s1">emit(self.options.event + stateStr(state));</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * Check that all the require failure recognizers has failed, 
     * if true, it emits a gesture event, 
     * otherwise, setup the state to FAILED. 
     * @param {Object} input 
     */</span>


    <span class="s1">_proto.tryEmit = </span><span class="s2">function </span><span class="s1">tryEmit(input) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.canEmit()) {</span>
        <span class="s2">return this</span><span class="s1">.emit(input);</span>
      <span class="s1">} </span><span class="s0">// it's failing anyway</span>


      <span class="s2">this</span><span class="s1">.state = STATE_FAILED;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * can we emit? 
     * @returns {boolean} 
     */</span>


    <span class="s1">_proto.canEmit = </span><span class="s2">function </span><span class="s1">canEmit() {</span>
      <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(i &lt; </span><span class="s2">this</span><span class="s1">.requireFail.length) {</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.requireFail[i].state &amp; (STATE_FAILED | STATE_POSSIBLE))) {</span>
          <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">i++;</span>
      <span class="s1">}</span>

      <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * update the recognizer 
     * @param {Object} inputData 
     */</span>


    <span class="s1">_proto.recognize = </span><span class="s2">function </span><span class="s1">recognize(inputData) {</span>
      <span class="s0">// make a new copy of the inputData</span>
      <span class="s0">// so we can change the inputData without messing up the other recognizers</span>
      <span class="s2">var </span><span class="s1">inputDataClone = assign$1({}, inputData); </span><span class="s0">// is is enabled and allow recognizing?</span>

      <span class="s2">if </span><span class="s1">(!boolOrFn(</span><span class="s2">this</span><span class="s1">.options.enable, [</span><span class="s2">this</span><span class="s1">, inputDataClone])) {</span>
        <span class="s2">this</span><span class="s1">.reset();</span>
        <span class="s2">this</span><span class="s1">.state = STATE_FAILED;</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// reset when we've reached the end</span>


      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state &amp; (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {</span>
        <span class="s2">this</span><span class="s1">.state = STATE_POSSIBLE;</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.state = </span><span class="s2">this</span><span class="s1">.process(inputDataClone); </span><span class="s0">// the recognizer has recognized a gesture</span>
      <span class="s0">// so trigger an event</span>

      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state &amp; (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {</span>
        <span class="s2">this</span><span class="s1">.tryEmit(inputDataClone);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * return the state of the recognizer 
     * the actual recognizing happens in this method 
     * @virtual 
     * @param {Object} inputData 
     * @returns {constant} STATE 
     */</span>

    <span class="s0">/* jshint ignore:start */</span>


    <span class="s1">_proto.process = </span><span class="s2">function </span><span class="s1">process(inputData) {};</span>
    <span class="s0">/* jshint ignore:end */</span>

    <span class="s0">/** 
     * @private 
     * return the preferred touch-action 
     * @virtual 
     * @returns {Array} 
     */</span>


    <span class="s1">_proto.getTouchAction = </span><span class="s2">function </span><span class="s1">getTouchAction() {};</span>
    <span class="s0">/** 
     * @private 
     * called when the gesture isn't allowed to recognize 
     * like when another is being recognized or it is disabled 
     * @virtual 
     */</span>


    <span class="s1">_proto.reset = </span><span class="s2">function </span><span class="s1">reset() {};</span>

    <span class="s2">return </span><span class="s1">Recognizer;</span>
  <span class="s1">}();</span>

  <span class="s0">/** 
   * @private 
   * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur 
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing 
   * a single tap. 
   * 
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of 
   * multi-taps being recognized. 
   * @constructor 
   * @extends Recognizer 
   */</span>

  <span class="s2">var </span><span class="s1">TapRecognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_Recognizer) {</span>
    <span class="s1">_inheritsLoose(TapRecognizer, _Recognizer);</span>

    <span class="s2">function </span><span class="s1">TapRecognizer(options) {</span>
      <span class="s2">var </span><span class="s1">_this;</span>

      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s1">_this = _Recognizer.call(</span><span class="s2">this</span><span class="s1">, _extends({</span>
        <span class="s1">event: </span><span class="s3">'tap'</span><span class="s1">,</span>
        <span class="s1">pointers: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">taps: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">interval: </span><span class="s4">300</span><span class="s1">,</span>
        <span class="s0">// max time between the multi-tap taps</span>
        <span class="s1">time: </span><span class="s4">250</span><span class="s1">,</span>
        <span class="s0">// max time of the pointer to be down (like finger on the screen)</span>
        <span class="s1">threshold: </span><span class="s4">9</span><span class="s1">,</span>
        <span class="s0">// a minimal movement is ok, but keep it low</span>
        <span class="s1">posThreshold: </span><span class="s4">10</span>
      <span class="s1">}, options)) || </span><span class="s2">this</span><span class="s1">; </span><span class="s0">// previous time and center,</span>
      <span class="s0">// used for tap counting</span>

      <span class="s1">_this.pTime = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">_this.pCenter = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">_this._timer = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">_this._input = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">_this.count = </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = TapRecognizer.prototype;</span>

    <span class="s1">_proto.getTouchAction = </span><span class="s2">function </span><span class="s1">getTouchAction() {</span>
      <span class="s2">return </span><span class="s1">[TOUCH_ACTION_MANIPULATION];</span>
    <span class="s1">};</span>

    <span class="s1">_proto.process = </span><span class="s2">function </span><span class="s1">process(input) {</span>
      <span class="s2">var </span><span class="s1">_this2 = </span><span class="s2">this</span><span class="s1">;</span>

      <span class="s2">var </span><span class="s1">options = </span><span class="s2">this</span><span class="s1">.options;</span>
      <span class="s2">var </span><span class="s1">validPointers = input.pointers.length === options.pointers;</span>
      <span class="s2">var </span><span class="s1">validMovement = input.distance &lt; options.threshold;</span>
      <span class="s2">var </span><span class="s1">validTouchTime = input.deltaTime &lt; options.time;</span>
      <span class="s2">this</span><span class="s1">.reset();</span>

      <span class="s2">if </span><span class="s1">(input.eventType &amp; INPUT_START &amp;&amp; </span><span class="s2">this</span><span class="s1">.count === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">return this</span><span class="s1">.failTimeout();</span>
      <span class="s1">} </span><span class="s0">// we only allow little movement</span>
      <span class="s0">// and we've reached an end event, so a tap is possible</span>


      <span class="s2">if </span><span class="s1">(validMovement &amp;&amp; validTouchTime &amp;&amp; validPointers) {</span>
        <span class="s2">if </span><span class="s1">(input.eventType !== INPUT_END) {</span>
          <span class="s2">return this</span><span class="s1">.failTimeout();</span>
        <span class="s1">}</span>

        <span class="s2">var </span><span class="s1">validInterval = </span><span class="s2">this</span><span class="s1">.pTime ? input.timeStamp - </span><span class="s2">this</span><span class="s1">.pTime &lt; options.interval : </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">var </span><span class="s1">validMultiTap = !</span><span class="s2">this</span><span class="s1">.pCenter || getDistance(</span><span class="s2">this</span><span class="s1">.pCenter, input.center) &lt; options.posThreshold;</span>
        <span class="s2">this</span><span class="s1">.pTime = input.timeStamp;</span>
        <span class="s2">this</span><span class="s1">.pCenter = input.center;</span>

        <span class="s2">if </span><span class="s1">(!validMultiTap || !validInterval) {</span>
          <span class="s2">this</span><span class="s1">.count = </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">this</span><span class="s1">.count += </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">this</span><span class="s1">._input = input; </span><span class="s0">// if tap count matches we have recognized it,</span>
        <span class="s0">// else it has began recognizing...</span>

        <span class="s2">var </span><span class="s1">tapCount = </span><span class="s2">this</span><span class="s1">.count % options.taps;</span>

        <span class="s2">if </span><span class="s1">(tapCount === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s0">// no failing requirements, immediately trigger the tap event</span>
          <span class="s0">// or wait as long as the multitap interval to trigger</span>
          <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.hasRequireFailures()) {</span>
            <span class="s2">return </span><span class="s1">STATE_RECOGNIZED;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">._timer = setTimeout(</span><span class="s2">function </span><span class="s1">() {</span>
              <span class="s1">_this2.state = STATE_RECOGNIZED;</span>

              <span class="s1">_this2.tryEmit();</span>
            <span class="s1">}, options.interval);</span>
            <span class="s2">return </span><span class="s1">STATE_BEGAN;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">STATE_FAILED;</span>
    <span class="s1">};</span>

    <span class="s1">_proto.failTimeout = </span><span class="s2">function </span><span class="s1">failTimeout() {</span>
      <span class="s2">var </span><span class="s1">_this3 = </span><span class="s2">this</span><span class="s1">;</span>

      <span class="s2">this</span><span class="s1">._timer = setTimeout(</span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">_this3.state = STATE_FAILED;</span>
      <span class="s1">}, </span><span class="s2">this</span><span class="s1">.options.interval);</span>
      <span class="s2">return </span><span class="s1">STATE_FAILED;</span>
    <span class="s1">};</span>

    <span class="s1">_proto.reset = </span><span class="s2">function </span><span class="s1">reset() {</span>
      <span class="s1">clearTimeout(</span><span class="s2">this</span><span class="s1">._timer);</span>
    <span class="s1">};</span>

    <span class="s1">_proto.emit = </span><span class="s2">function </span><span class="s1">emit() {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state === STATE_RECOGNIZED) {</span>
        <span class="s2">this</span><span class="s1">._input.tapCount = </span><span class="s2">this</span><span class="s1">.count;</span>
        <span class="s2">this</span><span class="s1">.manager.emit(</span><span class="s2">this</span><span class="s1">.options.event, </span><span class="s2">this</span><span class="s1">._input);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">TapRecognizer;</span>
  <span class="s1">}(Recognizer);</span>

  <span class="s0">/** 
   * @private 
   * This recognizer is just used as a base for the simple attribute recognizers. 
   * @constructor 
   * @extends Recognizer 
   */</span>

  <span class="s2">var </span><span class="s1">AttrRecognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_Recognizer) {</span>
    <span class="s1">_inheritsLoose(AttrRecognizer, _Recognizer);</span>

    <span class="s2">function </span><span class="s1">AttrRecognizer(options) {</span>
      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">_Recognizer.call(</span><span class="s2">this</span><span class="s1">, _extends({</span>
        <span class="s1">pointers: </span><span class="s4">1</span>
      <span class="s1">}, options)) || </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * @private 
     * Used to check if it the recognizer receives valid input, like input.distance &gt; 10. 
     * @memberof AttrRecognizer 
     * @param {Object} input 
     * @returns {Boolean} recognized 
     */</span>


    <span class="s2">var </span><span class="s1">_proto = AttrRecognizer.prototype;</span>

    <span class="s1">_proto.attrTest = </span><span class="s2">function </span><span class="s1">attrTest(input) {</span>
      <span class="s2">var </span><span class="s1">optionPointers = </span><span class="s2">this</span><span class="s1">.options.pointers;</span>
      <span class="s2">return </span><span class="s1">optionPointers === </span><span class="s4">0 </span><span class="s1">|| input.pointers.length === optionPointers;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * Process the input and return the state for the recognizer 
     * @memberof AttrRecognizer 
     * @param {Object} input 
     * @returns {*} State 
     */</span>


    <span class="s1">_proto.process = </span><span class="s2">function </span><span class="s1">process(input) {</span>
      <span class="s2">var </span><span class="s1">state = </span><span class="s2">this</span><span class="s1">.state;</span>
      <span class="s2">var </span><span class="s1">eventType = input.eventType;</span>
      <span class="s2">var </span><span class="s1">isRecognized = state &amp; (STATE_BEGAN | STATE_CHANGED);</span>
      <span class="s2">var </span><span class="s1">isValid = </span><span class="s2">this</span><span class="s1">.attrTest(input); </span><span class="s0">// on cancel input and we've recognized before, return STATE_CANCELLED</span>

      <span class="s2">if </span><span class="s1">(isRecognized &amp;&amp; (eventType &amp; INPUT_CANCEL || !isValid)) {</span>
        <span class="s2">return </span><span class="s1">state | STATE_CANCELLED;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRecognized || isValid) {</span>
        <span class="s2">if </span><span class="s1">(eventType &amp; INPUT_END) {</span>
          <span class="s2">return </span><span class="s1">state | STATE_ENDED;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!(state &amp; STATE_BEGAN)) {</span>
          <span class="s2">return </span><span class="s1">STATE_BEGAN;</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">state | STATE_CHANGED;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">STATE_FAILED;</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">AttrRecognizer;</span>
  <span class="s1">}(Recognizer);</span>

  <span class="s0">/** 
   * @private 
   * direction cons to string 
   * @param {constant} direction 
   * @returns {String} 
   */</span>

  <span class="s2">function </span><span class="s1">directionStr(direction) {</span>
    <span class="s2">if </span><span class="s1">(direction === DIRECTION_DOWN) {</span>
      <span class="s2">return </span><span class="s3">'down'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(direction === DIRECTION_UP) {</span>
      <span class="s2">return </span><span class="s3">'up'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(direction === DIRECTION_LEFT) {</span>
      <span class="s2">return </span><span class="s3">'left'</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(direction === DIRECTION_RIGHT) {</span>
      <span class="s2">return </span><span class="s3">'right'</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s3">''</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * Pan 
   * Recognized when the pointer is down and moved in the allowed direction. 
   * @constructor 
   * @extends AttrRecognizer 
   */</span>

  <span class="s2">var </span><span class="s1">PanRecognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_AttrRecognizer) {</span>
    <span class="s1">_inheritsLoose(PanRecognizer, _AttrRecognizer);</span>

    <span class="s2">function </span><span class="s1">PanRecognizer(options) {</span>
      <span class="s2">var </span><span class="s1">_this;</span>

      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s1">_this = _AttrRecognizer.call(</span><span class="s2">this</span><span class="s1">, _extends({</span>
        <span class="s1">event: </span><span class="s3">'pan'</span><span class="s1">,</span>
        <span class="s1">threshold: </span><span class="s4">10</span><span class="s1">,</span>
        <span class="s1">pointers: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">direction: DIRECTION_ALL</span>
      <span class="s1">}, options)) || </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s1">_this.pX = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">_this.pY = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = PanRecognizer.prototype;</span>

    <span class="s1">_proto.getTouchAction = </span><span class="s2">function </span><span class="s1">getTouchAction() {</span>
      <span class="s2">var </span><span class="s1">direction = </span><span class="s2">this</span><span class="s1">.options.direction;</span>
      <span class="s2">var </span><span class="s1">actions = [];</span>

      <span class="s2">if </span><span class="s1">(direction &amp; DIRECTION_HORIZONTAL) {</span>
        <span class="s1">actions.push(TOUCH_ACTION_PAN_Y);</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(direction &amp; DIRECTION_VERTICAL) {</span>
        <span class="s1">actions.push(TOUCH_ACTION_PAN_X);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">actions;</span>
    <span class="s1">};</span>

    <span class="s1">_proto.directionTest = </span><span class="s2">function </span><span class="s1">directionTest(input) {</span>
      <span class="s2">var </span><span class="s1">options = </span><span class="s2">this</span><span class="s1">.options;</span>
      <span class="s2">var </span><span class="s1">hasMoved = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">distance = input.distance;</span>
      <span class="s2">var </span><span class="s1">direction = input.direction;</span>
      <span class="s2">var </span><span class="s1">x = input.deltaX;</span>
      <span class="s2">var </span><span class="s1">y = input.deltaY; </span><span class="s0">// lock to axis?</span>

      <span class="s2">if </span><span class="s1">(!(direction &amp; options.direction)) {</span>
        <span class="s2">if </span><span class="s1">(options.direction &amp; DIRECTION_HORIZONTAL) {</span>
          <span class="s1">direction = x === </span><span class="s4">0 </span><span class="s1">? DIRECTION_NONE : x &lt; </span><span class="s4">0 </span><span class="s1">? DIRECTION_LEFT : DIRECTION_RIGHT;</span>
          <span class="s1">hasMoved = x !== </span><span class="s2">this</span><span class="s1">.pX;</span>
          <span class="s1">distance = Math.abs(input.deltaX);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">direction = y === </span><span class="s4">0 </span><span class="s1">? DIRECTION_NONE : y &lt; </span><span class="s4">0 </span><span class="s1">? DIRECTION_UP : DIRECTION_DOWN;</span>
          <span class="s1">hasMoved = y !== </span><span class="s2">this</span><span class="s1">.pY;</span>
          <span class="s1">distance = Math.abs(input.deltaY);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s1">input.direction = direction;</span>
      <span class="s2">return </span><span class="s1">hasMoved &amp;&amp; distance &gt; options.threshold &amp;&amp; direction &amp; options.direction;</span>
    <span class="s1">};</span>

    <span class="s1">_proto.attrTest = </span><span class="s2">function </span><span class="s1">attrTest(input) {</span>
      <span class="s2">return </span><span class="s1">AttrRecognizer.prototype.attrTest.call(</span><span class="s2">this</span><span class="s1">, input) &amp;&amp; ( </span><span class="s0">// replace with a super call</span>
      <span class="s2">this</span><span class="s1">.state &amp; STATE_BEGAN || !(</span><span class="s2">this</span><span class="s1">.state &amp; STATE_BEGAN) &amp;&amp; </span><span class="s2">this</span><span class="s1">.directionTest(input));</span>
    <span class="s1">};</span>

    <span class="s1">_proto.emit = </span><span class="s2">function </span><span class="s1">emit(input) {</span>
      <span class="s2">this</span><span class="s1">.pX = input.deltaX;</span>
      <span class="s2">this</span><span class="s1">.pY = input.deltaY;</span>
      <span class="s2">var </span><span class="s1">direction = directionStr(input.direction);</span>

      <span class="s2">if </span><span class="s1">(direction) {</span>
        <span class="s1">input.additionalEvent = </span><span class="s2">this</span><span class="s1">.options.event + direction;</span>
      <span class="s1">}</span>

      <span class="s1">_AttrRecognizer.prototype.emit.call(</span><span class="s2">this</span><span class="s1">, input);</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">PanRecognizer;</span>
  <span class="s1">}(AttrRecognizer);</span>

  <span class="s0">/** 
   * @private 
   * Swipe 
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction. 
   * @constructor 
   * @extends AttrRecognizer 
   */</span>

  <span class="s2">var </span><span class="s1">SwipeRecognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_AttrRecognizer) {</span>
    <span class="s1">_inheritsLoose(SwipeRecognizer, _AttrRecognizer);</span>

    <span class="s2">function </span><span class="s1">SwipeRecognizer(options) {</span>
      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">_AttrRecognizer.call(</span><span class="s2">this</span><span class="s1">, _extends({</span>
        <span class="s1">event: </span><span class="s3">'swipe'</span><span class="s1">,</span>
        <span class="s1">threshold: </span><span class="s4">10</span><span class="s1">,</span>
        <span class="s1">velocity: </span><span class="s4">0.3</span><span class="s1">,</span>
        <span class="s1">direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,</span>
        <span class="s1">pointers: </span><span class="s4">1</span>
      <span class="s1">}, options)) || </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = SwipeRecognizer.prototype;</span>

    <span class="s1">_proto.getTouchAction = </span><span class="s2">function </span><span class="s1">getTouchAction() {</span>
      <span class="s2">return </span><span class="s1">PanRecognizer.prototype.getTouchAction.call(</span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">};</span>

    <span class="s1">_proto.attrTest = </span><span class="s2">function </span><span class="s1">attrTest(input) {</span>
      <span class="s2">var </span><span class="s1">direction = </span><span class="s2">this</span><span class="s1">.options.direction;</span>
      <span class="s2">var </span><span class="s1">velocity;</span>

      <span class="s2">if </span><span class="s1">(direction &amp; (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {</span>
        <span class="s1">velocity = input.overallVelocity;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(direction &amp; DIRECTION_HORIZONTAL) {</span>
        <span class="s1">velocity = input.overallVelocityX;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(direction &amp; DIRECTION_VERTICAL) {</span>
        <span class="s1">velocity = input.overallVelocityY;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">_AttrRecognizer.prototype.attrTest.call(</span><span class="s2">this</span><span class="s1">, input) &amp;&amp; direction &amp; input.offsetDirection &amp;&amp; input.distance &gt; </span><span class="s2">this</span><span class="s1">.options.threshold &amp;&amp; input.maxPointers === </span><span class="s2">this</span><span class="s1">.options.pointers &amp;&amp; abs(velocity) &gt; </span><span class="s2">this</span><span class="s1">.options.velocity &amp;&amp; input.eventType &amp; INPUT_END;</span>
    <span class="s1">};</span>

    <span class="s1">_proto.emit = </span><span class="s2">function </span><span class="s1">emit(input) {</span>
      <span class="s2">var </span><span class="s1">direction = directionStr(input.offsetDirection);</span>

      <span class="s2">if </span><span class="s1">(direction) {</span>
        <span class="s2">this</span><span class="s1">.manager.emit(</span><span class="s2">this</span><span class="s1">.options.event + direction, input);</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.manager.emit(</span><span class="s2">this</span><span class="s1">.options.event, input);</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">SwipeRecognizer;</span>
  <span class="s1">}(AttrRecognizer);</span>

  <span class="s0">/** 
   * @private 
   * Pinch 
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out). 
   * @constructor 
   * @extends AttrRecognizer 
   */</span>

  <span class="s2">var </span><span class="s1">PinchRecognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_AttrRecognizer) {</span>
    <span class="s1">_inheritsLoose(PinchRecognizer, _AttrRecognizer);</span>

    <span class="s2">function </span><span class="s1">PinchRecognizer(options) {</span>
      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">_AttrRecognizer.call(</span><span class="s2">this</span><span class="s1">, _extends({</span>
        <span class="s1">event: </span><span class="s3">'pinch'</span><span class="s1">,</span>
        <span class="s1">threshold: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">pointers: </span><span class="s4">2</span>
      <span class="s1">}, options)) || </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = PinchRecognizer.prototype;</span>

    <span class="s1">_proto.getTouchAction = </span><span class="s2">function </span><span class="s1">getTouchAction() {</span>
      <span class="s2">return </span><span class="s1">[TOUCH_ACTION_NONE];</span>
    <span class="s1">};</span>

    <span class="s1">_proto.attrTest = </span><span class="s2">function </span><span class="s1">attrTest(input) {</span>
      <span class="s2">return </span><span class="s1">_AttrRecognizer.prototype.attrTest.call(</span><span class="s2">this</span><span class="s1">, input) &amp;&amp; (Math.abs(input.scale - </span><span class="s4">1</span><span class="s1">) &gt; </span><span class="s2">this</span><span class="s1">.options.threshold || </span><span class="s2">this</span><span class="s1">.state &amp; STATE_BEGAN);</span>
    <span class="s1">};</span>

    <span class="s1">_proto.emit = </span><span class="s2">function </span><span class="s1">emit(input) {</span>
      <span class="s2">if </span><span class="s1">(input.scale !== </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">var </span><span class="s1">inOut = input.scale &lt; </span><span class="s4">1 </span><span class="s1">? </span><span class="s3">'in' </span><span class="s1">: </span><span class="s3">'out'</span><span class="s1">;</span>
        <span class="s1">input.additionalEvent = </span><span class="s2">this</span><span class="s1">.options.event + inOut;</span>
      <span class="s1">}</span>

      <span class="s1">_AttrRecognizer.prototype.emit.call(</span><span class="s2">this</span><span class="s1">, input);</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">PinchRecognizer;</span>
  <span class="s1">}(AttrRecognizer);</span>

  <span class="s0">/** 
   * @private 
   * Rotate 
   * Recognized when two or more pointer are moving in a circular motion. 
   * @constructor 
   * @extends AttrRecognizer 
   */</span>

  <span class="s2">var </span><span class="s1">RotateRecognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_AttrRecognizer) {</span>
    <span class="s1">_inheritsLoose(RotateRecognizer, _AttrRecognizer);</span>

    <span class="s2">function </span><span class="s1">RotateRecognizer(options) {</span>
      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">_AttrRecognizer.call(</span><span class="s2">this</span><span class="s1">, _extends({</span>
        <span class="s1">event: </span><span class="s3">'rotate'</span><span class="s1">,</span>
        <span class="s1">threshold: </span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">pointers: </span><span class="s4">2</span>
      <span class="s1">}, options)) || </span><span class="s2">this</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = RotateRecognizer.prototype;</span>

    <span class="s1">_proto.getTouchAction = </span><span class="s2">function </span><span class="s1">getTouchAction() {</span>
      <span class="s2">return </span><span class="s1">[TOUCH_ACTION_NONE];</span>
    <span class="s1">};</span>

    <span class="s1">_proto.attrTest = </span><span class="s2">function </span><span class="s1">attrTest(input) {</span>
      <span class="s2">return </span><span class="s1">_AttrRecognizer.prototype.attrTest.call(</span><span class="s2">this</span><span class="s1">, input) &amp;&amp; (Math.abs(input.rotation) &gt; </span><span class="s2">this</span><span class="s1">.options.threshold || </span><span class="s2">this</span><span class="s1">.state &amp; STATE_BEGAN);</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">RotateRecognizer;</span>
  <span class="s1">}(AttrRecognizer);</span>

  <span class="s0">/** 
   * @private 
   * Press 
   * Recognized when the pointer is down for x ms without any movement. 
   * @constructor 
   * @extends Recognizer 
   */</span>

  <span class="s2">var </span><span class="s1">PressRecognizer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_Recognizer) {</span>
    <span class="s1">_inheritsLoose(PressRecognizer, _Recognizer);</span>

    <span class="s2">function </span><span class="s1">PressRecognizer(options) {</span>
      <span class="s2">var </span><span class="s1">_this;</span>

      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s1">_this = _Recognizer.call(</span><span class="s2">this</span><span class="s1">, _extends({</span>
        <span class="s1">event: </span><span class="s3">'press'</span><span class="s1">,</span>
        <span class="s1">pointers: </span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">time: </span><span class="s4">251</span><span class="s1">,</span>
        <span class="s0">// minimal time of the pointer to be pressed</span>
        <span class="s1">threshold: </span><span class="s4">9</span>
      <span class="s1">}, options)) || </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s1">_this._timer = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">_this._input = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = PressRecognizer.prototype;</span>

    <span class="s1">_proto.getTouchAction = </span><span class="s2">function </span><span class="s1">getTouchAction() {</span>
      <span class="s2">return </span><span class="s1">[TOUCH_ACTION_AUTO];</span>
    <span class="s1">};</span>

    <span class="s1">_proto.process = </span><span class="s2">function </span><span class="s1">process(input) {</span>
      <span class="s2">var </span><span class="s1">_this2 = </span><span class="s2">this</span><span class="s1">;</span>

      <span class="s2">var </span><span class="s1">options = </span><span class="s2">this</span><span class="s1">.options;</span>
      <span class="s2">var </span><span class="s1">validPointers = input.pointers.length === options.pointers;</span>
      <span class="s2">var </span><span class="s1">validMovement = input.distance &lt; options.threshold;</span>
      <span class="s2">var </span><span class="s1">validTime = input.deltaTime &gt; options.time;</span>
      <span class="s2">this</span><span class="s1">._input = input; </span><span class="s0">// we only allow little movement</span>
      <span class="s0">// and we've reached an end event, so a tap is possible</span>

      <span class="s2">if </span><span class="s1">(!validMovement || !validPointers || input.eventType &amp; (INPUT_END | INPUT_CANCEL) &amp;&amp; !validTime) {</span>
        <span class="s2">this</span><span class="s1">.reset();</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(input.eventType &amp; INPUT_START) {</span>
        <span class="s2">this</span><span class="s1">.reset();</span>
        <span class="s2">this</span><span class="s1">._timer = setTimeout(</span><span class="s2">function </span><span class="s1">() {</span>
          <span class="s1">_this2.state = STATE_RECOGNIZED;</span>

          <span class="s1">_this2.tryEmit();</span>
        <span class="s1">}, options.time);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(input.eventType &amp; INPUT_END) {</span>
        <span class="s2">return </span><span class="s1">STATE_RECOGNIZED;</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">STATE_FAILED;</span>
    <span class="s1">};</span>

    <span class="s1">_proto.reset = </span><span class="s2">function </span><span class="s1">reset() {</span>
      <span class="s1">clearTimeout(</span><span class="s2">this</span><span class="s1">._timer);</span>
    <span class="s1">};</span>

    <span class="s1">_proto.emit = </span><span class="s2">function </span><span class="s1">emit(input) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.state !== STATE_RECOGNIZED) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(input &amp;&amp; input.eventType &amp; INPUT_END) {</span>
        <span class="s2">this</span><span class="s1">.manager.emit(</span><span class="s2">this</span><span class="s1">.options.event + </span><span class="s3">&quot;up&quot;</span><span class="s1">, input);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">._input.timeStamp = now();</span>
        <span class="s2">this</span><span class="s1">.manager.emit(</span><span class="s2">this</span><span class="s1">.options.event, </span><span class="s2">this</span><span class="s1">._input);</span>
      <span class="s1">}</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">PressRecognizer;</span>
  <span class="s1">}(Recognizer);</span>

  <span class="s2">var </span><span class="s1">defaults = {</span>
    <span class="s0">/** 
     * @private 
     * set if DOM events are being triggered. 
     * But this is slower and unused by simple implementations, so disabled by default. 
     * @type {Boolean} 
     * @default false 
     */</span>
    <span class="s1">domEvents: </span><span class="s2">false</span><span class="s1">,</span>

    <span class="s0">/** 
     * @private 
     * The value for the touchAction property/fallback. 
     * When set to `compute` it will magically set the correct value based on the added recognizers. 
     * @type {String} 
     * @default compute 
     */</span>
    <span class="s1">touchAction: TOUCH_ACTION_COMPUTE,</span>

    <span class="s0">/** 
     * @private 
     * @type {Boolean} 
     * @default true 
     */</span>
    <span class="s1">enable: </span><span class="s2">true</span><span class="s1">,</span>

    <span class="s0">/** 
     * @private 
     * EXPERIMENTAL FEATURE -- can be removed/changed 
     * Change the parent input target element. 
     * If Null, then it is being set the to main element. 
     * @type {Null|EventTarget} 
     * @default null 
     */</span>
    <span class="s1">inputTarget: </span><span class="s2">null</span><span class="s1">,</span>

    <span class="s0">/** 
     * @private 
     * force an input class 
     * @type {Null|Function} 
     * @default null 
     */</span>
    <span class="s1">inputClass: </span><span class="s2">null</span><span class="s1">,</span>

    <span class="s0">/** 
     * @private 
     * Some CSS properties can be used to improve the working of Hammer. 
     * Add them to this method and they will be set when creating a new Manager. 
     * @namespace 
     */</span>
    <span class="s1">cssProps: {</span>
      <span class="s0">/** 
       * @private 
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers. 
       * @type {String} 
       * @default 'none' 
       */</span>
      <span class="s1">userSelect: </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>

      <span class="s0">/** 
       * @private 
       * Disable the Windows Phone grippers when pressing an element. 
       * @type {String} 
       * @default 'none' 
       */</span>
      <span class="s1">touchSelect: </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>

      <span class="s0">/** 
       * @private 
       * Disables the default callout shown when you touch and hold a touch target. 
       * On iOS, when you touch and hold a touch target such as a link, Safari displays 
       * a callout containing information about the link. This property allows you to disable that callout. 
       * @type {String} 
       * @default 'none' 
       */</span>
      <span class="s1">touchCallout: </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>

      <span class="s0">/** 
       * @private 
       * Specifies whether zooming is enabled. Used by IE10&gt; 
       * @type {String} 
       * @default 'none' 
       */</span>
      <span class="s1">contentZooming: </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>

      <span class="s0">/** 
       * @private 
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers. 
       * @type {String} 
       * @default 'none' 
       */</span>
      <span class="s1">userDrag: </span><span class="s3">&quot;none&quot;</span><span class="s1">,</span>

      <span class="s0">/** 
       * @private 
       * Overrides the highlight color shown when the user taps a link or a JavaScript 
       * clickable element in iOS. This property obeys the alpha value, if specified. 
       * @type {String} 
       * @default 'rgba(0,0,0,0)' 
       */</span>
      <span class="s1">tapHighlightColor: </span><span class="s3">&quot;rgba(0,0,0,0)&quot;</span>
    <span class="s1">}</span>
  <span class="s1">};</span>
  <span class="s0">/** 
   * @private 
   * Default recognizer setup when calling `Hammer()` 
   * When creating a new Manager these will be skipped. 
   * This is separated with other defaults because of tree-shaking. 
   * @type {Array} 
   */</span>

  <span class="s2">var </span><span class="s1">preset = [[RotateRecognizer, {</span>
    <span class="s1">enable: </span><span class="s2">false</span>
  <span class="s1">}], [PinchRecognizer, {</span>
    <span class="s1">enable: </span><span class="s2">false</span>
  <span class="s1">}, [</span><span class="s3">'rotate'</span><span class="s1">]], [SwipeRecognizer, {</span>
    <span class="s1">direction: DIRECTION_HORIZONTAL</span>
  <span class="s1">}], [PanRecognizer, {</span>
    <span class="s1">direction: DIRECTION_HORIZONTAL</span>
  <span class="s1">}, [</span><span class="s3">'swipe'</span><span class="s1">]], [TapRecognizer], [TapRecognizer, {</span>
    <span class="s1">event: </span><span class="s3">'doubletap'</span><span class="s1">,</span>
    <span class="s1">taps: </span><span class="s4">2</span>
  <span class="s1">}, [</span><span class="s3">'tap'</span><span class="s1">]], [PressRecognizer]];</span>

  <span class="s2">var </span><span class="s1">STOP = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">FORCED_STOP = </span><span class="s4">2</span><span class="s1">;</span>
  <span class="s0">/** 
   * @private 
   * add/remove the css properties as defined in manager.options.cssProps 
   * @param {Manager} manager 
   * @param {Boolean} add 
   */</span>

  <span class="s2">function </span><span class="s1">toggleCssProps(manager, add) {</span>
    <span class="s2">var </span><span class="s1">element = manager.element;</span>

    <span class="s2">if </span><span class="s1">(!element.style) {</span>
      <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">prop;</span>
    <span class="s1">each(manager.options.cssProps, </span><span class="s2">function </span><span class="s1">(value, name) {</span>
      <span class="s1">prop = prefixed(element.style, name);</span>

      <span class="s2">if </span><span class="s1">(add) {</span>
        <span class="s1">manager.oldCssProps[prop] = element.style[prop];</span>
        <span class="s1">element.style[prop] = value;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">element.style[prop] = manager.oldCssProps[prop] || </span><span class="s3">&quot;&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>
    <span class="s1">});</span>

    <span class="s2">if </span><span class="s1">(!add) {</span>
      <span class="s1">manager.oldCssProps = {};</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">/** 
   * @private 
   * trigger dom event 
   * @param {String} event 
   * @param {Object} data 
   */</span>


  <span class="s2">function </span><span class="s1">triggerDomEvent(event, data) {</span>
    <span class="s2">var </span><span class="s1">gestureEvent = document.createEvent(</span><span class="s3">&quot;Event&quot;</span><span class="s1">);</span>
    <span class="s1">gestureEvent.initEvent(event, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">gestureEvent.gesture = data;</span>
    <span class="s1">data.target.dispatchEvent(gestureEvent);</span>
  <span class="s1">}</span>
  <span class="s0">/** 
  * @private 
   * Manager 
   * @param {HTMLElement} element 
   * @param {Object} [options] 
   * @constructor 
   */</span>


  <span class="s2">var </span><span class="s1">Manager =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">function </span><span class="s1">Manager(element, options) {</span>
      <span class="s2">var </span><span class="s1">_this = </span><span class="s2">this</span><span class="s1">;</span>

      <span class="s2">this</span><span class="s1">.options = assign$1({}, defaults, options || {});</span>
      <span class="s2">this</span><span class="s1">.options.inputTarget = </span><span class="s2">this</span><span class="s1">.options.inputTarget || element;</span>
      <span class="s2">this</span><span class="s1">.handlers = {};</span>
      <span class="s2">this</span><span class="s1">.session = {};</span>
      <span class="s2">this</span><span class="s1">.recognizers = [];</span>
      <span class="s2">this</span><span class="s1">.oldCssProps = {};</span>
      <span class="s2">this</span><span class="s1">.element = element;</span>
      <span class="s2">this</span><span class="s1">.input = createInputInstance(</span><span class="s2">this</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.touchAction = </span><span class="s2">new </span><span class="s1">TouchAction(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.options.touchAction);</span>
      <span class="s1">toggleCssProps(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
      <span class="s1">each(</span><span class="s2">this</span><span class="s1">.options.recognizers, </span><span class="s2">function </span><span class="s1">(item) {</span>
        <span class="s2">var </span><span class="s1">recognizer = _this.add(</span><span class="s2">new </span><span class="s1">item[</span><span class="s4">0</span><span class="s1">](item[</span><span class="s4">1</span><span class="s1">]));</span>

        <span class="s1">item[</span><span class="s4">2</span><span class="s1">] &amp;&amp; recognizer.recognizeWith(item[</span><span class="s4">2</span><span class="s1">]);</span>
        <span class="s1">item[</span><span class="s4">3</span><span class="s1">] &amp;&amp; recognizer.requireFailure(item[</span><span class="s4">3</span><span class="s1">]);</span>
      <span class="s1">}, </span><span class="s2">this</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">/** 
     * @private 
     * set options 
     * @param {Object} options 
     * @returns {Manager} 
     */</span>


    <span class="s2">var </span><span class="s1">_proto = Manager.prototype;</span>

    <span class="s1">_proto.set = </span><span class="s2">function </span><span class="s1">set(options) {</span>
      <span class="s1">assign$1(</span><span class="s2">this</span><span class="s1">.options, options); </span><span class="s0">// Options that need a little more setup</span>

      <span class="s2">if </span><span class="s1">(options.touchAction) {</span>
        <span class="s2">this</span><span class="s1">.touchAction.update();</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(options.inputTarget) {</span>
        <span class="s0">// Clean up existing event listeners and reinitialize</span>
        <span class="s2">this</span><span class="s1">.input.destroy();</span>
        <span class="s2">this</span><span class="s1">.input.target = options.inputTarget;</span>
        <span class="s2">this</span><span class="s1">.input.init();</span>
      <span class="s1">}</span>

      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * stop recognizing for this session. 
     * This session will be discarded, when a new [input]start event is fired. 
     * When forced, the recognizer cycle is stopped immediately. 
     * @param {Boolean} [force] 
     */</span>


    <span class="s1">_proto.stop = </span><span class="s2">function </span><span class="s1">stop(force) {</span>
      <span class="s2">this</span><span class="s1">.session.stopped = force ? FORCED_STOP : STOP;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * run the recognizers! 
     * called by the inputHandler function on every movement of the pointers (touches) 
     * it walks through all the recognizers and tries to detect the gesture that is being made 
     * @param {Object} inputData 
     */</span>


    <span class="s1">_proto.recognize = </span><span class="s2">function </span><span class="s1">recognize(inputData) {</span>
      <span class="s2">var </span><span class="s1">session = </span><span class="s2">this</span><span class="s1">.session;</span>

      <span class="s2">if </span><span class="s1">(session.stopped) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// run the touch-action polyfill</span>


      <span class="s2">this</span><span class="s1">.touchAction.preventDefaults(inputData);</span>
      <span class="s2">var </span><span class="s1">recognizer;</span>
      <span class="s2">var </span><span class="s1">recognizers = </span><span class="s2">this</span><span class="s1">.recognizers; </span><span class="s0">// this holds the recognizer that is being recognized.</span>
      <span class="s0">// so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED</span>
      <span class="s0">// if no recognizer is detecting a thing, it is set to `null`</span>

      <span class="s2">var </span><span class="s1">curRecognizer = session.curRecognizer; </span><span class="s0">// reset when the last recognizer is recognized</span>
      <span class="s0">// or when we're in a new session</span>

      <span class="s2">if </span><span class="s1">(!curRecognizer || curRecognizer &amp;&amp; curRecognizer.state &amp; STATE_RECOGNIZED) {</span>
        <span class="s1">session.curRecognizer = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">curRecognizer = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(i &lt; recognizers.length) {</span>
        <span class="s1">recognizer = recognizers[i]; </span><span class="s0">// find out if we are allowed try to recognize the input for this one.</span>
        <span class="s0">// 1.   allow if the session is NOT forced stopped (see the .stop() method)</span>
        <span class="s0">// 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one</span>
        <span class="s0">//      that is being recognized.</span>
        <span class="s0">// 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.</span>
        <span class="s0">//      this can be setup with the `recognizeWith()` method on the recognizer.</span>

        <span class="s2">if </span><span class="s1">(session.stopped !== FORCED_STOP &amp;&amp; ( </span><span class="s0">// 1</span>
        <span class="s1">!curRecognizer || recognizer === curRecognizer || </span><span class="s0">// 2</span>
        <span class="s1">recognizer.canRecognizeWith(curRecognizer))) {</span>
          <span class="s0">// 3</span>
          <span class="s1">recognizer.recognize(inputData);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">recognizer.reset();</span>
        <span class="s1">} </span><span class="s0">// if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the</span>
        <span class="s0">// current active recognizer. but only if we don't already have an active recognizer</span>


        <span class="s2">if </span><span class="s1">(!curRecognizer &amp;&amp; recognizer.state &amp; (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {</span>
          <span class="s1">session.curRecognizer = recognizer;</span>
          <span class="s1">curRecognizer = recognizer;</span>
        <span class="s1">}</span>

        <span class="s1">i++;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * get a recognizer by its event name. 
     * @param {Recognizer|String} recognizer 
     * @returns {Recognizer|Null} 
     */</span>


    <span class="s1">_proto.get = </span><span class="s2">function </span><span class="s1">get(recognizer) {</span>
      <span class="s2">if </span><span class="s1">(recognizer </span><span class="s2">instanceof </span><span class="s1">Recognizer) {</span>
        <span class="s2">return </span><span class="s1">recognizer;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">recognizers = </span><span class="s2">this</span><span class="s1">.recognizers;</span>

      <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; recognizers.length; i++) {</span>
        <span class="s2">if </span><span class="s1">(recognizers[i].options.event === recognizer) {</span>
          <span class="s2">return </span><span class="s1">recognizers[i];</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private add a recognizer to the manager 
     * existing recognizers with the same event name will be removed 
     * @param {Recognizer} recognizer 
     * @returns {Recognizer|Manager} 
     */</span>


    <span class="s1">_proto.add = </span><span class="s2">function </span><span class="s1">add(recognizer) {</span>
      <span class="s2">if </span><span class="s1">(invokeArrayArg(recognizer, </span><span class="s3">&quot;add&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">)) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">} </span><span class="s0">// remove existing</span>


      <span class="s2">var </span><span class="s1">existing = </span><span class="s2">this</span><span class="s1">.get(recognizer.options.event);</span>

      <span class="s2">if </span><span class="s1">(existing) {</span>
        <span class="s2">this</span><span class="s1">.remove(existing);</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.recognizers.push(recognizer);</span>
      <span class="s1">recognizer.manager = </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">.touchAction.update();</span>
      <span class="s2">return </span><span class="s1">recognizer;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * remove a recognizer by name or instance 
     * @param {Recognizer|String} recognizer 
     * @returns {Manager} 
     */</span>


    <span class="s1">_proto.remove = </span><span class="s2">function </span><span class="s1">remove(recognizer) {</span>
      <span class="s2">if </span><span class="s1">(invokeArrayArg(recognizer, </span><span class="s3">&quot;remove&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">)) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">targetRecognizer = </span><span class="s2">this</span><span class="s1">.get(recognizer); </span><span class="s0">// let's make sure this recognizer exists</span>

      <span class="s2">if </span><span class="s1">(recognizer) {</span>
        <span class="s2">var </span><span class="s1">recognizers = </span><span class="s2">this</span><span class="s1">.recognizers;</span>
        <span class="s2">var </span><span class="s1">index = inArray(recognizers, targetRecognizer);</span>

        <span class="s2">if </span><span class="s1">(index !== -</span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">recognizers.splice(index, </span><span class="s4">1</span><span class="s1">);</span>
          <span class="s2">this</span><span class="s1">.touchAction.update();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * bind event 
     * @param {String} events 
     * @param {Function} handler 
     * @returns {EventEmitter} this 
     */</span>


    <span class="s1">_proto.on = </span><span class="s2">function </span><span class="s1">on(events, handler) {</span>
      <span class="s2">if </span><span class="s1">(events === undefined || handler === undefined) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">handlers = </span><span class="s2">this</span><span class="s1">.handlers;</span>
      <span class="s1">each(splitStr(events), </span><span class="s2">function </span><span class="s1">(event) {</span>
        <span class="s1">handlers[event] = handlers[event] || [];</span>
        <span class="s1">handlers[event].push(handler);</span>
      <span class="s1">});</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private unbind event, leave emit blank to remove all handlers 
     * @param {String} events 
     * @param {Function} [handler] 
     * @returns {EventEmitter} this 
     */</span>


    <span class="s1">_proto.off = </span><span class="s2">function </span><span class="s1">off(events, handler) {</span>
      <span class="s2">if </span><span class="s1">(events === undefined) {</span>
        <span class="s2">return this</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">handlers = </span><span class="s2">this</span><span class="s1">.handlers;</span>
      <span class="s1">each(splitStr(events), </span><span class="s2">function </span><span class="s1">(event) {</span>
        <span class="s2">if </span><span class="s1">(!handler) {</span>
          <span class="s2">delete </span><span class="s1">handlers[event];</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">handlers[event] &amp;&amp; handlers[event].splice(inArray(handlers[event], handler), </span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">});</span>
      <span class="s2">return this</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private emit event to the listeners 
     * @param {String} event 
     * @param {Object} data 
     */</span>


    <span class="s1">_proto.emit = </span><span class="s2">function </span><span class="s1">emit(event, data) {</span>
      <span class="s0">// we also want to trigger dom events</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.domEvents) {</span>
        <span class="s1">triggerDomEvent(event, data);</span>
      <span class="s1">} </span><span class="s0">// no handlers, so skip it all</span>


      <span class="s2">var </span><span class="s1">handlers = </span><span class="s2">this</span><span class="s1">.handlers[event] &amp;&amp; </span><span class="s2">this</span><span class="s1">.handlers[event].slice();</span>

      <span class="s2">if </span><span class="s1">(!handlers || !handlers.length) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s1">data.type = event;</span>

      <span class="s1">data.preventDefault = </span><span class="s2">function </span><span class="s1">() {</span>
        <span class="s1">data.srcEvent.preventDefault();</span>
      <span class="s1">};</span>

      <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

      <span class="s2">while </span><span class="s1">(i &lt; handlers.length) {</span>
        <span class="s1">handlers[i](data);</span>
        <span class="s1">i++;</span>
      <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s0">/** 
     * @private 
     * destroy the manager and unbinds all events 
     * it doesn't unbind dom events, that is the user own responsibility 
     */</span>


    <span class="s1">_proto.destroy = </span><span class="s2">function </span><span class="s1">destroy() {</span>
      <span class="s2">this</span><span class="s1">.element &amp;&amp; toggleCssProps(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
      <span class="s2">this</span><span class="s1">.handlers = {};</span>
      <span class="s2">this</span><span class="s1">.session = {};</span>
      <span class="s2">this</span><span class="s1">.input.destroy();</span>
      <span class="s2">this</span><span class="s1">.element = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">Manager;</span>
  <span class="s1">}();</span>

  <span class="s2">var </span><span class="s1">SINGLE_TOUCH_INPUT_MAP = {</span>
    <span class="s1">touchstart: INPUT_START,</span>
    <span class="s1">touchmove: INPUT_MOVE,</span>
    <span class="s1">touchend: INPUT_END,</span>
    <span class="s1">touchcancel: INPUT_CANCEL</span>
  <span class="s1">};</span>
  <span class="s2">var </span><span class="s1">SINGLE_TOUCH_TARGET_EVENTS = </span><span class="s3">'touchstart'</span><span class="s1">;</span>
  <span class="s2">var </span><span class="s1">SINGLE_TOUCH_WINDOW_EVENTS = </span><span class="s3">'touchstart touchmove touchend touchcancel'</span><span class="s1">;</span>
  <span class="s0">/** 
   * @private 
   * Touch events input 
   * @constructor 
   * @extends Input 
   */</span>

  <span class="s2">var </span><span class="s1">SingleTouchInput =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">(_Input) {</span>
    <span class="s1">_inheritsLoose(SingleTouchInput, _Input);</span>

    <span class="s2">function </span><span class="s1">SingleTouchInput() {</span>
      <span class="s2">var </span><span class="s1">_this;</span>

      <span class="s2">var </span><span class="s1">proto = SingleTouchInput.prototype;</span>
      <span class="s1">proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;</span>
      <span class="s1">proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;</span>
      <span class="s1">_this = _Input.apply(</span><span class="s2">this</span><span class="s1">, arguments) || </span><span class="s2">this</span><span class="s1">;</span>
      <span class="s1">_this.started = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>

    <span class="s2">var </span><span class="s1">_proto = SingleTouchInput.prototype;</span>

    <span class="s1">_proto.handler = </span><span class="s2">function </span><span class="s1">handler(ev) {</span>
      <span class="s2">var </span><span class="s1">type = SINGLE_TOUCH_INPUT_MAP[ev.type]; </span><span class="s0">// should we handle the touch events?</span>

      <span class="s2">if </span><span class="s1">(type === INPUT_START) {</span>
        <span class="s2">this</span><span class="s1">.started = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.started) {</span>
        <span class="s2">return</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">var </span><span class="s1">touches = normalizeSingleTouches.call(</span><span class="s2">this</span><span class="s1">, ev, type); </span><span class="s0">// when done, reset the started state</span>

      <span class="s2">if </span><span class="s1">(type &amp; (INPUT_END | INPUT_CANCEL) &amp;&amp; touches[</span><span class="s4">0</span><span class="s1">].length - touches[</span><span class="s4">1</span><span class="s1">].length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">this</span><span class="s1">.started = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s2">this</span><span class="s1">.callback(</span><span class="s2">this</span><span class="s1">.manager, type, {</span>
        <span class="s1">pointers: touches[</span><span class="s4">0</span><span class="s1">],</span>
        <span class="s1">changedPointers: touches[</span><span class="s4">1</span><span class="s1">],</span>
        <span class="s1">pointerType: INPUT_TYPE_TOUCH,</span>
        <span class="s1">srcEvent: ev</span>
      <span class="s1">});</span>
    <span class="s1">};</span>

    <span class="s2">return </span><span class="s1">SingleTouchInput;</span>
  <span class="s1">}(Input);</span>

  <span class="s2">function </span><span class="s1">normalizeSingleTouches(ev, type) {</span>
    <span class="s2">var </span><span class="s1">all = toArray(ev.touches);</span>
    <span class="s2">var </span><span class="s1">changed = toArray(ev.changedTouches);</span>

    <span class="s2">if </span><span class="s1">(type &amp; (INPUT_END | INPUT_CANCEL)) {</span>
      <span class="s1">all = uniqueArray(all.concat(changed), </span><span class="s3">'identifier'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">[all, changed];</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * wrap a method with a deprecation warning and stack trace 
   * @param {Function} method 
   * @param {String} name 
   * @param {String} message 
   * @returns {Function} A new function wrapping the supplied method. 
   */</span>
  <span class="s2">function </span><span class="s1">deprecate(method, name, message) {</span>
    <span class="s2">var </span><span class="s1">deprecationMessage = </span><span class="s3">&quot;DEPRECATED METHOD: &quot; </span><span class="s1">+ name + </span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s1">+ message + </span><span class="s3">&quot; AT </span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">;</span>
    <span class="s2">return function </span><span class="s1">() {</span>
      <span class="s2">var </span><span class="s1">e = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">'get-stack-trace'</span><span class="s1">);</span>
      <span class="s2">var </span><span class="s1">stack = e &amp;&amp; e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, </span><span class="s3">''</span><span class="s1">).replace(/^\s+at\s+/gm, </span><span class="s3">''</span><span class="s1">).replace(/^Object.&lt;anonymous&gt;\s*\(/gm, </span><span class="s3">'{anonymous}()@'</span><span class="s1">) : </span><span class="s3">'Unknown Stack Trace'</span><span class="s1">;</span>
      <span class="s2">var </span><span class="s1">log = window.console &amp;&amp; (window.console.warn || window.console.log);</span>

      <span class="s2">if </span><span class="s1">(log) {</span>
        <span class="s1">log.call(window.console, deprecationMessage, stack);</span>
      <span class="s1">}</span>

      <span class="s2">return </span><span class="s1">method.apply(</span><span class="s2">this</span><span class="s1">, arguments);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * extend object. 
   * means that properties in dest will be overwritten by the ones in src. 
   * @param {Object} dest 
   * @param {Object} src 
   * @param {Boolean} [merge=false] 
   * @returns {Object} dest 
   */</span>

  <span class="s2">var </span><span class="s1">extend = deprecate(</span><span class="s2">function </span><span class="s1">(dest, src, merge) {</span>
    <span class="s2">var </span><span class="s1">keys = Object.keys(src);</span>
    <span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s2">while </span><span class="s1">(i &lt; keys.length) {</span>
      <span class="s2">if </span><span class="s1">(!merge || merge &amp;&amp; dest[keys[i]] === undefined) {</span>
        <span class="s1">dest[keys[i]] = src[keys[i]];</span>
      <span class="s1">}</span>

      <span class="s1">i++;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">dest;</span>
  <span class="s1">}, </span><span class="s3">'extend'</span><span class="s1">, </span><span class="s3">'Use `assign`.'</span><span class="s1">);</span>

  <span class="s0">/** 
   * @private 
   * merge the values from src in the dest. 
   * means that properties that exist in dest will not be overwritten by src 
   * @param {Object} dest 
   * @param {Object} src 
   * @returns {Object} dest 
   */</span>

  <span class="s2">var </span><span class="s1">merge = deprecate(</span><span class="s2">function </span><span class="s1">(dest, src) {</span>
    <span class="s2">return </span><span class="s1">extend(dest, src, </span><span class="s2">true</span><span class="s1">);</span>
  <span class="s1">}, </span><span class="s3">'merge'</span><span class="s1">, </span><span class="s3">'Use `assign`.'</span><span class="s1">);</span>

  <span class="s0">/** 
   * @private 
   * simple class inheritance 
   * @param {Function} child 
   * @param {Function} base 
   * @param {Object} [properties] 
   */</span>

  <span class="s2">function </span><span class="s1">inherit(child, base, properties) {</span>
    <span class="s2">var </span><span class="s1">baseP = base.prototype;</span>
    <span class="s2">var </span><span class="s1">childP;</span>
    <span class="s1">childP = child.prototype = Object.create(baseP);</span>
    <span class="s1">childP.constructor = child;</span>
    <span class="s1">childP._super = baseP;</span>

    <span class="s2">if </span><span class="s1">(properties) {</span>
      <span class="s1">assign$1(childP, properties);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * simple function bind 
   * @param {Function} fn 
   * @param {Object} context 
   * @returns {Function} 
   */</span>
  <span class="s2">function </span><span class="s1">bindFn(fn, context) {</span>
    <span class="s2">return function </span><span class="s1">boundFn() {</span>
      <span class="s2">return </span><span class="s1">fn.apply(context, arguments);</span>
    <span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s0">/** 
   * @private 
   * Simple way to create a manager with a default set of recognizers. 
   * @param {HTMLElement} element 
   * @param {Object} [options] 
   * @constructor 
   */</span>

  <span class="s2">var </span><span class="s1">Hammer =</span>
  <span class="s0">/*#__PURE__*/</span>
  <span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">Hammer =</span>
    <span class="s0">/** 
      * @private 
      * @const {string} 
      */</span>
    <span class="s2">function </span><span class="s1">Hammer(element, options) {</span>
      <span class="s2">if </span><span class="s1">(options === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">options = {};</span>
      <span class="s1">}</span>

      <span class="s2">return new </span><span class="s1">Manager(element, _extends({</span>
        <span class="s1">recognizers: preset.concat()</span>
      <span class="s1">}, options));</span>
    <span class="s1">};</span>

    <span class="s1">Hammer.VERSION = </span><span class="s3">&quot;2.0.17-rc&quot;</span><span class="s1">;</span>
    <span class="s1">Hammer.DIRECTION_ALL = DIRECTION_ALL;</span>
    <span class="s1">Hammer.DIRECTION_DOWN = DIRECTION_DOWN;</span>
    <span class="s1">Hammer.DIRECTION_LEFT = DIRECTION_LEFT;</span>
    <span class="s1">Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;</span>
    <span class="s1">Hammer.DIRECTION_UP = DIRECTION_UP;</span>
    <span class="s1">Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;</span>
    <span class="s1">Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;</span>
    <span class="s1">Hammer.DIRECTION_NONE = DIRECTION_NONE;</span>
    <span class="s1">Hammer.DIRECTION_DOWN = DIRECTION_DOWN;</span>
    <span class="s1">Hammer.INPUT_START = INPUT_START;</span>
    <span class="s1">Hammer.INPUT_MOVE = INPUT_MOVE;</span>
    <span class="s1">Hammer.INPUT_END = INPUT_END;</span>
    <span class="s1">Hammer.INPUT_CANCEL = INPUT_CANCEL;</span>
    <span class="s1">Hammer.STATE_POSSIBLE = STATE_POSSIBLE;</span>
    <span class="s1">Hammer.STATE_BEGAN = STATE_BEGAN;</span>
    <span class="s1">Hammer.STATE_CHANGED = STATE_CHANGED;</span>
    <span class="s1">Hammer.STATE_ENDED = STATE_ENDED;</span>
    <span class="s1">Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;</span>
    <span class="s1">Hammer.STATE_CANCELLED = STATE_CANCELLED;</span>
    <span class="s1">Hammer.STATE_FAILED = STATE_FAILED;</span>
    <span class="s1">Hammer.Manager = Manager;</span>
    <span class="s1">Hammer.Input = Input;</span>
    <span class="s1">Hammer.TouchAction = TouchAction;</span>
    <span class="s1">Hammer.TouchInput = TouchInput;</span>
    <span class="s1">Hammer.MouseInput = MouseInput;</span>
    <span class="s1">Hammer.PointerEventInput = PointerEventInput;</span>
    <span class="s1">Hammer.TouchMouseInput = TouchMouseInput;</span>
    <span class="s1">Hammer.SingleTouchInput = SingleTouchInput;</span>
    <span class="s1">Hammer.Recognizer = Recognizer;</span>
    <span class="s1">Hammer.AttrRecognizer = AttrRecognizer;</span>
    <span class="s1">Hammer.Tap = TapRecognizer;</span>
    <span class="s1">Hammer.Pan = PanRecognizer;</span>
    <span class="s1">Hammer.Swipe = SwipeRecognizer;</span>
    <span class="s1">Hammer.Pinch = PinchRecognizer;</span>
    <span class="s1">Hammer.Rotate = RotateRecognizer;</span>
    <span class="s1">Hammer.Press = PressRecognizer;</span>
    <span class="s1">Hammer.on = addEventListeners;</span>
    <span class="s1">Hammer.off = removeEventListeners;</span>
    <span class="s1">Hammer.each = each;</span>
    <span class="s1">Hammer.merge = merge;</span>
    <span class="s1">Hammer.extend = extend;</span>
    <span class="s1">Hammer.bindFn = bindFn;</span>
    <span class="s1">Hammer.assign = assign$1;</span>
    <span class="s1">Hammer.inherit = inherit;</span>
    <span class="s1">Hammer.bindFn = bindFn;</span>
    <span class="s1">Hammer.prefixed = prefixed;</span>
    <span class="s1">Hammer.toArray = toArray;</span>
    <span class="s1">Hammer.inArray = inArray;</span>
    <span class="s1">Hammer.uniqueArray = uniqueArray;</span>
    <span class="s1">Hammer.splitStr = splitStr;</span>
    <span class="s1">Hammer.boolOrFn = boolOrFn;</span>
    <span class="s1">Hammer.hasParent = hasParent;</span>
    <span class="s1">Hammer.addEventListeners = addEventListeners;</span>
    <span class="s1">Hammer.removeEventListeners = removeEventListeners;</span>
    <span class="s1">Hammer.defaults = assign$1({}, defaults, {</span>
      <span class="s1">preset: preset</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">Hammer;</span>
  <span class="s1">}();</span>

  <span class="s2">return </span><span class="s1">Hammer;</span>

<span class="s1">})));</span>
<span class="s0">//# sourceMappingURL=hammer.js.map</span>
</pre>
</body>
</html>
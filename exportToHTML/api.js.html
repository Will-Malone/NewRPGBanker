<html>
<head>
<title>api.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
api.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">path = require(</span><span class="s0">'path'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">minimatch = require(</span><span class="s0">'minimatch'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">createDebug = require(</span><span class="s0">'debug'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">objectSchema = require(</span><span class="s0">'@humanwhocodes/object-schema'</span><span class="s1">);</span>

<span class="s3">/** 
 * @fileoverview ConfigSchema 
 * @author Nicholas C. Zakas 
 */</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/** 
 * Assets that a given value is an array. 
 * @param {*} value The value to check. 
 * @returns {void} 
 * @throws {TypeError} When the value is not an array.  
 */</span>
<span class="s2">function </span><span class="s1">assertIsArray(value) {</span>
	<span class="s2">if </span><span class="s1">(!Array.isArray(value)) {</span>
		<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Expected value to be an array.'</span><span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Assets that a given value is an array containing only strings and functions. 
 * @param {*} value The value to check. 
 * @returns {void} 
 * @throws {TypeError} When the value is not an array of strings and functions. 
 */</span>
<span class="s2">function </span><span class="s1">assertIsArrayOfStringsAndFunctions(value, name) {</span>
	<span class="s1">assertIsArray(value);</span>

	<span class="s2">if </span><span class="s1">(value.some(item =&gt; </span><span class="s2">typeof </span><span class="s1">item !== </span><span class="s0">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">item !== </span><span class="s0">'function'</span><span class="s1">)) {</span>
		<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Expected array to only contain strings.'</span><span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Exports</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/** 
 * The base schema that every ConfigArray uses. 
 * @type Object 
 */</span>
<span class="s1">const baseSchema = Object.freeze({</span>
	<span class="s1">name: {</span>
		<span class="s1">required: </span><span class="s2">false</span><span class="s1">,</span>
		<span class="s1">merge() {</span>
			<span class="s2">return </span><span class="s1">undefined;</span>
		<span class="s1">},</span>
		<span class="s1">validate(value) {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value !== </span><span class="s0">'string'</span><span class="s1">) {</span>
				<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Property must be a string.'</span><span class="s1">);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">},</span>
	<span class="s1">files: {</span>
		<span class="s1">required: </span><span class="s2">false</span><span class="s1">,</span>
		<span class="s1">merge() {</span>
			<span class="s2">return </span><span class="s1">undefined;</span>
		<span class="s1">},</span>
		<span class="s1">validate(value) {</span>

			<span class="s3">// first check if it's an array</span>
			<span class="s1">assertIsArray(value);</span>

			<span class="s3">// then check each member</span>
			<span class="s1">value.forEach(item =&gt; {</span>
				<span class="s2">if </span><span class="s1">(Array.isArray(item)) {</span>
					<span class="s1">assertIsArrayOfStringsAndFunctions(item);</span>
				<span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">item !== </span><span class="s0">'string' </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">item !== </span><span class="s0">'function'</span><span class="s1">) {</span>
					<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Items must be a string, a function, or an array of strings and functions.'</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">});</span>

		<span class="s1">}</span>
	<span class="s1">},</span>
	<span class="s1">ignores: {</span>
		<span class="s1">required: </span><span class="s2">false</span><span class="s1">,</span>
		<span class="s1">merge() {</span>
			<span class="s2">return </span><span class="s1">undefined;</span>
		<span class="s1">},</span>
		<span class="s1">validate: assertIsArrayOfStringsAndFunctions</span>
	<span class="s1">}</span>
<span class="s1">});</span>

<span class="s3">/** 
 * @fileoverview ConfigArray 
 * @author Nicholas C. Zakas 
 */</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s1">const Minimatch = minimatch.Minimatch;</span>
<span class="s1">const minimatchCache = </span><span class="s2">new </span><span class="s1">Map();</span>
<span class="s1">const negatedMinimatchCache = </span><span class="s2">new </span><span class="s1">Map();</span>
<span class="s1">const debug = createDebug(</span><span class="s0">'@hwc/config-array'</span><span class="s1">);</span>

<span class="s1">const MINIMATCH_OPTIONS = {</span>
	<span class="s3">// matchBase: true,</span>
	<span class="s1">dot: </span><span class="s2">true</span>
<span class="s1">};</span>

<span class="s1">const CONFIG_TYPES = </span><span class="s2">new </span><span class="s1">Set([</span><span class="s0">'array'</span><span class="s1">, </span><span class="s0">'function'</span><span class="s1">]);</span>

<span class="s3">/** 
 * Shorthand for checking if a value is a string. 
 * @param {any} value The value to check. 
 * @returns {boolean} True if a string, false if not.  
 */</span>
<span class="s2">function </span><span class="s1">isString(value) {</span>
	<span class="s2">return typeof </span><span class="s1">value === </span><span class="s0">'string'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Asserts that the files key of a config object is a nonempty array. 
 * @param {object} config The config object to check. 
 * @returns {void} 
 * @throws {TypeError} If the files key isn't a nonempty array.  
 */</span>
<span class="s2">function </span><span class="s1">assertNonEmptyFilesArray(config) {</span>
	<span class="s2">if </span><span class="s1">(!Array.isArray(config.files) || config.files.length === </span><span class="s4">0</span><span class="s1">) {</span>
		<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'The files key must be a non-empty array.'</span><span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Wrapper around minimatch that caches minimatch patterns for 
 * faster matching speed over multiple file path evaluations. 
 * @param {string} filepath The file path to match. 
 * @param {string} pattern The glob pattern to match against. 
 * @param {object} options The minimatch options to use. 
 * @returns  
 */</span>
<span class="s2">function </span><span class="s1">doMatch(filepath, pattern, options = {}) {</span>

	<span class="s1">let cache = minimatchCache;</span>

	<span class="s2">if </span><span class="s1">(options.flipNegate) {</span>
		<span class="s1">cache = negatedMinimatchCache;</span>
	<span class="s1">}</span>

	<span class="s1">let matcher = cache.get(pattern);</span>

	<span class="s2">if </span><span class="s1">(!matcher) {</span>
		<span class="s1">matcher = </span><span class="s2">new </span><span class="s1">Minimatch(pattern, Object.assign({}, MINIMATCH_OPTIONS, options));</span>
		<span class="s1">cache.set(pattern, matcher);</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">matcher.match(filepath);</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Normalizes a `ConfigArray` by flattening it and executing any functions 
 * that are found inside. 
 * @param {Array} items The items in a `ConfigArray`. 
 * @param {Object} context The context object to pass into any function 
 *      found. 
 * @param {Array&lt;string&gt;} extraConfigTypes The config types to check. 
 * @returns {Promise&lt;Array&gt;} A flattened array containing only config objects. 
 * @throws {TypeError} When a config function returns a function. 
 */</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">normalize(items, context, extraConfigTypes) {</span>

	<span class="s1">const allowFunctions = extraConfigTypes.includes(</span><span class="s0">'function'</span><span class="s1">);</span>
	<span class="s1">const allowArrays = extraConfigTypes.includes(</span><span class="s0">'array'</span><span class="s1">);</span>

	<span class="s1">async </span><span class="s2">function</span><span class="s1">* flatTraverse(array) {</span>
		<span class="s2">for </span><span class="s1">(let item of array) {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">item === </span><span class="s0">'function'</span><span class="s1">) {</span>
				<span class="s2">if </span><span class="s1">(!allowFunctions) {</span>
					<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Unexpected function.'</span><span class="s1">);</span>
				<span class="s1">}</span>

				<span class="s1">item = item(context);</span>
				<span class="s2">if </span><span class="s1">(item.then) {</span>
					<span class="s1">item = await item;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(Array.isArray(item)) {</span>
				<span class="s2">if </span><span class="s1">(!allowArrays) {</span>
					<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Unexpected array.'</span><span class="s1">);</span>
				<span class="s1">}</span>
				<span class="s1">yield* flatTraverse(item);</span>
			<span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">item === </span><span class="s0">'function'</span><span class="s1">) {</span>
				<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'A config function can only return an object or array.'</span><span class="s1">);</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">yield item;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s3">/* 
     * Async iterables cannot be used with the spread operator, so we need to manually 
     * create the array to return. 
     */</span>
	<span class="s1">const asyncIterable = await flatTraverse(items);</span>
	<span class="s1">const configs = [];</span>

	<span class="s2">for </span><span class="s1">await (const config of asyncIterable) {</span>
		<span class="s1">configs.push(config);</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">configs;</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Normalizes a `ConfigArray` by flattening it and executing any functions 
 * that are found inside. 
 * @param {Array} items The items in a `ConfigArray`. 
 * @param {Object} context The context object to pass into any function 
 *      found. 
 * @param {Array&lt;string&gt;} extraConfigTypes The config types to check. 
 * @returns {Array} A flattened array containing only config objects. 
 * @throws {TypeError} When a config function returns a function. 
 */</span>
<span class="s2">function </span><span class="s1">normalizeSync(items, context, extraConfigTypes) {</span>

	<span class="s1">const allowFunctions = extraConfigTypes.includes(</span><span class="s0">'function'</span><span class="s1">);</span>
	<span class="s1">const allowArrays = extraConfigTypes.includes(</span><span class="s0">'array'</span><span class="s1">);</span>

	<span class="s2">function</span><span class="s1">* flatTraverse(array) {</span>
		<span class="s2">for </span><span class="s1">(let item of array) {</span>
			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">item === </span><span class="s0">'function'</span><span class="s1">) {</span>

				<span class="s2">if </span><span class="s1">(!allowFunctions) {</span>
					<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Unexpected function.'</span><span class="s1">);</span>
				<span class="s1">}</span>

				<span class="s1">item = item(context);</span>
				<span class="s2">if </span><span class="s1">(item.then) {</span>
					<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Async config functions are not supported.'</span><span class="s1">);</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(Array.isArray(item)) {</span>

				<span class="s2">if </span><span class="s1">(!allowArrays) {</span>
					<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Unexpected array.'</span><span class="s1">);</span>
				<span class="s1">}</span>

				<span class="s1">yield* flatTraverse(item);</span>
			<span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">item === </span><span class="s0">'function'</span><span class="s1">) {</span>
				<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'A config function can only return an object or array.'</span><span class="s1">);</span>
			<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
				<span class="s1">yield item;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">[...flatTraverse(items)];</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Determines if a given file path should be ignored based on the given 
 * matcher. 
 * @param {Array&lt;string|() =&gt; boolean&gt;} ignores The ignore patterns to check.  
 * @param {string} filePath The absolute path of the file to check. 
 * @param {string} relativeFilePath The relative path of the file to check. 
 * @returns {boolean} True if the path should be ignored and false if not. 
 */</span>
<span class="s2">function </span><span class="s1">shouldIgnorePath(ignores, filePath, relativeFilePath) {</span>

	<span class="s3">// all files outside of the basePath are ignored</span>
	<span class="s2">if </span><span class="s1">(relativeFilePath.startsWith(</span><span class="s0">'..'</span><span class="s1">)) {</span>
		<span class="s2">return true</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">ignores.reduce((ignored, matcher) =&gt; {</span>

		<span class="s2">if </span><span class="s1">(!ignored) {</span>

			<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">matcher === </span><span class="s0">'function'</span><span class="s1">) {</span>
				<span class="s2">return </span><span class="s1">matcher(filePath);</span>
			<span class="s1">}</span>

			<span class="s3">// don't check negated patterns because we're not ignored yet</span>
			<span class="s2">if </span><span class="s1">(!matcher.startsWith(</span><span class="s0">'!'</span><span class="s1">)) {</span>
				<span class="s2">return </span><span class="s1">doMatch(relativeFilePath, matcher);</span>
			<span class="s1">}</span>

			<span class="s3">// otherwise we're still not ignored</span>
			<span class="s2">return false</span><span class="s1">;</span>

		<span class="s1">}</span>

		<span class="s3">// only need to check negated patterns because we're ignored</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">matcher === </span><span class="s0">'string' </span><span class="s1">&amp;&amp; matcher.startsWith(</span><span class="s0">'!'</span><span class="s1">)) {</span>
			<span class="s2">return </span><span class="s1">!doMatch(relativeFilePath, matcher, {</span>
				<span class="s1">flipNegate: </span><span class="s2">true</span>
			<span class="s1">});</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">ignored;</span>

	<span class="s1">}, </span><span class="s2">false</span><span class="s1">);</span>

<span class="s1">}</span>

<span class="s3">/** 
 * Determines if a given file path is matched by a config based on 
 * `ignores` only. 
 * @param {string} filePath The absolute file path to check. 
 * @param {string} basePath The base path for the config. 
 * @param {Object} config The config object to check. 
 * @returns {boolean} True if the file path is matched by the config, 
 *      false if not. 
 */</span>
<span class="s2">function </span><span class="s1">pathMatchesIgnores(filePath, basePath, config) {</span>

	<span class="s3">/* 
     * For both files and ignores, functions are passed the absolute 
     * file path while strings are compared against the relative 
     * file path. 
     */</span>
	<span class="s1">const relativeFilePath = path.relative(basePath, filePath);</span>

	<span class="s2">return </span><span class="s1">Object.keys(config).length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
		<span class="s1">!shouldIgnorePath(config.ignores, filePath, relativeFilePath);</span>
<span class="s1">}</span>


<span class="s3">/** 
 * Determines if a given file path is matched by a config. If the config 
 * has no `files` field, then it matches; otherwise, if a `files` field 
 * is present then we match the globs in `files` and exclude any globs in 
 * `ignores`. 
 * @param {string} filePath The absolute file path to check. 
 * @param {string} basePath The base path for the config. 
 * @param {Object} config The config object to check. 
 * @returns {boolean} True if the file path is matched by the config, 
 *      false if not. 
 */</span>
<span class="s2">function </span><span class="s1">pathMatches(filePath, basePath, config) {</span>

	<span class="s3">/* 
     * For both files and ignores, functions are passed the absolute 
     * file path while strings are compared against the relative 
     * file path. 
     */</span>
	<span class="s1">const relativeFilePath = path.relative(basePath, filePath);</span>

	<span class="s3">// if files isn't an array, throw an error</span>
	<span class="s1">assertNonEmptyFilesArray(config);</span>

	<span class="s3">// match both strings and functions</span>
	<span class="s1">const match = pattern =&gt; {</span>

		<span class="s2">if </span><span class="s1">(isString(pattern)) {</span>
			<span class="s2">return </span><span class="s1">doMatch(relativeFilePath, pattern);</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">pattern === </span><span class="s0">'function'</span><span class="s1">) {</span>
			<span class="s2">return </span><span class="s1">pattern(filePath);</span>
		<span class="s1">}</span>

		<span class="s2">throw new </span><span class="s1">TypeError(`Unexpected matcher type ${pattern}.`);</span>
	<span class="s1">};</span>

	<span class="s3">// check for all matches to config.files</span>
	<span class="s1">let filePathMatchesPattern = config.files.some(pattern =&gt; {</span>
		<span class="s2">if </span><span class="s1">(Array.isArray(pattern)) {</span>
			<span class="s2">return </span><span class="s1">pattern.every(match);</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">match(pattern);</span>
	<span class="s1">});</span>

	<span class="s3">/* 
     * If the file path matches the config.files patterns, then check to see 
     * if there are any files to ignore. 
     */</span>
	<span class="s2">if </span><span class="s1">(filePathMatchesPattern &amp;&amp; config.ignores) {</span>
		<span class="s1">filePathMatchesPattern = !shouldIgnorePath(config.ignores, filePath, relativeFilePath);</span>
	<span class="s1">}</span>

	<span class="s2">return </span><span class="s1">filePathMatchesPattern;</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Ensures that a ConfigArray has been normalized. 
 * @param {ConfigArray} configArray The ConfigArray to check.  
 * @returns {void} 
 * @throws {Error} When the `ConfigArray` is not normalized. 
 */</span>
<span class="s2">function </span><span class="s1">assertNormalized(configArray) {</span>
	<span class="s3">// TODO: Throw more verbose error</span>
	<span class="s2">if </span><span class="s1">(!configArray.isNormalized()) {</span>
		<span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'ConfigArray must be normalized to perform this operation.'</span><span class="s1">);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/** 
 * Ensures that config types are valid. 
 * @param {Array&lt;string&gt;} extraConfigTypes The config types to check. 
 * @returns {void} 
 * @throws {Error} When the config types array is invalid. 
 */</span>
<span class="s2">function </span><span class="s1">assertExtraConfigTypes(extraConfigTypes) {</span>
	<span class="s2">if </span><span class="s1">(extraConfigTypes.length &gt; </span><span class="s4">2</span><span class="s1">) {</span>
		<span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'configTypes must be an array with at most two items.'</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s2">for </span><span class="s1">(const configType of extraConfigTypes) {</span>
		<span class="s2">if </span><span class="s1">(!CONFIG_TYPES.has(configType)) {</span>
			<span class="s2">throw new </span><span class="s1">TypeError(`Unexpected config type </span><span class="s0">&quot;${configType}&quot; </span><span class="s1">found. Expected one of: </span><span class="s0">&quot;object&quot;</span><span class="s1">, </span><span class="s0">&quot;array&quot;</span><span class="s1">, </span><span class="s0">&quot;function&quot;</span><span class="s1">.`);</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Public Interface</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s1">const ConfigArraySymbol = {</span>
	<span class="s1">isNormalized: Symbol(</span><span class="s0">'isNormalized'</span><span class="s1">),</span>
	<span class="s1">configCache: Symbol(</span><span class="s0">'configCache'</span><span class="s1">),</span>
	<span class="s1">schema: Symbol(</span><span class="s0">'schema'</span><span class="s1">),</span>
	<span class="s1">finalizeConfig: Symbol(</span><span class="s0">'finalizeConfig'</span><span class="s1">),</span>
	<span class="s1">preprocessConfig: Symbol(</span><span class="s0">'preprocessConfig'</span><span class="s1">)</span>
<span class="s1">};</span>

<span class="s3">// used to store calculate data for faster lookup</span>
<span class="s1">const dataCache = </span><span class="s2">new </span><span class="s1">WeakMap();</span>

<span class="s3">/** 
 * Represents an array of config objects and provides method for working with 
 * those config objects. 
 */</span>
<span class="s1">class ConfigArray extends Array {</span>

	<span class="s3">/** 
     * Creates a new instance of ConfigArray. 
     * @param {Iterable|Function|Object} configs An iterable yielding config 
     *      objects, or a config function, or a config object. 
     * @param {string} [options.basePath=&quot;&quot;] The path of the config file 
     * @param {boolean} [options.normalized=false] Flag indicating if the 
     *      configs have already been normalized. 
     * @param {Object} [options.schema] The additional schema  
     *      definitions to use for the ConfigArray schema. 
     * @param {Array&lt;string&gt;} [options.configTypes] List of config types supported. 
     */</span>
	<span class="s1">constructor(configs, {</span>
		<span class="s1">basePath = </span><span class="s0">''</span><span class="s1">,</span>
		<span class="s1">normalized = </span><span class="s2">false</span><span class="s1">,</span>
		<span class="s1">schema: customSchema,</span>
		<span class="s1">extraConfigTypes = []</span>
	<span class="s1">} = {}</span>
	<span class="s1">) {</span>
		<span class="s1">super();</span>

		<span class="s3">/** 
         * Tracks if the array has been normalized. 
         * @property isNormalized 
         * @type boolean 
         * @private 
         */</span>
		<span class="s2">this</span><span class="s1">[ConfigArraySymbol.isNormalized] = normalized;</span>

		<span class="s3">/** 
         * The schema used for validating and merging configs. 
         * @property schema 
         * @type ObjectSchema 
         * @private 
         */</span>
		<span class="s2">this</span><span class="s1">[ConfigArraySymbol.schema] = </span><span class="s2">new </span><span class="s1">objectSchema.ObjectSchema(</span>
			<span class="s1">Object.assign({}, customSchema, baseSchema)</span>
		<span class="s1">);</span>

		<span class="s3">/** 
         * The path of the config file that this array was loaded from. 
         * This is used to calculate filename matches. 
         * @property basePath 
         * @type string 
         */</span>
		<span class="s2">this</span><span class="s1">.basePath = basePath;</span>

		<span class="s1">assertExtraConfigTypes(extraConfigTypes);</span>

		<span class="s3">/** 
         * The supported config types. 
         * @property configTypes 
         * @type Array&lt;string&gt; 
         */</span>
		<span class="s2">this</span><span class="s1">.extraConfigTypes = Object.freeze([...extraConfigTypes]);</span>

		<span class="s3">/** 
         * A cache to store calculated configs for faster repeat lookup. 
         * @property configCache 
         * @type Map 
         * @private 
         */</span>
		<span class="s2">this</span><span class="s1">[ConfigArraySymbol.configCache] = </span><span class="s2">new </span><span class="s1">Map();</span>

		<span class="s3">// init cache</span>
		<span class="s1">dataCache.set(</span><span class="s2">this</span><span class="s1">, {</span>
			<span class="s1">explicitMatches: </span><span class="s2">new </span><span class="s1">Map(),</span>
			<span class="s1">directoryMatches: </span><span class="s2">new </span><span class="s1">Map(),</span>
			<span class="s1">files: undefined,</span>
			<span class="s1">ignores: undefined</span>
		<span class="s1">});</span>

		<span class="s3">// load the configs into this array</span>
		<span class="s2">if </span><span class="s1">(Array.isArray(configs)) {</span>
			<span class="s2">this</span><span class="s1">.push(...configs);</span>
		<span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
			<span class="s2">this</span><span class="s1">.push(configs);</span>
		<span class="s1">}</span>

	<span class="s1">}</span>

	<span class="s3">/** 
     * Prevent normal array methods from creating a new `ConfigArray` instance. 
     * This is to ensure that methods such as `slice()` won't try to create a  
     * new instance of `ConfigArray` behind the scenes as doing so may throw 
     * an error due to the different constructor signature. 
     * @returns {Function} The `Array` constructor. 
     */</span>
	<span class="s1">static get [Symbol.species]() {</span>
		<span class="s2">return </span><span class="s1">Array;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Returns the `files` globs from every config object in the array. 
     * This can be used to determine which files will be matched by a 
     * config array or to use as a glob pattern when no patterns are provided 
     * for a command line interface. 
     * @returns {Array&lt;string|Function&gt;} An array of matchers. 
     */</span>
	<span class="s1">get files() {</span>

		<span class="s1">assertNormalized(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s3">// if this data has been cached, retrieve it</span>
		<span class="s1">const cache = dataCache.get(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(cache.files) {</span>
			<span class="s2">return </span><span class="s1">cache.files;</span>
		<span class="s1">}</span>

		<span class="s3">// otherwise calculate it</span>

		<span class="s1">const result = [];</span>

		<span class="s2">for </span><span class="s1">(const config of </span><span class="s2">this</span><span class="s1">) {</span>
			<span class="s2">if </span><span class="s1">(config.files) {</span>
				<span class="s1">config.files.forEach(filePattern =&gt; {</span>
					<span class="s1">result.push(filePattern);</span>
				<span class="s1">});</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s3">// store result</span>
		<span class="s1">cache.files = result;</span>
		<span class="s1">dataCache.set(</span><span class="s2">this</span><span class="s1">, cache);</span>

		<span class="s2">return </span><span class="s1">result;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Returns ignore matchers that should always be ignored regardless of 
     * the matching `files` fields in any configs. This is necessary to mimic 
     * the behavior of things like .gitignore and .eslintignore, allowing a 
     * globbing operation to be faster. 
     * @returns {string[]} An array of string patterns and functions to be ignored. 
     */</span>
	<span class="s1">get ignores() {</span>

		<span class="s1">assertNormalized(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s3">// if this data has been cached, retrieve it</span>
		<span class="s1">const cache = dataCache.get(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(cache.ignores) {</span>
			<span class="s2">return </span><span class="s1">cache.ignores;</span>
		<span class="s1">}</span>

		<span class="s3">// otherwise calculate it</span>

		<span class="s1">const result = [];</span>

		<span class="s2">for </span><span class="s1">(const config of </span><span class="s2">this</span><span class="s1">) {</span>

			<span class="s3">/* 
             * We only count ignores if there are no other keys in the object. 
             * In this case, it acts list a globally ignored pattern. If there 
             * are additional keys, then ignores act like exclusions. 
             */</span>
			<span class="s2">if </span><span class="s1">(config.ignores &amp;&amp; Object.keys(config).length === </span><span class="s4">1</span><span class="s1">) {</span>

				<span class="s3">/* 
                 * If there are directory ignores, then we need to double up 
                 * the patterns to be ignored. For instance, `foo` will also 
                 * need `foo/**` in order to account for subdirectories. 
                 */</span>
				<span class="s1">config.ignores.forEach(ignore =&gt; {</span>

					<span class="s1">result.push(ignore);</span>
					
					<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ignore === </span><span class="s0">'string'</span><span class="s1">) {</span>

						<span class="s3">// unignoring files won't work unless we unignore directories too</span>
						<span class="s2">if </span><span class="s1">(ignore.startsWith(</span><span class="s0">'!'</span><span class="s1">)) {</span>

							<span class="s2">if </span><span class="s1">(ignore.endsWith(</span><span class="s0">'/**'</span><span class="s1">)) {</span>
								<span class="s1">result.push(ignore.slice(</span><span class="s4">0</span><span class="s1">, ignore.length - </span><span class="s4">3</span><span class="s1">));</span>
							<span class="s1">} </span><span class="s2">else if </span><span class="s1">(ignore.endsWith(</span><span class="s0">'/*'</span><span class="s1">)) {</span>
								<span class="s1">result.push(ignore.slice(</span><span class="s4">0</span><span class="s1">, ignore.length - </span><span class="s4">2</span><span class="s1">));</span>
							<span class="s1">}</span>
						<span class="s1">}</span>

						<span class="s3">// directories should work with or without a trailing slash</span>
						<span class="s2">if </span><span class="s1">(ignore.endsWith(</span><span class="s0">'/'</span><span class="s1">)) {</span>
							<span class="s1">result.push(ignore.slice(</span><span class="s4">0</span><span class="s1">, ignore.length - </span><span class="s4">1</span><span class="s1">));</span>
							<span class="s1">result.push(ignore + </span><span class="s0">'**'</span><span class="s1">);</span>
						<span class="s1">} </span><span class="s2">else if </span><span class="s1">(!ignore.endsWith(</span><span class="s0">'*'</span><span class="s1">)) {</span>
							<span class="s1">result.push(ignore + </span><span class="s0">'/**'</span><span class="s1">);</span>
						<span class="s1">}</span>

					<span class="s1">}</span>
				<span class="s1">});</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s3">// store result</span>
		<span class="s1">cache.ignores = result;</span>
		<span class="s1">dataCache.set(</span><span class="s2">this</span><span class="s1">, cache);</span>

		<span class="s2">return </span><span class="s1">result;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Indicates if the config array has been normalized. 
     * @returns {boolean} True if the config array is normalized, false if not. 
     */</span>
	<span class="s1">isNormalized() {</span>
		<span class="s2">return this</span><span class="s1">[ConfigArraySymbol.isNormalized];</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Normalizes a config array by flattening embedded arrays and executing 
     * config functions. 
     * @param {ConfigContext} context The context object for config functions. 
     * @returns {Promise&lt;ConfigArray&gt;} The current ConfigArray instance. 
     */</span>
	<span class="s1">async normalize(context = {}) {</span>

		<span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isNormalized()) {</span>
			<span class="s1">const normalizedConfigs = await normalize(</span><span class="s2">this</span><span class="s1">, context, </span><span class="s2">this</span><span class="s1">.extraConfigTypes);</span>
			<span class="s2">this</span><span class="s1">.length = </span><span class="s4">0</span><span class="s1">;</span>
			<span class="s2">this</span><span class="s1">.push(...normalizedConfigs.map(</span><span class="s2">this</span><span class="s1">[ConfigArraySymbol.preprocessConfig].bind(</span><span class="s2">this</span><span class="s1">)));</span>
			<span class="s2">this</span><span class="s1">[ConfigArraySymbol.isNormalized] = </span><span class="s2">true</span><span class="s1">;</span>

			<span class="s3">// prevent further changes</span>
			<span class="s1">Object.freeze(</span><span class="s2">this</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Normalizes a config array by flattening embedded arrays and executing 
     * config functions. 
     * @param {ConfigContext} context The context object for config functions. 
     * @returns {ConfigArray} The current ConfigArray instance. 
     */</span>
	<span class="s1">normalizeSync(context = {}) {</span>

		<span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isNormalized()) {</span>
			<span class="s1">const normalizedConfigs = normalizeSync(</span><span class="s2">this</span><span class="s1">, context, </span><span class="s2">this</span><span class="s1">.extraConfigTypes);</span>
			<span class="s2">this</span><span class="s1">.length = </span><span class="s4">0</span><span class="s1">;</span>
			<span class="s2">this</span><span class="s1">.push(...normalizedConfigs.map(</span><span class="s2">this</span><span class="s1">[ConfigArraySymbol.preprocessConfig].bind(</span><span class="s2">this</span><span class="s1">)));</span>
			<span class="s2">this</span><span class="s1">[ConfigArraySymbol.isNormalized] = </span><span class="s2">true</span><span class="s1">;</span>

			<span class="s3">// prevent further changes</span>
			<span class="s1">Object.freeze(</span><span class="s2">this</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">return this</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Finalizes the state of a config before being cached and returned by 
     * `getConfig()`. Does nothing by default but is provided to be 
     * overridden by subclasses as necessary. 
     * @param {Object} config The config to finalize. 
     * @returns {Object} The finalized config. 
     */</span>
	<span class="s1">[ConfigArraySymbol.finalizeConfig](config) {</span>
		<span class="s2">return </span><span class="s1">config;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Preprocesses a config during the normalization process. This is the 
     * method to override if you want to convert an array item before it is 
     * validated for the first time. For example, if you want to replace a 
     * string with an object, this is the method to override. 
     * @param {Object} config The config to preprocess. 
     * @returns {Object} The config to use in place of the argument. 
     */</span>
	<span class="s1">[ConfigArraySymbol.preprocessConfig](config) {</span>
		<span class="s2">return </span><span class="s1">config;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Determines if a given file path explicitly matches a `files` entry 
     * and also doesn't match an `ignores` entry. Configs that don't have 
     * a `files` property are not considered an explicit match. 
     * @param {string} filePath The complete path of a file to check. 
     * @returns {boolean} True if the file path matches a `files` entry 
     *      or false if not. 
     */</span>
	<span class="s1">isExplicitMatch(filePath) {</span>

		<span class="s1">assertNormalized(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s1">const cache = dataCache.get(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s3">// first check the cache to avoid duplicate work</span>
		<span class="s1">let result = cache.explicitMatches.get(filePath);</span>

		<span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">result == </span><span class="s0">'boolean'</span><span class="s1">) {</span>
			<span class="s2">return </span><span class="s1">result;</span>
		<span class="s1">}</span>

		<span class="s3">// TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?</span>
		<span class="s1">const relativeFilePath = path.relative(</span><span class="s2">this</span><span class="s1">.basePath, filePath);</span>

		<span class="s2">if </span><span class="s1">(shouldIgnorePath(</span><span class="s2">this</span><span class="s1">.ignores, filePath, relativeFilePath)) {</span>
			<span class="s1">debug(`Ignoring ${filePath}`);</span>

			<span class="s3">// cache and return result</span>
			<span class="s1">cache.explicitMatches.set(filePath, </span><span class="s2">false</span><span class="s1">);</span>
			<span class="s2">return false</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s3">// filePath isn't automatically ignored, so try to find a match</span>

		<span class="s2">for </span><span class="s1">(const config of </span><span class="s2">this</span><span class="s1">) {</span>

			<span class="s2">if </span><span class="s1">(!config.files) {</span>
				<span class="s2">continue</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s2">if </span><span class="s1">(pathMatches(filePath, </span><span class="s2">this</span><span class="s1">.basePath, config)) {</span>
				<span class="s1">debug(`Matching config found </span><span class="s2">for </span><span class="s1">${filePath}`);</span>
				<span class="s1">cache.explicitMatches.set(filePath, </span><span class="s2">true</span><span class="s1">);</span>
				<span class="s2">return true</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">return false</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Returns the config object for a given file path. 
     * @param {string} filePath The complete path of a file to get a config for. 
     * @returns {Object} The config object for this file. 
     */</span>
	<span class="s1">getConfig(filePath) {</span>

		<span class="s1">assertNormalized(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s1">const cache = </span><span class="s2">this</span><span class="s1">[ConfigArraySymbol.configCache];</span>

		<span class="s3">// first check the cache for a filename match to avoid duplicate work</span>
		<span class="s1">let finalConfig = cache.get(filePath);</span>

		<span class="s2">if </span><span class="s1">(finalConfig) {</span>
			<span class="s2">return </span><span class="s1">finalConfig;</span>
		<span class="s1">}</span>

		<span class="s3">// next check to see if the file should be ignored</span>

		<span class="s3">// check if this should be ignored due to its directory</span>
		<span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isDirectoryIgnored(path.dirname(filePath))) {</span>
			<span class="s1">debug(`Ignoring ${filePath} based on directory pattern`);</span>

			<span class="s3">// cache and return result - finalConfig is undefined at this point</span>
			<span class="s1">cache.set(filePath, finalConfig);</span>
			<span class="s2">return </span><span class="s1">finalConfig;</span>
		<span class="s1">}</span>

		<span class="s3">// TODO: Maybe move elsewhere?</span>
		<span class="s1">const relativeFilePath = path.relative(</span><span class="s2">this</span><span class="s1">.basePath, filePath);</span>

		<span class="s2">if </span><span class="s1">(shouldIgnorePath(</span><span class="s2">this</span><span class="s1">.ignores, filePath, relativeFilePath)) {</span>
			<span class="s1">debug(`Ignoring ${filePath} based on file pattern`);</span>

			<span class="s3">// cache and return result - finalConfig is undefined at this point</span>
			<span class="s1">cache.set(filePath, finalConfig);</span>
			<span class="s2">return </span><span class="s1">finalConfig;</span>
		<span class="s1">}</span>

		<span class="s3">// filePath isn't automatically ignored, so try to construct config</span>

		<span class="s1">const matchingConfigIndices = [];</span>
		<span class="s1">let matchFound = </span><span class="s2">false</span><span class="s1">;</span>
		<span class="s1">const universalPattern = /\/\*{</span><span class="s4">1</span><span class="s1">,</span><span class="s4">2</span><span class="s1">}$/;</span>

		<span class="s2">this</span><span class="s1">.forEach((config, index) =&gt; {</span>

			<span class="s2">if </span><span class="s1">(!config.files) {</span>

				<span class="s2">if </span><span class="s1">(!config.ignores) {</span>
					<span class="s1">debug(`Anonymous universal config found </span><span class="s2">for </span><span class="s1">${filePath}`);</span>
					<span class="s1">matchingConfigIndices.push(index);</span>
					<span class="s2">return</span><span class="s1">;</span>
				<span class="s1">}</span>

				<span class="s2">if </span><span class="s1">(pathMatchesIgnores(filePath, </span><span class="s2">this</span><span class="s1">.basePath, config)) {</span>
					<span class="s1">debug(`Matching config found </span><span class="s2">for </span><span class="s1">${filePath} (based on ignores: ${config.ignores})`);</span>
					<span class="s1">matchingConfigIndices.push(index);</span>
					<span class="s2">return</span><span class="s1">;</span>
				<span class="s1">}</span>
				
				<span class="s1">debug(`Skipped config found </span><span class="s2">for </span><span class="s1">${filePath} (based on ignores: ${config.ignores})`);</span>
				<span class="s2">return</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s1">assertNonEmptyFilesArray(config);</span>

			<span class="s3">/* 
             * If a config has a files pattern ending in /** or /*, and the 
             * filePath only matches those patterns, then the config is only 
             * applied if there is another config where the filePath matches 
             * a file with a specific extensions such as *.js. 
             */</span>

			<span class="s1">const universalFiles = config.files.filter(</span>
				<span class="s1">pattern =&gt; universalPattern.test(pattern)</span>
			<span class="s1">);</span>

			<span class="s3">// universal patterns were found so we need to check the config twice</span>
			<span class="s2">if </span><span class="s1">(universalFiles.length) {</span>

				<span class="s1">debug(</span><span class="s0">'Universal files patterns found. Checking carefully.'</span><span class="s1">);</span>

				<span class="s1">const nonUniversalFiles = config.files.filter(</span>
					<span class="s1">pattern =&gt; !universalPattern.test(pattern)</span>
				<span class="s1">);</span>

				<span class="s3">// check that the config matches without the non-universal files first</span>
				<span class="s2">if </span><span class="s1">(</span>
					<span class="s1">nonUniversalFiles.length &amp;&amp; </span>
					<span class="s1">pathMatches(</span>
						<span class="s1">filePath, </span><span class="s2">this</span><span class="s1">.basePath,</span>
						<span class="s1">{ files: nonUniversalFiles, ignores: config.ignores }</span>
					<span class="s1">)</span>
				<span class="s1">) {</span>
					<span class="s1">debug(`Matching config found </span><span class="s2">for </span><span class="s1">${filePath}`);</span>
					<span class="s1">matchingConfigIndices.push(index);</span>
					<span class="s1">matchFound = </span><span class="s2">true</span><span class="s1">;</span>
					<span class="s2">return</span><span class="s1">;</span>
				<span class="s1">}</span>

				<span class="s3">// if there wasn't a match then check if it matches with universal files</span>
				<span class="s2">if </span><span class="s1">(</span>
					<span class="s1">universalFiles.length &amp;&amp;</span>
					<span class="s1">pathMatches(</span>
						<span class="s1">filePath, </span><span class="s2">this</span><span class="s1">.basePath,</span>
						<span class="s1">{ files: universalFiles, ignores: config.ignores }</span>
					<span class="s1">)</span>
				<span class="s1">) {</span>
					<span class="s1">debug(`Matching config found </span><span class="s2">for </span><span class="s1">${filePath}`);</span>
					<span class="s1">matchingConfigIndices.push(index);</span>
					<span class="s2">return</span><span class="s1">;</span>
				<span class="s1">}</span>

				<span class="s3">// if we make here, then there was no match</span>
				<span class="s2">return</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s3">// the normal case</span>
			<span class="s2">if </span><span class="s1">(pathMatches(filePath, </span><span class="s2">this</span><span class="s1">.basePath, config)) {</span>
				<span class="s1">debug(`Matching config found </span><span class="s2">for </span><span class="s1">${filePath}`);</span>
				<span class="s1">matchingConfigIndices.push(index);</span>
				<span class="s1">matchFound = </span><span class="s2">true</span><span class="s1">;</span>
				<span class="s2">return</span><span class="s1">;</span>
			<span class="s1">}</span>

		<span class="s1">});</span>

		<span class="s3">// if matching both files and ignores, there will be no config to create</span>
		<span class="s2">if </span><span class="s1">(!matchFound) {</span>
			<span class="s1">debug(`No matching configs found </span><span class="s2">for </span><span class="s1">${filePath}`);</span>

			<span class="s3">// cache and return result - finalConfig is undefined at this point</span>
			<span class="s1">cache.set(filePath, finalConfig);</span>
			<span class="s2">return </span><span class="s1">finalConfig;</span>
		<span class="s1">}</span>

		<span class="s3">// check to see if there is a config cached by indices</span>
		<span class="s1">finalConfig = cache.get(matchingConfigIndices.toString());</span>

		<span class="s2">if </span><span class="s1">(finalConfig) {</span>

			<span class="s3">// also store for filename for faster lookup next time</span>
			<span class="s1">cache.set(filePath, finalConfig);</span>

			<span class="s2">return </span><span class="s1">finalConfig;</span>
		<span class="s1">}</span>

		<span class="s3">// otherwise construct the config</span>

		<span class="s1">finalConfig = matchingConfigIndices.reduce((result, index) =&gt; {</span>
			<span class="s2">return this</span><span class="s1">[ConfigArraySymbol.schema].merge(result, </span><span class="s2">this</span><span class="s1">[index]);</span>
		<span class="s1">}, {}, </span><span class="s2">this</span><span class="s1">);</span>

		<span class="s1">finalConfig = </span><span class="s2">this</span><span class="s1">[ConfigArraySymbol.finalizeConfig](finalConfig);</span>

		<span class="s1">cache.set(filePath, finalConfig);</span>
		<span class="s1">cache.set(matchingConfigIndices.toString(), finalConfig);</span>

		<span class="s2">return </span><span class="s1">finalConfig;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Determines if the given filepath is ignored based on the configs. 
     * @param {string} filePath The complete path of a file to check. 
     * @returns {boolean} True if the path is ignored, false if not. 
     * @deprecated Use `isFileIgnored` instead. 
     */</span>
	<span class="s1">isIgnored(filePath) {</span>
		<span class="s2">return this</span><span class="s1">.isFileIgnored(filePath);</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Determines if the given filepath is ignored based on the configs. 
     * @param {string} filePath The complete path of a file to check. 
     * @returns {boolean} True if the path is ignored, false if not. 
     */</span>
	<span class="s1">isFileIgnored(filePath) {</span>
		<span class="s2">return this</span><span class="s1">.getConfig(filePath) === undefined;</span>
	<span class="s1">}</span>

	<span class="s3">/** 
     * Determines if the given directory is ignored based on the configs. 
     * This checks only default `ignores` that don't have `files` in the  
     * same config. A pattern such as `/foo` be considered to ignore the directory 
     * while a pattern such as `/foo/**` is not considered to ignore the 
     * directory because it is matching files. 
     * @param {string} directoryPath The complete path of a directory to check. 
     * @returns {boolean} True if the directory is ignored, false if not. Will 
     *      return true for any directory that is not inside of `basePath`. 
     * @throws {Error} When the `ConfigArray` is not normalized. 
     */</span>
	<span class="s1">isDirectoryIgnored(directoryPath) {</span>

		<span class="s1">assertNormalized(</span><span class="s2">this</span><span class="s1">);</span>

		<span class="s1">const relativeDirectoryPath = path.relative(</span><span class="s2">this</span><span class="s1">.basePath, directoryPath)</span>
			<span class="s1">.replace(/\\/g, </span><span class="s0">'/'</span><span class="s1">);</span>

		<span class="s2">if </span><span class="s1">(relativeDirectoryPath.startsWith(</span><span class="s0">'..'</span><span class="s1">)) {</span>
			<span class="s2">return true</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s3">// first check the cache</span>
		<span class="s1">const cache = dataCache.get(</span><span class="s2">this</span><span class="s1">).directoryMatches;</span>

		<span class="s2">if </span><span class="s1">(cache.has(relativeDirectoryPath)) {</span>
			<span class="s2">return </span><span class="s1">cache.get(relativeDirectoryPath);</span>
		<span class="s1">}</span>

		<span class="s1">const directoryParts = relativeDirectoryPath.split(</span><span class="s0">'/'</span><span class="s1">);</span>
		<span class="s1">let relativeDirectoryToCheck = </span><span class="s0">''</span><span class="s1">;</span>
		<span class="s1">let result = </span><span class="s2">false</span><span class="s1">;</span>

		<span class="s3">/* 
         * In order to get the correct gitignore-style ignores, where an 
         * ignored parent directory cannot have any descendants unignored, 
         * we need to check every directory starting at the parent all 
         * the way down to the actual requested directory. 
         *  
         * We aggressively cache all of this info to make sure we don't 
         * have to recalculate everything for every call. 
         */</span>
		<span class="s2">do </span><span class="s1">{</span>

			<span class="s1">relativeDirectoryToCheck += directoryParts.shift() + </span><span class="s0">'/'</span><span class="s1">;</span>

			<span class="s1">result = shouldIgnorePath(</span>
				<span class="s2">this</span><span class="s1">.ignores,</span>
				<span class="s1">path.join(</span><span class="s2">this</span><span class="s1">.basePath, relativeDirectoryToCheck),</span>
				<span class="s1">relativeDirectoryToCheck</span>
			<span class="s1">);</span>

			<span class="s1">cache.set(relativeDirectoryToCheck, result);</span>

		<span class="s1">} </span><span class="s2">while </span><span class="s1">(!result &amp;&amp; directoryParts.length);</span>

		<span class="s3">// also cache the result for the requested path</span>
		<span class="s1">cache.set(relativeDirectoryPath, result);</span>

		<span class="s2">return </span><span class="s1">result;</span>
	<span class="s1">}</span>

<span class="s1">}</span>

<span class="s1">exports.ConfigArray = ConfigArray;</span>
<span class="s1">exports.ConfigArraySymbol = ConfigArraySymbol;</span>
</pre>
</body>
</html>
<html>
<head>
<title>RCTSurfacePointerHandler.mm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
.s6 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
RCTSurfacePointerHandler.mm</font>
</center></td></tr></table>
<pre><span class="s0">/* 
 * Copyright (c) Meta Platforms, Inc. and affiliates. 
 * 
 * This source code is licensed under the MIT license found in the 
 * LICENSE file in the root directory of this source tree. 
 */</span>

<span class="s2">#import </span><span class="s3">&quot;RCTSurfacePointerHandler.h&quot;</span>

<span class="s2">#import </span><span class="s3">&lt;React/RCTIdentifierPool.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTReactTaggedView.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTUtils.h&gt;</span>
<span class="s2">#import </span><span class="s3">&lt;React/RCTViewComponentView.h&gt;</span>

<span class="s2">#import </span><span class="s3">&quot;RCTConversions.h&quot;</span>
<span class="s2">#import </span><span class="s3">&quot;RCTTouchableComponentViewProtocol.h&quot;</span>

<span class="s4">using namespace </span><span class="s1">facebook::react</span><span class="s4">;</span>

<span class="s4">typedef </span><span class="s1">NS_ENUM(NSInteger</span><span class="s4">, </span><span class="s1">RCTPointerEventType) {</span>
  <span class="s1">RCTPointerEventTypeStart</span><span class="s4">,</span>
  <span class="s1">RCTPointerEventTypeMove</span><span class="s4">,</span>
  <span class="s1">RCTPointerEventTypeEnd</span><span class="s4">,</span>
  <span class="s1">RCTPointerEventTypeCancel</span><span class="s4">,</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">struct </span><span class="s1">ActivePointer {</span>
  <span class="s0">/* 
   * Pointer ID 
   */</span>
  <span class="s1">NSInteger identifier</span><span class="s4">;</span>

  <span class="s0">/* 
   * The component view on which the touch started. 
   */</span>
  <span class="s1">UIView&lt;RCTComponentViewProtocol&gt; *initialComponentView = nil</span><span class="s4">;</span>

  <span class="s0">/* 
   * The current target component view of the pointer 
   */</span>
  <span class="s1">UIView&lt;RCTComponentViewProtocol&gt; *componentView = nil</span><span class="s4">;</span>

  <span class="s0">/* 
   * The location of the pointer relative to the root component view 
   */</span>
  <span class="s1">CGPoint clientPoint</span><span class="s4">;</span>

  <span class="s0">/* 
   * The location of the pointer relative to the device's screen 
   */</span>
  <span class="s1">CGPoint screenPoint</span><span class="s4">;</span>

  <span class="s0">/* 
   * The location of the pointer relative to the pointer's target 
   */</span>
  <span class="s1">CGPoint offsetPoint</span><span class="s4">;</span>

  <span class="s0">/* 
   * Current timestamp of the pointer event 
   */</span>
  <span class="s1">NSTimeInterval timestamp</span><span class="s4">;</span>

  <span class="s0">/* 
   * The current force of the pointer 
   */</span>
  <span class="s1">Float force</span><span class="s4">;</span>

  <span class="s0">/* 
   * The type of touch received. 
   */</span>
  <span class="s1">UITouchType touchType</span><span class="s4">;</span>

  <span class="s0">/* 
   * The radius (in points) of the touch. 
   */</span>
  <span class="s1">CGFloat majorRadius</span><span class="s4">;</span>

  <span class="s0">/* 
   * The altitude (in radians) of the stylus. 
   */</span>
  <span class="s1">CGFloat altitudeAngle</span><span class="s4">;</span>

  <span class="s0">/* 
   * The azimuth angle (in radians) of the stylus. 
   */</span>
  <span class="s1">CGFloat azimuthAngle</span><span class="s4">;</span>

  <span class="s0">/* 
   * The button mask of the touch 
   */</span>
  <span class="s1">UIEventButtonMask buttonMask</span><span class="s4">;</span>

  <span class="s0">/* 
   * The bit mask of modifier flags in the gesture represented by the receiver. 
   */</span>
  <span class="s1">UIKeyModifierFlags modifierFlags</span><span class="s4">;</span>

  <span class="s0">/* 
   * Indicates if the active touch represents the primary pointer of this pointer type. 
   */</span>
  <span class="s1">BOOL isPrimary</span><span class="s4">;</span>

  <span class="s0">/* 
   * The button number that was pressed (if applicable) when the event was fired. 
   */</span>
  <span class="s1">NSInteger button</span><span class="s4">;</span>

  <span class="s0">/* 
   * Informs the event system that when the touch is released it should be treated as the 
   * pointer leaving the screen entirely. 
   */</span>
  <span class="s1">BOOL shouldLeaveWhenReleased</span><span class="s4">;</span>

  <span class="s4">struct </span><span class="s1">Hasher {</span>
    <span class="s1">size_t </span><span class="s4">operator</span><span class="s1">()(</span><span class="s4">const </span><span class="s1">ActivePointer &amp;activePointer) </span><span class="s4">const</span>
    <span class="s1">{</span>
      <span class="s4">return </span><span class="s1">std::hash&lt;</span><span class="s4">decltype</span><span class="s1">(activePointer.identifier)&gt;()(activePointer.identifier)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>

  <span class="s4">struct </span><span class="s1">Comparator {</span>
    <span class="s4">bool operator</span><span class="s1">()(</span><span class="s4">const </span><span class="s1">ActivePointer &amp;lhs</span><span class="s4">, const </span><span class="s1">ActivePointer &amp;rhs) </span><span class="s4">const</span>
    <span class="s1">{</span>
      <span class="s4">return </span><span class="s1">lhs.identifier == rhs.identifier</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s4">;</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s0">// Mouse and Pen pointers get reserved IDs so they stay consistent no matter the order</span>
<span class="s0">// at which events come in</span>
<span class="s4">static </span><span class="s1">NSInteger </span><span class="s4">constexpr </span><span class="s1">kMousePointerId = </span><span class="s5">0</span><span class="s4">;</span>
<span class="s4">static </span><span class="s1">NSInteger </span><span class="s4">constexpr </span><span class="s1">kPencilPointerId = </span><span class="s5">1</span><span class="s4">;</span>

<span class="s0">// If a new reserved ID is added above this should be incremented to ensure touch events</span>
<span class="s0">// do not conflict</span>
<span class="s4">static </span><span class="s1">NSInteger </span><span class="s4">constexpr </span><span class="s1">kTouchIdentifierPoolOffset = </span><span class="s5">2</span><span class="s4">;</span>

<span class="s4">static </span><span class="s1">SharedTouchEventEmitter GetTouchEmitterFromView(UIView *componentView</span><span class="s4">, </span><span class="s1">CGPoint point)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">[(id&lt;RCTTouchableComponentViewProtocol&gt;)componentView touchEventEmitterAtPoint:point]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSOrderedSet&lt;RCTReactTaggedView *&gt; *GetTouchableViewsInPathToRoot(UIView *componentView)</span>
<span class="s1">{</span>
  <span class="s1">NSMutableOrderedSet *results = [NSMutableOrderedSet orderedSet]</span><span class="s4">;</span>
  <span class="s4">do </span><span class="s1">{</span>
    <span class="s4">if </span><span class="s1">([componentView respondsToSelector:</span><span class="s4">@selector</span><span class="s1">(touchEventEmitterAtPoint:)]) {</span>
      <span class="s1">[results addObject:[RCTReactTaggedView wrap:componentView]]</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">componentView = componentView.superview</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">while </span><span class="s1">(componentView)</span><span class="s4">;</span>
  <span class="s4">return </span><span class="s1">results</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">UIView *FindClosestFabricManagedTouchableView(UIView *componentView)</span>
<span class="s1">{</span>
  <span class="s4">while </span><span class="s1">(componentView) {</span>
    <span class="s4">if </span><span class="s1">([componentView respondsToSelector:</span><span class="s4">@selector</span><span class="s1">(touchEventEmitterAtPoint:)]) {</span>
      <span class="s4">return </span><span class="s1">componentView</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">componentView = componentView.superview</span><span class="s4">;</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">nil</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSInteger ButtonMaskDiffToButton(UIEventButtonMask prevButtonMask</span><span class="s4">, </span><span class="s1">UIEventButtonMask curButtonMask)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s4">if </span><span class="s1">((prevButtonMask &amp; UIEventButtonMaskPrimary) != (curButtonMask &amp; UIEventButtonMaskPrimary)) {</span>
      <span class="s4">return </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">((prevButtonMask &amp; </span><span class="s5">0x4</span><span class="s1">) != (curButtonMask &amp; </span><span class="s5">0x4</span><span class="s1">)) {</span>
      <span class="s4">return </span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">((prevButtonMask &amp; UIEventButtonMaskSecondary) != (curButtonMask &amp; UIEventButtonMaskSecondary)) {</span>
      <span class="s4">return </span><span class="s5">2</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">-</span><span class="s5">1</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">// Returns a CGPoint which represents the tiltX/Y values (in RADIANS)</span>
<span class="s0">// Adapted from https://gist.github.com/k3a/2903719bb42b48c9198d20c2d6f73ac1</span>
<span class="s4">static </span><span class="s1">CGPoint SphericalToTilt(CGFloat altitudeAngleRad</span><span class="s4">, </span><span class="s1">CGFloat azimuthAngleRad)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(altitudeAngleRad == M_PI / </span><span class="s5">2.0</span><span class="s1">) {</span>
    <span class="s4">return </span><span class="s1">CGPointMake(</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else if </span><span class="s1">(altitudeAngleRad == </span><span class="s5">0.0</span><span class="s1">) {</span>
    <span class="s0">// when pen is laying on the pad it is impossible to precisely encode but at least approximate for 4 cases</span>
    <span class="s4">if </span><span class="s1">(azimuthAngleRad &gt; </span><span class="s5">7.0 </span><span class="s1">* M_PI / </span><span class="s5">4.0 </span><span class="s1">|| azimuthAngleRad &lt;= M_PI / </span><span class="s5">4.0</span><span class="s1">) {</span>
      <span class="s0">// for azimuthRad == 0, the pen is on the positive Y axis</span>
      <span class="s4">return </span><span class="s1">CGPointMake(</span><span class="s5">0.0</span><span class="s4">, </span><span class="s1">M_PI / </span><span class="s5">2.0</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(azimuthAngleRad &gt; M_PI / </span><span class="s5">4.0 </span><span class="s1">&amp;&amp; azimuthAngleRad &lt;= </span><span class="s5">3 </span><span class="s1">* M_PI / </span><span class="s5">4.0</span><span class="s1">) {</span>
      <span class="s0">// for azimuthRad == math.pi/2 the pen is on the positive X axis</span>
      <span class="s4">return </span><span class="s1">CGPointMake(M_PI / </span><span class="s5">2.0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(azimuthAngleRad &gt; </span><span class="s5">3.0 </span><span class="s1">* M_PI / </span><span class="s5">4.0 </span><span class="s1">&amp;&amp; azimuthAngleRad &lt;= </span><span class="s5">5.0 </span><span class="s1">* M_PI / </span><span class="s5">4.0</span><span class="s1">) {</span>
      <span class="s0">// for azimuthRad == math.pi, the pen is on the negative Y axis</span>
      <span class="s4">return </span><span class="s1">CGPointMake(</span><span class="s5">0.0</span><span class="s4">, </span><span class="s1">-M_PI / </span><span class="s5">2.0</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(azimuthAngleRad &gt; </span><span class="s5">5.0 </span><span class="s1">* M_PI / </span><span class="s5">4.0 </span><span class="s1">&amp;&amp; azimuthAngleRad &lt;= </span><span class="s5">7.0 </span><span class="s1">* M_PI / </span><span class="s5">4.0</span><span class="s1">) {</span>
      <span class="s0">// for azimuthRad == math.pi + math.pi/2 pen on negative X axis</span>
      <span class="s4">return </span><span class="s1">CGPointMake(-M_PI / </span><span class="s5">2.0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">CGFloat tanAlt = tan(altitudeAngleRad)</span><span class="s4">; </span><span class="s0">// tan(x) = sin(x)/cos(x)</span>

  <span class="s1">CGFloat tiltXrad = atan(sin(azimuthAngleRad) / tanAlt)</span><span class="s4">;</span>
  <span class="s1">CGFloat tiltYrad = atan(cos(azimuthAngleRad) / tanAlt)</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">CGPointMake(tiltXrad</span><span class="s4">, </span><span class="s1">tiltYrad)</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">CGFloat RadsToDegrees(CGFloat rads)</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">rads * </span><span class="s5">180 </span><span class="s1">/ M_PI</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">NSInteger ButtonMaskToButtons(UIEventButtonMask buttonMask)</span>
<span class="s1">{</span>
  <span class="s1">NSInteger buttonsMaskResult = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s4">if </span><span class="s1">((buttonMask &amp; UIEventButtonMaskPrimary) != </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">buttonsMaskResult |= </span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s4">if </span><span class="s1">((buttonMask &amp; UIEventButtonMaskSecondary) != </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">buttonsMaskResult |= </span><span class="s5">2</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s0">// undocumented mask value which represents the &quot;auxiliary button&quot; (i.e. middle mouse button)</span>
    <span class="s4">if </span><span class="s1">((buttonMask &amp; </span><span class="s5">0x4</span><span class="s1">) != </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">buttonsMaskResult |= </span><span class="s5">4</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">buttonsMaskResult</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static const char </span><span class="s1">*PointerTypeCStringFromUITouchType(UITouchType type)</span>
<span class="s1">{</span>
  <span class="s4">switch </span><span class="s1">(type) {</span>
    <span class="s4">case </span><span class="s1">UITouchTypeDirect:</span>
      <span class="s4">return </span><span class="s3">&quot;touch&quot;</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">UITouchTypePencil:</span>
      <span class="s4">return </span><span class="s3">&quot;pen&quot;</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">UITouchTypeIndirectPointer:</span>
      <span class="s4">return </span><span class="s3">&quot;mouse&quot;</span><span class="s4">;</span>
    <span class="s4">case </span><span class="s1">UITouchTypeIndirect:</span>
    <span class="s4">default</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">UpdatePointerEventModifierFlags(PointerEvent &amp;event</span><span class="s4">, </span><span class="s1">UIKeyModifierFlags flags)</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s1">event.ctrlKey = (flags &amp; UIKeyModifierControl) != </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">event.shiftKey = (flags &amp; UIKeyModifierShift) != </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">event.altKey = (flags &amp; UIKeyModifierAlternate) != </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">event.metaKey = (flags &amp; UIKeyModifierCommand) != </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">event.ctrlKey = </span><span class="s4">false;</span>
    <span class="s1">event.shiftKey = </span><span class="s4">false;</span>
    <span class="s1">event.altKey = </span><span class="s4">false;</span>
    <span class="s1">event.metaKey = </span><span class="s4">false;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">PointerEvent CreatePointerEventFromActivePointer(</span>
    <span class="s1">ActivePointer activePointer</span><span class="s4">,</span>
    <span class="s1">RCTPointerEventType eventType</span><span class="s4">,</span>
    <span class="s1">UIView *rootComponentView)</span>
<span class="s1">{</span>
  <span class="s1">PointerEvent event = {}</span><span class="s4">;</span>
  <span class="s1">event.pointerId = activePointer.identifier</span><span class="s4">;</span>
  <span class="s1">event.pointerType = PointerTypeCStringFromUITouchType(activePointer.touchType)</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(eventType == RCTPointerEventTypeCancel) {</span>
    <span class="s1">event.clientPoint = RCTPointFromCGPoint(CGPointZero)</span><span class="s4">;</span>
    <span class="s1">event.screenPoint =</span>
        <span class="s1">RCTPointFromCGPoint([rootComponentView convertPoint:CGPointZero</span>
                                          <span class="s1">toCoordinateSpace:rootComponentView.window.screen.coordinateSpace])</span><span class="s4">;</span>
    <span class="s1">event.offsetPoint = RCTPointFromCGPoint([rootComponentView convertPoint:CGPointZero</span>
                                                                     <span class="s1">toView:activePointer.componentView])</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">event.clientPoint = RCTPointFromCGPoint(activePointer.clientPoint)</span><span class="s4">;</span>
    <span class="s1">event.screenPoint = RCTPointFromCGPoint(activePointer.screenPoint)</span><span class="s4">;</span>
    <span class="s1">event.offsetPoint = RCTPointFromCGPoint(activePointer.offsetPoint)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">event.pressure = activePointer.force</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s4">if </span><span class="s1">(activePointer.touchType == UITouchTypeIndirectPointer) {</span>
      <span class="s0">// pointer events with a mouse button pressed should report a pressure of 0.5</span>
      <span class="s0">// when the touch is down and 0.0 when it is lifted regardless of how it is reported by the OS</span>
      <span class="s1">event.pressure = eventType != RCTPointerEventTypeEnd ? </span><span class="s5">0.5 </span><span class="s1">: </span><span class="s5">0.0</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">CGFloat pointerSize = activePointer.majorRadius * </span><span class="s5">2.0</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s4">if </span><span class="s1">(activePointer.touchType == UITouchTypeIndirectPointer) {</span>
      <span class="s0">// mouse type pointers should always report a size of 1</span>
      <span class="s1">pointerSize = </span><span class="s5">1.0</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">event.width = pointerSize</span><span class="s4">;</span>
  <span class="s1">event.height = pointerSize</span><span class="s4">;</span>

  <span class="s1">CGPoint tilt = SphericalToTilt(activePointer.altitudeAngle</span><span class="s4">, </span><span class="s1">activePointer.azimuthAngle)</span><span class="s4">;</span>
  <span class="s1">event.tiltX = RadsToDegrees(tilt.x)</span><span class="s4">;</span>
  <span class="s1">event.tiltY = RadsToDegrees(tilt.y)</span><span class="s4">;</span>

  <span class="s1">event.detail = </span><span class="s5">0</span><span class="s4">;</span>

  <span class="s1">event.button = activePointer.button</span><span class="s4">;</span>
  <span class="s1">event.buttons = ButtonMaskToButtons(activePointer.buttonMask)</span><span class="s4">;</span>

  <span class="s1">UpdatePointerEventModifierFlags(event</span><span class="s4">, </span><span class="s1">activePointer.modifierFlags)</span><span class="s4">;</span>

  <span class="s1">event.tangentialPressure = </span><span class="s5">0.0</span><span class="s4">;</span>
  <span class="s1">event.twist = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">event.isPrimary = activePointer.isPrimary</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">event</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">PointerEvent CreatePointerEventFromIncompleteHoverData(</span>
    <span class="s1">NSInteger pointerId</span><span class="s4">,</span>
    <span class="s1">std::string pointerType</span><span class="s4">,</span>
    <span class="s1">CGPoint clientLocation</span><span class="s4">,</span>
    <span class="s1">CGPoint screenLocation</span><span class="s4">,</span>
    <span class="s1">CGPoint offsetLocation</span><span class="s4">,</span>
    <span class="s1">UIKeyModifierFlags modifierFlags)</span>
<span class="s1">{</span>
  <span class="s1">PointerEvent event = {}</span><span class="s4">;</span>
  <span class="s1">event.pointerId = pointerId</span><span class="s4">;</span>
  <span class="s1">event.pressure = </span><span class="s5">0.0</span><span class="s4">;</span>
  <span class="s1">event.pointerType = pointerType</span><span class="s4">;</span>
  <span class="s1">event.clientPoint = RCTPointFromCGPoint(clientLocation)</span><span class="s4">;</span>
  <span class="s1">event.screenPoint = RCTPointFromCGPoint(screenLocation)</span><span class="s4">;</span>
  <span class="s1">event.offsetPoint = RCTPointFromCGPoint(offsetLocation)</span><span class="s4">;</span>
  <span class="s1">event.width = </span><span class="s5">1.0</span><span class="s4">;</span>
  <span class="s1">event.height = </span><span class="s5">1.0</span><span class="s4">;</span>
  <span class="s1">event.tiltX = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">event.tiltY = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">event.detail = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">event.button = -</span><span class="s5">1</span><span class="s4">;</span>
  <span class="s1">event.buttons = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">UpdatePointerEventModifierFlags(event</span><span class="s4">, </span><span class="s1">modifierFlags)</span><span class="s4">;</span>
  <span class="s1">event.tangentialPressure = </span><span class="s5">0.0</span><span class="s4">;</span>
  <span class="s1">event.twist = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">event.isPrimary = </span><span class="s4">true;</span>

  <span class="s4">return </span><span class="s1">event</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static void </span><span class="s1">UpdateActivePointerWithUITouch(</span>
    <span class="s1">ActivePointer &amp;activePointer</span><span class="s4">,</span>
    <span class="s1">UITouch *uiTouch</span><span class="s4">,</span>
    <span class="s1">UIEvent *uiEvent</span><span class="s4">,</span>
    <span class="s1">UIView *rootComponentView)</span>
<span class="s1">{</span>
  <span class="s1">activePointer.componentView = FindClosestFabricManagedTouchableView(uiTouch.view)</span><span class="s4">;</span>

  <span class="s1">activePointer.clientPoint = [uiTouch locationInView:rootComponentView]</span><span class="s4">;</span>
  <span class="s1">activePointer.screenPoint = [rootComponentView convertPoint:activePointer.clientPoint</span>
                                            <span class="s1">toCoordinateSpace:rootComponentView.window.screen.coordinateSpace]</span><span class="s4">;</span>
  <span class="s1">activePointer.offsetPoint = [uiTouch locationInView:activePointer.componentView]</span><span class="s4">;</span>

  <span class="s1">activePointer.timestamp = uiTouch.timestamp</span><span class="s4">;</span>

  <span class="s1">activePointer.force = RCTZeroIfNaN(uiTouch.force / uiTouch.maximumPossibleForce)</span><span class="s4">;</span>

  <span class="s1">activePointer.touchType = uiTouch.type</span><span class="s4">;</span>
  <span class="s1">activePointer.majorRadius = uiTouch.majorRadius</span><span class="s4">;</span>
  <span class="s1">activePointer.altitudeAngle = uiTouch.altitudeAngle</span><span class="s4">;</span>
  <span class="s1">activePointer.azimuthAngle = [uiTouch azimuthAngleInView:nil]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(ios </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s1">UIEventButtonMask nextButtonMask = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(uiTouch.phase != UITouchPhaseEnded) {</span>
      <span class="s1">nextButtonMask = uiTouch.type == UITouchTypeIndirectPointer ? uiEvent.buttonMask : </span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">activePointer.button = ButtonMaskDiffToButton(activePointer.buttonMask</span><span class="s4">, </span><span class="s1">nextButtonMask)</span><span class="s4">;</span>
    <span class="s1">activePointer.buttonMask = nextButtonMask</span><span class="s4">;</span>
    <span class="s1">activePointer.modifierFlags = uiEvent.modifierFlags</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">activePointer.button = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">activePointer.buttonMask = </span><span class="s5">0</span><span class="s4">;</span>
    <span class="s1">activePointer.modifierFlags = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">BOOL IsViewListeningToEvent(RCTReactTaggedView *taggedView</span><span class="s4">, </span><span class="s1">ViewEvents::Offset eventType)</span>
<span class="s1">{</span>
  <span class="s1">UIView *view = taggedView.view</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(view &amp;&amp; [view.</span><span class="s4">class </span><span class="s1">conformsToProtocol:</span><span class="s4">@protocol</span><span class="s1">(RCTComponentViewProtocol)]) {</span>
    <span class="s4">auto </span><span class="s1">props = ((id&lt;RCTComponentViewProtocol&gt;)view).props</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(SharedViewProps viewProps = std::dynamic_pointer_cast&lt;ViewProps </span><span class="s4">const</span><span class="s1">&gt;(props)) {</span>
      <span class="s4">return </span><span class="s1">viewProps-&gt;events[eventType]</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">static </span><span class="s1">BOOL IsAnyViewInPathListeningToEvent(NSOrderedSet&lt;RCTReactTaggedView *&gt; *viewPath</span><span class="s4">, </span><span class="s1">ViewEvents::Offset eventType)</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(RCTReactTaggedView *taggedView in viewPath) {</span>
    <span class="s4">if </span><span class="s1">(IsViewListeningToEvent(taggedView</span><span class="s4">, </span><span class="s1">eventType)) {</span>
      <span class="s4">return </span><span class="s1">YES</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Surprisingly, `__unsafe_unretained id` pointers are not regular pointers 
 * and `std::hash&lt;&gt;` cannot hash them. 
 * This is quite trivial but decent implementation of hasher function 
 * inspired by this research: https://stackoverflow.com/a/21062520/496389. 
 */</span>
<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">typename </span><span class="s1">PointerT&gt;</span>
<span class="s4">struct </span><span class="s1">PointerHasher {</span>
  <span class="s4">constexpr </span><span class="s1">std::size_t </span><span class="s4">operator</span><span class="s1">()(</span><span class="s4">const </span><span class="s1">PointerT &amp;value) </span><span class="s4">const</span>
  <span class="s1">{</span>
    <span class="s4">return reinterpret_cast</span><span class="s1">&lt;size_t&gt;(value)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s4">;</span>

<span class="s4">@interface </span><span class="s1">RCTSurfacePointerHandler () &lt;UIGestureRecognizerDelegate&gt;</span>
<span class="s4">@end</span>

<span class="s4">@implementation </span><span class="s1">RCTSurfacePointerHandler {</span>
  <span class="s1">std::unordered_map&lt;</span><span class="s4">__unsafe_unretained </span><span class="s1">UITouch *</span><span class="s4">, </span><span class="s1">ActivePointer</span><span class="s4">, </span><span class="s1">PointerHasher&lt;</span><span class="s4">__unsafe_unretained </span><span class="s1">UITouch *&gt;&gt;</span>
      <span class="s1">_activePointers</span><span class="s4">;</span>

  <span class="s0">/* 
   * We hold the view weakly to prevent a retain cycle. 
   */</span>
  <span class="s4">__weak </span><span class="s1">UIView *_rootComponentView</span><span class="s4">;</span>
  <span class="s1">RCTIdentifierPool&lt;</span><span class="s5">11</span><span class="s1">&gt; _identifierPool</span><span class="s4">;</span>

  <span class="s1">UIHoverGestureRecognizer *_mouseHoverRecognizer API_AVAILABLE(ios(</span><span class="s5">13.0</span><span class="s1">))</span><span class="s4">;</span>
  <span class="s1">UIHoverGestureRecognizer *_penHoverRecognizer API_AVAILABLE(ios(</span><span class="s5">13.0</span><span class="s1">))</span><span class="s4">;</span>

  <span class="s1">NSMutableDictionary&lt;NSNumber *</span><span class="s4">, </span><span class="s1">NSOrderedSet&lt;RCTReactTaggedView *&gt; *&gt; *_currentlyHoveredViewsPerPointer</span><span class="s4">;</span>

  <span class="s1">NSInteger _primaryTouchPointerId</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (instancetype)init</span>
<span class="s1">{</span>
  <span class="s4">if </span><span class="s1">(self = [super initWithTarget:nil action:nil]) {</span>
    <span class="s0">// `cancelsTouchesInView` and `delaysTouches*` are needed in order</span>
    <span class="s0">// to be used as a top level event delegated recognizer.</span>
    <span class="s0">// Otherwise, lower-level components not built using React Native,</span>
    <span class="s0">// will fail to recognize gestures.</span>
    <span class="s1">self.cancelsTouchesInView = NO</span><span class="s4">;</span>
    <span class="s1">self.delaysTouchesBegan = NO</span><span class="s4">; </span><span class="s0">// This is default value.</span>
    <span class="s1">self.delaysTouchesEnded = NO</span><span class="s4">;</span>

    <span class="s1">self.delegate = self</span><span class="s4">;</span>

    <span class="s1">_mouseHoverRecognizer = nil</span><span class="s4">;</span>
    <span class="s1">_penHoverRecognizer = nil</span><span class="s4">;</span>
    <span class="s1">_currentlyHoveredViewsPerPointer = [[NSMutableDictionary alloc] init]</span><span class="s4">;</span>
    <span class="s1">_primaryTouchPointerId = -</span><span class="s5">1</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">self</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">RCT_NOT_IMPLEMENTED(-(instancetype)initWithTarget : (id)target action : (SEL)action)</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)attachToView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s1">RCTAssert(self.view == nil</span><span class="s4">, @</span><span class="s3">&quot;RCTSurfacePointerHandler already has an attached view.&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">[view addGestureRecognizer:self]</span><span class="s4">;</span>
  <span class="s1">_rootComponentView = view</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s1">_mouseHoverRecognizer = [[UIHoverGestureRecognizer alloc] initWithTarget:self action:</span><span class="s4">@selector</span><span class="s1">(mouseHovering:)]</span><span class="s4">;</span>
    <span class="s1">_mouseHoverRecognizer.allowedTouchTypes = </span><span class="s4">@</span><span class="s1">[ </span><span class="s4">@</span><span class="s1">(UITouchTypeIndirectPointer) ]</span><span class="s4">;</span>
    <span class="s1">[view addGestureRecognizer:_mouseHoverRecognizer]</span><span class="s4">;</span>

    <span class="s1">_penHoverRecognizer = [[UIHoverGestureRecognizer alloc] initWithTarget:self action:</span><span class="s4">@selector</span><span class="s1">(penHovering:)]</span><span class="s4">;</span>
    <span class="s1">_penHoverRecognizer.allowedTouchTypes = </span><span class="s4">@</span><span class="s1">[ </span><span class="s4">@</span><span class="s1">(UITouchTypePencil) ]</span><span class="s4">;</span>
    <span class="s1">[view addGestureRecognizer:_penHoverRecognizer]</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)detachFromView:(UIView *)view</span>
<span class="s1">{</span>
  <span class="s1">RCTAssertParam(view)</span><span class="s4">;</span>
  <span class="s1">RCTAssert(self.view == view</span><span class="s4">, @</span><span class="s3">&quot;RCTSufracePointerHandler attached to another view.&quot;</span><span class="s1">)</span><span class="s4">;</span>

  <span class="s1">[view removeGestureRecognizer:self]</span><span class="s4">;</span>
  <span class="s1">_rootComponentView = nil</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(_mouseHoverRecognizer != nil) {</span>
    <span class="s1">[view removeGestureRecognizer:_mouseHoverRecognizer]</span><span class="s4">;</span>
    <span class="s1">_mouseHoverRecognizer = nil</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(_penHoverRecognizer != nil) {</span>
    <span class="s1">[view removeGestureRecognizer:_penHoverRecognizer]</span><span class="s4">;</span>
    <span class="s1">_penHoverRecognizer = nil</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - UITouch to ActivePointer management</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_registerTouches:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(UITouch *touch in touches) {</span>
    <span class="s1">ActivePointer activePointer = {}</span><span class="s4">;</span>

    <span class="s0">// Determine the identifier of the Pointer and if it is the primary pointer</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
      <span class="s4">switch </span><span class="s1">(touch.type) {</span>
        <span class="s4">case </span><span class="s1">UITouchTypeIndirectPointer:</span>
          <span class="s1">activePointer.identifier = kMousePointerId</span><span class="s4">;</span>
          <span class="s1">activePointer.isPrimary = </span><span class="s4">true;</span>
          <span class="s4">break;</span>
        <span class="s4">case </span><span class="s1">UITouchTypePencil:</span>
          <span class="s1">activePointer.identifier = kPencilPointerId</span><span class="s4">;</span>
          <span class="s1">activePointer.isPrimary = </span><span class="s4">true;</span>
          <span class="s4">break;</span>
        <span class="s4">default</span><span class="s1">:</span>
          <span class="s0">// use the identifier pool offset to ensure no conflicts between the reserved IDs and the</span>
          <span class="s0">// touch IDs</span>
          <span class="s1">activePointer.identifier = _identifierPool.dequeue() + kTouchIdentifierPoolOffset</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(_primaryTouchPointerId == -</span><span class="s5">1</span><span class="s1">) {</span>
            <span class="s1">_primaryTouchPointerId = activePointer.identifier</span><span class="s4">;</span>
            <span class="s1">activePointer.isPrimary = </span><span class="s4">true;</span>
          <span class="s1">}</span>
          <span class="s4">break;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">activePointer.identifier = _identifierPool.dequeue()</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(_primaryTouchPointerId == -</span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s1">_primaryTouchPointerId = activePointer.identifier</span><span class="s4">;</span>
        <span class="s1">activePointer.isPrimary = </span><span class="s4">true;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">// If the pointer has not been marked as hovering over views before the touch started, we register</span>
    <span class="s0">// that the activeTouch should not maintain its hovered state once the pointer has been lifted.</span>
    <span class="s4">auto </span><span class="s1">currentlyHoveredViews = [_currentlyHoveredViewsPerPointer objectForKey:</span><span class="s4">@</span><span class="s1">(activePointer.identifier)]</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(currentlyHoveredViews == nil || [currentlyHoveredViews count] == </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">activePointer.shouldLeaveWhenReleased = YES</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">UpdateActivePointerWithUITouch(activePointer</span><span class="s4">, </span><span class="s1">touch</span><span class="s4">, </span><span class="s1">event</span><span class="s4">, </span><span class="s1">_rootComponentView)</span><span class="s4">;</span>

    <span class="s1">_activePointers.emplace(touch</span><span class="s4">, </span><span class="s1">activePointer)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_updateTouches:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(UITouch *touch in touches) {</span>
    <span class="s4">auto </span><span class="s1">iterator = _activePointers.find(touch)</span><span class="s4">;</span>
    <span class="s1">RCTAssert(iterator != _activePointers.</span><span class="s4">end</span><span class="s1">()</span><span class="s4">, @</span><span class="s3">&quot;Inconsistency between local and UIKit touch registries&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(iterator == _activePointers.</span><span class="s4">end</span><span class="s1">()) {</span>
      <span class="s4">continue;</span>
    <span class="s1">}</span>
    <span class="s1">UpdateActivePointerWithUITouch(iterator-&gt;second</span><span class="s4">, </span><span class="s1">touch</span><span class="s4">, </span><span class="s1">event</span><span class="s4">, </span><span class="s1">_rootComponentView)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_unregisterTouches:(NSSet&lt;UITouch *&gt; *)touches</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(UITouch *touch in touches) {</span>
    <span class="s4">auto </span><span class="s1">iterator = _activePointers.find(touch)</span><span class="s4">;</span>
    <span class="s1">RCTAssert(iterator != _activePointers.</span><span class="s4">end</span><span class="s1">()</span><span class="s4">, @</span><span class="s3">&quot;Inconsistency between local and UIKit touch registries&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(iterator == _activePointers.</span><span class="s4">end</span><span class="s1">()) {</span>
      <span class="s4">continue;</span>
    <span class="s1">}</span>
    <span class="s4">auto </span><span class="s1">&amp;activePointer = iterator-&gt;second</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(activePointer.identifier == _primaryTouchPointerId) {</span>
      <span class="s1">_primaryTouchPointerId = -</span><span class="s5">1</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
      <span class="s0">// only need to enqueue if the touch type isn't one with a reserved identifier</span>
      <span class="s4">switch </span><span class="s1">(touch.type) {</span>
        <span class="s4">case </span><span class="s1">UITouchTypeIndirectPointer:</span>
        <span class="s4">case </span><span class="s1">UITouchTypePencil:</span>
          <span class="s4">break;</span>
        <span class="s4">default</span><span class="s1">:</span>
          <span class="s0">// since the touch's identifier has been offset we need to re-normalize it to 0-based</span>
          <span class="s0">// which is what the identifier pool expects</span>
          <span class="s1">_identifierPool.enqueue(activePointer.identifier - kTouchIdentifierPoolOffset)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">_identifierPool.enqueue(activePointer.identifier)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">_activePointers.erase(touch)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (std::vector&lt;ActivePointer&gt;)_activePointersFromTouches:(NSSet&lt;UITouch *&gt; *)touches</span>
<span class="s1">{</span>
  <span class="s1">std::vector&lt;ActivePointer&gt; activePointers</span><span class="s4">;</span>
  <span class="s1">activePointers.reserve(touches.count)</span><span class="s4">;</span>

  <span class="s4">for </span><span class="s1">(UITouch *touch in touches) {</span>
    <span class="s4">auto </span><span class="s1">iterator = _activePointers.find(touch)</span><span class="s4">;</span>
    <span class="s1">RCTAssert(iterator != _activePointers.</span><span class="s4">end</span><span class="s1">()</span><span class="s4">, @</span><span class="s3">&quot;Inconsistency between local and UIKit touch registries&quot;</span><span class="s1">)</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(iterator == _activePointers.</span><span class="s4">end</span><span class="s1">()) {</span>
      <span class="s4">continue;</span>
    <span class="s1">}</span>
    <span class="s1">activePointers.push_back(iterator-&gt;second)</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">activePointers</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)_dispatchActivePointers:(std::vector&lt;ActivePointer&gt;)activePointers eventType:(RCTPointerEventType)eventType</span>
<span class="s1">{</span>
  <span class="s4">for </span><span class="s1">(</span><span class="s4">const auto </span><span class="s1">&amp;activePointer : activePointers) {</span>
    <span class="s1">PointerEvent pointerEvent = CreatePointerEventFromActivePointer(activePointer</span><span class="s4">, </span><span class="s1">eventType</span><span class="s4">, </span><span class="s1">_rootComponentView)</span><span class="s4">;</span>
    <span class="s1">NSOrderedSet&lt;RCTReactTaggedView *&gt; *eventPathViews = [self handleIncomingPointerEvent:pointerEvent</span>
                                                                                   <span class="s1">onView:activePointer.componentView]</span><span class="s4">;</span>

    <span class="s1">SharedTouchEventEmitter eventEmitter = GetTouchEmitterFromView(</span>
        <span class="s1">activePointer.componentView</span><span class="s4">,</span>
        <span class="s1">[_rootComponentView convertPoint:activePointer.clientPoint toView:activePointer.componentView])</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(eventEmitter != nil) {</span>
      <span class="s4">switch </span><span class="s1">(eventType) {</span>
        <span class="s4">case </span><span class="s1">RCTPointerEventTypeStart: {</span>
          <span class="s1">eventEmitter-&gt;onPointerDown(pointerEvent)</span><span class="s4">;</span>
          <span class="s4">break;</span>
        <span class="s1">}</span>
        <span class="s4">case </span><span class="s1">RCTPointerEventTypeMove: {</span>
          <span class="s1">BOOL hasMoveEventListeners =</span>
              <span class="s1">IsAnyViewInPathListeningToEvent(eventPathViews</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerMove) ||</span>
              <span class="s1">IsAnyViewInPathListeningToEvent(eventPathViews</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerMoveCapture)</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(hasMoveEventListeners) {</span>
            <span class="s1">eventEmitter-&gt;onPointerMove(pointerEvent)</span><span class="s4">;</span>
          <span class="s1">}</span>
          <span class="s4">break;</span>
        <span class="s1">}</span>
        <span class="s4">case </span><span class="s1">RCTPointerEventTypeEnd: {</span>
          <span class="s1">eventEmitter-&gt;onPointerUp(pointerEvent)</span><span class="s4">;</span>
          <span class="s4">if </span><span class="s1">(activePointer.shouldLeaveWhenReleased) {</span>
            <span class="s1">[self handleIncomingPointerEvent:pointerEvent onView:nil]</span><span class="s4">;</span>
          <span class="s1">}</span>
          <span class="s4">break;</span>
        <span class="s1">}</span>
        <span class="s4">case </span><span class="s1">RCTPointerEventTypeCancel: {</span>
          <span class="s1">eventEmitter-&gt;onPointerCancel(pointerEvent)</span><span class="s4">;</span>
          <span class="s1">[self handleIncomingPointerEvent:pointerEvent onView:nil]</span><span class="s4">;</span>
          <span class="s4">break;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - </span><span class="s6">`</span><span class="s1">UIResponder</span><span class="s6">`</span><span class="s1">-ish touch-delivery methods</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s1">[super touchesBegan:touches withEvent:event]</span><span class="s4">;</span>

  <span class="s1">[self _registerTouches:touches withEvent:event]</span><span class="s4">;</span>
  <span class="s1">[self _dispatchActivePointers:[self _activePointersFromTouches:touches] eventType:RCTPointerEventTypeStart]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s1">[super touchesMoved:touches withEvent:event]</span><span class="s4">;</span>

  <span class="s1">[self _updateTouches:touches withEvent:event]</span><span class="s4">;</span>
  <span class="s1">[self _dispatchActivePointers:[self _activePointersFromTouches:touches] eventType:RCTPointerEventTypeMove]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s1">[super touchesEnded:touches withEvent:event]</span><span class="s4">;</span>

  <span class="s1">[self _updateTouches:touches withEvent:event]</span><span class="s4">;</span>
  <span class="s1">[self _dispatchActivePointers:[self _activePointersFromTouches:touches] eventType:RCTPointerEventTypeEnd]</span><span class="s4">;</span>
  <span class="s1">[self _unregisterTouches:touches]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span>
<span class="s1">{</span>
  <span class="s1">[super touchesCancelled:touches withEvent:event]</span><span class="s4">;</span>

  <span class="s1">[self _updateTouches:touches withEvent:event]</span><span class="s4">;</span>
  <span class="s1">[self _dispatchActivePointers:[self _activePointersFromTouches:touches] eventType:RCTPointerEventTypeCancel]</span><span class="s4">;</span>
  <span class="s1">[self _unregisterTouches:touches]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)reset</span>
<span class="s1">{</span>
  <span class="s1">[super reset]</span><span class="s4">;</span>

  <span class="s4">if </span><span class="s1">(!_activePointers.empty()) {</span>
    <span class="s1">std::vector&lt;ActivePointer&gt; activePointers</span><span class="s4">;</span>
    <span class="s1">activePointers.reserve(_activePointers.size())</span><span class="s4">;</span>

    <span class="s4">for </span><span class="s1">(</span><span class="s4">auto const </span><span class="s1">&amp;pair : _activePointers) {</span>
      <span class="s1">activePointers.push_back(pair.second)</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s1">[self _dispatchActivePointers:activePointers eventType:RCTPointerEventTypeCancel]</span><span class="s4">;</span>

    <span class="s0">// Force-unregistering all the pointers</span>
    <span class="s1">_activePointers.clear()</span><span class="s4">;</span>
    <span class="s1">_identifierPool.reset()</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">- (BOOL)canPreventGestureRecognizer:(UIGestureRecognizer *)preventedGestureRecognizer</span>
<span class="s1">{</span>
  <span class="s4">return </span><span class="s1">NO</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Hover callbacks</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)penHovering:(UIHoverGestureRecognizer *)recognizer API_AVAILABLE(ios(</span><span class="s5">13.0</span><span class="s1">))</span>
<span class="s1">{</span>
  <span class="s1">[self hovering:recognizer pointerId:kPencilPointerId pointerType:</span><span class="s3">&quot;pen&quot;</span><span class="s1">]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)mouseHovering:(UIHoverGestureRecognizer *)recognizer API_AVAILABLE(ios(</span><span class="s5">13.0</span><span class="s1">))</span>
<span class="s1">{</span>
  <span class="s1">[self hovering:recognizer pointerId:kMousePointerId pointerType:</span><span class="s3">&quot;mouse&quot;</span><span class="s1">]</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s1">- (</span><span class="s4">void</span><span class="s1">)hovering:(UIHoverGestureRecognizer *)recognizer</span>
       <span class="s1">pointerId:(</span><span class="s4">int</span><span class="s1">)pointerId</span>
     <span class="s1">pointerType:(std::string)pointerType API_AVAILABLE(ios(</span><span class="s5">13.0</span><span class="s1">))</span>
<span class="s1">{</span>
  <span class="s1">UIView *listenerView = recognizer.view</span><span class="s4">;</span>
  <span class="s1">CGPoint clientLocation = [recognizer locationInView:listenerView]</span><span class="s4">;</span>
  <span class="s1">CGPoint screenLocation = [listenerView convertPoint:clientLocation</span>
                                    <span class="s1">toCoordinateSpace:listenerView.window.screen.coordinateSpace]</span><span class="s4">;</span>

  <span class="s1">UIView *targetView = [listenerView hitTest:clientLocation withEvent:nil]</span><span class="s4">;</span>
  <span class="s1">targetView = FindClosestFabricManagedTouchableView(targetView)</span><span class="s4">;</span>

  <span class="s1">CGPoint offsetLocation = [recognizer locationInView:targetView]</span><span class="s4">;</span>

  <span class="s1">UIKeyModifierFlags modifierFlags</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(</span><span class="s4">@available</span><span class="s1">(iOS </span><span class="s5">13.4</span><span class="s4">, </span><span class="s1">*)) {</span>
    <span class="s1">modifierFlags = recognizer.modifierFlags</span><span class="s4">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">modifierFlags = </span><span class="s5">0</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">PointerEvent event = CreatePointerEventFromIncompleteHoverData(</span>
      <span class="s1">pointerId</span><span class="s4">, </span><span class="s1">pointerType</span><span class="s4">, </span><span class="s1">clientLocation</span><span class="s4">, </span><span class="s1">screenLocation</span><span class="s4">, </span><span class="s1">offsetLocation</span><span class="s4">, </span><span class="s1">modifierFlags)</span><span class="s4">;</span>

  <span class="s1">NSOrderedSet&lt;RCTReactTaggedView *&gt; *eventPathViews = [self handleIncomingPointerEvent:event onView:targetView]</span><span class="s4">;</span>
  <span class="s1">SharedTouchEventEmitter eventEmitter = GetTouchEmitterFromView(targetView</span><span class="s4">, </span><span class="s1">offsetLocation)</span><span class="s4">;</span>
  <span class="s1">BOOL hasMoveEventListeners = IsAnyViewInPathListeningToEvent(eventPathViews</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerMove) ||</span>
      <span class="s1">IsAnyViewInPathListeningToEvent(eventPathViews</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerMoveCapture)</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(eventEmitter != nil &amp;&amp; hasMoveEventListeners) {</span>
    <span class="s1">eventEmitter-&gt;onPointerMove(event)</span><span class="s4">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">#pragma </span><span class="s1">mark - Shared pointer handlers</span>

<span class="s0">/** 
 * Private method which is used for tracking the location of pointer events to manage the entering/leaving events. 
 * The primary idea is that a pointer's presence &amp; movement is dicated by a variety of underlying events such as down, 
 * move, and up — and they should all be treated the same when it comes to tracking the entering &amp; leaving of pointers 
 * to views. This method accomplishes that by receiving the pointer event, the target view (can be null in cases when 
 * the event indicates that the pointer has left the screen entirely), and a block/callback where the underlying event 
 * should be fired. 
 */</span>
<span class="s1">- (NSOrderedSet&lt;RCTReactTaggedView *&gt; *)handleIncomingPointerEvent:(PointerEvent)event</span>
                                                            <span class="s1">onView:(nullable UIView *)targetView</span>
<span class="s1">{</span>
  <span class="s1">NSInteger pointerId = event.pointerId</span><span class="s4">;</span>
  <span class="s1">CGPoint clientLocation = CGPointMake(event.clientPoint.x</span><span class="s4">, </span><span class="s1">event.clientPoint.y)</span><span class="s4">;</span>

  <span class="s1">NSOrderedSet&lt;RCTReactTaggedView *&gt; *currentlyHoveredViews =</span>
      <span class="s1">[_currentlyHoveredViewsPerPointer objectForKey:</span><span class="s4">@</span><span class="s1">(pointerId)]</span><span class="s4">;</span>
  <span class="s4">if </span><span class="s1">(currentlyHoveredViews == nil) {</span>
    <span class="s1">currentlyHoveredViews = [NSOrderedSet orderedSet]</span><span class="s4">;</span>
  <span class="s1">}</span>

  <span class="s1">RCTReactTaggedView *targetTaggedView = [RCTReactTaggedView wrap:targetView]</span><span class="s4">;</span>
  <span class="s1">RCTReactTaggedView *prevTargetTaggedView = [currentlyHoveredViews firstObject]</span><span class="s4">;</span>
  <span class="s1">UIView *prevTargetView = prevTargetTaggedView.view</span><span class="s4">;</span>

  <span class="s1">NSOrderedSet&lt;RCTReactTaggedView *&gt; *eventPathViews = GetTouchableViewsInPathToRoot(targetView)</span><span class="s4">;</span>

  <span class="s0">// Out</span>
  <span class="s4">if </span><span class="s1">(prevTargetView != nil &amp;&amp; prevTargetTaggedView.tag != targetTaggedView.tag) {</span>
    <span class="s1">BOOL shouldEmitOutEvent = IsAnyViewInPathListeningToEvent(currentlyHoveredViews</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerOut)</span><span class="s4">;</span>
    <span class="s1">SharedTouchEventEmitter eventEmitter =</span>
        <span class="s1">GetTouchEmitterFromView(prevTargetView</span><span class="s4">, </span><span class="s1">[_rootComponentView convertPoint:clientLocation toView:prevTargetView])</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(shouldEmitOutEvent &amp;&amp; eventEmitter != nil) {</span>
      <span class="s1">eventEmitter-&gt;onPointerOut(event)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Leaving</span>

  <span class="s0">// pointerleave events need to be emitted from the deepest target to the root but</span>
  <span class="s0">// we also need to efficiently keep track of if a view has a parent which is listening to the leave events,</span>
  <span class="s0">// so we first iterate from the root to the target, collecting the views which need events fired for, of which</span>
  <span class="s0">// we reverse iterate (now from target to root), actually emitting the events.</span>
  <span class="s1">NSMutableOrderedSet&lt;UIView *&gt; *viewsToEmitLeaveEventsTo = [NSMutableOrderedSet orderedSet]</span><span class="s4">;</span>

  <span class="s1">BOOL hasParentLeaveListener = NO</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(RCTReactTaggedView *taggedView in [currentlyHoveredViews reverseObjectEnumerator]) {</span>
    <span class="s1">UIView *componentView = taggedView.view</span><span class="s4">;</span>

    <span class="s1">BOOL shouldEmitEvent = componentView != nil &amp;&amp;</span>
        <span class="s1">(hasParentLeaveListener || IsViewListeningToEvent(taggedView</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerLeave))</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(shouldEmitEvent &amp;&amp; ![eventPathViews containsObject:taggedView]) {</span>
      <span class="s1">[viewsToEmitLeaveEventsTo addObject:componentView]</span><span class="s4">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(shouldEmitEvent &amp;&amp; !hasParentLeaveListener) {</span>
      <span class="s1">hasParentLeaveListener = YES</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">for </span><span class="s1">(UIView *componentView in [viewsToEmitLeaveEventsTo reverseObjectEnumerator]) {</span>
    <span class="s1">SharedTouchEventEmitter eventEmitter =</span>
        <span class="s1">GetTouchEmitterFromView(componentView</span><span class="s4">, </span><span class="s1">[_rootComponentView convertPoint:clientLocation toView:componentView])</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(eventEmitter != nil) {</span>
      <span class="s1">eventEmitter-&gt;onPointerLeave(event)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Over</span>
  <span class="s4">if </span><span class="s1">(targetView != nil &amp;&amp; prevTargetTaggedView.tag != targetTaggedView.tag) {</span>
    <span class="s1">BOOL shouldEmitOverEvent = IsAnyViewInPathListeningToEvent(eventPathViews</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerOver)</span><span class="s4">;</span>
    <span class="s1">SharedTouchEventEmitter eventEmitter =</span>
        <span class="s1">GetTouchEmitterFromView(targetView</span><span class="s4">, </span><span class="s1">[_rootComponentView convertPoint:clientLocation toView:targetView])</span><span class="s4">;</span>
    <span class="s4">if </span><span class="s1">(shouldEmitOverEvent &amp;&amp; eventEmitter != nil) {</span>
      <span class="s1">eventEmitter-&gt;onPointerOver(event)</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">// Entering</span>

  <span class="s0">// We only want to emit events to JS if there is a view that is currently listening to said event</span>
  <span class="s0">// so we only send those event to the JS side if the element which has been entered is itself listening,</span>
  <span class="s0">// or if one of its parents is listening in case those listeners care about the capturing phase. Adding the ability</span>
  <span class="s0">// for native to distinguish between capturing listeners and not could be an optimization to further reduce the number</span>
  <span class="s0">// of events we send to JS</span>
  <span class="s1">BOOL hasParentEnterListener = NO</span><span class="s4">;</span>
  <span class="s4">for </span><span class="s1">(RCTReactTaggedView *taggedView in [eventPathViews reverseObjectEnumerator]) {</span>
    <span class="s1">UIView *componentView = taggedView.view</span><span class="s4">;</span>

    <span class="s1">BOOL shouldEmitEvent = componentView != nil &amp;&amp;</span>
        <span class="s1">(hasParentEnterListener || IsViewListeningToEvent(taggedView</span><span class="s4">, </span><span class="s1">ViewEvents::Offset::PointerEnter))</span><span class="s4">;</span>

    <span class="s4">if </span><span class="s1">(shouldEmitEvent &amp;&amp; ![currentlyHoveredViews containsObject:taggedView]) {</span>
      <span class="s1">SharedTouchEventEmitter eventEmitter =</span>
          <span class="s1">GetTouchEmitterFromView(componentView</span><span class="s4">, </span><span class="s1">[_rootComponentView convertPoint:clientLocation toView:componentView])</span><span class="s4">;</span>
      <span class="s4">if </span><span class="s1">(eventEmitter != nil) {</span>
        <span class="s1">eventEmitter-&gt;onPointerEnter(event)</span><span class="s4">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(shouldEmitEvent &amp;&amp; !hasParentEnterListener) {</span>
      <span class="s1">hasParentEnterListener = YES</span><span class="s4">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">[_currentlyHoveredViewsPerPointer setObject:eventPathViews forKey:</span><span class="s4">@</span><span class="s1">(pointerId)]</span><span class="s4">;</span>

  <span class="s4">return </span><span class="s1">eventPathViews</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">@end</span>
</pre>
</body>
</html>
<html>
<head>
<title>trace-mapping.umd.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #cc7832;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
trace-mapping.umd.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports, require(</span><span class="s2">'@jridgewell/sourcemap-codec'</span><span class="s0">), require(</span><span class="s2">'@jridgewell/resolve-uri'</span><span class="s0">)) :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">, </span><span class="s2">'@jridgewell/sourcemap-codec'</span><span class="s0">, </span><span class="s2">'@jridgewell/resolve-uri'</span><span class="s0">], factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports, sourcemapCodec, resolveUri) { </span><span class="s2">'use strict'</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">_interopDefaultLegacy (e) { </span><span class="s1">return </span><span class="s0">e &amp;&amp; </span><span class="s1">typeof </span><span class="s0">e === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s2">'default' </span><span class="s1">in </span><span class="s0">e ? e : { </span><span class="s2">'default'</span><span class="s0">: e }; }</span>

    <span class="s1">var </span><span class="s0">resolveUri__default = </span><span class="s3">/*#__PURE__*/</span><span class="s0">_interopDefaultLegacy(resolveUri);</span>

    <span class="s1">function </span><span class="s0">resolve(input, base) {</span>
        <span class="s3">// The base is always treated as a directory, if it's not empty.</span>
        <span class="s3">// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327</span>
        <span class="s3">// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401</span>
        <span class="s1">if </span><span class="s0">(base &amp;&amp; !base.endsWith(</span><span class="s2">'/'</span><span class="s0">))</span>
            <span class="s0">base += </span><span class="s2">'/'</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">resolveUri__default[</span><span class="s2">&quot;default&quot;</span><span class="s0">](input, base);</span>
    <span class="s0">}</span>

    <span class="s3">/** 
     * Removes everything after the last &quot;/&quot;, but leaves the slash. 
     */</span>
    <span class="s1">function </span><span class="s0">stripFilename(path) {</span>
        <span class="s1">if </span><span class="s0">(!path)</span>
            <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">const index = path.lastIndexOf(</span><span class="s2">'/'</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">path.slice(</span><span class="s4">0</span><span class="s0">, index + </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s0">const COLUMN = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">const SOURCES_INDEX = </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">const SOURCE_LINE = </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s0">const SOURCE_COLUMN = </span><span class="s4">3</span><span class="s0">;</span>
    <span class="s0">const NAMES_INDEX = </span><span class="s4">4</span><span class="s0">;</span>
    <span class="s0">const REV_GENERATED_LINE = </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">const REV_GENERATED_COLUMN = </span><span class="s4">2</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">maybeSort(mappings, owned) {</span>
        <span class="s0">const unsortedIndex = nextUnsortedSegmentLine(mappings, </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(unsortedIndex === mappings.length)</span>
            <span class="s1">return </span><span class="s0">mappings;</span>
        <span class="s3">// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If</span>
        <span class="s3">// not, we do not want to modify the consumer's input array.</span>
        <span class="s1">if </span><span class="s0">(!owned)</span>
            <span class="s0">mappings = mappings.slice();</span>
        <span class="s1">for </span><span class="s0">(let i = unsortedIndex; i &lt; mappings.length; i = nextUnsortedSegmentLine(mappings, i + </span><span class="s4">1</span><span class="s0">)) {</span>
            <span class="s0">mappings[i] = sortSegments(mappings[i], owned);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mappings;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">nextUnsortedSegmentLine(mappings, start) {</span>
        <span class="s1">for </span><span class="s0">(let i = start; i &lt; mappings.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(!isSorted(mappings[i]))</span>
                <span class="s1">return </span><span class="s0">i;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mappings.length;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isSorted(line) {</span>
        <span class="s1">for </span><span class="s0">(let j = </span><span class="s4">1</span><span class="s0">; j &lt; line.length; j++) {</span>
            <span class="s1">if </span><span class="s0">(line[j][COLUMN] &lt; line[j - </span><span class="s4">1</span><span class="s0">][COLUMN]) {</span>
                <span class="s1">return false</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sortSegments(line, owned) {</span>
        <span class="s1">if </span><span class="s0">(!owned)</span>
            <span class="s0">line = line.slice();</span>
        <span class="s1">return </span><span class="s0">line.sort(sortComparator);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sortComparator(a, b) {</span>
        <span class="s1">return </span><span class="s0">a[COLUMN] - b[COLUMN];</span>
    <span class="s0">}</span>

    <span class="s0">let found = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s3">/** 
     * A binary search implementation that returns the index if a match is found. 
     * If no match is found, then the left-index (the index associated with the item that comes just 
     * before the desired index) is returned. To maintain proper sort order, a splice would happen at 
     * the next index: 
     * 
     * ```js 
     * const array = [1, 3]; 
     * const needle = 2; 
     * const index = binarySearch(array, needle, (item, needle) =&gt; item - needle); 
     * 
     * assert.equal(index, 0); 
     * array.splice(index + 1, 0, needle); 
     * assert.deepEqual(array, [1, 2, 3]); 
     * ``` 
     */</span>
    <span class="s1">function </span><span class="s0">binarySearch(haystack, needle, low, high) {</span>
        <span class="s1">while </span><span class="s0">(low &lt;= high) {</span>
            <span class="s0">const mid = low + ((high - low) &gt;&gt; </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">const cmp = haystack[mid][COLUMN] - needle;</span>
            <span class="s1">if </span><span class="s0">(cmp === </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">found = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">mid;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(cmp &lt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s0">low = mid + </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">high = mid - </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">found = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">low - </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">upperBound(haystack, needle, index) {</span>
        <span class="s1">for </span><span class="s0">(let i = index + </span><span class="s4">1</span><span class="s0">; i &lt; haystack.length; index = i++) {</span>
            <span class="s1">if </span><span class="s0">(haystack[i][COLUMN] !== needle)</span>
                <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">index;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">lowerBound(haystack, needle, index) {</span>
        <span class="s1">for </span><span class="s0">(let i = index - </span><span class="s4">1</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; index = i--) {</span>
            <span class="s1">if </span><span class="s0">(haystack[i][COLUMN] !== needle)</span>
                <span class="s1">break</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">index;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">memoizedState() {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">lastKey: -</span><span class="s4">1</span><span class="s0">,</span>
            <span class="s0">lastNeedle: -</span><span class="s4">1</span><span class="s0">,</span>
            <span class="s0">lastIndex: -</span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">/** 
     * This overly complicated beast is just to record the last tested line/column and the resulting 
     * index, allowing us to skip a few tests if mappings are monotonically increasing. 
     */</span>
    <span class="s1">function </span><span class="s0">memoizedBinarySearch(haystack, needle, state, key) {</span>
        <span class="s0">const { lastKey, lastNeedle, lastIndex } = state;</span>
        <span class="s0">let low = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">let high = haystack.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(key === lastKey) {</span>
            <span class="s1">if </span><span class="s0">(needle === lastNeedle) {</span>
                <span class="s0">found = lastIndex !== -</span><span class="s4">1 </span><span class="s0">&amp;&amp; haystack[lastIndex][COLUMN] === needle;</span>
                <span class="s1">return </span><span class="s0">lastIndex;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(needle &gt;= lastNeedle) {</span>
                <span class="s3">// lastIndex may be -1 if the previous needle was not found.</span>
                <span class="s0">low = lastIndex === -</span><span class="s4">1 </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: lastIndex;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">high = lastIndex;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">state.lastKey = key;</span>
        <span class="s0">state.lastNeedle = needle;</span>
        <span class="s1">return </span><span class="s0">(state.lastIndex = binarySearch(haystack, needle, low, high));</span>
    <span class="s0">}</span>

    <span class="s3">// Rebuilds the original source files, with mappings that are ordered by source line/column instead</span>
    <span class="s3">// of generated line/column.</span>
    <span class="s1">function </span><span class="s0">buildBySources(decoded, memos) {</span>
        <span class="s0">const sources = memos.map(buildNullArray);</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
            <span class="s0">const line = decoded[i];</span>
            <span class="s1">for </span><span class="s0">(let j = </span><span class="s4">0</span><span class="s0">; j &lt; line.length; j++) {</span>
                <span class="s0">const seg = line[j];</span>
                <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s4">1</span><span class="s0">)</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">const sourceIndex = seg[SOURCES_INDEX];</span>
                <span class="s0">const sourceLine = seg[SOURCE_LINE];</span>
                <span class="s0">const sourceColumn = seg[SOURCE_COLUMN];</span>
                <span class="s0">const originalSource = sources[sourceIndex];</span>
                <span class="s0">const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));</span>
                <span class="s0">const memo = memos[sourceIndex];</span>
                <span class="s3">// The binary search either found a match, or it found the left-index just before where the</span>
                <span class="s3">// segment should go. Either way, we want to insert after that. And there may be multiple</span>
                <span class="s3">// generated segments associated with an original location, so there may need to move several</span>
                <span class="s3">// indexes before we find where we need to insert.</span>
                <span class="s0">const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));</span>
                <span class="s0">insert(originalLine, (memo.lastIndex = index + </span><span class="s4">1</span><span class="s0">), [sourceColumn, i, seg[COLUMN]]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">sources;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">insert(array, index, value) {</span>
        <span class="s1">for </span><span class="s0">(let i = array.length; i &gt; index; i--) {</span>
            <span class="s0">array[i] = array[i - </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s0">array[index] = value;</span>
    <span class="s0">}</span>
    <span class="s3">// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like</span>
    <span class="s3">// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.</span>
    <span class="s3">// Numeric properties on objects are magically sorted in ascending order by the engine regardless of</span>
    <span class="s3">// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending</span>
    <span class="s3">// order when iterating with for-in.</span>
    <span class="s1">function </span><span class="s0">buildNullArray() {</span>
        <span class="s1">return </span><span class="s0">{ __proto__: </span><span class="s1">null </span><span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s0">const AnyMap = </span><span class="s1">function </span><span class="s0">(map, mapUrl) {</span>
        <span class="s0">const parsed = </span><span class="s1">typeof </span><span class="s0">map === </span><span class="s2">'string' </span><span class="s0">? JSON.parse(map) : map;</span>
        <span class="s1">if </span><span class="s0">(!(</span><span class="s2">'sections' </span><span class="s1">in </span><span class="s0">parsed))</span>
            <span class="s1">return new </span><span class="s0">TraceMap(parsed, mapUrl);</span>
        <span class="s0">const mappings = [];</span>
        <span class="s0">const sources = [];</span>
        <span class="s0">const sourcesContent = [];</span>
        <span class="s0">const names = [];</span>
        <span class="s0">recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, Infinity, Infinity);</span>
        <span class="s0">const joined = {</span>
            <span class="s0">version: </span><span class="s4">3</span><span class="s0">,</span>
            <span class="s0">file: parsed.file,</span>
            <span class="s0">names,</span>
            <span class="s0">sources,</span>
            <span class="s0">sourcesContent,</span>
            <span class="s0">mappings,</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">exports.presortedDecodedMap(joined);</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {</span>
        <span class="s0">const { sections } = input;</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; sections.length; i++) {</span>
            <span class="s0">const { map, offset } = sections[i];</span>
            <span class="s0">let sl = stopLine;</span>
            <span class="s0">let sc = stopColumn;</span>
            <span class="s1">if </span><span class="s0">(i + </span><span class="s4">1 </span><span class="s0">&lt; sections.length) {</span>
                <span class="s0">const nextOffset = sections[i + </span><span class="s4">1</span><span class="s0">].offset;</span>
                <span class="s0">sl = Math.min(stopLine, lineOffset + nextOffset.line);</span>
                <span class="s1">if </span><span class="s0">(sl === stopLine) {</span>
                    <span class="s0">sc = Math.min(stopColumn, columnOffset + nextOffset.column);</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(sl &lt; stopLine) {</span>
                    <span class="s0">sc = columnOffset + nextOffset.column;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">'sections' </span><span class="s1">in </span><span class="s0">input)</span>
            <span class="s1">return </span><span class="s0">recurse(...arguments);</span>
        <span class="s0">const map = </span><span class="s1">new </span><span class="s0">TraceMap(input, mapUrl);</span>
        <span class="s0">const sourcesOffset = sources.length;</span>
        <span class="s0">const namesOffset = names.length;</span>
        <span class="s0">const decoded = exports.decodedMappings(map);</span>
        <span class="s0">const { resolvedSources, sourcesContent: contents } = map;</span>
        <span class="s0">append(sources, resolvedSources);</span>
        <span class="s0">append(names, map.names);</span>
        <span class="s1">if </span><span class="s0">(contents)</span>
            <span class="s0">append(sourcesContent, contents);</span>
        <span class="s1">else</span>
            <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; resolvedSources.length; i++)</span>
                <span class="s0">sourcesContent.push(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
            <span class="s0">const lineI = lineOffset + i;</span>
            <span class="s3">// We can only add so many lines before we step into the range that the next section's map</span>
            <span class="s3">// controls. When we get to the last line, then we'll start checking the segments to see if</span>
            <span class="s3">// they've crossed into the column range. But it may not have any columns that overstep, so we</span>
            <span class="s3">// still need to check that we don't overstep lines, too.</span>
            <span class="s1">if </span><span class="s0">(lineI &gt; stopLine)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s3">// The out line may already exist in mappings (if we're continuing the line started by a</span>
            <span class="s3">// previous section). Or, we may have jumped ahead several lines to start this section.</span>
            <span class="s0">const out = getLine(mappings, lineI);</span>
            <span class="s3">// On the 0th loop, the section's column offset shifts us forward. On all other lines (since the</span>
            <span class="s3">// map can be multiple lines), it doesn't.</span>
            <span class="s0">const cOffset = i === </span><span class="s4">0 </span><span class="s0">? columnOffset : </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">const line = decoded[i];</span>
            <span class="s1">for </span><span class="s0">(let j = </span><span class="s4">0</span><span class="s0">; j &lt; line.length; j++) {</span>
                <span class="s0">const seg = line[j];</span>
                <span class="s0">const column = cOffset + seg[COLUMN];</span>
                <span class="s3">// If this segment steps into the column range that the next section's map controls, we need</span>
                <span class="s3">// to stop early.</span>
                <span class="s1">if </span><span class="s0">(lineI === stopLine &amp;&amp; column &gt;= stopColumn)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s0">out.push([column]);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];</span>
                <span class="s0">const sourceLine = seg[SOURCE_LINE];</span>
                <span class="s0">const sourceColumn = seg[SOURCE_COLUMN];</span>
                <span class="s0">out.push(seg.length === </span><span class="s4">4</span>
                    <span class="s0">? [column, sourcesIndex, sourceLine, sourceColumn]</span>
                    <span class="s0">: [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">append(arr, other) {</span>
        <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; other.length; i++)</span>
            <span class="s0">arr.push(other[i]);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getLine(arr, index) {</span>
        <span class="s1">for </span><span class="s0">(let i = arr.length; i &lt;= index; i++)</span>
            <span class="s0">arr[i] = [];</span>
        <span class="s1">return </span><span class="s0">arr[index];</span>
    <span class="s0">}</span>

    <span class="s0">const LINE_GTR_ZERO = </span><span class="s2">'`line` must be greater than 0 (lines start at line 1)'</span><span class="s0">;</span>
    <span class="s0">const COL_GTR_EQ_ZERO = </span><span class="s2">'`column` must be greater than or equal to 0 (columns start at column 0)'</span><span class="s0">;</span>
    <span class="s0">const LEAST_UPPER_BOUND = -</span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">const GREATEST_LOWER_BOUND = </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s3">/** 
     * Returns the encoded (VLQ string) form of the SourceMap's mappings field. 
     */</span>
    <span class="s0">exports.encodedMappings = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field. 
     */</span>
    <span class="s0">exports.decodedMappings = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * A low-level API to find the segment associated with a generated line/column (think, from a 
     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`. 
     */</span>
    <span class="s0">exports.traceSegment = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * A higher-level API to find the source/line/column associated with a generated line/column 
     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in 
     * `source-map` library. 
     */</span>
    <span class="s0">exports.originalPositionFor = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * Finds the generated line/column position of the provided source/line/column source position. 
     */</span>
    <span class="s0">exports.generatedPositionFor = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * Finds all generated line/column positions of the provided source/line/column source position. 
     */</span>
    <span class="s0">exports.allGeneratedPositionsFor = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * Iterates each mapping in generated position order. 
     */</span>
    <span class="s0">exports.eachMapping = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * Retrieves the source content for a particular source, if its found. Returns null if not. 
     */</span>
    <span class="s0">exports.sourceContentFor = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger 
     * maps. 
     */</span>
    <span class="s0">exports.presortedDecodedMap = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects 
     * a sourcemap, or to JSON.stringify. 
     */</span>
    <span class="s0">exports.decodedMap = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">/** 
     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects 
     * a sourcemap, or to JSON.stringify. 
     */</span>
    <span class="s0">exports.encodedMap = </span><span class="s1">void </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">class TraceMap {</span>
        <span class="s0">constructor(map, mapUrl) {</span>
            <span class="s0">const isString = </span><span class="s1">typeof </span><span class="s0">map === </span><span class="s2">'string'</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!isString &amp;&amp; map._decodedMemo)</span>
                <span class="s1">return </span><span class="s0">map;</span>
            <span class="s0">const parsed = (isString ? JSON.parse(map) : map);</span>
            <span class="s0">const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;</span>
            <span class="s1">this</span><span class="s0">.version = version;</span>
            <span class="s1">this</span><span class="s0">.file = file;</span>
            <span class="s1">this</span><span class="s0">.names = names;</span>
            <span class="s1">this</span><span class="s0">.sourceRoot = sourceRoot;</span>
            <span class="s1">this</span><span class="s0">.sources = sources;</span>
            <span class="s1">this</span><span class="s0">.sourcesContent = sourcesContent;</span>
            <span class="s0">const from = resolve(sourceRoot || </span><span class="s2">''</span><span class="s0">, stripFilename(mapUrl));</span>
            <span class="s1">this</span><span class="s0">.resolvedSources = sources.map((s) =&gt; resolve(s || </span><span class="s2">''</span><span class="s0">, from));</span>
            <span class="s0">const { mappings } = parsed;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">mappings === </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">._encoded = mappings;</span>
                <span class="s1">this</span><span class="s0">._decoded = undefined;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">._encoded = undefined;</span>
                <span class="s1">this</span><span class="s0">._decoded = maybeSort(mappings, isString);</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">._decodedMemo = memoizedState();</span>
            <span class="s1">this</span><span class="s0">._bySources = undefined;</span>
            <span class="s1">this</span><span class="s0">._bySourceMemos = undefined;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">(() =&gt; {</span>
        <span class="s0">exports.encodedMappings = (map) =&gt; {</span>
            <span class="s1">var </span><span class="s0">_a;</span>
            <span class="s1">return </span><span class="s0">((_a = map._encoded) !== </span><span class="s1">null </span><span class="s0">&amp;&amp; _a !== </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">? _a : (map._encoded = sourcemapCodec.encode(map._decoded)));</span>
        <span class="s0">};</span>
        <span class="s0">exports.decodedMappings = (map) =&gt; {</span>
            <span class="s1">return </span><span class="s0">(map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded)));</span>
        <span class="s0">};</span>
        <span class="s0">exports.traceSegment = (map, line, column) =&gt; {</span>
            <span class="s0">const decoded = exports.decodedMappings(map);</span>
            <span class="s3">// It's common for parent source maps to have pointers to lines that have no</span>
            <span class="s3">// mapping (like a &quot;//# sourceMappingURL=&quot;) at the end of the child file.</span>
            <span class="s1">if </span><span class="s0">(line &gt;= decoded.length)</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s0">const segments = decoded[line];</span>
            <span class="s0">const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);</span>
            <span class="s1">return </span><span class="s0">index === -</span><span class="s4">1 </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: segments[index];</span>
        <span class="s0">};</span>
        <span class="s0">exports.originalPositionFor = (map, { line, column, bias }) =&gt; {</span>
            <span class="s0">line--;</span>
            <span class="s1">if </span><span class="s0">(line &lt; </span><span class="s4">0</span><span class="s0">)</span>
                <span class="s1">throw new </span><span class="s0">Error(LINE_GTR_ZERO);</span>
            <span class="s1">if </span><span class="s0">(column &lt; </span><span class="s4">0</span><span class="s0">)</span>
                <span class="s1">throw new </span><span class="s0">Error(COL_GTR_EQ_ZERO);</span>
            <span class="s0">const decoded = exports.decodedMappings(map);</span>
            <span class="s3">// It's common for parent source maps to have pointers to lines that have no</span>
            <span class="s3">// mapping (like a &quot;//# sourceMappingURL=&quot;) at the end of the child file.</span>
            <span class="s1">if </span><span class="s0">(line &gt;= decoded.length)</span>
                <span class="s1">return </span><span class="s0">OMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">const segments = decoded[line];</span>
            <span class="s0">const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);</span>
            <span class="s1">if </span><span class="s0">(index === -</span><span class="s4">1</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">OMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">const segment = segments[index];</span>
            <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s4">1</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">OMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">const { names, resolvedSources } = map;</span>
            <span class="s1">return </span><span class="s0">OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + </span><span class="s4">1</span><span class="s0">, segment[SOURCE_COLUMN], segment.length === </span><span class="s4">5 </span><span class="s0">? names[segment[NAMES_INDEX]] : </span><span class="s1">null</span><span class="s0">);</span>
        <span class="s0">};</span>
        <span class="s0">exports.allGeneratedPositionsFor = (map, { source, line, column, bias }) =&gt; {</span>
            <span class="s3">// SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.</span>
            <span class="s1">return </span><span class="s0">generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">};</span>
        <span class="s0">exports.generatedPositionFor = (map, { source, line, column, bias }) =&gt; {</span>
            <span class="s1">return </span><span class="s0">generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, </span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">};</span>
        <span class="s0">exports.eachMapping = (map, cb) =&gt; {</span>
            <span class="s0">const decoded = exports.decodedMappings(map);</span>
            <span class="s0">const { names, resolvedSources } = map;</span>
            <span class="s1">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; decoded.length; i++) {</span>
                <span class="s0">const line = decoded[i];</span>
                <span class="s1">for </span><span class="s0">(let j = </span><span class="s4">0</span><span class="s0">; j &lt; line.length; j++) {</span>
                    <span class="s0">const seg = line[j];</span>
                    <span class="s0">const generatedLine = i + </span><span class="s4">1</span><span class="s0">;</span>
                    <span class="s0">const generatedColumn = seg[</span><span class="s4">0</span><span class="s0">];</span>
                    <span class="s0">let source = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">let originalLine = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">let originalColumn = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s0">let name = </span><span class="s1">null</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(seg.length !== </span><span class="s4">1</span><span class="s0">) {</span>
                        <span class="s0">source = resolvedSources[seg[</span><span class="s4">1</span><span class="s0">]];</span>
                        <span class="s0">originalLine = seg[</span><span class="s4">2</span><span class="s0">] + </span><span class="s4">1</span><span class="s0">;</span>
                        <span class="s0">originalColumn = seg[</span><span class="s4">3</span><span class="s0">];</span>
                    <span class="s0">}</span>
                    <span class="s1">if </span><span class="s0">(seg.length === </span><span class="s4">5</span><span class="s0">)</span>
                        <span class="s0">name = names[seg[</span><span class="s4">4</span><span class="s0">]];</span>
                    <span class="s0">cb({</span>
                        <span class="s0">generatedLine,</span>
                        <span class="s0">generatedColumn,</span>
                        <span class="s0">source,</span>
                        <span class="s0">originalLine,</span>
                        <span class="s0">originalColumn,</span>
                        <span class="s0">name,</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">exports.sourceContentFor = (map, source) =&gt; {</span>
            <span class="s0">const { sources, resolvedSources, sourcesContent } = map;</span>
            <span class="s1">if </span><span class="s0">(sourcesContent == </span><span class="s1">null</span><span class="s0">)</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s0">let index = sources.indexOf(source);</span>
            <span class="s1">if </span><span class="s0">(index === -</span><span class="s4">1</span><span class="s0">)</span>
                <span class="s0">index = resolvedSources.indexOf(source);</span>
            <span class="s1">return </span><span class="s0">index === -</span><span class="s4">1 </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: sourcesContent[index];</span>
        <span class="s0">};</span>
        <span class="s0">exports.presortedDecodedMap = (map, mapUrl) =&gt; {</span>
            <span class="s0">const tracer = </span><span class="s1">new </span><span class="s0">TraceMap(clone(map, []), mapUrl);</span>
            <span class="s0">tracer._decoded = map.mappings;</span>
            <span class="s1">return </span><span class="s0">tracer;</span>
        <span class="s0">};</span>
        <span class="s0">exports.decodedMap = (map) =&gt; {</span>
            <span class="s1">return </span><span class="s0">clone(map, exports.decodedMappings(map));</span>
        <span class="s0">};</span>
        <span class="s0">exports.encodedMap = (map) =&gt; {</span>
            <span class="s1">return </span><span class="s0">clone(map, exports.encodedMappings(map));</span>
        <span class="s0">};</span>
        <span class="s1">function </span><span class="s0">generatedPosition(map, source, line, column, bias, all) {</span>
            <span class="s0">line--;</span>
            <span class="s1">if </span><span class="s0">(line &lt; </span><span class="s4">0</span><span class="s0">)</span>
                <span class="s1">throw new </span><span class="s0">Error(LINE_GTR_ZERO);</span>
            <span class="s1">if </span><span class="s0">(column &lt; </span><span class="s4">0</span><span class="s0">)</span>
                <span class="s1">throw new </span><span class="s0">Error(COL_GTR_EQ_ZERO);</span>
            <span class="s0">const { sources, resolvedSources } = map;</span>
            <span class="s0">let sourceIndex = sources.indexOf(source);</span>
            <span class="s1">if </span><span class="s0">(sourceIndex === -</span><span class="s4">1</span><span class="s0">)</span>
                <span class="s0">sourceIndex = resolvedSources.indexOf(source);</span>
            <span class="s1">if </span><span class="s0">(sourceIndex === -</span><span class="s4">1</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">all ? [] : GMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">const generated = (map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));</span>
            <span class="s0">const segments = generated[sourceIndex][line];</span>
            <span class="s1">if </span><span class="s0">(segments == </span><span class="s1">null</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">all ? [] : GMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">const memo = map._bySourceMemos[sourceIndex];</span>
            <span class="s1">if </span><span class="s0">(all)</span>
                <span class="s1">return </span><span class="s0">sliceGeneratedPositions(segments, memo, line, column, bias);</span>
            <span class="s0">const index = traceSegmentInternal(segments, memo, line, column, bias);</span>
            <span class="s1">if </span><span class="s0">(index === -</span><span class="s4">1</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">GMapping(</span><span class="s1">null</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">const segment = segments[index];</span>
            <span class="s1">return </span><span class="s0">GMapping(segment[REV_GENERATED_LINE] + </span><span class="s4">1</span><span class="s0">, segment[REV_GENERATED_COLUMN]);</span>
        <span class="s0">}</span>
    <span class="s0">})();</span>
    <span class="s1">function </span><span class="s0">clone(map, mappings) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">version: map.version,</span>
            <span class="s0">file: map.file,</span>
            <span class="s0">names: map.names,</span>
            <span class="s0">sourceRoot: map.sourceRoot,</span>
            <span class="s0">sources: map.sources,</span>
            <span class="s0">sourcesContent: map.sourcesContent,</span>
            <span class="s0">mappings,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">OMapping(source, line, column, name) {</span>
        <span class="s1">return </span><span class="s0">{ source, line, column, name };</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">GMapping(line, column) {</span>
        <span class="s1">return </span><span class="s0">{ line, column };</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">traceSegmentInternal(segments, memo, line, column, bias) {</span>
        <span class="s0">let index = memoizedBinarySearch(segments, column, memo, line);</span>
        <span class="s1">if </span><span class="s0">(found) {</span>
            <span class="s0">index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(bias === LEAST_UPPER_BOUND)</span>
            <span class="s0">index++;</span>
        <span class="s1">if </span><span class="s0">(index === -</span><span class="s4">1 </span><span class="s0">|| index === segments.length)</span>
            <span class="s1">return </span><span class="s0">-</span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">index;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">sliceGeneratedPositions(segments, memo, line, column, bias) {</span>
        <span class="s0">let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);</span>
        <span class="s3">// We ignored the bias when tracing the segment so that we're guarnateed to find the first (in</span>
        <span class="s3">// insertion order) segment that matched. Even if we did respect the bias when tracing, we would</span>
        <span class="s3">// still need to call `lowerBound()` to find the first segment, which is slower than just looking</span>
        <span class="s3">// for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the</span>
        <span class="s3">// binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to</span>
        <span class="s3">// match LEAST_UPPER_BOUND.</span>
        <span class="s1">if </span><span class="s0">(!found &amp;&amp; bias === LEAST_UPPER_BOUND)</span>
            <span class="s0">min++;</span>
        <span class="s1">if </span><span class="s0">(min === -</span><span class="s4">1 </span><span class="s0">|| min === segments.length)</span>
            <span class="s1">return </span><span class="s0">[];</span>
        <span class="s3">// We may have found the segment that started at an earlier column. If this is the case, then we</span>
        <span class="s3">// need to slice all generated segments that match _that_ column, because all such segments span</span>
        <span class="s3">// to our desired column.</span>
        <span class="s0">const matchedColumn = found ? column : segments[min][COLUMN];</span>
        <span class="s3">// The binary search is not guaranteed to find the lower bound when a match wasn't found.</span>
        <span class="s1">if </span><span class="s0">(!found)</span>
            <span class="s0">min = lowerBound(segments, matchedColumn, min);</span>
        <span class="s0">const max = upperBound(segments, matchedColumn, min);</span>
        <span class="s0">const result = [];</span>
        <span class="s1">for </span><span class="s0">(; min &lt;= max; min++) {</span>
            <span class="s0">const segment = segments[min];</span>
            <span class="s0">result.push(GMapping(segment[REV_GENERATED_LINE] + </span><span class="s4">1</span><span class="s0">, segment[REV_GENERATED_COLUMN]));</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">}</span>

    <span class="s0">exports.AnyMap = AnyMap;</span>
    <span class="s0">exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;</span>
    <span class="s0">exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;</span>
    <span class="s0">exports.TraceMap = TraceMap;</span>

    <span class="s0">Object.defineProperty(exports, </span><span class="s2">'__esModule'</span><span class="s0">, { value: </span><span class="s1">true </span><span class="s0">});</span>

<span class="s0">}));</span>
<span class="s3">//# sourceMappingURL=trace-mapping.umd.js.map</span>
</pre>
</body>
</html>
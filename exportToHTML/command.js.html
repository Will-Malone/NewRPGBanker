<html>
<head>
<title>command.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #4646f1;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
command.js</font>
</center></td></tr></table>
<pre><span class="s0">const EventEmitter = require(</span><span class="s1">'events'</span><span class="s0">).EventEmitter;</span>
<span class="s0">const childProcess = require(</span><span class="s1">'child_process'</span><span class="s0">);</span>
<span class="s0">const path = require(</span><span class="s1">'path'</span><span class="s0">);</span>
<span class="s0">const fs = require(</span><span class="s1">'fs'</span><span class="s0">);</span>
<span class="s0">const process = require(</span><span class="s1">'process'</span><span class="s0">);</span>

<span class="s0">const { Argument, humanReadableArgName } = require(</span><span class="s1">'./argument.js'</span><span class="s0">);</span>
<span class="s0">const { CommanderError } = require(</span><span class="s1">'./error.js'</span><span class="s0">);</span>
<span class="s0">const { Help } = require(</span><span class="s1">'./help.js'</span><span class="s0">);</span>
<span class="s0">const { Option, splitOptionFlags, DualOptions } = require(</span><span class="s1">'./option.js'</span><span class="s0">);</span>
<span class="s0">const { suggestSimilar } = require(</span><span class="s1">'./suggestSimilar'</span><span class="s0">);</span>

<span class="s2">// @ts-check</span>

<span class="s0">class Command extends EventEmitter {</span>
  <span class="s2">/** 
   * Initialize a new `Command`. 
   * 
   * @param {string} [name] 
   */</span>

  <span class="s0">constructor(name) {</span>
    <span class="s0">super();</span>
    <span class="s2">/** @type {Command[]} */</span>
    <span class="s3">this</span><span class="s0">.commands = [];</span>
    <span class="s2">/** @type {Option[]} */</span>
    <span class="s3">this</span><span class="s0">.options = [];</span>
    <span class="s3">this</span><span class="s0">.parent = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._allowUnknownOption = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._allowExcessArguments = </span><span class="s3">true</span><span class="s0">;</span>
    <span class="s2">/** @type {Argument[]} */</span>
    <span class="s3">this</span><span class="s0">._args = [];</span>
    <span class="s2">/** @type {string[]} */</span>
    <span class="s3">this</span><span class="s0">.args = []; </span><span class="s2">// cli args with options removed</span>
    <span class="s3">this</span><span class="s0">.rawArgs = [];</span>
    <span class="s3">this</span><span class="s0">.processedArgs = []; </span><span class="s2">// like .args but after custom processing and collecting variadic</span>
    <span class="s3">this</span><span class="s0">._scriptPath = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._name = name || </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._optionValues = {};</span>
    <span class="s3">this</span><span class="s0">._optionValueSources = {}; </span><span class="s2">// default, env, cli etc</span>
    <span class="s3">this</span><span class="s0">._storeOptionsAsProperties = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._actionHandler = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._executableHandler = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._executableFile = </span><span class="s3">null</span><span class="s0">; </span><span class="s2">// custom name for executable</span>
    <span class="s3">this</span><span class="s0">._executableDir = </span><span class="s3">null</span><span class="s0">; </span><span class="s2">// custom search directory for subcommands</span>
    <span class="s3">this</span><span class="s0">._defaultCommandName = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._exitCallback = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._aliases = [];</span>
    <span class="s3">this</span><span class="s0">._combineFlagAndOptionalValue = </span><span class="s3">true</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._description = </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._summary = </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._argsDescription = undefined; </span><span class="s2">// legacy</span>
    <span class="s3">this</span><span class="s0">._enablePositionalOptions = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._passThroughOptions = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._lifeCycleHooks = {}; </span><span class="s2">// a hash of arrays</span>
    <span class="s2">/** @type {boolean | string} */</span>
    <span class="s3">this</span><span class="s0">._showHelpAfterError = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._showSuggestionAfterError = </span><span class="s3">true</span><span class="s0">;</span>

    <span class="s2">// see .configureOutput() for docs</span>
    <span class="s3">this</span><span class="s0">._outputConfiguration = {</span>
      <span class="s0">writeOut: (str) =&gt; process.stdout.write(str),</span>
      <span class="s0">writeErr: (str) =&gt; process.stderr.write(str),</span>
      <span class="s0">getOutHelpWidth: () =&gt; process.stdout.isTTY ? process.stdout.columns : undefined,</span>
      <span class="s0">getErrHelpWidth: () =&gt; process.stderr.isTTY ? process.stderr.columns : undefined,</span>
      <span class="s0">outputError: (str, write) =&gt; write(str)</span>
    <span class="s0">};</span>

    <span class="s3">this</span><span class="s0">._hidden = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._hasHelpOption = </span><span class="s3">true</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._helpFlags = </span><span class="s1">'-h, --help'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._helpDescription = </span><span class="s1">'display help for command'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._helpShortFlag = </span><span class="s1">'-h'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._helpLongFlag = </span><span class="s1">'--help'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._addImplicitHelpCommand = undefined; </span><span class="s2">// Deliberately undefined, not decided whether true or false</span>
    <span class="s3">this</span><span class="s0">._helpCommandName = </span><span class="s1">'help'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._helpCommandnameAndArgs = </span><span class="s1">'help [command]'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._helpCommandDescription = </span><span class="s1">'display help for command'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._helpConfiguration = {};</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Copy settings that are useful to have in common across root command and subcommands. 
   * 
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.) 
   * 
   * @param {Command} sourceCommand 
   * @return {Command} `this` command for chaining 
   */</span>
  <span class="s0">copyInheritedSettings(sourceCommand) {</span>
    <span class="s3">this</span><span class="s0">._outputConfiguration = sourceCommand._outputConfiguration;</span>
    <span class="s3">this</span><span class="s0">._hasHelpOption = sourceCommand._hasHelpOption;</span>
    <span class="s3">this</span><span class="s0">._helpFlags = sourceCommand._helpFlags;</span>
    <span class="s3">this</span><span class="s0">._helpDescription = sourceCommand._helpDescription;</span>
    <span class="s3">this</span><span class="s0">._helpShortFlag = sourceCommand._helpShortFlag;</span>
    <span class="s3">this</span><span class="s0">._helpLongFlag = sourceCommand._helpLongFlag;</span>
    <span class="s3">this</span><span class="s0">._helpCommandName = sourceCommand._helpCommandName;</span>
    <span class="s3">this</span><span class="s0">._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;</span>
    <span class="s3">this</span><span class="s0">._helpCommandDescription = sourceCommand._helpCommandDescription;</span>
    <span class="s3">this</span><span class="s0">._helpConfiguration = sourceCommand._helpConfiguration;</span>
    <span class="s3">this</span><span class="s0">._exitCallback = sourceCommand._exitCallback;</span>
    <span class="s3">this</span><span class="s0">._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;</span>
    <span class="s3">this</span><span class="s0">._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;</span>
    <span class="s3">this</span><span class="s0">._allowExcessArguments = sourceCommand._allowExcessArguments;</span>
    <span class="s3">this</span><span class="s0">._enablePositionalOptions = sourceCommand._enablePositionalOptions;</span>
    <span class="s3">this</span><span class="s0">._showHelpAfterError = sourceCommand._showHelpAfterError;</span>
    <span class="s3">this</span><span class="s0">._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;</span>

    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Define a command. 
   * 
   * There are two styles of command: pay attention to where to put the description. 
   * 
   * @example 
   * // Command implemented using action handler (description is supplied separately to `.command`) 
   * program 
   *   .command('clone &lt;source&gt; [destination]') 
   *   .description('clone a repository into a newly created directory') 
   *   .action((source, destination) =&gt; { 
   *     console.log('clone command called'); 
   *   }); 
   * 
   * // Command implemented using separate executable file (description is second parameter to `.command`) 
   * program 
   *   .command('start &lt;service&gt;', 'start named service') 
   *   .command('stop [service]', 'stop named service, or all if no name supplied'); 
   * 
   * @param {string} nameAndArgs - command name and arguments, args are `&lt;required&gt;` or `[optional]` and last may also be `variadic...` 
   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable) 
   * @param {Object} [execOpts] - configuration options (for executable) 
   * @return {Command} returns new command for action handler, or `this` for executable command 
   */</span>

  <span class="s0">command(nameAndArgs, actionOptsOrExecDesc, execOpts) {</span>
    <span class="s0">let desc = actionOptsOrExecDesc;</span>
    <span class="s0">let opts = execOpts;</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">desc === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; desc !== </span><span class="s3">null</span><span class="s0">) {</span>
      <span class="s0">opts = desc;</span>
      <span class="s0">desc = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">opts = opts || {};</span>
    <span class="s0">const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);</span>

    <span class="s0">const cmd = </span><span class="s3">this</span><span class="s0">.createCommand(name);</span>
    <span class="s3">if </span><span class="s0">(desc) {</span>
      <span class="s0">cmd.description(desc);</span>
      <span class="s0">cmd._executableHandler = </span><span class="s3">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(opts.isDefault) </span><span class="s3">this</span><span class="s0">._defaultCommandName = cmd._name;</span>
    <span class="s0">cmd._hidden = !!(opts.noHelp || opts.hidden); </span><span class="s2">// noHelp is deprecated old name for hidden</span>
    <span class="s0">cmd._executableFile = opts.executableFile || </span><span class="s3">null</span><span class="s0">; </span><span class="s2">// Custom name for executable file, set missing to null to match constructor</span>
    <span class="s3">if </span><span class="s0">(args) cmd.arguments(args);</span>
    <span class="s3">this</span><span class="s0">.commands.push(cmd);</span>
    <span class="s0">cmd.parent = </span><span class="s3">this</span><span class="s0">;</span>
    <span class="s0">cmd.copyInheritedSettings(</span><span class="s3">this</span><span class="s0">);</span>

    <span class="s3">if </span><span class="s0">(desc) </span><span class="s3">return this</span><span class="s0">;</span>
    <span class="s3">return </span><span class="s0">cmd;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Factory routine to create a new unattached command. 
   * 
   * See .command() for creating an attached subcommand, which uses this routine to 
   * create the command. You can override createCommand to customise subcommands. 
   * 
   * @param {string} [name] 
   * @return {Command} new command 
   */</span>

  <span class="s0">createCommand(name) {</span>
    <span class="s3">return new </span><span class="s0">Command(name);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * You can customise the help with a subclass of Help by overriding createHelp, 
   * or by overriding Help properties using configureHelp(). 
   * 
   * @return {Help} 
   */</span>

  <span class="s0">createHelp() {</span>
    <span class="s3">return </span><span class="s0">Object.assign(</span><span class="s3">new </span><span class="s0">Help(), </span><span class="s3">this</span><span class="s0">.configureHelp());</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * You can customise the help by overriding Help properties using configureHelp(), 
   * or with a subclass of Help by overriding createHelp(). 
   * 
   * @param {Object} [configuration] - configuration options 
   * @return {Command|Object} `this` command for chaining, or stored configuration 
   */</span>

  <span class="s0">configureHelp(configuration) {</span>
    <span class="s3">if </span><span class="s0">(configuration === undefined) </span><span class="s3">return this</span><span class="s0">._helpConfiguration;</span>

    <span class="s3">this</span><span class="s0">._helpConfiguration = configuration;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * The default output goes to stdout and stderr. You can customise this for special 
   * applications. You can also customise the display of errors by overriding outputError. 
   * 
   * The configuration properties are all functions: 
   * 
   *     // functions to change where being written, stdout and stderr 
   *     writeOut(str) 
   *     writeErr(str) 
   *     // matching functions to specify width for wrapping help 
   *     getOutHelpWidth() 
   *     getErrHelpWidth() 
   *     // functions based on what is being written out 
   *     outputError(str, write) // used for displaying errors, and not used for displaying help 
   * 
   * @param {Object} [configuration] - configuration options 
   * @return {Command|Object} `this` command for chaining, or stored configuration 
   */</span>

  <span class="s0">configureOutput(configuration) {</span>
    <span class="s3">if </span><span class="s0">(configuration === undefined) </span><span class="s3">return this</span><span class="s0">._outputConfiguration;</span>

    <span class="s0">Object.assign(</span><span class="s3">this</span><span class="s0">._outputConfiguration, configuration);</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Display the help or a custom message after an error occurs. 
   * 
   * @param {boolean|string} [displayHelp] 
   * @return {Command} `this` command for chaining 
   */</span>
  <span class="s0">showHelpAfterError(displayHelp = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">displayHelp !== </span><span class="s1">'string'</span><span class="s0">) displayHelp = !!displayHelp;</span>
    <span class="s3">this</span><span class="s0">._showHelpAfterError = displayHelp;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Display suggestion of similar commands for unknown commands, or options for unknown options. 
   * 
   * @param {boolean} [displaySuggestion] 
   * @return {Command} `this` command for chaining 
   */</span>
  <span class="s0">showSuggestionAfterError(displaySuggestion = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">this</span><span class="s0">._showSuggestionAfterError = !!displaySuggestion;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Add a prepared subcommand. 
   * 
   * See .command() for creating an attached subcommand which inherits settings from its parent. 
   * 
   * @param {Command} cmd - new subcommand 
   * @param {Object} [opts] - configuration options 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">addCommand(cmd, opts) {</span>
    <span class="s3">if </span><span class="s0">(!cmd._name) {</span>
      <span class="s3">throw new </span><span class="s0">Error(`Command passed to .addCommand() must have a name</span>
<span class="s0">- specify the name </span><span class="s3">in </span><span class="s0">Command constructor or using .name()`);</span>
    <span class="s0">}</span>

    <span class="s0">opts = opts || {};</span>
    <span class="s3">if </span><span class="s0">(opts.isDefault) </span><span class="s3">this</span><span class="s0">._defaultCommandName = cmd._name;</span>
    <span class="s3">if </span><span class="s0">(opts.noHelp || opts.hidden) cmd._hidden = </span><span class="s3">true</span><span class="s0">; </span><span class="s2">// modifying passed command due to existing implementation</span>

    <span class="s3">this</span><span class="s0">.commands.push(cmd);</span>
    <span class="s0">cmd.parent = </span><span class="s3">this</span><span class="s0">;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Factory routine to create a new unattached argument. 
   * 
   * See .argument() for creating an attached argument, which uses this routine to 
   * create the argument. You can override createArgument to return a custom argument. 
   * 
   * @param {string} name 
   * @param {string} [description] 
   * @return {Argument} new argument 
   */</span>

  <span class="s0">createArgument(name, description) {</span>
    <span class="s3">return new </span><span class="s0">Argument(name, description);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Define argument syntax for command. 
   * 
   * The default is that the argument is required, and you can explicitly 
   * indicate this with &lt;&gt; around the name. Put [] around the name for an optional argument. 
   * 
   * @example 
   * program.argument('&lt;input-file&gt;'); 
   * program.argument('[output-file]'); 
   * 
   * @param {string} name 
   * @param {string} [description] 
   * @param {Function|*} [fn] - custom argument processing function 
   * @param {*} [defaultValue] 
   * @return {Command} `this` command for chaining 
   */</span>
  <span class="s0">argument(name, description, fn, defaultValue) {</span>
    <span class="s0">const argument = </span><span class="s3">this</span><span class="s0">.createArgument(name, description);</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">fn === </span><span class="s1">'function'</span><span class="s0">) {</span>
      <span class="s0">argument.</span><span class="s3">default</span><span class="s0">(defaultValue).argParser(fn);</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s0">argument.</span><span class="s3">default</span><span class="s0">(fn);</span>
    <span class="s0">}</span>
    <span class="s3">this</span><span class="s0">.addArgument(argument);</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Define argument syntax for command, adding multiple at once (without descriptions). 
   * 
   * See also .argument(). 
   * 
   * @example 
   * program.arguments('&lt;cmd&gt; [env]'); 
   * 
   * @param {string} names 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">arguments(names) {</span>
    <span class="s0">names.split(/ +/).forEach((detail) =&gt; {</span>
      <span class="s3">this</span><span class="s0">.argument(detail);</span>
    <span class="s0">});</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Define argument syntax for command, adding a prepared argument. 
   * 
   * @param {Argument} argument 
   * @return {Command} `this` command for chaining 
   */</span>
  <span class="s0">addArgument(argument) {</span>
    <span class="s0">const previousArgument = </span><span class="s3">this</span><span class="s0">._args.slice(-</span><span class="s4">1</span><span class="s0">)[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s3">if </span><span class="s0">(previousArgument &amp;&amp; previousArgument.variadic) {</span>
      <span class="s3">throw new </span><span class="s0">Error(`only the last argument can be variadic </span><span class="s1">'${previousArgument.name()}'</span><span class="s0">`);</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(argument.required &amp;&amp; argument.defaultValue !== undefined &amp;&amp; argument.parseArg === undefined) {</span>
      <span class="s3">throw new </span><span class="s0">Error(`a </span><span class="s3">default </span><span class="s0">value </span><span class="s3">for </span><span class="s0">a required argument is never used: </span><span class="s1">'${argument.name()}'</span><span class="s0">`);</span>
    <span class="s0">}</span>
    <span class="s3">this</span><span class="s0">._args.push(argument);</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Override default decision whether to add implicit help command. 
   * 
   *    addHelpCommand() // force on 
   *    addHelpCommand(false); // force off 
   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details 
   * 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">addHelpCommand(enableOrNameAndArgs, description) {</span>
    <span class="s3">if </span><span class="s0">(enableOrNameAndArgs === </span><span class="s3">false</span><span class="s0">) {</span>
      <span class="s3">this</span><span class="s0">._addImplicitHelpCommand = </span><span class="s3">false</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s3">this</span><span class="s0">._addImplicitHelpCommand = </span><span class="s3">true</span><span class="s0">;</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">enableOrNameAndArgs === </span><span class="s1">'string'</span><span class="s0">) {</span>
        <span class="s3">this</span><span class="s0">._helpCommandName = enableOrNameAndArgs.split(</span><span class="s1">' '</span><span class="s0">)[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s3">this</span><span class="s0">._helpCommandnameAndArgs = enableOrNameAndArgs;</span>
      <span class="s0">}</span>
      <span class="s3">this</span><span class="s0">._helpCommandDescription = description || </span><span class="s3">this</span><span class="s0">._helpCommandDescription;</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * @return {boolean} 
   * @api private 
   */</span>

  <span class="s0">_hasImplicitHelpCommand() {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._addImplicitHelpCommand === undefined) {</span>
      <span class="s3">return this</span><span class="s0">.commands.length &amp;&amp; !</span><span class="s3">this</span><span class="s0">._actionHandler &amp;&amp; !</span><span class="s3">this</span><span class="s0">._findCommand(</span><span class="s1">'help'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">._addImplicitHelpCommand;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Add hook for life cycle event. 
   * 
   * @param {string} event 
   * @param {Function} listener 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">hook(event, listener) {</span>
    <span class="s0">const allowedValues = [</span><span class="s1">'preSubcommand'</span><span class="s0">, </span><span class="s1">'preAction'</span><span class="s0">, </span><span class="s1">'postAction'</span><span class="s0">];</span>
    <span class="s3">if </span><span class="s0">(!allowedValues.includes(event)) {</span>
      <span class="s3">throw new </span><span class="s0">Error(`Unexpected value </span><span class="s3">for </span><span class="s0">event passed to hook : </span><span class="s1">'${event}'</span><span class="s0">.</span>
<span class="s0">Expecting one of </span><span class="s1">'${allowedValues.join(&quot;'</span><span class="s0">, </span><span class="s1">'&quot;)}'</span><span class="s0">`);</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._lifeCycleHooks[event]) {</span>
      <span class="s3">this</span><span class="s0">._lifeCycleHooks[event].push(listener);</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s3">this</span><span class="s0">._lifeCycleHooks[event] = [listener];</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Register callback to use as replacement for calling process.exit. 
   * 
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">exitOverride(fn) {</span>
    <span class="s3">if </span><span class="s0">(fn) {</span>
      <span class="s3">this</span><span class="s0">._exitCallback = fn;</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s3">this</span><span class="s0">._exitCallback = (err) =&gt; {</span>
        <span class="s3">if </span><span class="s0">(err.code !== </span><span class="s1">'commander.executeSubCommandAsync'</span><span class="s0">) {</span>
          <span class="s3">throw </span><span class="s0">err;</span>
        <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
          <span class="s2">// Async callback from spawn events, not useful to throw.</span>
        <span class="s0">}</span>
      <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Call process.exit, and _exitCallback if defined. 
   * 
   * @param {number} exitCode exit code for using with process.exit 
   * @param {string} code an id string representing the error 
   * @param {string} message human-readable description of the error 
   * @return never 
   * @api private 
   */</span>

  <span class="s0">_exit(exitCode, code, message) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._exitCallback) {</span>
      <span class="s3">this</span><span class="s0">._exitCallback(</span><span class="s3">new </span><span class="s0">CommanderError(exitCode, code, message));</span>
      <span class="s2">// Expecting this line is not reached.</span>
    <span class="s0">}</span>
    <span class="s0">process.exit(exitCode);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Register callback `fn` for the command. 
   * 
   * @example 
   * program 
   *   .command('serve') 
   *   .description('start service') 
   *   .action(function() { 
   *      // do work here 
   *   }); 
   * 
   * @param {Function} fn 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">action(fn) {</span>
    <span class="s0">const listener = (args) =&gt; {</span>
      <span class="s2">// The .action callback takes an extra parameter which is the command or options.</span>
      <span class="s0">const expectedArgsCount = </span><span class="s3">this</span><span class="s0">._args.length;</span>
      <span class="s0">const actionArgs = args.slice(</span><span class="s4">0</span><span class="s0">, expectedArgsCount);</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._storeOptionsAsProperties) {</span>
        <span class="s0">actionArgs[expectedArgsCount] = </span><span class="s3">this</span><span class="s0">; </span><span class="s2">// backwards compatible &quot;options&quot;</span>
      <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
        <span class="s0">actionArgs[expectedArgsCount] = </span><span class="s3">this</span><span class="s0">.opts();</span>
      <span class="s0">}</span>
      <span class="s0">actionArgs.push(</span><span class="s3">this</span><span class="s0">);</span>

      <span class="s3">return </span><span class="s0">fn.apply(</span><span class="s3">this</span><span class="s0">, actionArgs);</span>
    <span class="s0">};</span>
    <span class="s3">this</span><span class="s0">._actionHandler = listener;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Factory routine to create a new unattached option. 
   * 
   * See .option() for creating an attached option, which uses this routine to 
   * create the option. You can override createOption to return a custom option. 
   * 
   * @param {string} flags 
   * @param {string} [description] 
   * @return {Option} new option 
   */</span>

  <span class="s0">createOption(flags, description) {</span>
    <span class="s3">return new </span><span class="s0">Option(flags, description);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Add an option. 
   * 
   * @param {Option} option 
   * @return {Command} `this` command for chaining 
   */</span>
  <span class="s0">addOption(option) {</span>
    <span class="s0">const oname = option.name();</span>
    <span class="s0">const name = option.attributeName();</span>

    <span class="s2">// store default value</span>
    <span class="s3">if </span><span class="s0">(option.negate) {</span>
      <span class="s2">// --no-foo is special and defaults foo to true, unless a --foo option is already defined</span>
      <span class="s0">const positiveLongFlag = option.long.replace(/^--no-/, </span><span class="s1">'--'</span><span class="s0">);</span>
      <span class="s3">if </span><span class="s0">(!</span><span class="s3">this</span><span class="s0">._findOption(positiveLongFlag)) {</span>
        <span class="s3">this</span><span class="s0">.setOptionValueWithSource(name, option.defaultValue === undefined ? </span><span class="s3">true </span><span class="s0">: option.defaultValue, </span><span class="s1">'default'</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">else if </span><span class="s0">(option.defaultValue !== undefined) {</span>
      <span class="s3">this</span><span class="s0">.setOptionValueWithSource(name, option.defaultValue, </span><span class="s1">'default'</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s2">// register the option</span>
    <span class="s3">this</span><span class="s0">.options.push(option);</span>

    <span class="s2">// handler for cli and env supplied values</span>
    <span class="s0">const handleOptionValue = (val, invalidValueMessage, valueSource) =&gt; {</span>
      <span class="s2">// val is null for optional option used without an optional-argument.</span>
      <span class="s2">// val is undefined for boolean and negated option.</span>
      <span class="s3">if </span><span class="s0">(val == </span><span class="s3">null </span><span class="s0">&amp;&amp; option.presetArg !== undefined) {</span>
        <span class="s0">val = option.presetArg;</span>
      <span class="s0">}</span>

      <span class="s2">// custom processing</span>
      <span class="s0">const oldValue = </span><span class="s3">this</span><span class="s0">.getOptionValue(name);</span>
      <span class="s3">if </span><span class="s0">(val !== </span><span class="s3">null </span><span class="s0">&amp;&amp; option.parseArg) {</span>
        <span class="s3">try </span><span class="s0">{</span>
          <span class="s0">val = option.parseArg(val, oldValue);</span>
        <span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
          <span class="s3">if </span><span class="s0">(err.code === </span><span class="s1">'commander.invalidArgument'</span><span class="s0">) {</span>
            <span class="s0">const message = `${invalidValueMessage} ${err.message}`;</span>
            <span class="s3">this</span><span class="s0">.error(message, { exitCode: err.exitCode, code: err.code });</span>
          <span class="s0">}</span>
          <span class="s3">throw </span><span class="s0">err;</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s3">else if </span><span class="s0">(val !== </span><span class="s3">null </span><span class="s0">&amp;&amp; option.variadic) {</span>
        <span class="s0">val = option._concatValue(val, oldValue);</span>
      <span class="s0">}</span>

      <span class="s2">// Fill-in appropriate missing values. Long winded but easy to follow.</span>
      <span class="s3">if </span><span class="s0">(val == </span><span class="s3">null</span><span class="s0">) {</span>
        <span class="s3">if </span><span class="s0">(option.negate) {</span>
          <span class="s0">val = </span><span class="s3">false</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">else if </span><span class="s0">(option.isBoolean() || option.optional) {</span>
          <span class="s0">val = </span><span class="s3">true</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
          <span class="s0">val = </span><span class="s1">''</span><span class="s0">; </span><span class="s2">// not normal, parseArg might have failed or be a mock function for testing</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
      <span class="s3">this</span><span class="s0">.setOptionValueWithSource(name, val, valueSource);</span>
    <span class="s0">};</span>

    <span class="s3">this</span><span class="s0">.on(</span><span class="s1">'option:' </span><span class="s0">+ oname, (val) =&gt; {</span>
      <span class="s0">const invalidValueMessage = `error: option </span><span class="s1">'${option.flags}' </span><span class="s0">argument </span><span class="s1">'${val}' </span><span class="s0">is invalid.`;</span>
      <span class="s0">handleOptionValue(val, invalidValueMessage, </span><span class="s1">'cli'</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s3">if </span><span class="s0">(option.envVar) {</span>
      <span class="s3">this</span><span class="s0">.on(</span><span class="s1">'optionEnv:' </span><span class="s0">+ oname, (val) =&gt; {</span>
        <span class="s0">const invalidValueMessage = `error: option </span><span class="s1">'${option.flags}' </span><span class="s0">value </span><span class="s1">'${val}' </span><span class="s0">from env </span><span class="s1">'${option.envVar}' </span><span class="s0">is invalid.`;</span>
        <span class="s0">handleOptionValue(val, invalidValueMessage, </span><span class="s1">'env'</span><span class="s0">);</span>
      <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Internal implementation shared by .option() and .requiredOption() 
   * 
   * @api private 
   */</span>
  <span class="s0">_optionEx(config, flags, description, fn, defaultValue) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">flags === </span><span class="s1">'object' </span><span class="s0">&amp;&amp; flags </span><span class="s3">instanceof </span><span class="s0">Option) {</span>
      <span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'To add an Option object use addOption() instead of option() or requiredOption()'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">const option = </span><span class="s3">this</span><span class="s0">.createOption(flags, description);</span>
    <span class="s0">option.makeOptionMandatory(!!config.mandatory);</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">fn === </span><span class="s1">'function'</span><span class="s0">) {</span>
      <span class="s0">option.</span><span class="s3">default</span><span class="s0">(defaultValue).argParser(fn);</span>
    <span class="s0">} </span><span class="s3">else if </span><span class="s0">(fn </span><span class="s3">instanceof </span><span class="s0">RegExp) {</span>
      <span class="s2">// deprecated</span>
      <span class="s0">const regex = fn;</span>
      <span class="s0">fn = (val, def) =&gt; {</span>
        <span class="s0">const m = regex.exec(val);</span>
        <span class="s3">return </span><span class="s0">m ? m[</span><span class="s4">0</span><span class="s0">] : def;</span>
      <span class="s0">};</span>
      <span class="s0">option.</span><span class="s3">default</span><span class="s0">(defaultValue).argParser(fn);</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s0">option.</span><span class="s3">default</span><span class="s0">(fn);</span>
    <span class="s0">}</span>

    <span class="s3">return this</span><span class="s0">.addOption(option);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Define option with `flags`, `description` and optional 
   * coercion `fn`. 
   * 
   * The `flags` string contains the short and/or long flags, 
   * separated by comma, a pipe or space. The following are all valid 
   * all will output this way when `--help` is used. 
   * 
   *     &quot;-p, --pepper&quot; 
   *     &quot;-p|--pepper&quot; 
   *     &quot;-p --pepper&quot; 
   * 
   * @example 
   * // simple boolean defaulting to undefined 
   * program.option('-p, --pepper', 'add pepper'); 
   * 
   * program.pepper 
   * // =&gt; undefined 
   * 
   * --pepper 
   * program.pepper 
   * // =&gt; true 
   * 
   * // simple boolean defaulting to true (unless non-negated option is also defined) 
   * program.option('-C, --no-cheese', 'remove cheese'); 
   * 
   * program.cheese 
   * // =&gt; true 
   * 
   * --no-cheese 
   * program.cheese 
   * // =&gt; false 
   * 
   * // required argument 
   * program.option('-C, --chdir &lt;path&gt;', 'change the working directory'); 
   * 
   * --chdir /tmp 
   * program.chdir 
   * // =&gt; &quot;/tmp&quot; 
   * 
   * // optional argument 
   * program.option('-c, --cheese [type]', 'add cheese [marble]'); 
   * 
   * @param {string} flags 
   * @param {string} [description] 
   * @param {Function|*} [fn] - custom option processing function or default value 
   * @param {*} [defaultValue] 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">option(flags, description, fn, defaultValue) {</span>
    <span class="s3">return this</span><span class="s0">._optionEx({}, flags, description, fn, defaultValue);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
  * Add a required option which must have a value after parsing. This usually means 
  * the option must be specified on the command line. (Otherwise the same as .option().) 
  * 
  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. 
  * 
  * @param {string} flags 
  * @param {string} [description] 
  * @param {Function|*} [fn] - custom option processing function or default value 
  * @param {*} [defaultValue] 
  * @return {Command} `this` command for chaining 
  */</span>

  <span class="s0">requiredOption(flags, description, fn, defaultValue) {</span>
    <span class="s3">return this</span><span class="s0">._optionEx({ mandatory: </span><span class="s3">true </span><span class="s0">}, flags, description, fn, defaultValue);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Alter parsing of short flags with optional values. 
   * 
   * @example 
   * // for `.option('-f,--flag [value]'): 
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour 
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b` 
   * 
   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag. 
   */</span>
  <span class="s0">combineFlagAndOptionalValue(combine = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">this</span><span class="s0">._combineFlagAndOptionalValue = !!combine;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Allow unknown options on the command line. 
   * 
   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown 
   * for unknown options. 
   */</span>
  <span class="s0">allowUnknownOption(allowUnknown = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">this</span><span class="s0">._allowUnknownOption = !!allowUnknown;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error. 
   * 
   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown 
   * for excess arguments. 
   */</span>
  <span class="s0">allowExcessArguments(allowExcess = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">this</span><span class="s0">._allowExcessArguments = !!allowExcess;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Enable positional options. Positional means global options are specified before subcommands which lets 
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions. 
   * The default behaviour is non-positional and global options may appear anywhere on the command line. 
   * 
   * @param {Boolean} [positional=true] 
   */</span>
  <span class="s0">enablePositionalOptions(positional = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">this</span><span class="s0">._enablePositionalOptions = !!positional;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Pass through options that come after command-arguments rather than treat them as command-options, 
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires 
   * positional options to have been enabled on the program (parent commands). 
   * The default behaviour is non-positional and options may appear before or after command-arguments. 
   * 
   * @param {Boolean} [passThrough=true] 
   * for unknown options. 
   */</span>
  <span class="s0">passThroughOptions(passThrough = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">this</span><span class="s0">._passThroughOptions = !!passThrough;</span>
    <span class="s3">if </span><span class="s0">(!!</span><span class="s3">this</span><span class="s0">.parent &amp;&amp; passThrough &amp;&amp; !</span><span class="s3">this</span><span class="s0">.parent._enablePositionalOptions) {</span>
      <span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
    * Whether to store option values as properties on command object, 
    * or store separately (specify false). In both cases the option values can be accessed using .opts(). 
    * 
    * @param {boolean} [storeAsProperties=true] 
    * @return {Command} `this` command for chaining 
    */</span>

  <span class="s0">storeOptionsAsProperties(storeAsProperties = </span><span class="s3">true</span><span class="s0">) {</span>
    <span class="s3">this</span><span class="s0">._storeOptionsAsProperties = !!storeAsProperties;</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.options.length) {</span>
      <span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'call .storeOptionsAsProperties() before adding options'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Retrieve option value. 
   * 
   * @param {string} key 
   * @return {Object} value 
   */</span>

  <span class="s0">getOptionValue(key) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._storeOptionsAsProperties) {</span>
      <span class="s3">return this</span><span class="s0">[key];</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">._optionValues[key];</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Store option value. 
   * 
   * @param {string} key 
   * @param {Object} value 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">setOptionValue(key, value) {</span>
    <span class="s3">return this</span><span class="s0">.setOptionValueWithSource(key, value, undefined);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
    * Store option value and where the value came from. 
    * 
    * @param {string} key 
    * @param {Object} value 
    * @param {string} source - expected values are default/config/env/cli/implied 
    * @return {Command} `this` command for chaining 
    */</span>

  <span class="s0">setOptionValueWithSource(key, value, source) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._storeOptionsAsProperties) {</span>
      <span class="s3">this</span><span class="s0">[key] = value;</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s3">this</span><span class="s0">._optionValues[key] = value;</span>
    <span class="s0">}</span>
    <span class="s3">this</span><span class="s0">._optionValueSources[key] = source;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
    * Get source of option value. 
    * Expected values are default | config | env | cli | implied 
    * 
    * @param {string} key 
    * @return {string} 
    */</span>

  <span class="s0">getOptionValueSource(key) {</span>
    <span class="s3">return this</span><span class="s0">._optionValueSources[key];</span>
  <span class="s0">}</span>

  <span class="s2">/** 
    * Get source of option value. See also .optsWithGlobals(). 
    * Expected values are default | config | env | cli | implied 
    * 
    * @param {string} key 
    * @return {string} 
    */</span>

  <span class="s0">getOptionValueSourceWithGlobals(key) {</span>
    <span class="s2">// global overwrites local, like optsWithGlobals</span>
    <span class="s0">let source;</span>
    <span class="s0">getCommandAndParents(</span><span class="s3">this</span><span class="s0">).forEach((cmd) =&gt; {</span>
      <span class="s3">if </span><span class="s0">(cmd.getOptionValueSource(key) !== undefined) {</span>
        <span class="s0">source = cmd.getOptionValueSource(key);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s3">return </span><span class="s0">source;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Get user arguments from implied or explicit arguments. 
   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches. 
   * 
   * @api private 
   */</span>

  <span class="s0">_prepareUserArgs(argv, parseOptions) {</span>
    <span class="s3">if </span><span class="s0">(argv !== undefined &amp;&amp; !Array.isArray(argv)) {</span>
      <span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'first parameter to parse must be array or undefined'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">parseOptions = parseOptions || {};</span>

    <span class="s2">// Default to using process.argv</span>
    <span class="s3">if </span><span class="s0">(argv === undefined) {</span>
      <span class="s0">argv = process.argv;</span>
      <span class="s2">// @ts-ignore: unknown property</span>
      <span class="s3">if </span><span class="s0">(process.versions &amp;&amp; process.versions.electron) {</span>
        <span class="s0">parseOptions.from = </span><span class="s1">'electron'</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">this</span><span class="s0">.rawArgs = argv.slice();</span>

    <span class="s2">// make it a little easier for callers by supporting various argv conventions</span>
    <span class="s0">let userArgs;</span>
    <span class="s3">switch </span><span class="s0">(parseOptions.from) {</span>
      <span class="s3">case </span><span class="s0">undefined:</span>
      <span class="s3">case </span><span class="s1">'node'</span><span class="s0">:</span>
        <span class="s3">this</span><span class="s0">._scriptPath = argv[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s0">userArgs = argv.slice(</span><span class="s4">2</span><span class="s0">);</span>
        <span class="s3">break</span><span class="s0">;</span>
      <span class="s3">case </span><span class="s1">'electron'</span><span class="s0">:</span>
        <span class="s2">// @ts-ignore: unknown property</span>
        <span class="s3">if </span><span class="s0">(process.defaultApp) {</span>
          <span class="s3">this</span><span class="s0">._scriptPath = argv[</span><span class="s4">1</span><span class="s0">];</span>
          <span class="s0">userArgs = argv.slice(</span><span class="s4">2</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
          <span class="s0">userArgs = argv.slice(</span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s3">break</span><span class="s0">;</span>
      <span class="s3">case </span><span class="s1">'user'</span><span class="s0">:</span>
        <span class="s0">userArgs = argv.slice(</span><span class="s4">0</span><span class="s0">);</span>
        <span class="s3">break</span><span class="s0">;</span>
      <span class="s3">default</span><span class="s0">:</span>
        <span class="s3">throw new </span><span class="s0">Error(`unexpected parse option { from: </span><span class="s1">'${parseOptions.from}' </span><span class="s0">}`);</span>
    <span class="s0">}</span>

    <span class="s2">// Find default name for program from arguments.</span>
    <span class="s3">if </span><span class="s0">(!</span><span class="s3">this</span><span class="s0">._name &amp;&amp; </span><span class="s3">this</span><span class="s0">._scriptPath) </span><span class="s3">this</span><span class="s0">.nameFromFilename(</span><span class="s3">this</span><span class="s0">._scriptPath);</span>
    <span class="s3">this</span><span class="s0">._name = </span><span class="s3">this</span><span class="s0">._name || </span><span class="s1">'program'</span><span class="s0">;</span>

    <span class="s3">return </span><span class="s0">userArgs;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Parse `argv`, setting options and invoking commands when defined. 
   * 
   * The default expectation is that the arguments are from node and have the application as argv[0] 
   * and the script being run in argv[1], with user parameters after that. 
   * 
   * @example 
   * program.parse(process.argv); 
   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions 
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0] 
   * 
   * @param {string[]} [argv] - optional, defaults to process.argv 
   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron 
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron' 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">parse(argv, parseOptions) {</span>
    <span class="s0">const userArgs = </span><span class="s3">this</span><span class="s0">._prepareUserArgs(argv, parseOptions);</span>
    <span class="s3">this</span><span class="s0">._parseCommand([], userArgs);</span>

    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Parse `argv`, setting options and invoking commands when defined. 
   * 
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise. 
   * 
   * The default expectation is that the arguments are from node and have the application as argv[0] 
   * and the script being run in argv[1], with user parameters after that. 
   * 
   * @example 
   * await program.parseAsync(process.argv); 
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions 
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0] 
   * 
   * @param {string[]} [argv] 
   * @param {Object} [parseOptions] 
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron' 
   * @return {Promise} 
   */</span>

  <span class="s0">async parseAsync(argv, parseOptions) {</span>
    <span class="s0">const userArgs = </span><span class="s3">this</span><span class="s0">._prepareUserArgs(argv, parseOptions);</span>
    <span class="s0">await </span><span class="s3">this</span><span class="s0">._parseCommand([], userArgs);</span>

    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Execute a sub-command executable. 
   * 
   * @api private 
   */</span>

  <span class="s0">_executeSubCommand(subcommand, args) {</span>
    <span class="s0">args = args.slice();</span>
    <span class="s0">let launchWithNode = </span><span class="s3">false</span><span class="s0">; </span><span class="s2">// Use node for source targets so do not need to get permissions correct, and on Windows.</span>
    <span class="s0">const sourceExt = [</span><span class="s1">'.js'</span><span class="s0">, </span><span class="s1">'.ts'</span><span class="s0">, </span><span class="s1">'.tsx'</span><span class="s0">, </span><span class="s1">'.mjs'</span><span class="s0">, </span><span class="s1">'.cjs'</span><span class="s0">];</span>

    <span class="s3">function </span><span class="s0">findFile(baseDir, baseName) {</span>
      <span class="s2">// Look for specified file</span>
      <span class="s0">const localBin = path.resolve(baseDir, baseName);</span>
      <span class="s3">if </span><span class="s0">(fs.existsSync(localBin)) </span><span class="s3">return </span><span class="s0">localBin;</span>

      <span class="s2">// Stop looking if candidate already has an expected extension.</span>
      <span class="s3">if </span><span class="s0">(sourceExt.includes(path.extname(baseName))) </span><span class="s3">return </span><span class="s0">undefined;</span>

      <span class="s2">// Try all the extensions.</span>
      <span class="s0">const foundExt = sourceExt.find(ext =&gt; fs.existsSync(`${localBin}${ext}`));</span>
      <span class="s3">if </span><span class="s0">(foundExt) </span><span class="s3">return </span><span class="s0">`${localBin}${foundExt}`;</span>

      <span class="s3">return </span><span class="s0">undefined;</span>
    <span class="s0">}</span>

    <span class="s2">// Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.</span>
    <span class="s3">this</span><span class="s0">._checkForMissingMandatoryOptions();</span>
    <span class="s3">this</span><span class="s0">._checkForConflictingOptions();</span>

    <span class="s2">// executableFile and executableDir might be full path, or just a name</span>
    <span class="s0">let executableFile = subcommand._executableFile || `${</span><span class="s3">this</span><span class="s0">._name}-${subcommand._name}`;</span>
    <span class="s0">let executableDir = </span><span class="s3">this</span><span class="s0">._executableDir || </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._scriptPath) {</span>
      <span class="s0">let resolvedScriptPath; </span><span class="s2">// resolve possible symlink for installed npm binary</span>
      <span class="s3">try </span><span class="s0">{</span>
        <span class="s0">resolvedScriptPath = fs.realpathSync(</span><span class="s3">this</span><span class="s0">._scriptPath);</span>
      <span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
        <span class="s0">resolvedScriptPath = </span><span class="s3">this</span><span class="s0">._scriptPath;</span>
      <span class="s0">}</span>
      <span class="s0">executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);</span>
    <span class="s0">}</span>

    <span class="s2">// Look for a local file in preference to a command in PATH.</span>
    <span class="s3">if </span><span class="s0">(executableDir) {</span>
      <span class="s0">let localFile = findFile(executableDir, executableFile);</span>

      <span class="s2">// Legacy search using prefix of script name instead of command name</span>
      <span class="s3">if </span><span class="s0">(!localFile &amp;&amp; !subcommand._executableFile &amp;&amp; </span><span class="s3">this</span><span class="s0">._scriptPath) {</span>
        <span class="s0">const legacyName = path.basename(</span><span class="s3">this</span><span class="s0">._scriptPath, path.extname(</span><span class="s3">this</span><span class="s0">._scriptPath));</span>
        <span class="s3">if </span><span class="s0">(legacyName !== </span><span class="s3">this</span><span class="s0">._name) {</span>
          <span class="s0">localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
      <span class="s0">executableFile = localFile || executableFile;</span>
    <span class="s0">}</span>

    <span class="s0">launchWithNode = sourceExt.includes(path.extname(executableFile));</span>

    <span class="s0">let proc;</span>
    <span class="s3">if </span><span class="s0">(process.platform !== </span><span class="s1">'win32'</span><span class="s0">) {</span>
      <span class="s3">if </span><span class="s0">(launchWithNode) {</span>
        <span class="s0">args.unshift(executableFile);</span>
        <span class="s2">// add executable arguments to spawn</span>
        <span class="s0">args = incrementNodeInspectorPort(process.execArgv).concat(args);</span>

        <span class="s0">proc = childProcess.spawn(process.argv[</span><span class="s4">0</span><span class="s0">], args, { stdio: </span><span class="s1">'inherit' </span><span class="s0">});</span>
      <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
        <span class="s0">proc = childProcess.spawn(executableFile, args, { stdio: </span><span class="s1">'inherit' </span><span class="s0">});</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s0">args.unshift(executableFile);</span>
      <span class="s2">// add executable arguments to spawn</span>
      <span class="s0">args = incrementNodeInspectorPort(process.execArgv).concat(args);</span>
      <span class="s0">proc = childProcess.spawn(process.execPath, args, { stdio: </span><span class="s1">'inherit' </span><span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">if </span><span class="s0">(!proc.killed) { </span><span class="s2">// testing mainly to avoid leak warnings during unit tests with mocked spawn</span>
      <span class="s0">const signals = [</span><span class="s1">'SIGUSR1'</span><span class="s0">, </span><span class="s1">'SIGUSR2'</span><span class="s0">, </span><span class="s1">'SIGTERM'</span><span class="s0">, </span><span class="s1">'SIGINT'</span><span class="s0">, </span><span class="s1">'SIGHUP'</span><span class="s0">];</span>
      <span class="s0">signals.forEach((signal) =&gt; {</span>
        <span class="s2">// @ts-ignore</span>
        <span class="s0">process.on(signal, () =&gt; {</span>
          <span class="s3">if </span><span class="s0">(proc.killed === </span><span class="s3">false </span><span class="s0">&amp;&amp; proc.exitCode === </span><span class="s3">null</span><span class="s0">) {</span>
            <span class="s0">proc.kill(signal);</span>
          <span class="s0">}</span>
        <span class="s0">});</span>
      <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s2">// By default terminate process when spawned process terminates.</span>
    <span class="s2">// Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!</span>
    <span class="s0">const exitCallback = </span><span class="s3">this</span><span class="s0">._exitCallback;</span>
    <span class="s3">if </span><span class="s0">(!exitCallback) {</span>
      <span class="s0">proc.on(</span><span class="s1">'close'</span><span class="s0">, process.exit.bind(process));</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s0">proc.on(</span><span class="s1">'close'</span><span class="s0">, () =&gt; {</span>
        <span class="s0">exitCallback(</span><span class="s3">new </span><span class="s0">CommanderError(process.exitCode || </span><span class="s4">0</span><span class="s0">, </span><span class="s1">'commander.executeSubCommandAsync'</span><span class="s0">, </span><span class="s1">'(close)'</span><span class="s0">));</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">proc.on(</span><span class="s1">'error'</span><span class="s0">, (err) =&gt; {</span>
      <span class="s2">// @ts-ignore</span>
      <span class="s3">if </span><span class="s0">(err.code === </span><span class="s1">'ENOENT'</span><span class="s0">) {</span>
        <span class="s0">const executableDirMessage = executableDir</span>
          <span class="s0">? `searched </span><span class="s3">for </span><span class="s0">local subcommand relative to directory </span><span class="s1">'${executableDir}'</span><span class="s0">`</span>
          <span class="s0">: </span><span class="s1">'no directory for search for local subcommand, use .executableDir() to supply a custom directory'</span><span class="s0">;</span>
        <span class="s0">const executableMissing = `</span><span class="s1">'${executableFile}' </span><span class="s0">does not exist</span>
 <span class="s0">- </span><span class="s3">if </span><span class="s1">'${subcommand._name}' </span><span class="s0">is not meant to be an executable command, remove description parameter from </span><span class="s1">'.command()' </span><span class="s0">and use </span><span class="s1">'.description()' </span><span class="s0">instead</span>
 <span class="s0">- </span><span class="s3">if </span><span class="s0">the </span><span class="s3">default </span><span class="s0">executable name is not suitable, use the executableFile option to supply a custom name or path</span>
 <span class="s0">- ${executableDirMessage}`;</span>
        <span class="s3">throw new </span><span class="s0">Error(executableMissing);</span>
      <span class="s2">// @ts-ignore</span>
      <span class="s0">} </span><span class="s3">else if </span><span class="s0">(err.code === </span><span class="s1">'EACCES'</span><span class="s0">) {</span>
        <span class="s3">throw new </span><span class="s0">Error(`</span><span class="s1">'${executableFile}' </span><span class="s0">not executable`);</span>
      <span class="s0">}</span>
      <span class="s3">if </span><span class="s0">(!exitCallback) {</span>
        <span class="s0">process.exit(</span><span class="s4">1</span><span class="s0">);</span>
      <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
        <span class="s0">const wrappedError = </span><span class="s3">new </span><span class="s0">CommanderError(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">'commander.executeSubCommandAsync'</span><span class="s0">, </span><span class="s1">'(error)'</span><span class="s0">);</span>
        <span class="s0">wrappedError.nestedError = err;</span>
        <span class="s0">exitCallback(wrappedError);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>

    <span class="s2">// Store the reference to the child process</span>
    <span class="s3">this</span><span class="s0">.runningCommand = proc;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * @api private 
   */</span>

  <span class="s0">_dispatchSubcommand(commandName, operands, unknown) {</span>
    <span class="s0">const subCommand = </span><span class="s3">this</span><span class="s0">._findCommand(commandName);</span>
    <span class="s3">if </span><span class="s0">(!subCommand) </span><span class="s3">this</span><span class="s0">.help({ error: </span><span class="s3">true </span><span class="s0">});</span>

    <span class="s0">let hookResult;</span>
    <span class="s0">hookResult = </span><span class="s3">this</span><span class="s0">._chainOrCallSubCommandHook(hookResult, subCommand, </span><span class="s1">'preSubcommand'</span><span class="s0">);</span>
    <span class="s0">hookResult = </span><span class="s3">this</span><span class="s0">._chainOrCall(hookResult, () =&gt; {</span>
      <span class="s3">if </span><span class="s0">(subCommand._executableHandler) {</span>
        <span class="s3">this</span><span class="s0">._executeSubCommand(subCommand, operands.concat(unknown));</span>
      <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
        <span class="s3">return </span><span class="s0">subCommand._parseCommand(operands, unknown);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s3">return </span><span class="s0">hookResult;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Check this.args against expected this._args. 
   * 
   * @api private 
   */</span>

  <span class="s0">_checkNumberOfArguments() {</span>
    <span class="s2">// too few</span>
    <span class="s3">this</span><span class="s0">._args.forEach((arg, i) =&gt; {</span>
      <span class="s3">if </span><span class="s0">(arg.required &amp;&amp; </span><span class="s3">this</span><span class="s0">.args[i] == </span><span class="s3">null</span><span class="s0">) {</span>
        <span class="s3">this</span><span class="s0">.missingArgument(arg.name());</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s2">// too many</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._args.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; </span><span class="s3">this</span><span class="s0">._args[</span><span class="s3">this</span><span class="s0">._args.length - </span><span class="s4">1</span><span class="s0">].variadic) {</span>
      <span class="s3">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.args.length &gt; </span><span class="s3">this</span><span class="s0">._args.length) {</span>
      <span class="s3">this</span><span class="s0">._excessArguments(</span><span class="s3">this</span><span class="s0">.args);</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Process this.args using this._args and save as this.processedArgs! 
   * 
   * @api private 
   */</span>

  <span class="s0">_processArguments() {</span>
    <span class="s0">const myParseArg = (argument, value, previous) =&gt; {</span>
      <span class="s2">// Extra processing for nice error message on parsing failure.</span>
      <span class="s0">let parsedValue = value;</span>
      <span class="s3">if </span><span class="s0">(value !== </span><span class="s3">null </span><span class="s0">&amp;&amp; argument.parseArg) {</span>
        <span class="s3">try </span><span class="s0">{</span>
          <span class="s0">parsedValue = argument.parseArg(value, previous);</span>
        <span class="s0">} </span><span class="s3">catch </span><span class="s0">(err) {</span>
          <span class="s3">if </span><span class="s0">(err.code === </span><span class="s1">'commander.invalidArgument'</span><span class="s0">) {</span>
            <span class="s0">const message = `error: command-argument value </span><span class="s1">'${value}' </span><span class="s0">is invalid </span><span class="s3">for </span><span class="s0">argument </span><span class="s1">'${argument.name()}'</span><span class="s0">. ${err.message}`;</span>
            <span class="s3">this</span><span class="s0">.error(message, { exitCode: err.exitCode, code: err.code });</span>
          <span class="s0">}</span>
          <span class="s3">throw </span><span class="s0">err;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
      <span class="s3">return </span><span class="s0">parsedValue;</span>
    <span class="s0">};</span>

    <span class="s3">this</span><span class="s0">._checkNumberOfArguments();</span>

    <span class="s0">const processedArgs = [];</span>
    <span class="s3">this</span><span class="s0">._args.forEach((declaredArg, index) =&gt; {</span>
      <span class="s0">let value = declaredArg.defaultValue;</span>
      <span class="s3">if </span><span class="s0">(declaredArg.variadic) {</span>
        <span class="s2">// Collect together remaining arguments for passing together as an array.</span>
        <span class="s3">if </span><span class="s0">(index &lt; </span><span class="s3">this</span><span class="s0">.args.length) {</span>
          <span class="s0">value = </span><span class="s3">this</span><span class="s0">.args.slice(index);</span>
          <span class="s3">if </span><span class="s0">(declaredArg.parseArg) {</span>
            <span class="s0">value = value.reduce((processed, v) =&gt; {</span>
              <span class="s3">return </span><span class="s0">myParseArg(declaredArg, v, processed);</span>
            <span class="s0">}, declaredArg.defaultValue);</span>
          <span class="s0">}</span>
        <span class="s0">} </span><span class="s3">else if </span><span class="s0">(value === undefined) {</span>
          <span class="s0">value = [];</span>
        <span class="s0">}</span>
      <span class="s0">} </span><span class="s3">else if </span><span class="s0">(index &lt; </span><span class="s3">this</span><span class="s0">.args.length) {</span>
        <span class="s0">value = </span><span class="s3">this</span><span class="s0">.args[index];</span>
        <span class="s3">if </span><span class="s0">(declaredArg.parseArg) {</span>
          <span class="s0">value = myParseArg(declaredArg, value, declaredArg.defaultValue);</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
      <span class="s0">processedArgs[index] = value;</span>
    <span class="s0">});</span>
    <span class="s3">this</span><span class="s0">.processedArgs = processedArgs;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Once we have a promise we chain, but call synchronously until then. 
   * 
   * @param {Promise|undefined} promise 
   * @param {Function} fn 
   * @return {Promise|undefined} 
   * @api private 
   */</span>

  <span class="s0">_chainOrCall(promise, fn) {</span>
    <span class="s2">// thenable</span>
    <span class="s3">if </span><span class="s0">(promise &amp;&amp; promise.then &amp;&amp; </span><span class="s3">typeof </span><span class="s0">promise.then === </span><span class="s1">'function'</span><span class="s0">) {</span>
      <span class="s2">// already have a promise, chain callback</span>
      <span class="s3">return </span><span class="s0">promise.then(() =&gt; fn());</span>
    <span class="s0">}</span>
    <span class="s2">// callback might return a promise</span>
    <span class="s3">return </span><span class="s0">fn();</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * 
   * @param {Promise|undefined} promise 
   * @param {string} event 
   * @return {Promise|undefined} 
   * @api private 
   */</span>

  <span class="s0">_chainOrCallHooks(promise, event) {</span>
    <span class="s0">let result = promise;</span>
    <span class="s0">const hooks = [];</span>
    <span class="s0">getCommandAndParents(</span><span class="s3">this</span><span class="s0">)</span>
      <span class="s0">.reverse()</span>
      <span class="s0">.filter(cmd =&gt; cmd._lifeCycleHooks[event] !== undefined)</span>
      <span class="s0">.forEach(hookedCommand =&gt; {</span>
        <span class="s0">hookedCommand._lifeCycleHooks[event].forEach((callback) =&gt; {</span>
          <span class="s0">hooks.push({ hookedCommand, callback });</span>
        <span class="s0">});</span>
      <span class="s0">});</span>
    <span class="s3">if </span><span class="s0">(event === </span><span class="s1">'postAction'</span><span class="s0">) {</span>
      <span class="s0">hooks.reverse();</span>
    <span class="s0">}</span>

    <span class="s0">hooks.forEach((hookDetail) =&gt; {</span>
      <span class="s0">result = </span><span class="s3">this</span><span class="s0">._chainOrCall(result, () =&gt; {</span>
        <span class="s3">return </span><span class="s0">hookDetail.callback(hookDetail.hookedCommand, </span><span class="s3">this</span><span class="s0">);</span>
      <span class="s0">});</span>
    <span class="s0">});</span>
    <span class="s3">return </span><span class="s0">result;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * 
   * @param {Promise|undefined} promise 
   * @param {Command} subCommand 
   * @param {string} event 
   * @return {Promise|undefined} 
   * @api private 
   */</span>

  <span class="s0">_chainOrCallSubCommandHook(promise, subCommand, event) {</span>
    <span class="s0">let result = promise;</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._lifeCycleHooks[event] !== undefined) {</span>
      <span class="s3">this</span><span class="s0">._lifeCycleHooks[event].forEach((hook) =&gt; {</span>
        <span class="s0">result = </span><span class="s3">this</span><span class="s0">._chainOrCall(result, () =&gt; {</span>
          <span class="s3">return </span><span class="s0">hook(</span><span class="s3">this</span><span class="s0">, subCommand);</span>
        <span class="s0">});</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">result;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Process arguments in context of this command. 
   * Returns action result, in case it is a promise. 
   * 
   * @api private 
   */</span>

  <span class="s0">_parseCommand(operands, unknown) {</span>
    <span class="s0">const parsed = </span><span class="s3">this</span><span class="s0">.parseOptions(unknown);</span>
    <span class="s3">this</span><span class="s0">._parseOptionsEnv(); </span><span class="s2">// after cli, so parseArg not called on both cli and env</span>
    <span class="s3">this</span><span class="s0">._parseOptionsImplied();</span>
    <span class="s0">operands = operands.concat(parsed.operands);</span>
    <span class="s0">unknown = parsed.unknown;</span>
    <span class="s3">this</span><span class="s0">.args = operands.concat(unknown);</span>

    <span class="s3">if </span><span class="s0">(operands &amp;&amp; </span><span class="s3">this</span><span class="s0">._findCommand(operands[</span><span class="s4">0</span><span class="s0">])) {</span>
      <span class="s3">return this</span><span class="s0">._dispatchSubcommand(operands[</span><span class="s4">0</span><span class="s0">], operands.slice(</span><span class="s4">1</span><span class="s0">), unknown);</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._hasImplicitHelpCommand() &amp;&amp; operands[</span><span class="s4">0</span><span class="s0">] === </span><span class="s3">this</span><span class="s0">._helpCommandName) {</span>
      <span class="s3">if </span><span class="s0">(operands.length === </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">this</span><span class="s0">.help();</span>
      <span class="s0">}</span>
      <span class="s3">return this</span><span class="s0">._dispatchSubcommand(operands[</span><span class="s4">1</span><span class="s0">], [], [</span><span class="s3">this</span><span class="s0">._helpLongFlag]);</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._defaultCommandName) {</span>
      <span class="s0">outputHelpIfRequested(</span><span class="s3">this</span><span class="s0">, unknown); </span><span class="s2">// Run the help for default command from parent rather than passing to default command</span>
      <span class="s3">return this</span><span class="s0">._dispatchSubcommand(</span><span class="s3">this</span><span class="s0">._defaultCommandName, operands, unknown);</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.commands.length &amp;&amp; </span><span class="s3">this</span><span class="s0">.args.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; !</span><span class="s3">this</span><span class="s0">._actionHandler &amp;&amp; !</span><span class="s3">this</span><span class="s0">._defaultCommandName) {</span>
      <span class="s2">// probably missing subcommand and no handler, user needs help (and exit)</span>
      <span class="s3">this</span><span class="s0">.help({ error: </span><span class="s3">true </span><span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s0">outputHelpIfRequested(</span><span class="s3">this</span><span class="s0">, parsed.unknown);</span>
    <span class="s3">this</span><span class="s0">._checkForMissingMandatoryOptions();</span>
    <span class="s3">this</span><span class="s0">._checkForConflictingOptions();</span>

    <span class="s2">// We do not always call this check to avoid masking a &quot;better&quot; error, like unknown command.</span>
    <span class="s0">const checkForUnknownOptions = () =&gt; {</span>
      <span class="s3">if </span><span class="s0">(parsed.unknown.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s3">this</span><span class="s0">.unknownOption(parsed.unknown[</span><span class="s4">0</span><span class="s0">]);</span>
      <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s0">const commandEvent = `command:${</span><span class="s3">this</span><span class="s0">.name()}`;</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._actionHandler) {</span>
      <span class="s0">checkForUnknownOptions();</span>
      <span class="s3">this</span><span class="s0">._processArguments();</span>

      <span class="s0">let actionResult;</span>
      <span class="s0">actionResult = </span><span class="s3">this</span><span class="s0">._chainOrCallHooks(actionResult, </span><span class="s1">'preAction'</span><span class="s0">);</span>
      <span class="s0">actionResult = </span><span class="s3">this</span><span class="s0">._chainOrCall(actionResult, () =&gt; </span><span class="s3">this</span><span class="s0">._actionHandler(</span><span class="s3">this</span><span class="s0">.processedArgs));</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.parent) {</span>
        <span class="s0">actionResult = </span><span class="s3">this</span><span class="s0">._chainOrCall(actionResult, () =&gt; {</span>
          <span class="s3">this</span><span class="s0">.parent.emit(commandEvent, operands, unknown); </span><span class="s2">// legacy</span>
        <span class="s0">});</span>
      <span class="s0">}</span>
      <span class="s0">actionResult = </span><span class="s3">this</span><span class="s0">._chainOrCallHooks(actionResult, </span><span class="s1">'postAction'</span><span class="s0">);</span>
      <span class="s3">return </span><span class="s0">actionResult;</span>
    <span class="s0">}</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.parent &amp;&amp; </span><span class="s3">this</span><span class="s0">.parent.listenerCount(commandEvent)) {</span>
      <span class="s0">checkForUnknownOptions();</span>
      <span class="s3">this</span><span class="s0">._processArguments();</span>
      <span class="s3">this</span><span class="s0">.parent.emit(commandEvent, operands, unknown); </span><span class="s2">// legacy</span>
    <span class="s0">} </span><span class="s3">else if </span><span class="s0">(operands.length) {</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._findCommand(</span><span class="s1">'*'</span><span class="s0">)) { </span><span class="s2">// legacy default command</span>
        <span class="s3">return this</span><span class="s0">._dispatchSubcommand(</span><span class="s1">'*'</span><span class="s0">, operands, unknown);</span>
      <span class="s0">}</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.listenerCount(</span><span class="s1">'command:*'</span><span class="s0">)) {</span>
        <span class="s2">// skip option check, emit event for possible misspelling suggestion</span>
        <span class="s3">this</span><span class="s0">.emit(</span><span class="s1">'command:*'</span><span class="s0">, operands, unknown);</span>
      <span class="s0">} </span><span class="s3">else if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.commands.length) {</span>
        <span class="s3">this</span><span class="s0">.unknownCommand();</span>
      <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
        <span class="s0">checkForUnknownOptions();</span>
        <span class="s3">this</span><span class="s0">._processArguments();</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">else if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.commands.length) {</span>
      <span class="s0">checkForUnknownOptions();</span>
      <span class="s2">// This command has subcommands and nothing hooked up at this level, so display help (and exit).</span>
      <span class="s3">this</span><span class="s0">.help({ error: </span><span class="s3">true </span><span class="s0">});</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s0">checkForUnknownOptions();</span>
      <span class="s3">this</span><span class="s0">._processArguments();</span>
      <span class="s2">// fall through for caller to handle after calling .parse()</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Find matching command. 
   * 
   * @api private 
   */</span>
  <span class="s0">_findCommand(name) {</span>
    <span class="s3">if </span><span class="s0">(!name) </span><span class="s3">return </span><span class="s0">undefined;</span>
    <span class="s3">return this</span><span class="s0">.commands.find(cmd =&gt; cmd._name === name || cmd._aliases.includes(name));</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Return an option matching `arg` if any. 
   * 
   * @param {string} arg 
   * @return {Option} 
   * @api private 
   */</span>

  <span class="s0">_findOption(arg) {</span>
    <span class="s3">return this</span><span class="s0">.options.find(option =&gt; option.is(arg));</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Display an error message if a mandatory option does not have a value. 
   * Called after checking for help flags in leaf subcommand. 
   * 
   * @api private 
   */</span>

  <span class="s0">_checkForMissingMandatoryOptions() {</span>
    <span class="s2">// Walk up hierarchy so can call in subcommand after checking for displaying help.</span>
    <span class="s3">for </span><span class="s0">(let cmd = </span><span class="s3">this</span><span class="s0">; cmd; cmd = cmd.parent) {</span>
      <span class="s0">cmd.options.forEach((anOption) =&gt; {</span>
        <span class="s3">if </span><span class="s0">(anOption.mandatory &amp;&amp; (cmd.getOptionValue(anOption.attributeName()) === undefined)) {</span>
          <span class="s0">cmd.missingMandatoryOptionValue(anOption);</span>
        <span class="s0">}</span>
      <span class="s0">});</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Display an error message if conflicting options are used together in this. 
   * 
   * @api private 
   */</span>
  <span class="s0">_checkForConflictingLocalOptions() {</span>
    <span class="s0">const definedNonDefaultOptions = </span><span class="s3">this</span><span class="s0">.options.filter(</span>
      <span class="s0">(option) =&gt; {</span>
        <span class="s0">const optionKey = option.attributeName();</span>
        <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.getOptionValue(optionKey) === undefined) {</span>
          <span class="s3">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">return this</span><span class="s0">.getOptionValueSource(optionKey) !== </span><span class="s1">'default'</span><span class="s0">;</span>
      <span class="s0">}</span>
    <span class="s0">);</span>

    <span class="s0">const optionsWithConflicting = definedNonDefaultOptions.filter(</span>
      <span class="s0">(option) =&gt; option.conflictsWith.length &gt; </span><span class="s4">0</span>
    <span class="s0">);</span>

    <span class="s0">optionsWithConflicting.forEach((option) =&gt; {</span>
      <span class="s0">const conflictingAndDefined = definedNonDefaultOptions.find((defined) =&gt;</span>
        <span class="s0">option.conflictsWith.includes(defined.attributeName())</span>
      <span class="s0">);</span>
      <span class="s3">if </span><span class="s0">(conflictingAndDefined) {</span>
        <span class="s3">this</span><span class="s0">._conflictingOption(option, conflictingAndDefined);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Display an error message if conflicting options are used together. 
   * Called after checking for help flags in leaf subcommand. 
   * 
   * @api private 
   */</span>
  <span class="s0">_checkForConflictingOptions() {</span>
    <span class="s2">// Walk up hierarchy so can call in subcommand after checking for displaying help.</span>
    <span class="s3">for </span><span class="s0">(let cmd = </span><span class="s3">this</span><span class="s0">; cmd; cmd = cmd.parent) {</span>
      <span class="s0">cmd._checkForConflictingLocalOptions();</span>
    <span class="s0">}</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Parse options from `argv` removing known options, 
   * and return argv split into operands and unknown arguments. 
   * 
   * Examples: 
   * 
   *     argv =&gt; operands, unknown 
   *     --known kkk op =&gt; [op], [] 
   *     op --known kkk =&gt; [op], [] 
   *     sub --unknown uuu op =&gt; [sub], [--unknown uuu op] 
   *     sub -- --unknown uuu op =&gt; [sub --unknown uuu op], [] 
   * 
   * @param {String[]} argv 
   * @return {{operands: String[], unknown: String[]}} 
   */</span>

  <span class="s0">parseOptions(argv) {</span>
    <span class="s0">const operands = []; </span><span class="s2">// operands, not options or values</span>
    <span class="s0">const unknown = []; </span><span class="s2">// first unknown option and remaining unknown args</span>
    <span class="s0">let dest = operands;</span>
    <span class="s0">const args = argv.slice();</span>

    <span class="s3">function </span><span class="s0">maybeOption(arg) {</span>
      <span class="s3">return </span><span class="s0">arg.length &gt; </span><span class="s4">1 </span><span class="s0">&amp;&amp; arg[</span><span class="s4">0</span><span class="s0">] === </span><span class="s1">'-'</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s2">// parse options</span>
    <span class="s0">let activeVariadicOption = </span><span class="s3">null</span><span class="s0">;</span>
    <span class="s3">while </span><span class="s0">(args.length) {</span>
      <span class="s0">const arg = args.shift();</span>

      <span class="s2">// literal</span>
      <span class="s3">if </span><span class="s0">(arg === </span><span class="s1">'--'</span><span class="s0">) {</span>
        <span class="s3">if </span><span class="s0">(dest === unknown) dest.push(arg);</span>
        <span class="s0">dest.push(...args);</span>
        <span class="s3">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s3">if </span><span class="s0">(activeVariadicOption &amp;&amp; !maybeOption(arg)) {</span>
        <span class="s3">this</span><span class="s0">.emit(`option:${activeVariadicOption.name()}`, arg);</span>
        <span class="s3">continue</span><span class="s0">;</span>
      <span class="s0">}</span>
      <span class="s0">activeVariadicOption = </span><span class="s3">null</span><span class="s0">;</span>

      <span class="s3">if </span><span class="s0">(maybeOption(arg)) {</span>
        <span class="s0">const option = </span><span class="s3">this</span><span class="s0">._findOption(arg);</span>
        <span class="s2">// recognised option, call listener to assign value with possible custom processing</span>
        <span class="s3">if </span><span class="s0">(option) {</span>
          <span class="s3">if </span><span class="s0">(option.required) {</span>
            <span class="s0">const value = args.shift();</span>
            <span class="s3">if </span><span class="s0">(value === undefined) </span><span class="s3">this</span><span class="s0">.optionMissingArgument(option);</span>
            <span class="s3">this</span><span class="s0">.emit(`option:${option.name()}`, value);</span>
          <span class="s0">} </span><span class="s3">else if </span><span class="s0">(option.optional) {</span>
            <span class="s0">let value = </span><span class="s3">null</span><span class="s0">;</span>
            <span class="s2">// historical behaviour is optional value is following arg unless an option</span>
            <span class="s3">if </span><span class="s0">(args.length &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; !maybeOption(args[</span><span class="s4">0</span><span class="s0">])) {</span>
              <span class="s0">value = args.shift();</span>
            <span class="s0">}</span>
            <span class="s3">this</span><span class="s0">.emit(`option:${option.name()}`, value);</span>
          <span class="s0">} </span><span class="s3">else </span><span class="s0">{ </span><span class="s2">// boolean flag</span>
            <span class="s3">this</span><span class="s0">.emit(`option:${option.name()}`);</span>
          <span class="s0">}</span>
          <span class="s0">activeVariadicOption = option.variadic ? option : </span><span class="s3">null</span><span class="s0">;</span>
          <span class="s3">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">// Look for combo options following single dash, eat first one if known.</span>
      <span class="s3">if </span><span class="s0">(arg.length &gt; </span><span class="s4">2 </span><span class="s0">&amp;&amp; arg[</span><span class="s4">0</span><span class="s0">] === </span><span class="s1">'-' </span><span class="s0">&amp;&amp; arg[</span><span class="s4">1</span><span class="s0">] !== </span><span class="s1">'-'</span><span class="s0">) {</span>
        <span class="s0">const option = </span><span class="s3">this</span><span class="s0">._findOption(`-${arg[</span><span class="s4">1</span><span class="s0">]}`);</span>
        <span class="s3">if </span><span class="s0">(option) {</span>
          <span class="s3">if </span><span class="s0">(option.required || (option.optional &amp;&amp; </span><span class="s3">this</span><span class="s0">._combineFlagAndOptionalValue)) {</span>
            <span class="s2">// option with value following in same argument</span>
            <span class="s3">this</span><span class="s0">.emit(`option:${option.name()}`, arg.slice(</span><span class="s4">2</span><span class="s0">));</span>
          <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
            <span class="s2">// boolean option, emit and put back remainder of arg for further processing</span>
            <span class="s3">this</span><span class="s0">.emit(`option:${option.name()}`);</span>
            <span class="s0">args.unshift(`-${arg.slice(</span><span class="s4">2</span><span class="s0">)}`);</span>
          <span class="s0">}</span>
          <span class="s3">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">// Look for known long flag with value, like --foo=bar</span>
      <span class="s3">if </span><span class="s0">(/^--[^=]+=/.test(arg)) {</span>
        <span class="s0">const index = arg.indexOf(</span><span class="s1">'='</span><span class="s0">);</span>
        <span class="s0">const option = </span><span class="s3">this</span><span class="s0">._findOption(arg.slice(</span><span class="s4">0</span><span class="s0">, index));</span>
        <span class="s3">if </span><span class="s0">(option &amp;&amp; (option.required || option.optional)) {</span>
          <span class="s3">this</span><span class="s0">.emit(`option:${option.name()}`, arg.slice(index + </span><span class="s4">1</span><span class="s0">));</span>
          <span class="s3">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">// Not a recognised option by this command.</span>
      <span class="s2">// Might be a command-argument, or subcommand option, or unknown option, or help command or option.</span>

      <span class="s2">// An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.</span>
      <span class="s3">if </span><span class="s0">(maybeOption(arg)) {</span>
        <span class="s0">dest = unknown;</span>
      <span class="s0">}</span>

      <span class="s2">// If using positionalOptions, stop processing our options at subcommand.</span>
      <span class="s3">if </span><span class="s0">((</span><span class="s3">this</span><span class="s0">._enablePositionalOptions || </span><span class="s3">this</span><span class="s0">._passThroughOptions) &amp;&amp; operands.length === </span><span class="s4">0 </span><span class="s0">&amp;&amp; unknown.length === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._findCommand(arg)) {</span>
          <span class="s0">operands.push(arg);</span>
          <span class="s3">if </span><span class="s0">(args.length &gt; </span><span class="s4">0</span><span class="s0">) unknown.push(...args);</span>
          <span class="s3">break</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">else if </span><span class="s0">(arg === </span><span class="s3">this</span><span class="s0">._helpCommandName &amp;&amp; </span><span class="s3">this</span><span class="s0">._hasImplicitHelpCommand()) {</span>
          <span class="s0">operands.push(arg);</span>
          <span class="s3">if </span><span class="s0">(args.length &gt; </span><span class="s4">0</span><span class="s0">) operands.push(...args);</span>
          <span class="s3">break</span><span class="s0">;</span>
        <span class="s0">} </span><span class="s3">else if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._defaultCommandName) {</span>
          <span class="s0">unknown.push(arg);</span>
          <span class="s3">if </span><span class="s0">(args.length &gt; </span><span class="s4">0</span><span class="s0">) unknown.push(...args);</span>
          <span class="s3">break</span><span class="s0">;</span>
        <span class="s0">}</span>
      <span class="s0">}</span>

      <span class="s2">// If using passThroughOptions, stop processing options at first command-argument.</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._passThroughOptions) {</span>
        <span class="s0">dest.push(arg);</span>
        <span class="s3">if </span><span class="s0">(args.length &gt; </span><span class="s4">0</span><span class="s0">) dest.push(...args);</span>
        <span class="s3">break</span><span class="s0">;</span>
      <span class="s0">}</span>

      <span class="s2">// add arg</span>
      <span class="s0">dest.push(arg);</span>
    <span class="s0">}</span>

    <span class="s3">return </span><span class="s0">{ operands, unknown };</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Return an object containing local option values as key-value pairs. 
   * 
   * @return {Object} 
   */</span>
  <span class="s0">opts() {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._storeOptionsAsProperties) {</span>
      <span class="s2">// Preserve original behaviour so backwards compatible when still using properties</span>
      <span class="s0">const result = {};</span>
      <span class="s0">const len = </span><span class="s3">this</span><span class="s0">.options.length;</span>

      <span class="s3">for </span><span class="s0">(let i = </span><span class="s4">0</span><span class="s0">; i &lt; len; i++) {</span>
        <span class="s0">const key = </span><span class="s3">this</span><span class="s0">.options[i].attributeName();</span>
        <span class="s0">result[key] = key === </span><span class="s3">this</span><span class="s0">._versionOptionName ? </span><span class="s3">this</span><span class="s0">._version : </span><span class="s3">this</span><span class="s0">[key];</span>
      <span class="s0">}</span>
      <span class="s3">return </span><span class="s0">result;</span>
    <span class="s0">}</span>

    <span class="s3">return this</span><span class="s0">._optionValues;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Return an object containing merged local and global option values as key-value pairs. 
   * 
   * @return {Object} 
   */</span>
  <span class="s0">optsWithGlobals() {</span>
    <span class="s2">// globals overwrite locals</span>
    <span class="s3">return </span><span class="s0">getCommandAndParents(</span><span class="s3">this</span><span class="s0">).reduce(</span>
      <span class="s0">(combinedOptions, cmd) =&gt; Object.assign(combinedOptions, cmd.opts()),</span>
      <span class="s0">{}</span>
    <span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Display error message and exit (or call exitOverride). 
   * 
   * @param {string} message 
   * @param {Object} [errorOptions] 
   * @param {string} [errorOptions.code] - an id string representing the error 
   * @param {number} [errorOptions.exitCode] - used with process.exit 
   */</span>
  <span class="s0">error(message, errorOptions) {</span>
    <span class="s2">// output handling</span>
    <span class="s3">this</span><span class="s0">._outputConfiguration.outputError(`${message}\n`, </span><span class="s3">this</span><span class="s0">._outputConfiguration.writeErr);</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof this</span><span class="s0">._showHelpAfterError === </span><span class="s1">'string'</span><span class="s0">) {</span>
      <span class="s3">this</span><span class="s0">._outputConfiguration.writeErr(`${</span><span class="s3">this</span><span class="s0">._showHelpAfterError}\n`);</span>
    <span class="s0">} </span><span class="s3">else if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._showHelpAfterError) {</span>
      <span class="s3">this</span><span class="s0">._outputConfiguration.writeErr(</span><span class="s1">'</span><span class="s5">\n</span><span class="s1">'</span><span class="s0">);</span>
      <span class="s3">this</span><span class="s0">.outputHelp({ error: </span><span class="s3">true </span><span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s2">// exit handling</span>
    <span class="s0">const config = errorOptions || {};</span>
    <span class="s0">const exitCode = config.exitCode || </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">const code = config.code || </span><span class="s1">'commander.error'</span><span class="s0">;</span>
    <span class="s3">this</span><span class="s0">._exit(exitCode, code, message);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Apply any option related environment variables, if option does 
   * not have a value from cli or client code. 
   * 
   * @api private 
   */</span>
  <span class="s0">_parseOptionsEnv() {</span>
    <span class="s3">this</span><span class="s0">.options.forEach((option) =&gt; {</span>
      <span class="s3">if </span><span class="s0">(option.envVar &amp;&amp; option.envVar </span><span class="s3">in </span><span class="s0">process.env) {</span>
        <span class="s0">const optionKey = option.attributeName();</span>
        <span class="s2">// Priority check. Do not overwrite cli or options from unknown source (client-code).</span>
        <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.getOptionValue(optionKey) === undefined || [</span><span class="s1">'default'</span><span class="s0">, </span><span class="s1">'config'</span><span class="s0">, </span><span class="s1">'env'</span><span class="s0">].includes(</span><span class="s3">this</span><span class="s0">.getOptionValueSource(optionKey))) {</span>
          <span class="s3">if </span><span class="s0">(option.required || option.optional) { </span><span class="s2">// option can take a value</span>
            <span class="s2">// keep very simple, optional always takes value</span>
            <span class="s3">this</span><span class="s0">.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);</span>
          <span class="s0">} </span><span class="s3">else </span><span class="s0">{ </span><span class="s2">// boolean</span>
            <span class="s2">// keep very simple, only care that envVar defined and not the value</span>
            <span class="s3">this</span><span class="s0">.emit(`optionEnv:${option.name()}`);</span>
          <span class="s0">}</span>
        <span class="s0">}</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Apply any implied option values, if option is undefined or default value. 
   * 
   * @api private 
   */</span>
  <span class="s0">_parseOptionsImplied() {</span>
    <span class="s0">const dualHelper = </span><span class="s3">new </span><span class="s0">DualOptions(</span><span class="s3">this</span><span class="s0">.options);</span>
    <span class="s0">const hasCustomOptionValue = (optionKey) =&gt; {</span>
      <span class="s3">return this</span><span class="s0">.getOptionValue(optionKey) !== undefined &amp;&amp; ![</span><span class="s1">'default'</span><span class="s0">, </span><span class="s1">'implied'</span><span class="s0">].includes(</span><span class="s3">this</span><span class="s0">.getOptionValueSource(optionKey));</span>
    <span class="s0">};</span>
    <span class="s3">this</span><span class="s0">.options</span>
      <span class="s0">.filter(option =&gt; (option.implied !== undefined) &amp;&amp;</span>
        <span class="s0">hasCustomOptionValue(option.attributeName()) &amp;&amp;</span>
        <span class="s0">dualHelper.valueFromOption(</span><span class="s3">this</span><span class="s0">.getOptionValue(option.attributeName()), option))</span>
      <span class="s0">.forEach((option) =&gt; {</span>
        <span class="s0">Object.keys(option.implied)</span>
          <span class="s0">.filter(impliedKey =&gt; !hasCustomOptionValue(impliedKey))</span>
          <span class="s0">.forEach(impliedKey =&gt; {</span>
            <span class="s3">this</span><span class="s0">.setOptionValueWithSource(impliedKey, option.implied[impliedKey], </span><span class="s1">'implied'</span><span class="s0">);</span>
          <span class="s0">});</span>
      <span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Argument `name` is missing. 
   * 
   * @param {string} name 
   * @api private 
   */</span>

  <span class="s0">missingArgument(name) {</span>
    <span class="s0">const message = `error: missing required argument </span><span class="s1">'${name}'</span><span class="s0">`;</span>
    <span class="s3">this</span><span class="s0">.error(message, { code: </span><span class="s1">'commander.missingArgument' </span><span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * `Option` is missing an argument. 
   * 
   * @param {Option} option 
   * @api private 
   */</span>

  <span class="s0">optionMissingArgument(option) {</span>
    <span class="s0">const message = `error: option </span><span class="s1">'${option.flags}' </span><span class="s0">argument missing`;</span>
    <span class="s3">this</span><span class="s0">.error(message, { code: </span><span class="s1">'commander.optionMissingArgument' </span><span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * `Option` does not have a value, and is a mandatory option. 
   * 
   * @param {Option} option 
   * @api private 
   */</span>

  <span class="s0">missingMandatoryOptionValue(option) {</span>
    <span class="s0">const message = `error: required option </span><span class="s1">'${option.flags}' </span><span class="s0">not specified`;</span>
    <span class="s3">this</span><span class="s0">.error(message, { code: </span><span class="s1">'commander.missingMandatoryOptionValue' </span><span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * `Option` conflicts with another option. 
   * 
   * @param {Option} option 
   * @param {Option} conflictingOption 
   * @api private 
   */</span>
  <span class="s0">_conflictingOption(option, conflictingOption) {</span>
    <span class="s2">// The calling code does not know whether a negated option is the source of the</span>
    <span class="s2">// value, so do some work to take an educated guess.</span>
    <span class="s0">const findBestOptionFromValue = (option) =&gt; {</span>
      <span class="s0">const optionKey = option.attributeName();</span>
      <span class="s0">const optionValue = </span><span class="s3">this</span><span class="s0">.getOptionValue(optionKey);</span>
      <span class="s0">const negativeOption = </span><span class="s3">this</span><span class="s0">.options.find(target =&gt; target.negate &amp;&amp; optionKey === target.attributeName());</span>
      <span class="s0">const positiveOption = </span><span class="s3">this</span><span class="s0">.options.find(target =&gt; !target.negate &amp;&amp; optionKey === target.attributeName());</span>
      <span class="s3">if </span><span class="s0">(negativeOption &amp;&amp; (</span>
        <span class="s0">(negativeOption.presetArg === undefined &amp;&amp; optionValue === </span><span class="s3">false</span><span class="s0">) ||</span>
        <span class="s0">(negativeOption.presetArg !== undefined &amp;&amp; optionValue === negativeOption.presetArg)</span>
      <span class="s0">)) {</span>
        <span class="s3">return </span><span class="s0">negativeOption;</span>
      <span class="s0">}</span>
      <span class="s3">return </span><span class="s0">positiveOption || option;</span>
    <span class="s0">};</span>

    <span class="s0">const getErrorMessage = (option) =&gt; {</span>
      <span class="s0">const bestOption = findBestOptionFromValue(option);</span>
      <span class="s0">const optionKey = bestOption.attributeName();</span>
      <span class="s0">const source = </span><span class="s3">this</span><span class="s0">.getOptionValueSource(optionKey);</span>
      <span class="s3">if </span><span class="s0">(source === </span><span class="s1">'env'</span><span class="s0">) {</span>
        <span class="s3">return </span><span class="s0">`environment variable </span><span class="s1">'${bestOption.envVar}'</span><span class="s0">`;</span>
      <span class="s0">}</span>
      <span class="s3">return </span><span class="s0">`option </span><span class="s1">'${bestOption.flags}'</span><span class="s0">`;</span>
    <span class="s0">};</span>

    <span class="s0">const message = `error: ${getErrorMessage(option)} cannot be used </span><span class="s3">with </span><span class="s0">${getErrorMessage(conflictingOption)}`;</span>
    <span class="s3">this</span><span class="s0">.error(message, { code: </span><span class="s1">'commander.conflictingOption' </span><span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Unknown option `flag`. 
   * 
   * @param {string} flag 
   * @api private 
   */</span>

  <span class="s0">unknownOption(flag) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._allowUnknownOption) </span><span class="s3">return</span><span class="s0">;</span>
    <span class="s0">let suggestion = </span><span class="s1">''</span><span class="s0">;</span>

    <span class="s3">if </span><span class="s0">(flag.startsWith(</span><span class="s1">'--'</span><span class="s0">) &amp;&amp; </span><span class="s3">this</span><span class="s0">._showSuggestionAfterError) {</span>
      <span class="s2">// Looping to pick up the global options too</span>
      <span class="s0">let candidateFlags = [];</span>
      <span class="s0">let command = </span><span class="s3">this</span><span class="s0">;</span>
      <span class="s3">do </span><span class="s0">{</span>
        <span class="s0">const moreFlags = command.createHelp().visibleOptions(command)</span>
          <span class="s0">.filter(option =&gt; option.long)</span>
          <span class="s0">.map(option =&gt; option.long);</span>
        <span class="s0">candidateFlags = candidateFlags.concat(moreFlags);</span>
        <span class="s0">command = command.parent;</span>
      <span class="s0">} </span><span class="s3">while </span><span class="s0">(command &amp;&amp; !command._enablePositionalOptions);</span>
      <span class="s0">suggestion = suggestSimilar(flag, candidateFlags);</span>
    <span class="s0">}</span>

    <span class="s0">const message = `error: unknown option </span><span class="s1">'${flag}'</span><span class="s0">${suggestion}`;</span>
    <span class="s3">this</span><span class="s0">.error(message, { code: </span><span class="s1">'commander.unknownOption' </span><span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Excess arguments, more than expected. 
   * 
   * @param {string[]} receivedArgs 
   * @api private 
   */</span>

  <span class="s0">_excessArguments(receivedArgs) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._allowExcessArguments) </span><span class="s3">return</span><span class="s0">;</span>

    <span class="s0">const expected = </span><span class="s3">this</span><span class="s0">._args.length;</span>
    <span class="s0">const s = (expected === </span><span class="s4">1</span><span class="s0">) ? </span><span class="s1">'' </span><span class="s0">: </span><span class="s1">'s'</span><span class="s0">;</span>
    <span class="s0">const forSubcommand = </span><span class="s3">this</span><span class="s0">.parent ? ` </span><span class="s3">for </span><span class="s1">'${this.name()}'</span><span class="s0">` : </span><span class="s1">''</span><span class="s0">;</span>
    <span class="s0">const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;</span>
    <span class="s3">this</span><span class="s0">.error(message, { code: </span><span class="s1">'commander.excessArguments' </span><span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Unknown command. 
   * 
   * @api private 
   */</span>

  <span class="s0">unknownCommand() {</span>
    <span class="s0">const unknownName = </span><span class="s3">this</span><span class="s0">.args[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s0">let suggestion = </span><span class="s1">''</span><span class="s0">;</span>

    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._showSuggestionAfterError) {</span>
      <span class="s0">const candidateNames = [];</span>
      <span class="s3">this</span><span class="s0">.createHelp().visibleCommands(</span><span class="s3">this</span><span class="s0">).forEach((command) =&gt; {</span>
        <span class="s0">candidateNames.push(command.name());</span>
        <span class="s2">// just visible alias</span>
        <span class="s3">if </span><span class="s0">(command.alias()) candidateNames.push(command.alias());</span>
      <span class="s0">});</span>
      <span class="s0">suggestion = suggestSimilar(unknownName, candidateNames);</span>
    <span class="s0">}</span>

    <span class="s0">const message = `error: unknown command </span><span class="s1">'${unknownName}'</span><span class="s0">${suggestion}`;</span>
    <span class="s3">this</span><span class="s0">.error(message, { code: </span><span class="s1">'commander.unknownCommand' </span><span class="s0">});</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Set the program version to `str`. 
   * 
   * This method auto-registers the &quot;-V, --version&quot; flag 
   * which will print the version number when passed. 
   * 
   * You can optionally supply the  flags and description to override the defaults. 
   * 
   * @param {string} str 
   * @param {string} [flags] 
   * @param {string} [description] 
   * @return {this | string} `this` command for chaining, or version string if no arguments 
   */</span>

  <span class="s0">version(str, flags, description) {</span>
    <span class="s3">if </span><span class="s0">(str === undefined) </span><span class="s3">return this</span><span class="s0">._version;</span>
    <span class="s3">this</span><span class="s0">._version = str;</span>
    <span class="s0">flags = flags || </span><span class="s1">'-V, --version'</span><span class="s0">;</span>
    <span class="s0">description = description || </span><span class="s1">'output the version number'</span><span class="s0">;</span>
    <span class="s0">const versionOption = </span><span class="s3">this</span><span class="s0">.createOption(flags, description);</span>
    <span class="s3">this</span><span class="s0">._versionOptionName = versionOption.attributeName();</span>
    <span class="s3">this</span><span class="s0">.options.push(versionOption);</span>
    <span class="s3">this</span><span class="s0">.on(</span><span class="s1">'option:' </span><span class="s0">+ versionOption.name(), () =&gt; {</span>
      <span class="s3">this</span><span class="s0">._outputConfiguration.writeOut(`${str}\n`);</span>
      <span class="s3">this</span><span class="s0">._exit(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">'commander.version'</span><span class="s0">, str);</span>
    <span class="s0">});</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Set the description. 
   * 
   * @param {string} [str] 
   * @param {Object} [argsDescription] 
   * @return {string|Command} 
   */</span>
  <span class="s0">description(str, argsDescription) {</span>
    <span class="s3">if </span><span class="s0">(str === undefined &amp;&amp; argsDescription === undefined) </span><span class="s3">return this</span><span class="s0">._description;</span>
    <span class="s3">this</span><span class="s0">._description = str;</span>
    <span class="s3">if </span><span class="s0">(argsDescription) {</span>
      <span class="s3">this</span><span class="s0">._argsDescription = argsDescription;</span>
    <span class="s0">}</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Set the summary. Used when listed as subcommand of parent. 
   * 
   * @param {string} [str] 
   * @return {string|Command} 
   */</span>
  <span class="s0">summary(str) {</span>
    <span class="s3">if </span><span class="s0">(str === undefined) </span><span class="s3">return this</span><span class="s0">._summary;</span>
    <span class="s3">this</span><span class="s0">._summary = str;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Set an alias for the command. 
   * 
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help. 
   * 
   * @param {string} [alias] 
   * @return {string|Command} 
   */</span>

  <span class="s0">alias(alias) {</span>
    <span class="s3">if </span><span class="s0">(alias === undefined) </span><span class="s3">return this</span><span class="s0">._aliases[</span><span class="s4">0</span><span class="s0">]; </span><span class="s2">// just return first, for backwards compatibility</span>

    <span class="s2">/** @type {Command} */</span>
    <span class="s0">let command = </span><span class="s3">this</span><span class="s0">;</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">.commands.length !== </span><span class="s4">0 </span><span class="s0">&amp;&amp; </span><span class="s3">this</span><span class="s0">.commands[</span><span class="s3">this</span><span class="s0">.commands.length - </span><span class="s4">1</span><span class="s0">]._executableHandler) {</span>
      <span class="s2">// assume adding alias for last added executable subcommand, rather than this</span>
      <span class="s0">command = </span><span class="s3">this</span><span class="s0">.commands[</span><span class="s3">this</span><span class="s0">.commands.length - </span><span class="s4">1</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s3">if </span><span class="s0">(alias === command._name) </span><span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'Command alias can</span><span class="s5">\'</span><span class="s1">t be the same as its name'</span><span class="s0">);</span>

    <span class="s0">command._aliases.push(alias);</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Set aliases for the command. 
   * 
   * Only the first alias is shown in the auto-generated help. 
   * 
   * @param {string[]} [aliases] 
   * @return {string[]|Command} 
   */</span>

  <span class="s0">aliases(aliases) {</span>
    <span class="s2">// Getter for the array of aliases is the main reason for having aliases() in addition to alias().</span>
    <span class="s3">if </span><span class="s0">(aliases === undefined) </span><span class="s3">return this</span><span class="s0">._aliases;</span>

    <span class="s0">aliases.forEach((alias) =&gt; </span><span class="s3">this</span><span class="s0">.alias(alias));</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Set / get the command usage `str`. 
   * 
   * @param {string} [str] 
   * @return {String|Command} 
   */</span>

  <span class="s0">usage(str) {</span>
    <span class="s3">if </span><span class="s0">(str === undefined) {</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">this</span><span class="s0">._usage) </span><span class="s3">return this</span><span class="s0">._usage;</span>

      <span class="s0">const args = </span><span class="s3">this</span><span class="s0">._args.map((arg) =&gt; {</span>
        <span class="s3">return </span><span class="s0">humanReadableArgName(arg);</span>
      <span class="s0">});</span>
      <span class="s3">return </span><span class="s0">[].concat(</span>
        <span class="s0">(</span><span class="s3">this</span><span class="s0">.options.length || </span><span class="s3">this</span><span class="s0">._hasHelpOption ? </span><span class="s1">'[options]' </span><span class="s0">: []),</span>
        <span class="s0">(</span><span class="s3">this</span><span class="s0">.commands.length ? </span><span class="s1">'[command]' </span><span class="s0">: []),</span>
        <span class="s0">(</span><span class="s3">this</span><span class="s0">._args.length ? args : [])</span>
      <span class="s0">).join(</span><span class="s1">' '</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">this</span><span class="s0">._usage = str;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Get or set the name of the command. 
   * 
   * @param {string} [str] 
   * @return {string|Command} 
   */</span>

  <span class="s0">name(str) {</span>
    <span class="s3">if </span><span class="s0">(str === undefined) </span><span class="s3">return this</span><span class="s0">._name;</span>
    <span class="s3">this</span><span class="s0">._name = str;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Set the name of the command from script filename, such as process.argv[1], 
   * or require.main.filename, or __filename. 
   * 
   * (Used internally and public although not documented in README.) 
   * 
   * @example 
   * program.nameFromFilename(require.main.filename); 
   * 
   * @param {string} filename 
   * @return {Command} 
   */</span>

  <span class="s0">nameFromFilename(filename) {</span>
    <span class="s3">this</span><span class="s0">._name = path.basename(filename, path.extname(filename));</span>

    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Get or set the directory for searching for executable subcommands of this command. 
   * 
   * @example 
   * program.executableDir(__dirname); 
   * // or 
   * program.executableDir('subcommands'); 
   * 
   * @param {string} [path] 
   * @return {string|Command} 
   */</span>

  <span class="s0">executableDir(path) {</span>
    <span class="s3">if </span><span class="s0">(path === undefined) </span><span class="s3">return this</span><span class="s0">._executableDir;</span>
    <span class="s3">this</span><span class="s0">._executableDir = path;</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Return program help documentation. 
   * 
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout 
   * @return {string} 
   */</span>

  <span class="s0">helpInformation(contextOptions) {</span>
    <span class="s0">const helper = </span><span class="s3">this</span><span class="s0">.createHelp();</span>
    <span class="s3">if </span><span class="s0">(helper.helpWidth === undefined) {</span>
      <span class="s0">helper.helpWidth = (contextOptions &amp;&amp; contextOptions.error) ? </span><span class="s3">this</span><span class="s0">._outputConfiguration.getErrHelpWidth() : </span><span class="s3">this</span><span class="s0">._outputConfiguration.getOutHelpWidth();</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">helper.formatHelp(</span><span class="s3">this</span><span class="s0">, helper);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * @api private 
   */</span>

  <span class="s0">_getHelpContext(contextOptions) {</span>
    <span class="s0">contextOptions = contextOptions || {};</span>
    <span class="s0">const context = { error: !!contextOptions.error };</span>
    <span class="s0">let write;</span>
    <span class="s3">if </span><span class="s0">(context.error) {</span>
      <span class="s0">write = (arg) =&gt; </span><span class="s3">this</span><span class="s0">._outputConfiguration.writeErr(arg);</span>
    <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
      <span class="s0">write = (arg) =&gt; </span><span class="s3">this</span><span class="s0">._outputConfiguration.writeOut(arg);</span>
    <span class="s0">}</span>
    <span class="s0">context.write = contextOptions.write || write;</span>
    <span class="s0">context.command = </span><span class="s3">this</span><span class="s0">;</span>
    <span class="s3">return </span><span class="s0">context;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Output help information for this command. 
   * 
   * Outputs built-in help, and custom text added using `.addHelpText()`. 
   * 
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout 
   */</span>

  <span class="s0">outputHelp(contextOptions) {</span>
    <span class="s0">let deprecatedCallback;</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">contextOptions === </span><span class="s1">'function'</span><span class="s0">) {</span>
      <span class="s0">deprecatedCallback = contextOptions;</span>
      <span class="s0">contextOptions = undefined;</span>
    <span class="s0">}</span>
    <span class="s0">const context = </span><span class="s3">this</span><span class="s0">._getHelpContext(contextOptions);</span>

    <span class="s0">getCommandAndParents(</span><span class="s3">this</span><span class="s0">).reverse().forEach(command =&gt; command.emit(</span><span class="s1">'beforeAllHelp'</span><span class="s0">, context));</span>
    <span class="s3">this</span><span class="s0">.emit(</span><span class="s1">'beforeHelp'</span><span class="s0">, context);</span>

    <span class="s0">let helpInformation = </span><span class="s3">this</span><span class="s0">.helpInformation(context);</span>
    <span class="s3">if </span><span class="s0">(deprecatedCallback) {</span>
      <span class="s0">helpInformation = deprecatedCallback(helpInformation);</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">helpInformation !== </span><span class="s1">'string' </span><span class="s0">&amp;&amp; !Buffer.isBuffer(helpInformation)) {</span>
        <span class="s3">throw new </span><span class="s0">Error(</span><span class="s1">'outputHelp callback must return a string or a Buffer'</span><span class="s0">);</span>
      <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">context.write(helpInformation);</span>

    <span class="s3">this</span><span class="s0">.emit(</span><span class="s3">this</span><span class="s0">._helpLongFlag); </span><span class="s2">// deprecated</span>
    <span class="s3">this</span><span class="s0">.emit(</span><span class="s1">'afterHelp'</span><span class="s0">, context);</span>
    <span class="s0">getCommandAndParents(</span><span class="s3">this</span><span class="s0">).forEach(command =&gt; command.emit(</span><span class="s1">'afterAllHelp'</span><span class="s0">, context));</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * You can pass in flags and a description to override the help 
   * flags and help description for your command. Pass in false to 
   * disable the built-in help option. 
   * 
   * @param {string | boolean} [flags] 
   * @param {string} [description] 
   * @return {Command} `this` command for chaining 
   */</span>

  <span class="s0">helpOption(flags, description) {</span>
    <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">flags === </span><span class="s1">'boolean'</span><span class="s0">) {</span>
      <span class="s3">this</span><span class="s0">._hasHelpOption = flags;</span>
      <span class="s3">return this</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">this</span><span class="s0">._helpFlags = flags || </span><span class="s3">this</span><span class="s0">._helpFlags;</span>
    <span class="s3">this</span><span class="s0">._helpDescription = description || </span><span class="s3">this</span><span class="s0">._helpDescription;</span>

    <span class="s0">const helpFlags = splitOptionFlags(</span><span class="s3">this</span><span class="s0">._helpFlags);</span>
    <span class="s3">this</span><span class="s0">._helpShortFlag = helpFlags.shortFlag;</span>
    <span class="s3">this</span><span class="s0">._helpLongFlag = helpFlags.longFlag;</span>

    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Output help information and exit. 
   * 
   * Outputs built-in help, and custom text added using `.addHelpText()`. 
   * 
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout 
   */</span>

  <span class="s0">help(contextOptions) {</span>
    <span class="s3">this</span><span class="s0">.outputHelp(contextOptions);</span>
    <span class="s0">let exitCode = process.exitCode || </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">if </span><span class="s0">(exitCode === </span><span class="s4">0 </span><span class="s0">&amp;&amp; contextOptions &amp;&amp; </span><span class="s3">typeof </span><span class="s0">contextOptions !== </span><span class="s1">'function' </span><span class="s0">&amp;&amp; contextOptions.error) {</span>
      <span class="s0">exitCode = </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s2">// message: do not have all displayed text available so only passing placeholder.</span>
    <span class="s3">this</span><span class="s0">._exit(exitCode, </span><span class="s1">'commander.help'</span><span class="s0">, </span><span class="s1">'(outputHelp)'</span><span class="s0">);</span>
  <span class="s0">}</span>

  <span class="s2">/** 
   * Add additional text to be displayed with the built-in help. 
   * 
   * Position is 'before' or 'after' to affect just this command, 
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands. 
   * 
   * @param {string} position - before or after built-in help 
   * @param {string | Function} text - string to add, or a function returning a string 
   * @return {Command} `this` command for chaining 
   */</span>
  <span class="s0">addHelpText(position, text) {</span>
    <span class="s0">const allowedValues = [</span><span class="s1">'beforeAll'</span><span class="s0">, </span><span class="s1">'before'</span><span class="s0">, </span><span class="s1">'after'</span><span class="s0">, </span><span class="s1">'afterAll'</span><span class="s0">];</span>
    <span class="s3">if </span><span class="s0">(!allowedValues.includes(position)) {</span>
      <span class="s3">throw new </span><span class="s0">Error(`Unexpected value </span><span class="s3">for </span><span class="s0">position to addHelpText.</span>
<span class="s0">Expecting one of </span><span class="s1">'${allowedValues.join(&quot;'</span><span class="s0">, </span><span class="s1">'&quot;)}'</span><span class="s0">`);</span>
    <span class="s0">}</span>
    <span class="s0">const helpEvent = `${position}Help`;</span>
    <span class="s3">this</span><span class="s0">.on(helpEvent, (context) =&gt; {</span>
      <span class="s0">let helpStr;</span>
      <span class="s3">if </span><span class="s0">(</span><span class="s3">typeof </span><span class="s0">text === </span><span class="s1">'function'</span><span class="s0">) {</span>
        <span class="s0">helpStr = text({ error: context.error, command: context.command });</span>
      <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
        <span class="s0">helpStr = text;</span>
      <span class="s0">}</span>
      <span class="s2">// Ignore falsy value when nothing to output.</span>
      <span class="s3">if </span><span class="s0">(helpStr) {</span>
        <span class="s0">context.write(`${helpStr}\n`);</span>
      <span class="s0">}</span>
    <span class="s0">});</span>
    <span class="s3">return this</span><span class="s0">;</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Output help information if help flags specified 
 * 
 * @param {Command} cmd - command to output help for 
 * @param {Array} args - array of options to search for help flags 
 * @api private 
 */</span>

<span class="s3">function </span><span class="s0">outputHelpIfRequested(cmd, args) {</span>
  <span class="s0">const helpOption = cmd._hasHelpOption &amp;&amp; args.find(arg =&gt; arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);</span>
  <span class="s3">if </span><span class="s0">(helpOption) {</span>
    <span class="s0">cmd.outputHelp();</span>
    <span class="s2">// (Do not have all displayed text available so only passing placeholder.)</span>
    <span class="s0">cmd._exit(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">'commander.helpDisplayed'</span><span class="s0">, </span><span class="s1">'(outputHelp)'</span><span class="s0">);</span>
  <span class="s0">}</span>
<span class="s0">}</span>

<span class="s2">/** 
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command). 
 * 
 * @param {string[]} args - array of arguments from node.execArgv 
 * @returns {string[]} 
 * @api private 
 */</span>

<span class="s3">function </span><span class="s0">incrementNodeInspectorPort(args) {</span>
  <span class="s2">// Testing for these options:</span>
  <span class="s2">//  --inspect[=[host:]port]</span>
  <span class="s2">//  --inspect-brk[=[host:]port]</span>
  <span class="s2">//  --inspect-port=[host:]port</span>
  <span class="s3">return </span><span class="s0">args.map((arg) =&gt; {</span>
    <span class="s3">if </span><span class="s0">(!arg.startsWith(</span><span class="s1">'--inspect'</span><span class="s0">)) {</span>
      <span class="s3">return </span><span class="s0">arg;</span>
    <span class="s0">}</span>
    <span class="s0">let debugOption;</span>
    <span class="s0">let debugHost = </span><span class="s1">'127.0.0.1'</span><span class="s0">;</span>
    <span class="s0">let debugPort = </span><span class="s1">'9229'</span><span class="s0">;</span>
    <span class="s0">let match;</span>
    <span class="s3">if </span><span class="s0">((match = arg.match(/^(--inspect(-brk)?)$/)) !== </span><span class="s3">null</span><span class="s0">) {</span>
      <span class="s2">// e.g. --inspect</span>
      <span class="s0">debugOption = match[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s0">} </span><span class="s3">else if </span><span class="s0">((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== </span><span class="s3">null</span><span class="s0">) {</span>
      <span class="s0">debugOption = match[</span><span class="s4">1</span><span class="s0">];</span>
      <span class="s3">if </span><span class="s0">(/^\d+$/.test(match[</span><span class="s4">3</span><span class="s0">])) {</span>
        <span class="s2">// e.g. --inspect=1234</span>
        <span class="s0">debugPort = match[</span><span class="s4">3</span><span class="s0">];</span>
      <span class="s0">} </span><span class="s3">else </span><span class="s0">{</span>
        <span class="s2">// e.g. --inspect=localhost</span>
        <span class="s0">debugHost = match[</span><span class="s4">3</span><span class="s0">];</span>
      <span class="s0">}</span>
    <span class="s0">} </span><span class="s3">else if </span><span class="s0">((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== </span><span class="s3">null</span><span class="s0">) {</span>
      <span class="s2">// e.g. --inspect=localhost:1234</span>
      <span class="s0">debugOption = match[</span><span class="s4">1</span><span class="s0">];</span>
      <span class="s0">debugHost = match[</span><span class="s4">3</span><span class="s0">];</span>
      <span class="s0">debugPort = match[</span><span class="s4">4</span><span class="s0">];</span>
    <span class="s0">}</span>

    <span class="s3">if </span><span class="s0">(debugOption &amp;&amp; debugPort !== </span><span class="s1">'0'</span><span class="s0">) {</span>
      <span class="s3">return </span><span class="s0">`${debugOption}=${debugHost}:${parseInt(debugPort) + </span><span class="s4">1</span><span class="s0">}`;</span>
    <span class="s0">}</span>
    <span class="s3">return </span><span class="s0">arg;</span>
  <span class="s0">});</span>
<span class="s0">}</span>

<span class="s2">/** 
 * @param {Command} startCommand 
 * @returns {Command[]} 
 * @api private 
 */</span>

<span class="s3">function </span><span class="s0">getCommandAndParents(startCommand) {</span>
  <span class="s0">const result = [];</span>
  <span class="s3">for </span><span class="s0">(let command = startCommand; command; command = command.parent) {</span>
    <span class="s0">result.push(command);</span>
  <span class="s0">}</span>
  <span class="s3">return </span><span class="s0">result;</span>
<span class="s0">}</span>

<span class="s0">exports.Command = Command;</span>
</pre>
</body>
</html>